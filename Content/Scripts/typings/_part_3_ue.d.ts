declare class KismetNodeHelperLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): KismetNodeHelperLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetNodeHelperLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): KismetNodeHelperLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetNodeHelperLibrary;
	/**
	 * Sets the bit at index "Index" in the data
	 * @param Data - The integer containing the bits that are being set
	 * @param Index - The bit index into the Data that we are setting
	*/
	static MarkBit(Data?: number,Index?: number): {Data: number};
	/**
	 * Returns whether there exists an unmarked bit in the data
	 * @param Data - The data being tested against
	 * @param NumBits - The logical number of bits we want to track
	 * @return - Whether there is a bit not marked in the data
	*/
	static HasUnmarkedBit(Data: number,NumBits: number): boolean;
	/**
	 * Returns whether there exists a marked bit in the data
	 * @param Data - The data being tested against
	 * @param NumBits - The logical number of bits we want to track
	 * @return - Whether there is a bit marked in the data
	*/
	static HasMarkedBit(Data: number,NumBits: number): boolean;
	/**
	 * @param Enum - Enumeration
	 * @param EnumeratorIndex - Input value
	 * @return - if EnumeratorIndex is valid return EnumeratorIndex, otherwise return MAX value of Enum
	*/
	static GetValidValue(Enum: Enum,EnumeratorValue: number): number;
	/**
	 * Gets an already unmarked bit and returns the bit index selected
	 * @param Data - The integer containing the bits that are being set
	 * @param StartIdx - The index to start with when determining the selection'
	 * @param NumBits - The logical number of bits we want to track
	 * @param bRandom - Whether to select a random index or not
	 * @return - The index that was selected (returns INDEX_NONE if there was no unmarked bits to choose from)
	*/
	static GetUnmarkedBit(Data: number,StartIdx: number,NumBits: number,bRandom: boolean): number;
	/**
	 * Gets a random not already marked bit and returns the bit index selected
	 * @param Data - The integer containing the bits that are being set
	 * @param NumBits - The logical number of bits we want to track
	 * @return - The index that was selected (returns INDEX_NONE if there was no unmarked bits to choose from)
	*/
	static GetRandomUnmarkedBit(Data: number,StartIdx: number,NumBits: number): number;
	/**
	 * Gets the first index not already marked starting from a specific index and returns the bit index selected
	 * @param Data - The integer containing the bits that are being set
	 * @param StartIdx - The index to start looking for an available index from
	 * @param NumBits - The logical number of bits we want to track
	 * @return - The index that was selected (returns INDEX_NONE if there was no unmarked bits to choose from)
	*/
	static GetFirstUnmarkedBit(Data: number,StartIdx: number,NumBits: number): number;
	/**
	 * @param Enum - Enumeration
	 * @param EnumeratorIndex - Input index
	 * @return - The value of the enumerator, or INDEX_NONE
	*/
	static GetEnumeratorValueFromIndex(Enum: Enum,EnumeratorIndex: number): number;
	/**
	 * Gets enumerator name as FString. Use DeisplayName when possible.
	 * @param Enum - Enumeration
	 * @param EnumeratorValue - Value of searched enumeration
	 * @return - name of the searched enumerator, or NAME_None
	*/
	static GetEnumeratorUserFriendlyName(Enum: Enum,EnumeratorValue: number): string;
	/**
	 * Gets enumerator name.
	 * @param Enum - Enumeration
	 * @param EnumeratorValue - Value of searched enumeration
	 * @return - name of the searched enumerator, or NAME_None
	*/
	static GetEnumeratorName(Enum: Enum,EnumeratorValue: number): string;
	/**
	 * Clears the bit at index "Index" in the data
	 * @param Data - The integer containing the bits that are being cleared
	 * @param Index - The bit index into the Data that we are clearing
	*/
	static ClearBit(Data?: number,Index?: number): {Data: number};
	/**
	 * Clears all of the bit in the data
	 * @param Data - The integer containing the bits that are being cleared
	*/
	static ClearAllBits(Data?: number): {Data: number};
	/**
	 * Returns whether the bit at index "Index" is set or not in the data
	 * @param Data - The integer containing the bits that are being tested against
	 * @param Index - The bit index into the Data that we are inquiring
	 * @return  - Whether the bit at index "Index" is set or not
	*/
	static BitIsMarked(Data: number,Index: number): boolean;
	static C(Other: UObject): KismetNodeHelperLibrary;
}

declare class KismetRenderingLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): KismetRenderingLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetRenderingLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): KismetRenderingLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetRenderingLibrary;
	/**
	 * Exports a Texture2D as a HDR image onto the disk.
	*/
	static ExportTexture2D(WorldContextObject: UObject,Texture: Texture2D,FilePath: string,FileName: string): void;
	/**
	 * Exports a render target as a HDR image onto the disk.
	*/
	static ExportRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,FilePath: string,FileName: string): void;
	/**
	 * Must be paired with a BeginDrawCanvasToRenderTarget to complete rendering to a render target.
	*/
	static EndDrawCanvasToRenderTarget(WorldContextObject: UObject,Context: DrawToRenderTargetContext): void;
	/**
	 * Renders a quad with the material applied to the specified render target.
	 * This sets the render target even if it is already set, which is an expensive operation.
	 * Use BeginDrawCanvasToRenderTarget / EndDrawCanvasToRenderTarget instead if rendering multiple primitives to the same render target.
	*/
	static DrawMaterialToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Material: MaterialInterface): void;
	/**
	 * Creates a new render target and initializes it to the specified dimensions
	*/
	static CreateRenderTarget2D(WorldContextObject: UObject,Width: number,Height: number): TextureRenderTarget2D;
	/**
	 * Clears the specified render target with the given ClearColor.
	*/
	static ClearRenderTarget2D(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,ClearColor: LinearColor): void;
	/**
	 * Returns a Canvas object that can be used to draw to the specified render target.
	 * Be sure to call EndDrawCanvasToRenderTarget to complete the rendering!
	*/
	static BeginDrawCanvasToRenderTarget(WorldContextObject: UObject,TextureRenderTarget: TextureRenderTarget2D,Canvas?: Canvas,Size?: Vector2D,Context?: DrawToRenderTargetContext): {Canvas: Canvas, Size: Vector2D, Context: DrawToRenderTargetContext};
	static C(Other: UObject): KismetRenderingLibrary;
}

declare type ESearchCase = string | symbol;
declare var ESearchCase = { CaseSensitive:'CaseSensitive',IgnoreCase:'IgnoreCase', };
declare type ESearchDir = string | symbol;
declare var ESearchDir = { FromStart:'FromStart',FromEnd:'FromEnd', };
declare class KismetStringLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): KismetStringLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetStringLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): KismetStringLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetStringLibrary;
	/**
	 * Removes trailing whitespace characters
	*/
	static TrimTrailing(SourceString: string): string;
	/**
	 * Removes whitespace characters from the front of this string.
	*/
	static Trim(SourceString: string): string;
	/**
	 * Returns a string converted to Upper case
	 * @param       SourceString    The string to convert
	 * @return      The string in upper case
	*/
	static ToUpper(SourceString: string): string;
	/**
	 * Returns a string converted to Lower case
	 * @param        SourceString    The string to convert
	 * @return       The string in lower case
	*/
	static ToLower(SourceString: string): string;
	/**
	 * Convert a number of seconds into minutes:seconds.milliseconds format string
	*/
	static TimeSecondsToString(InSeconds: number): string;
	/**
	 * Test whether this string starts with given string.
	 * @param SearchCase            Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
	 * @return true if this string begins with specified text, false otherwise
	*/
	static StartsWith(SourceString: string,InPrefix: string,SearchCase: ESearchCase): boolean;
	/**
	 * Splits this string at given string position case sensitive.
	 * @param InStr The string to search and split at
	 * @param LeftS out the string to the left of InStr, not updated if return is false
	 * @param RightS out the string to the right of InStr, not updated if return is false
	 * @param SearchCase             Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
	 * @param SearchDir                      Indicates whether the search starts at the begining or at the end ( defaults to ESearchDir::FromStart )
	 * @return true if string is split, otherwise false
	*/
	static Split(SourceString: string,InStr: string,LeftS?: string,RightS?: string,SearchCase?: ESearchCase,SearchDir?: ESearchDir): {LeftS: string, RightS: string, $: boolean};
	/**
	 * * Pad the right of this string for a specified number of characters
	 * * @param       SourceString    The string to pad
	 * * @param       ChCount                 Amount of padding required
	 * * @return      The padded string
	*/
	static RightPad(SourceString: string,ChCount: number): string;
	/**
	 * @return the string to the right of the specified location, counting forward from the left (from the beginning of the word).
	*/
	static RightChop(SourceString: string,Count: number): string;
	/**
	 * @return the string to the right of the specified location, counting back from the right (end of the word).
	*/
	static Right(SourceString: string,Count: number): string;
	/**
	 * Returns a copy of this string, with the characters in reverse order
	*/
	static Reverse(SourceString: string): string;
	/**
	 * Replace all occurrences of SearchText with ReplacementText in this string.
	 * @param       SearchText      the text that should be removed from this string
	 * @param       ReplacementText         the text to insert in its place
	 * @param SearchCase    Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
	 * @return      the number of occurrences of SearchText that were replaced.
	*/
	static ReplaceInline(SourceString?: string,SearchText?: string,ReplacementText?: string,SearchCase?: ESearchCase): {SourceString: string, $: number};
	/**
	 * Replace all occurrences of a substring in this string
	 * @param From substring to replace
	 * @param To substring to replace From with
	 * @param SearchCase    Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
	 * @return a copy of this string with the replacement made
	*/
	static Replace(SourceString: string,From: string,To: string,SearchCase: ESearchCase): string;
	/**
	 * Gets an array of strings from a source string divided up by a separator and empty strings can optionally be culled.
	 * @param SourceString - The string to chop up
	 * @param Delimiter - The string to delimit on
	 * @param CullEmptyStrings = true - Cull (true) empty strings or add them to the array (false)
	 * @return The array of string that have been separated
	*/
	static ParseIntoArray(SourceString: string,Delimiter: string,CullEmptyStrings: boolean): string[];
	/**
	 * Test if the input string are not equal (A != B)
	 * @param A - The string to compare against
	 * @param B - The string to compare
	 * @return Returns true if the input strings are not equal, false if they are equal
	*/
	static NotEqual(A: string,B: string): boolean;
	/**
	 * Test if the input string are not equal (A != B), ignoring case differences
	 * @param A - The string to compare against
	 * @param B - The string to compare
	 * @return Returns true if the input strings are not equal, false if they are equal
	*/
	static NotEqual_StriStri(A: string,B: string): boolean;
	/**
	 * @return the substring from Start position for Count characters.
	*/
	static Mid(SourceString: string,Start: number,Count: number): string;
	/**
	 * Searches this string for a given wild card
	 * @param Wildcard              *?-type wildcard
	 * @param SearchCase    Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
	 * @return true if this string matches the *?-type wildcard given.
	 * @warning This is a simple, SLOW routine. Use with caution
	*/
	static MatchesWildcard(SourceString: string,Wildcard: string,SearchCase: ESearchCase): boolean;
	/**
	 * Returns the number of characters in the string
	 * @param SourceString - The string to measure
	 * @return The number of chars in the string
	*/
	static Len(S: string): number;
	/**
	 * * Pad the left of this string for a specified number of characters
	 * * @param       SourceString    The string to pad
	 * * @param       ChCount                 Amount of padding required
	 * * @return      The padded string
	*/
	static LeftPad(SourceString: string,ChCount: number): string;
	/**
	 * @return the left most characters from the string chopping the given number of characters from the end
	*/
	static LeftChop(SourceString: string,Count: number): string;
	/**
	 * @return the left most given number of characters
	*/
	static Left(SourceString: string,Count: number): string;
	/**
	 * Concatenates an array of strings into a single string.
	 * @param SourceArray - The array of strings to concatenate.
	 * @param Separator - The string used to separate each element.
	 * @return The final, joined, separated string.
	*/
	static JoinStringArray(SourceArray: string[],Separator: string): string;
	/**
	 * * Checks if a string contains only numeric characters
	 * * @param       SourceString    The string to check
	 * * @return true if the string only contains numeric characters
	*/
	static IsNumeric(SourceString: string): boolean;
	/**
	 * Returns a substring from the string starting at the specified position
	 * @param SourceString - The string to get the substring from
	 * @param StartIndex - The location in SourceString to use as the start of the substring
	 * @param Length The length of the requested substring
	 * @return The requested substring
	*/
	static GetSubstring(SourceString: string,StartIndex: number,Length: number): string;
	/**
	 * Gets a single character from the string (as an integer)
	 * @param SourceString - The string to convert
	 * @param Index - Location of the character whose value is required
	 * @return The integer value of the character or 0 if index is out of range
	*/
	static GetCharacterAsNumber(SourceString: string,Index: number): number;
	/**
	 * Returns an array that contains one entry for each character in SourceString
	 * @param        SourceString    The string to break apart into characters
	 * @return       An array containing one entry for each character in SourceString
	*/
	static GetCharacterArrayFromString(SourceString: string): string[];
	/**
	 * Finds the starting index of a substring in the a specified string
	 * @param SearchIn The string to search within
	 * @param Substring The string to look for in the SearchIn string
	 * @param bUseCase Whether or not to be case-sensitive
	 * @param bSearchFromEnd Whether or not to start the search from the end of the string instead of the beginning
	 * @param StartPosition The position to start the search from
	 * @return The index (starting from 0 if bSearchFromEnd is false) of the first occurence of the substring
	*/
	static FindSubstring(SearchIn: string,Substring: string,bUseCase: boolean,bSearchFromEnd: boolean,StartPosition: number): number;
	/**
	 * Test if the input strings are equal (A == B)
	 * @param A - The string to compare against
	 * @param B - The string to compare
	 * @returns True if the strings are equal, false otherwise
	*/
	static Equal(A: string,B: string): boolean;
	/**
	 * Test if the input strings are equal (A == B), ignoring case
	 * @param A - The string to compare against
	 * @param B - The string to compare
	 * @returns True if the strings are equal, false otherwise
	*/
	static EqualEqual_StriStri(A: string,B: string): boolean;
	/**
	 * Test whether this string ends with given string.
	 * @param SearchCase            Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
	 * @return true if this string ends with specified text, false otherwise
	*/
	static EndsWith(SourceString: string,InSuffix: string,SearchCase: ESearchCase): boolean;
	/**
	 * Takes an array of strings and removes any zero length entries.
	 * @param       InArray The array to cull
	 * @return      The number of elements left in InArray
	*/
	static CullArray(SourceString: string,InArray?: string[]): {InArray: string[], $: number};
	/**
	 * Converts a vector value to a string, in the form 'X= Y= Z='
	*/
	static ToString(InVec: Vector): string;
	/**
	 * Converts a vector2d value to a string, in the form 'X= Y='
	*/
	static ToString(InVec: Vector2D): string;
	/**
	 * Converts a transform value to a string, in the form 'Translation: X= Y= Z= Rotation: P= Y= R= Scale: X= Y= Z='
	*/
	static ToString(InTrans: Transform): string;
	/**
	 * Convert String Back To Vector2D. IsValid indicates whether or not the string could be successfully converted.
	*/
	static StringtoVector2D(InString: string,OutConvertedVector2D?: Vector2D,OutIsValid?: boolean): {OutConvertedVector2D: Vector2D, OutIsValid: boolean};
	/**
	 * Convert String Back To Vector. IsValid indicates whether or not the string could be successfully converted.
	*/
	static StringtoVector(InString: string,OutConvertedVector?: Vector,OutIsValid?: boolean): {OutConvertedVector: Vector, OutIsValid: boolean};
	/**
	 * Convert String Back To Rotator. IsValid indicates whether or not the string could be successfully converted.
	*/
	static StringtoRotator(InString: string,OutConvertedRotator?: Rotator,OutIsValid?: boolean): {OutConvertedRotator: Rotator, OutIsValid: boolean};
	/**
	 * Converts a string to a name value
	*/
	static StringToName(InString: string): string;
	/**
	 * Converts a string to a int value
	*/
	static StringToInt(InString: string): number;
	/**
	 * Converts a string to a float value
	*/
	static StringToFloat(InString: string): number;
	/**
	 * Convert String Back To Color. IsValid indicates whether or not the string could be successfully converted.
	*/
	static StringtoColor(InString: string,OutConvertedColor?: LinearColor,OutIsValid?: boolean): {OutConvertedColor: LinearColor, OutIsValid: boolean};
	/**
	 * Converts a rotator value to a string, in the form 'P= Y= R='
	*/
	static ToString(InRot: Rotator): string;
	/**
	 * Converts a UObject value to a string by calling the object's GetName method
	*/
	static ToString(InObj: UObject): string;
	/**
	 * Converts a name value to a string
	*/
	static ToString(InName: string): string;
	/**
	 * Converts an integer value to a string
	*/
	static ToString(InInt: number): string;
	/**
	 * Converts a float value to a string
	*/
	static ToString(InFloat: number): string;
	/**
	 * Converts a linear color value to a string, in the form '(R=,G=,B=,A=)'
	*/
	static ToString(InColor: LinearColor): string;
	/**
	 * Converts a byte value to a string
	*/
	static ToString(InByte: number): string;
	/**
	 * Converts a boolean value to a string, either 'true' or 'false'
	*/
	static ToString(InBool: boolean): string;
	/**
	 * Returns whether this string contains the specified substring.
	 * @param SubStr                 Find to search for
	 * @param SearchCase             Indicates whether the search is case sensitive or not ( defaults to ESearchCase::IgnoreCase )
	 * @param SearchDir                      Indicates whether the search starts at the begining or at the end ( defaults to ESearchDir::FromStart )
	 * @return                                       Returns whether the string contains the substring
	*/
	static Contains(SearchIn: string,Substring: string,bUseCase: boolean,bSearchFromEnd: boolean): boolean;
	/**
	 * Concatenates two strings together to make a new string
	 * @param A - The original string
	 * @param B - The string to append to A
	 * @returns A new string which is the concatenation of A+B
	*/
	static Append(A: string,B: string): string;
	/**
	 * Converts a vector2d->string, creating a new string in the form AppendTo+Prefix+InVector2d+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InVector2d - The vector2d value to convert. Uses the standard FVector2D::ToString conversion
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InVector2d: Vector2D,Suffix: string): string;
	/**
	 * Converts a vector->string, creating a new string in the form AppendTo+Prefix+InVector+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InVector - The vector value to convert. Uses the standard FVector::ToString conversion
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InVector: Vector,Suffix: string): string;
	/**
	 * Converts a rotator->string, creating a new string in the form AppendTo+Prefix+InRot+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InRot - The rotator value to convert. Uses the standard ToString conversion
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InRot: Rotator,Suffix: string): string;
	/**
	 * Converts a object->string, creating a new string in the form AppendTo+Prefix+object name+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InObj - The object to convert. Will insert the name of the object into the conversion string
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InObj: UObject,Suffix: string): string;
	/**
	 * Converts a color->string, creating a new string in the form AppendTo+Prefix+InName+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InName - The name value to convert
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InName: string,Suffix: string): string;
	/**
	 * Converts a int->string, creating a new string in the form AppendTo+Prefix+InInt+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InInt - The int value to convert
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InInt: number,Suffix: string): string;
	/**
	 * Converts a float->string, create a new string in the form AppendTo+Prefix+InFloat+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InFloat - The float value to convert
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InFloat: number,Suffix: string): string;
	/**
	 * Converts a color->string, creating a new string in the form AppendTo+Prefix+InColor+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InColor - The linear color value to convert. Uses the standard ToString conversion
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InColor: LinearColor,Suffix: string): string;
	/**
	 * Converts a boolean->string, creating a new string in the form AppendTo+Prefix+InBool+Suffix
	 * @param AppendTo - An existing string to use as the start of the conversion string
	 * @param Prefix - A string to use as a prefix, after the AppendTo string
	 * @param InBool - The bool value to convert. Will add "true" or "false" to the conversion string
	 * @param Suffix - A suffix to append to the end of the conversion string
	 * @return A new string built from the passed parameters
	*/
	static BuildString(AppendTo: string,Prefix: string,InBool: boolean,Suffix: string): string;
	static C(Other: UObject): KismetStringLibrary;
}

declare type EFormatArgumentType = string | symbol;
declare var EFormatArgumentType = { Int:'Int',UInt:'UInt',Float:'Float',Double:'Double',Text:'Text',Gender:'Gender', };
declare type ETextGender = string | symbol;
declare var ETextGender = { Masculine:'Masculine',Feminine:'Feminine',Neuter:'Neuter', };
declare class FormatArgumentData { 
	/**
	 * Argument Name
	*/
	ArgumentName: string;
	/**
	 * Argument Value Type
	*/
	ArgumentValueType: EFormatArgumentType;
	/**
	 * Argument Value
	*/
	ArgumentValue: string;
	/**
	 * Argument Value Int
	*/
	ArgumentValueInt: number;
	/**
	 * Argument Value Float
	*/
	ArgumentValueFloat: number;
	/**
	 * Argument Value Gender
	*/
	ArgumentValueGender: ETextGender;
	clone() : FormatArgumentData;
	static C(Other: UObject): FormatArgumentData;
}

declare type ERoundingMode = string | symbol;
declare var ERoundingMode = { HalfToEven:'HalfToEven',HalfFromZero:'HalfFromZero',HalfToZero:'HalfToZero',FromZero:'FromZero',ToZero:'ToZero',ToNegativeInfinity:'ToNegativeInfinity',ToPositiveInfinity:'ToPositiveInfinity', };
declare class KismetTextLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): KismetTextLibrary;
	static Find(Outer: UObject, ResourceName: string): KismetTextLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): KismetTextLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): KismetTextLibrary;
	/**
	 * Removes trailing whitespace characters.
	*/
	static TextTrimTrailing(InText: string): string;
	/**
	 * Removes whitespace characters from the front and end of the text.
	*/
	static TextTrimPrecedingAndTrailing(InText: string): string;
	/**
	 * Removes whitespace characters from the front of the text.
	*/
	static TextTrimPreceding(InText: string): string;
	/**
	 * Returns true if text is transient.
	*/
	static TextIsTransient(InText: string): boolean;
	/**
	 * Returns true if text is empty.
	*/
	static TextIsEmpty(InText: string): boolean;
	/**
	 * Returns true if text is culture invariant.
	*/
	static TextIsCultureInvariant(InText: string): boolean;
	/**
	 * Returns true if A and B are linguistically not equal (A != B).
	*/
	static NotEqual(A: string,B: string): boolean;
	/**
	 * Returns true if A and B are linguistically not equal (A != B), ignoring case.
	*/
	static NotEqual_IgnoreCase_TextText(A: string,B: string): boolean;
	/**
	 * Returns an empty piece of text.
	*/
	static GetEmptyText(): string;
	/**
	 * Used for formatting text using the FText::Format function and utilized by the UK2Node_FormatText
	*/
	static Format(InPattern: string,InArgs: FormatArgumentData[]): string;
	/**
	 * Attempts to find existing Text using the representation found in the loc tables for the specified namespace and key.
	*/
	static FindTextInLocalizationTable(Namespace: string,Key: string,OutText?: string): {OutText: string, $: boolean};
	/**
	 * Returns true if A and B are linguistically equal (A == B).
	*/
	static Equal(A: string,B: string): boolean;
	/**
	 * Returns true if A and B are linguistically equal (A == B), ignoring case.
	*/
	static EqualEqual_IgnoreCase_TextText(A: string,B: string): boolean;
	/**
	 * Converts a vector value to a localizable text, in the form 'X= Y= Z='
	*/
	static ToText(InVec: Vector): string;
	/**
	 * Converts a vector2d value to a localizable text, in the form 'X= Y='
	*/
	static ToText(InVec: Vector2D): string;
	/**
	 * Converts a transform value to a localizable text, in the form 'Translation: X= Y= Z= Rotation: P= Y= R= Scale: X= Y= Z='
	*/
	static ToText(InTrans: Transform): string;
	/**
	 * Converts localizable text to the string
	*/
	static ToString(InText: string): string;
	/**
	 * Converts string to localizable text
	*/
	static ToText(InString: string): string;
	/**
	 * Converts a rotator value to a localizable text, in the form 'P= Y= R='
	*/
	static ToText(InRot: Rotator): string;
	/**
	 * Converts a UObject value to a localizable text by calling the object's GetName method
	*/
	static ToText(InObj: UObject): string;
	/**
	 * Converts string to localizable text
	*/
	static ToText(InName: string): string;
	/**
	 * Converts a passed in integer to a text based on formatting options
	*/
	static ToText(Value: number,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number): string;
	/**
	 * Converts a passed in float to a text based on formatting options
	*/
	static ToText(Value: number,RoundingMode: ERoundingMode,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number): string;
	/**
	 * Converts a linear color value to a localizable text, in the form '(R=,G=,B=,A=)'
	*/
	static ToText(InColor: LinearColor): string;
	/**
	 * Converts a byte value to text
	*/
	static ToText(Value: number): string;
	/**
	 * Converts a boolean value to text, either 'true' or 'false'
	*/
	static ToText(InBool: boolean): string;
	/**
	 * Converts a passed in time span to a text, formatted as a time span
	*/
	static AsTimespan(InTimespan: Timespan): string;
	/**
	 * Converts a passed in date & time to a text, formatted as a time
	*/
	static AsTime(In: DateTime): string;
	/**
	 * Converts a passed in float to a text, formatted as a percent
	*/
	static AsPercent(Value: number,RoundingMode: ERoundingMode,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number): string;
	/**
	 * Converts a passed in date & time to a text, formatted as a date & time
	*/
	static AsDateTime(In: DateTime): string;
	/**
	 * Converts a passed in date & time to a text, formatted as a date
	*/
	static AsDate(InDateTime: DateTime): string;
	/**
	 * Generate an FText that represents the passed number as currency in the current culture.
	 * BaseVal is specified in the smallest fractional value of the currency and will be converted for formatting according to the selected culture.
	 * Keep in mind the CurrencyCode is completely independent of the culture it's displayed in (and they do not imply one another).
	 * For example: FText::AsCurrencyBase(650, TEXT("EUR")); would return an FText of "?6.50" in most English cultures (en_US/en_UK) and "6,50?" in Spanish (es_ES).
	*/
	static AsCurrency(BaseValue: number,CurrencyCode: string): string;
	/**
	 * Converts a passed in integer to a text formatted as a currency
	*/
	static AsCurrency(Value: number,RoundingMode: ERoundingMode,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number,CurrencyCode: string): string;
	/**
	 * Converts a passed in float to a text formatted as a currency
	*/
	static AsCurrency(Value: number,RoundingMode: ERoundingMode,bUseGrouping: boolean,MinimumIntegralDigits: number,MaximumIntegralDigits: number,MinimumFractionalDigits: number,MaximumFractionalDigits: number,CurrencyCode: string): string;
	static C(Other: UObject): KismetTextLibrary;
}

declare class MeshVertexPainterKismetLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MeshVertexPainterKismetLibrary;
	static Find(Outer: UObject, ResourceName: string): MeshVertexPainterKismetLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MeshVertexPainterKismetLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshVertexPainterKismetLibrary;
	/**
	 * Removes vertex colors on a mesh component
	*/
	static RemovePaintedVertices(StaticMeshComponent: StaticMeshComponent): void;
	/**
	 * Paints vertex colors on a mesh component in a specified color.
	*/
	static PaintVerticesSingleColor(StaticMeshComponent: StaticMeshComponent,FillColor: LinearColor,bConvertToSRGB: boolean): void;
	/**
	 * Paints vertex colors on a mesh component lerping from the start to the end color along the specified axis.
	*/
	static PaintVerticesLerpAlongAxis(StaticMeshComponent: StaticMeshComponent,StartColor: LinearColor,EndColor: LinearColor,Axis: EVertexPaintAxis,bConvertToSRGB: boolean): void;
	static C(Other: UObject): MeshVertexPainterKismetLibrary;
}

declare class VisualLoggerKismetLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VisualLoggerKismetLibrary;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerKismetLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VisualLoggerKismetLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerKismetLibrary;
	/**
	 * Logs simple text string with Visual Logger - recording for Visual Logs has to be enabled to record this data
	*/
	static LogText(WorldContextObject: UObject,Text: string,LogCategory: string): void;
	/**
	 * Logs location as sphere with given radius - recording for Visual Logs has to be enabled to record this data
	*/
	static LogLocation(WorldContextObject: UObject,Location: Vector,Text: string,ObjectColor: LinearColor,Radius: number,LogCategory: string): void;
	/**
	 * Logs box shape - recording for Visual Logs has to be enabled to record this data
	*/
	static LogBoxShape(WorldContextObject: UObject,BoxShape: Box,Text: string,ObjectColor: LinearColor,LogCategory: string): void;
	static C(Other: UObject): VisualLoggerKismetLibrary;
}

declare class AnimBlueprintGeneratedClass extends BlueprintGeneratedClass { 
	/**
	 * List of state machines present in this blueprint class
	*/
	BakedStateMachines: BakedAnimationStateMachine[];
	/**
	 * Target skeleton for this blueprint class
	*/
	TargetSkeleton: Skeleton;
	/**
	 * A list of anim notifies that state machines (or anything else) may reference
	*/
	AnimNotifies: AnimNotifyEvent[];
	/**
	 * The index of the root node in the animation tree
	*/
	RootAnimNodeIndex: number;
	/**
	 * Indices for each of the saved pose nodes that require updating, in the order they need to get updates.
	*/
	OrderedSavedPoseIndices: number[];
	/**
	 * Array of sync group names in the order that they are requested during compile
	*/
	SyncGroupNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimBlueprintGeneratedClass;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprintGeneratedClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimBlueprintGeneratedClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprintGeneratedClass;
	static C(Other: UObject): AnimBlueprintGeneratedClass;
}

declare class CircleElement2D { 
	/**
	 * Center
	*/
	Center: Vector2D;
	/**
	 * Radius
	*/
	Radius: number;
	clone() : CircleElement2D;
	static C(Other: UObject): CircleElement2D;
}

declare class BoxElement2D { 
	/**
	 * Center of the box
	*/
	Center: Vector2D;
	/**
	 * Width of the box
	*/
	Width: number;
	/**
	 * Height of the box
	*/
	Height: number;
	/**
	 * Rotation of the box (in degrees)
	*/
	Angle: number;
	clone() : BoxElement2D;
	static C(Other: UObject): BoxElement2D;
}

declare class ConvexElement2D { 
	/**
	 * Vertices that lie on the convex hull
	*/
	VertexData: Vector2D[];
	clone() : ConvexElement2D;
	static C(Other: UObject): ConvexElement2D;
}

declare class AggregateGeometry2D { 
	/**
	 * Circle Elements
	*/
	CircleElements: CircleElement2D[];
	/**
	 * Box Elements
	*/
	BoxElements: BoxElement2D[];
	/**
	 * Convex Elements
	*/
	ConvexElements: ConvexElement2D[];
	clone() : AggregateGeometry2D;
	static C(Other: UObject): AggregateGeometry2D;
}

declare class BodySetup2D extends BodySetup { 
	/**
	 * Agg Geom 2D
	*/
	AggGeom2D: AggregateGeometry2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BodySetup2D;
	static Find(Outer: UObject, ResourceName: string): BodySetup2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BodySetup2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BodySetup2D;
	static C(Other: UObject): BodySetup2D;
}

declare class BoneMaskFilter extends UObject { 
	/**
	 * Blend Poses
	*/
	BlendPoses: InputBlendPose[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BoneMaskFilter;
	static Find(Outer: UObject, ResourceName: string): BoneMaskFilter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BoneMaskFilter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BoneMaskFilter;
	static C(Other: UObject): BoneMaskFilter;
}

declare class BookMark2D extends UObject { 
	/**
	 * Zoom of the camera
	*/
	Zoom2D: number;
	/**
	 * Location of the camera
	*/
	Location: IntPoint;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BookMark2D;
	static Find(Outer: UObject, ResourceName: string): BookMark2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BookMark2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BookMark2D;
	static C(Other: UObject): BookMark2D;
}

declare class ButtonStyleAsset extends UObject { 
	/**
	 * The actual data describing the button's appearance.
	*/
	ButtonStyle: ButtonStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ButtonStyleAsset;
	static Find(Outer: UObject, ResourceName: string): ButtonStyleAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ButtonStyleAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ButtonStyleAsset;
	static C(Other: UObject): ButtonStyleAsset;
}

declare class PendingNetGame extends UObject { 
	/**
	 * Net driver created for contacting the new server
	 * Transferred to world on successful connection
	*/
	NetDriver: NetDriver;
	/**
	 * Demo Net driver created for loading demos, but we need to go through pending net game
	 * Transferred to world on successful connection
	*/
	DemoNetDriver: DemoNetDriver;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PendingNetGame;
	static Find(Outer: UObject, ResourceName: string): PendingNetGame;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PendingNetGame;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PendingNetGame;
	static C(Other: UObject): PendingNetGame;
}

declare class ActorChannel extends Channel { 
	/**
	 * Variables.
	*/
	Actor: Actor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorChannel;
	static Find(Outer: UObject, ResourceName: string): ActorChannel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorChannel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorChannel;
	static C(Other: UObject): ActorChannel;
}

declare class ControlChannel extends Channel { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ControlChannel;
	static Find(Outer: UObject, ResourceName: string): ControlChannel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ControlChannel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ControlChannel;
	static C(Other: UObject): ControlChannel;
}

declare class VoiceChannel extends Channel { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VoiceChannel;
	static Find(Outer: UObject, ResourceName: string): VoiceChannel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VoiceChannel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VoiceChannel;
	static C(Other: UObject): VoiceChannel;
}

declare class CheckBoxStyleAsset extends UObject { 
	/**
	 * The actual data describing the Check Box's appearance.
	*/
	CheckBoxStyle: CheckBoxStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CheckBoxStyleAsset;
	static Find(Outer: UObject, ResourceName: string): CheckBoxStyleAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CheckBoxStyleAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheckBoxStyleAsset;
	static C(Other: UObject): CheckBoxStyleAsset;
}

declare class PluginCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PluginCommandlet;
	static Find(Outer: UObject, ResourceName: string): PluginCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PluginCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PluginCommandlet;
	static C(Other: UObject): PluginCommandlet;
}

declare class SmokeTestCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SmokeTestCommandlet;
	static Find(Outer: UObject, ResourceName: string): SmokeTestCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SmokeTestCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SmokeTestCommandlet;
	static C(Other: UObject): SmokeTestCommandlet;
}

declare class CurveEdPresetCurve extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveEdPresetCurve;
	static Find(Outer: UObject, ResourceName: string): CurveEdPresetCurve;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveEdPresetCurve;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveEdPresetCurve;
	static C(Other: UObject): CurveEdPresetCurve;
}

declare class AnimationSettings extends DeveloperSettings { 
	/**
	 * compression upgrade version
	*/
	CompressCommandletVersion: number;
	/**
	 * Key End Effectors Match Name Array
	*/
	KeyEndEffectorsMatchNameArray: string[];
	/**
	 * Default Compression Algorithm
	*/
	DefaultCompressionAlgorithm: UnrealEngineClass;
	/**
	 * Rotation Compression Format
	*/
	RotationCompressionFormat: AnimationCompressionFormat;
	/**
	 * Translation Compression Format
	*/
	TranslationCompressionFormat: AnimationCompressionFormat;
	/**
	 * The alternate error threshold (0.0 means don't try anything other than the current / default scheme)
	 * Determines the current setting for world-space error tolerance in the animation compressor.
	 * When requested, animation being compressed will also consider an alternative compression
	 * method if the end result of that method produces less error than the AlternativeCompressionThreshold.
	 * Also known as "Max End Effector Error"
	*/
	AlternativeCompressionThreshold: number;
	/**
	 * Force Recompression
	*/
	ForceRecompression: boolean;
	/**
	 * Only Check for Missing Skeletal Meshes
	*/
	bOnlyCheckForMissingSkeletalMeshes: boolean;
	/**
	 * If true and the existing compression error is greater than Alternative Compression Threshold, then any compression technique (even one that increases the size) with a lower error will be used until it falls below the threshold
	*/
	bForceBelowThreshold: boolean;
	/**
	 * If true, then the animation will be first recompressed with it's current compressor if non-NULL, or with the global default compressor (specified in the engine ini)
	 * Also known as "Run Current Default Compressor"
	*/
	bFirstRecompressUsingCurrentOrDefault: boolean;
	/**
	 * If true and the existing compression error is greater than Alternative Compression Threshold, then Alternative Compression Threshold will be effectively raised to the existing error level
	*/
	bRaiseMaxErrorToExisting: boolean;
	/**
	 * If true, the uniform bitwise techniques will be tried
	*/
	bTryFixedBitwiseCompression: boolean;
	/**
	 * If true, the per-track compressor techniques will be tried
	*/
	bTryPerTrackBitwiseCompression: boolean;
	/**
	 * If true, the linear key removal techniques will be tried
	*/
	bTryLinearKeyRemovalCompression: boolean;
	/**
	 * If true, the resampling techniques will be tried
	*/
	bTryIntervalKeyRemoval: boolean;
	/**
	 * Enable Performance Log
	*/
	bEnablePerformanceLog: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationSettings;
	static Find(Outer: UObject, ResourceName: string): AnimationSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationSettings;
	static C(Other: UObject): AnimationSettings;
}

declare class AudioQualitySettings { 
	/**
	 * Display Name
	*/
	DisplayName: string;
	/**
	 * The number of audio channels that can be used at once
	 * NOTE: Some platforms may cap this value to a lower setting regardless of what the settings request
	*/
	MaxChannels: number;
	clone() : AudioQualitySettings;
	static C(Other: UObject): AudioQualitySettings;
}

declare class AudioSettings extends DeveloperSettings { 
	/**
	 * The SoundClass assigned to newly created sounds
	*/
	DefaultSoundClassName: StringAssetReference;
	/**
	 * The SoundConcurrency assigned to newly created sounds
	*/
	DefaultSoundConcurrencyName: StringAssetReference;
	/**
	 * The SoundMix to use as base when no other system has specified a Base SoundMix
	*/
	DefaultBaseSoundMix: StringAssetReference;
	/**
	 * Sound class to be used for the VOIP audio component
	*/
	VoiPSoundClass: StringAssetReference;
	/**
	 * Low Pass Filter Resonance
	*/
	LowPassFilterResonance: number;
	/**
	 * How many streaming sounds can be played at the same time (if more are played they will be sorted by priority)
	*/
	MaximumConcurrentStreams: number;
	/**
	 * Quality Levels
	*/
	QualityLevels: AudioQualitySettings[];
	/**
	 * Allows sounds to play at 0 volume.
	*/
	bAllowVirtualizedSounds: boolean;
	/**
	 * The format string to use when generating the filename for contexts within dialogue waves. This must generate unique names for your project.
	 * Available format markers:
	 *   * {DialogueGuid} - The GUID of the dialogue wave. Guaranteed to be unique and stable against asset renames.
	 *   * {DialogueHash} - The hash of the dialogue wave. Not guaranteed to be unique or stable against asset renames, however may be unique enough if combined with the dialogue name.
	 *   * {DialogueName} - The name of the dialogue wave. Not guaranteed to be unique or stable against asset renames, however may be unique enough if combined with the dialogue hash.
	 *   * {ContextId}    - The ID of the context. Guaranteed to be unique within its dialogue wave. Not guaranteed to be stable against changes to the context.
	 *   * {ContextIndex} - The index of the context within its parent dialogue wave. Guaranteed to be unique within its dialogue wave. Not guaranteed to be stable against contexts being removed.
	*/
	DialogueFilenameFormat: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AudioSettings;
	static Find(Outer: UObject, ResourceName: string): AudioSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AudioSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioSettings;
	static C(Other: UObject): AudioSettings;
}

declare type ERenderFocusRule = string | symbol;
declare var ERenderFocusRule = { Always:'Always',NonPointer:'NonPointer',NavigationOnly:'NavigationOnly',Never:'Never', };
declare type EUIScalingRule = string | symbol;
declare var EUIScalingRule = { ShortestSide:'ShortestSide',LongestSide:'LongestSide',Horizontal:'Horizontal',Vertical:'Vertical',Custom:'Custom', };
declare class DPICustomScalingRule extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DPICustomScalingRule;
	static Find(Outer: UObject, ResourceName: string): DPICustomScalingRule;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DPICustomScalingRule;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DPICustomScalingRule;
	static C(Other: UObject): DPICustomScalingRule;
}

declare class UserInterfaceSettings extends DeveloperSettings { 
	/**
	 * Rule to determine if we should render the Focus Brush for widgets that have user focus.
	*/
	RenderFocusRule: ERenderFocusRule;
	/**
	 * Widget to use when the Default Cursor is requested.
	*/
	DefaultCursor: StringClassReference;
	/**
	 * Widget to use when the TextEditBeam Cursor is requested.
	*/
	TextEditBeamCursor: StringClassReference;
	/**
	 * Widget to use when the Crosshairs Cursor is requested.
	*/
	CrosshairsCursor: StringClassReference;
	/**
	 * Widget to use when the Hand Cursor is requested.
	*/
	HandCursor: StringClassReference;
	/**
	 * Widget to use when the GrabHand Cursor is requested.
	*/
	GrabHandCursor: StringClassReference;
	/**
	 * Widget to use when the GrabHandClosed Cursor is requested.
	*/
	GrabHandClosedCursor: StringClassReference;
	/**
	 * Widget to use when the SlashedCircle Cursor is requested.
	*/
	SlashedCircleCursor: StringClassReference;
	/**
	 * An optional application scale to apply on top of the custom scaling rules.  So if you want to expose a property in your game title, you can modify this underlying value to scale the entire UI.
	*/
	ApplicationScale: number;
	/**
	 * The rule used when trying to decide what scale to apply.
	*/
	UIScaleRule: EUIScalingRule;
	/**
	 * Set DPI Scale Rule to Custom, and this class will be used instead of any of the built-in rules.
	*/
	CustomScalingRuleClass: StringClassReference;
	/**
	 * Controls how the UI is scaled at different resolutions based on the DPI Scale Rule
	*/
	UIScaleCurve: RuntimeFloatCurve;
	/**
	 * Cursor Classes
	*/
	CursorClasses: UObject[];
	/**
	 * Custom Scaling Rule Class Instance
	*/
	CustomScalingRuleClassInstance: UnrealEngineClass;
	/**
	 * Custom Scaling Rule
	*/
	CustomScalingRule: DPICustomScalingRule;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UserInterfaceSettings;
	static Find(Outer: UObject, ResourceName: string): UserInterfaceSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UserInterfaceSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserInterfaceSettings;
	static C(Other: UObject): UserInterfaceSettings;
}

declare class StreamingSettings extends DeveloperSettings { 
	/**
	 * Enables separate thread for package streaming. Requires restart to take effect.
	*/
	AsyncLoadingThreadEnabled: boolean;
	/**
	 * Enables log warning if time limit for time-sliced package streaming has been exceeded.
	*/
	WarnIfTimeLimitExceeded: boolean;
	/**
	 * Multiplier for time limit exceeded warning time threshold.
	*/
	TimeLimitExceededMultiplier: number;
	/**
	 * Minimum time the time limit exceeded warning will be triggered by.
	*/
	TimeLimitExceededMinTime: number;
	/**
	 * Minimum time the time limit exceeded warning will be triggered by.
	*/
	MinBulkDataSizeForAsyncLoading: number;
	/**
	 * Constrain bandwidth if wanted. Value is in MByte/ sec.
	*/
	AsyncIOBandwidthLimit: number;
	/**
	 * Whether to allow background level streaming.
	*/
	UseBackgroundLevelStreaming: boolean;
	/**
	 * Whether to use the entire time limit even if blocked on I/O.
	*/
	AsyncLoadingUseFullTimeLimit: boolean;
	/**
	 * Maximum amount of time to spend doing asynchronous loading (ms per frame).
	*/
	AsyncLoadingTimeLimit: number;
	/**
	 * Additional time to spend asynchronous loading during a high priority load.
	*/
	PriorityAsyncLoadingExtraTime: number;
	/**
	 * Maximum allowed time to spend for actor registration steps during level streaming (ms per frame).
	*/
	LevelStreamingActorsUpdateTimeLimit: number;
	/**
	 * Batching granularity used to register actor components during level streaming.
	*/
	LevelStreamingComponentsRegistrationGranularity: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StreamingSettings;
	static Find(Outer: UObject, ResourceName: string): StreamingSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StreamingSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StreamingSettings;
	static C(Other: UObject): StreamingSettings;
}

declare class GarbageCollectionSettings extends DeveloperSettings { 
	/**
	 * Time in seconds (game time) we should wait between purging object references to objects that are pending kill.
	*/
	TimeBetweenPurgingPendingKillObjects: number;
	/**
	 * If enabled, streaming will be flushed each time garbage collection is triggered.
	*/
	FlushStreamingOnGC: boolean;
	/**
	 * If enabled, garbage collection will use multiple threads.
	*/
	AllowParallelGC: boolean;
	/**
	 * If true, the engine will attempt to create clusters of objects for better garbage collection performance.
	*/
	CreateGCClusters: boolean;
	/**
	 * If true, when creating clusters, the clusters referenced from another cluster will get merged into one big cluster.
	*/
	MergeGCClusters: boolean;
	/**
	 * Maximum number of times GC can be skipped if worker threads are currently modifying UObject state. 0 = never force GC
	*/
	NumRetriesBeforeForcingGC: number;
	/**
	 * Maximum Object Count Not Considered By GC. Works only in cooked builds.
	*/
	MaxObjectsNotConsideredByGC: number;
	/**
	 * Size Of Permanent Object Pool (bytes). Works only in cooked builds.
	*/
	SizeOfPermanentObjectPool: number;
	/**
	 * Maximum number of UObjects that can exist in cooked game. Keep this as small as possible.
	*/
	MaxObjectsInGame: number;
	/**
	 * Maximum number of UObjects that can exist in the editor game. Make sure this can hold enough objects for the editor and commadlets within reasonable limit.
	*/
	MaxObjectsInEditor: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GarbageCollectionSettings;
	static Find(Outer: UObject, ResourceName: string): GarbageCollectionSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GarbageCollectionSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GarbageCollectionSettings;
	static C(Other: UObject): GarbageCollectionSettings;
}

declare class NetworkSettings extends DeveloperSettings { 
	/**
	 * If true, libcurl authenticates the peer's certificate. Disable to allow self-signed certificates.
	*/
	bVerifyPeer: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NetworkSettings;
	static Find(Outer: UObject, ResourceName: string): NetworkSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NetworkSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetworkSettings;
	static C(Other: UObject): NetworkSettings;
}

declare type ESettingsLockedAxis = string | symbol;
declare var ESettingsLockedAxis = { None:'None',X:'X',Y:'Y',Z:'Z',Invalid:'Invalid', };
declare type ESettingsDOF = string | symbol;
declare var ESettingsDOF = { Full3D:'Full3D',YZPlane:'YZPlane',XZPlane:'XZPlane',XYPlane:'XYPlane', };
declare class PhysicalSurfaceName { 
	/**
	 * Type
	*/
	Type: EPhysicalSurface;
	/**
	 * Name
	*/
	Name: string;
	clone() : PhysicalSurfaceName;
	static C(Other: UObject): PhysicalSurfaceName;
}

declare class PhysicsSettings extends DeveloperSettings { 
	/**
	 * Default gravity.
	*/
	DefaultGravityZ: number;
	/**
	 * Default terminal velocity for Physics Volumes.
	*/
	DefaultTerminalVelocity: number;
	/**
	 * Default fluid friction for Physics Volumes.
	*/
	DefaultFluidFriction: number;
	/**
	 * Amount of memory to reserve for PhysX simulate(), this is per pxscene
	*/
	SimulateScratchMemorySize: number;
	/**
	 * Threshold for ragdoll bodies above which they will be added to an aggregate before being added to the scene
	*/
	RagdollAggregateThreshold: number;
	/**
	 * Triangles from triangle meshes (BSP) with an area less than or equal to this value will be removed from physics collision data. Set to less than 0 to disable.
	*/
	TriangleMeshTriangleMinAreaThreshold: number;
	/**
	 * Enables the use of an async scene
	*/
	bEnableAsyncScene: boolean;
	/**
	 * Enables shape sharing between sync and async scene for static rigid actors
	*/
	bEnableShapeSharing: boolean;
	/**
	 * Enables persistent contact manifolds. This will generate fewer contact points, but with more accuracy. Reduces stability of stacking, but can help energy conservation.
	*/
	bEnablePCM: boolean;
	/**
	 * Whether to warn when physics locks are used incorrectly. Turning this off is not recommended and should only be used by very advanced users.
	*/
	bWarnMissingLocks: boolean;
	/**
	 * Can 2D physics be used (Box2D)?
	*/
	bEnable2DPhysics: boolean;
	/**
	 * Locked Axis
	*/
	LockedAxis: ESettingsLockedAxis;
	/**
	 * Useful for constraining all objects in the world, for example if you are making a 2D game using 3D environments.
	*/
	DefaultDegreesOfFreedom: ESettingsDOF;
	/**
	 * Minimum relative velocity required for an object to bounce. A typical value for simulation stability is about 0.2 * gravity
	*/
	BounceThresholdVelocity: number;
	/**
	 * Friction combine mode, controls how friction is computed for multiple materials.
	*/
	FrictionCombineMode: EFrictionCombineMode;
	/**
	 * Restitution combine mode, controls how restitution is computed for multiple materials.
	*/
	RestitutionCombineMode: EFrictionCombineMode;
	/**
	 * Max angular velocity that a simulated object can achieve.
	*/
	MaxAngularVelocity: number;
	/**
	 * Max velocity which may be used to depenetrate simulated physics objects. 0 means no maximum.
	*/
	MaxDepenetrationVelocity: number;
	/**
	 * Contact offset multiplier. When creating a physics shape we look at its bounding volume and multiply its minimum value by this multiplier. A bigger number will generate contact points earlier which results in higher stability at the cost of performance.
	*/
	ContactOffsetMultiplier: number;
	/**
	 * Min Contact offset.
	*/
	MinContactOffset: number;
	/**
	 * Max Contact offset.
	*/
	MaxContactOffset: number;
	/**
	 * If true, simulate physics for this component on a dedicated server.
	 * This should be set if simulating physics and replicating with a dedicated server.
	*/
	bSimulateSkeletalMeshOnDedicatedServer: boolean;
	/**
	 * Determines the default physics shape complexity.
	*/
	DefaultShapeComplexity: ECollisionTraceFlag;
	/**
	 * If true, static meshes will use per poly collision as complex collision by default. If false the default behavior is the same as UseSimpleAsComplex.
	*/
	bDefaultHasComplexCollision: boolean;
	/**
	 * If true, the internal physx face to UE face mapping will not be generated. This is a memory optimization available if you do not rely on face indices returned by scene queries.
	*/
	bSuppressFaceRemapTable: boolean;
	/**
	 * If true, store extra information to allow FindCollisionUV to derive UV info from a line trace hit result, using the FindCollisionUV utility
	*/
	bSupportUVFromHitResults: boolean;
	/**
	 * If true, physx will not update unreal with any bodies that have moved during the simulation. This should only be used if you have no physx simulation or you are manually updating the unreal data via polling physx.
	*/
	bDisableActiveTransforms: boolean;
	/**
	 * If true CCD will be ignored. This is an optimization when CCD is never used which removes the need for physx to check it internally.
	*/
	bDisableCCD: boolean;
	/**
	 * Max Physics Delta Time to be clamped.
	*/
	MaxPhysicsDeltaTime: number;
	/**
	 * Whether to substep the physics simulation. This feature is still experimental. Certain functionality might not work correctly
	*/
	bSubstepping: boolean;
	/**
	 * Whether to substep the async physics simulation. This feature is still experimental. Certain functionality might not work correctly
	*/
	bSubsteppingAsync: boolean;
	/**
	 * Max delta time (in seconds) for an individual simulation substep.
	*/
	MaxSubstepDeltaTime: number;
	/**
	 * Max number of substeps for physics simulation.
	*/
	MaxSubsteps: number;
	/**
	 * Physics delta time smoothing factor for sync scene.
	*/
	SyncSceneSmoothingFactor: number;
	/**
	 * Physics delta time smoothing factor for async scene.
	*/
	AsyncSceneSmoothingFactor: number;
	/**
	 * Physics delta time initial average.
	*/
	InitialAverageFrameRate: number;
	/**
	 * PhysicalMaterial Surface Types
	*/
	PhysicalSurfaces: PhysicalSurfaceName[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsSettings;
	static Find(Outer: UObject, ResourceName: string): PhysicsSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsSettings;
	static C(Other: UObject): PhysicsSettings;
}

declare type ETranslucentSortPolicy = string | symbol;
declare var ETranslucentSortPolicy = { SortByDistance:'SortByDistance',SortByProjectedZ:'SortByProjectedZ',SortAlongAxis:'SortAlongAxis', };
declare type ECustomDepthStencil = string | symbol;
declare var ECustomDepthStencil = { Disabled:'Disabled',Enabled:'Enabled',EnabledOnDemand:'EnabledOnDemand',EnabledWithStencil:'EnabledWithStencil', };
declare type EAutoExposureMethodUI = string | symbol;
declare var EAutoExposureMethodUI = { AEM_Histogram:'AEM_Histogram',AEM_Basic:'AEM_Basic', };
declare type EAntiAliasingMethodUI = string | symbol;
declare var EAntiAliasingMethodUI = { AAM_None:'AAM_None',AAM_FXAA:'AAM_FXAA',AAM_TemporalAA:'AAM_TemporalAA', };
declare type EEarlyZPass = string | symbol;
declare var EEarlyZPass = { None:'None',OpaqueOnly:'OpaqueOnly',OpaqueAndMasked:'OpaqueAndMasked',Auto:'Auto', };
declare type EClearSceneOptions = string | symbol;
declare var EClearSceneOptions = { NoClear:'NoClear',HardwareClear:'HardwareClear',QuadAtMaxZ:'QuadAtMaxZ', };
declare type EGBufferFormat = string | symbol;
declare var EGBufferFormat = { Force8BitsPerChannel:'Force8BitsPerChannel',Default:'Default',HighPrecisionNormals:'HighPrecisionNormals',Force16BitsPerChannel:'Force16BitsPerChannel',EGBufferFormat_MAX:'EGBufferFormat_MAX',None:'None', };
declare class RendererSettings extends DeveloperSettings { 
	/**
	 * If true, mobile renders in full HDR. Disable this setting for games that do not require lighting features for better performance on slow devices.
	*/
	bMobileHDR: boolean;
	/**
	 * The number of dynamic point lights to support on mobile devices. Setting this to 0 for games which do not require dynamic point lights will reduce the number of shaders generated. Changing this setting requires restarting the editor.
	*/
	MobileNumDynamicPointLights: any;
	/**
	 * If this setting is enabled, the same shader will be used for any number of dynamic point lights (up to the maximum specified above) hitting a surface. This is slightly slower but reduces the number of shaders generated. Changing this setting requires restarting the editor.
	*/
	bMobileDynamicPointLightsUseStaticBranch: boolean;
	/**
	 * Allow primitives to receive both static and CSM shadows from a stationary light. Disabling will free a mobile texture sampler.
	*/
	bMobileEnableStaticAndCSMShadowReceivers: boolean;
	/**
	 * When running in game mode, whether to keep shaders for all quality levels in memory or only those needed for the current quality level.
	 * Unchecked: Keep all quality levels in memory allowing a runtime quality level change. (default)
	 * Checked: Discard unused quality levels when loading content for the game, saving some memory.
	*/
	bDiscardUnusedQualityLevels: boolean;
	/**
	 * Allows occluded meshes to be culled and no rendered.
	*/
	bOcclusionCulling: boolean;
	/**
	 * Screen radius at which lights are culled. Larger values can improve performance but causes lights to pop off when they affect a small area of the screen.
	*/
	MinScreenRadiusForLights: number;
	/**
	 * Screen radius at which objects are culled for the early Z pass. Larger values can improve performance but very large values can degrade performance if large occluders are not rendered.
	*/
	MinScreenRadiusForEarlyZPass: number;
	/**
	 * Screen radius at which objects are culled for cascaded shadow map depth passes. Larger values can improve performance but can cause artifacts as objects stop casting shadows.
	*/
	MinScreenRadiusForCSMdepth: number;
	/**
	 * Displays a warning when no precomputed visibility data is available for the current camera location. This can be helpful if you are making a game that relies on precomputed visibility, e.g. a first person mobile game.
	*/
	bPrecomputedVisibilityWarning: boolean;
	/**
	 * When enabled textures will stream in based on what is visible on screen.
	*/
	bTextureStreaming: boolean;
	/**
	 * Whether to use DXT5 for normal maps, otherwise BC5 will be used, which is not supported on all hardware. Changing this setting requires restarting the editor.
	*/
	bUseDXT5NormalMaps: boolean;
	/**
	 * Use a separate normal map for the bottom layer of a clear coat material. This is a higher quality feature that is expensive.
	*/
	bClearCoatEnableSecondNormal: boolean;
	/**
	 * The cubemap resolution for all reflection capture probes. Must be power of 2. Note that for very high values the memory and performance impact may be severe.
	*/
	ReflectionCaptureResolution: number;
	/**
	 * Whether to use forward shading on desktop platforms.  Requires Shader Model 5 hardware.  Forward shading has lower constant cost, but fewer features supported.  Changing this setting requires restarting the editor.
	*/
	bForwardShading: boolean;
	/**
	 * Whether to allow any static lighting to be generated and used, like lightmaps and shadowmaps. Games that only use dynamic lighting should set this to 0 to save some static lighting overhead. Changing this setting requires restarting the editor.
	*/
	bAllowStaticLighting: boolean;
	/**
	 * Whether to allow any static lighting to use normal maps for lighting computations.
	*/
	bUseNormalMapsForStaticLighting: boolean;
	/**
	 * Whether to build distance fields of static meshes, needed for distance field AO, which is used to implement Movable SkyLight shadows, and ray traced distance field shadows on directional lights.  Enabling will increase mesh build times and memory usage.  Changing this setting requires restarting the editor.
	*/
	bGenerateMeshDistanceFields: boolean;
	/**
	 * Whether to generate a low-resolution base color texture for landscapes for rendering real-time global illumination.  This feature requires GenerateMeshDistanceFields is also enabled, and will increase mesh build times and memory usage.
	*/
	bGenerateLandscapeGIData: boolean;
	/**
	 * When adaptive tessellation is enabled it will try to tessellate a mesh so that each triangle contains the specified number of pixels. The tessellation multiplier specified in the material can increase or decrease the amount of tessellation.
	*/
	TessellationAdaptivePixelsPerTriangle: number;
	/**
	 * Allow translucency to be rendered to a separate render targeted and composited after depth of field. Prevents translucency from appearing out of focus.
	*/
	bSeparateTranslucency: boolean;
	/**
	 * The sort mode for translucent primitives, affecting how they are ordered and how they change order as the camera moves.
	*/
	TranslucentSortPolicy: ETranslucentSortPolicy;
	/**
	 * The axis that sorting will occur along when Translucent Sort Policy is set to SortAlongAxis.
	*/
	TranslucentSortAxis: Vector;
	/**
	 * Whether the custom depth pass for tagging primitives for postprocessing passes is enabled. Enabling it on demand can save memory but may cause a hitch the first time the feature is used.
	*/
	CustomDepthStencil: ECustomDepthStencil;
	/**
	 * Whether the default for Bloom is enabled or not (postprocess volume/camera/game setting can still override and enable or disable it independently)
	*/
	bDefaultFeatureBloom: boolean;
	/**
	 * Whether the default for AmbientOcclusion is enabled or not (postprocess volume/camera/game setting can still override and enable or disable it independently)
	*/
	bDefaultFeatureAmbientOcclusion: boolean;
	/**
	 * Whether the default for AmbientOcclusionStaticFraction is enabled or not (only useful for baked lighting and if AO is on, allows to have SSAO affect baked lighting as well, costs performance, postprocess volume/camera/game setting can still override and enable or disable it independently)
	*/
	bDefaultFeatureAmbientOcclusionStaticFraction: boolean;
	/**
	 * Whether the default for AutoExposure is enabled or not (postprocess volume/camera/game setting can still override and enable or disable it independently)
	*/
	bDefaultFeatureAutoExposure: boolean;
	/**
	 * The default method for AutoExposure(postprocess volume/camera/game setting can still override and enable or disable it independently)
	*/
	DefaultFeatureAutoExposure: EAutoExposureMethodUI;
	/**
	 * Whether the default for MotionBlur is enabled or not (postprocess volume/camera/game setting can still override and enable or disable it independently)
	*/
	bDefaultFeatureMotionBlur: boolean;
	/**
	 * Whether the default for LensFlare is enabled or not (postprocess volume/camera/game setting can still override and enable or disable it independently)
	*/
	bDefaultFeatureLensFlare: boolean;
	/**
	 * What anti-aliasing mode is used by default (postprocess volume/camera/game setting can still override and enable or disable it independently)
	*/
	DefaultFeatureAntiAliasing: EAntiAliasingMethodUI;
	/**
	 * Whether to use stencil for LOD dither fading.  This saves GPU time in the base pass for materials with dither fading enabled, but forces a full prepass. Changing this setting requires restarting the editor.
	*/
	bStencilForLODDither: boolean;
	/**
	 * Whether to use a depth only pass to initialize Z culling for the base pass.
	*/
	EarlyZPass: EEarlyZPass;
	/**
	 * Whether to render movable objects in the early Z pass. Need to reload the level!
	*/
	bEarlyZPassMovable: boolean;
	/**
	 * Experimental decal feature (see r.DBuffer, ideally combined with 'Movables in early Z-pass' and 'Early Z-pass')
	*/
	bDBuffer: boolean;
	/**
	 * Select how the g-buffer is cleared in game mode (only affects deferred shading).
	*/
	ClearSceneMethod: EClearSceneOptions;
	/**
	 * Enables materials with time-based World Position Offset and/or World Displacement to output accurate velocities. This incurs a performance cost. If this is disabled, those materials will not output velocities. Changing this setting requires restarting the editor.
	*/
	bBasePassOutputsVelocity: boolean;
	/**
	 * Enables not exporting to the GBuffer rendertargets that are not relevant. Changing this setting requires restarting the editor.
	*/
	bSelectiveBasePassOutputs: boolean;
	/**
	 * Whether to support the global clip plane needed for planar reflections.  Enabling this increases BasePass triangle cost by ~15% regardless of whether planar reflections are active. Changing this setting requires restarting the editor.
	*/
	bGlobalClipPlane: boolean;
	/**
	 * Selects which GBuffer format should be used. Affects performance primarily via how much GPU memory bandwidth used.
	*/
	GBufferFormat: EGBufferFormat;
	/**
	 * Whether to use original CPU method (loop per morph then by vertex) or use a GPU-based method on Shader Model 5 hardware.
	*/
	bUseGPUMorphTargets: boolean;
	/**
	 * Enable instanced stereo rendering (only available for D3D SM5 or PS4).
	*/
	bInstancedStereo: boolean;
	/**
	 * Enable multi-view for instanced stereo rendering (only available on the PS4).
	*/
	bMultiView: boolean;
	/**
	 * Screen radius at which wireframe objects are culled. Larger values can improve performance when viewing a scene in wireframe.
	*/
	WireframeCullThreshold: number;
	/**
	 * "Stationary skylight requires permutations of the basepass shaders.  Disabling will reduce the number of shader permutations required per material. Changing this setting requires restarting the editor."
	*/
	bSupportStationarySkylight: boolean;
	/**
	 * "Low quality lightmap requires permutations of the lightmap rendering shaders.  Disabling will reduce the number of shader permutations required per material. Changing this setting requires restarting the editor."
	*/
	bSupportLowQualityLightmaps: boolean;
	/**
	 * PointLight WholeSceneShadows requires many vertex and geometry shader permutations for cubemap rendering. Disabling will reduce the number of shader permutations required per material. Changing this setting requires restarting the editor."
	*/
	bSupportPointLightWholeSceneShadows: boolean;
	/**
	 * "Atmospheric fog requires permutations of the basepass shaders.  Disabling will reduce the number of shader permutations required per material. Changing this setting requires restarting the editor."
	*/
	bSupportAtmosphericFog: boolean;
	/**
	 * UIScale Rule
	*/
	UIScaleRule: EUIScalingRule;
	/**
	 * UIScale Curve
	*/
	UIScaleCurve: RuntimeFloatCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): RendererSettings;
	static Find(Outer: UObject, ResourceName: string): RendererSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RendererSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RendererSettings;
	static C(Other: UObject): RendererSettings;
}

declare class RendererOverrideSettings extends DeveloperSettings { 
	/**
	 * "Enabling will locally override all ShaderPermutationReduction settings from the Renderer section to be enabled.  Saved to local user config only.."
	*/
	bSupportAllShaderPermutations: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): RendererOverrideSettings;
	static Find(Outer: UObject, ResourceName: string): RendererOverrideSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RendererOverrideSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RendererOverrideSettings;
	static C(Other: UObject): RendererOverrideSettings;
}

declare class TextureLODGroup { 
	/**
	 * Minimum LOD mip count below which the code won't bias.
	*/
	Group: TextureGroup;
	/**
	 * Group LOD bias.
	*/
	LODBias: number;
	/**
	 * Number of mip-levels that can be streamed. -1 means all mips can stream.
	*/
	NumStreamedMips: number;
	/**
	 * Defines how the the mip-map generation works, e.g. sharpening
	*/
	MipGenSettings: TextureMipGenSettings;
	/**
	 * Min LODSize
	*/
	MinLODSize: number;
	/**
	 * Max LODSize
	*/
	MaxLODSize: number;
	/**
	 * Min Mag Filter
	*/
	MinMagFilter: string;
	/**
	 * Mip Filter
	*/
	MipFilter: string;
	clone() : TextureLODGroup;
	static C(Other: UObject): TextureLODGroup;
}

declare class TextureLODSettings extends UObject { 
	/**
	 * Array of LOD settings with entries per group.
	*/
	TextureLODGroups: TextureLODGroup[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureLODSettings;
	static Find(Outer: UObject, ResourceName: string): TextureLODSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureLODSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureLODSettings;
	static C(Other: UObject): TextureLODSettings;
}

declare class DeviceProfile extends TextureLODSettings { 
	/**
	 * The type of this profile, I.e. IOS, Windows, PS4 etc
	*/
	DeviceType: string;
	/**
	 * The name of the parent profile of this object
	*/
	BaseProfileName: string;
	/**
	 * The parent object of this profile, it is the object matching this DeviceType with the BaseProfileName
	*/
	Parent: UObject;
	/**
	 * The collection of CVars which is set from this profile
	*/
	CVars: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DeviceProfile;
	static Find(Outer: UObject, ResourceName: string): DeviceProfile;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DeviceProfile;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeviceProfile;
	static C(Other: UObject): DeviceProfile;
}

declare class DeviceProfileManager extends UObject { 
	/**
	 * Holds the collection of managed profiles.
	*/
	Profiles: UObject[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DeviceProfileManager;
	static Find(Outer: UObject, ResourceName: string): DeviceProfileManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DeviceProfileManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DeviceProfileManager;
	static C(Other: UObject): DeviceProfileManager;
}

declare class DistributionFloatConstant extends DistributionFloat { 
	/**
	 * This float will be returned for all values of time.
	*/
	Constant: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionFloatConstant;
	static Find(Outer: UObject, ResourceName: string): DistributionFloatConstant;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionFloatConstant;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloatConstant;
	static C(Other: UObject): DistributionFloatConstant;
}

declare type DistributionParamMode = string | symbol;
declare var DistributionParamMode = { DPM_Normal:'DPM_Normal',DPM_Abs:'DPM_Abs',DPM_Direct:'DPM_Direct', };
declare class DistributionFloatParameterBase extends DistributionFloatConstant { 
	/**
	 * todo document
	*/
	ParameterName: string;
	/**
	 * todo document
	*/
	MinInput: number;
	/**
	 * todo document
	*/
	MaxInput: number;
	/**
	 * todo document
	*/
	MinOutput: number;
	/**
	 * todo document
	*/
	MaxOutput: number;
	/**
	 * todo document
	*/
	ParamMode: DistributionParamMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionFloatParameterBase;
	static Find(Outer: UObject, ResourceName: string): DistributionFloatParameterBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionFloatParameterBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloatParameterBase;
	static C(Other: UObject): DistributionFloatParameterBase;
}

declare class DistributionFloatParticleParameter extends DistributionFloatParameterBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionFloatParticleParameter;
	static Find(Outer: UObject, ResourceName: string): DistributionFloatParticleParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionFloatParticleParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloatParticleParameter;
	static C(Other: UObject): DistributionFloatParticleParameter;
}

declare class DistributionFloatConstantCurve extends DistributionFloat { 
	/**
	 * Keyframe data for how output constant varies over time.
	*/
	ConstantCurve: InterpCurveFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionFloatConstantCurve;
	static Find(Outer: UObject, ResourceName: string): DistributionFloatConstantCurve;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionFloatConstantCurve;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloatConstantCurve;
	static C(Other: UObject): DistributionFloatConstantCurve;
}

declare class DistributionFloatUniform extends DistributionFloat { 
	/**
	 * Low end of output float distribution.
	*/
	Min: number;
	/**
	 * High end of output float distribution.
	*/
	Max: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionFloatUniform;
	static Find(Outer: UObject, ResourceName: string): DistributionFloatUniform;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionFloatUniform;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloatUniform;
	static C(Other: UObject): DistributionFloatUniform;
}

declare class InterpCurvePointVector2D { 
	/**
	 * In Val
	*/
	InVal: number;
	/**
	 * Out Val
	*/
	OutVal: Vector2D;
	/**
	 * Arrive Tangent
	*/
	ArriveTangent: Vector2D;
	/**
	 * Leave Tangent
	*/
	LeaveTangent: Vector2D;
	/**
	 * Interp Mode
	*/
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointVector2D;
	static C(Other: UObject): InterpCurvePointVector2D;
}

declare class InterpCurveVector2D { 
	/**
	 * Points
	*/
	Points: InterpCurvePointVector2D[];
	/**
	 * Is Looped
	*/
	bIsLooped: boolean;
	/**
	 * Loop Key Offset
	*/
	LoopKeyOffset: number;
	clone() : InterpCurveVector2D;
	static C(Other: UObject): InterpCurveVector2D;
}

declare class DistributionFloatUniformCurve extends DistributionFloat { 
	/**
	 * Keyframe data for how output constant varies over time.
	*/
	ConstantCurve: InterpCurveVector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionFloatUniformCurve;
	static Find(Outer: UObject, ResourceName: string): DistributionFloatUniformCurve;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionFloatUniformCurve;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloatUniformCurve;
	static C(Other: UObject): DistributionFloatUniformCurve;
}

declare type EDistributionVectorLockFlags = string | symbol;
declare var EDistributionVectorLockFlags = { EDVLF_None:'EDVLF_None',EDVLF_XY:'EDVLF_XY',EDVLF_XZ:'EDVLF_XZ',EDVLF_YZ:'EDVLF_YZ',EDVLF_XYZ:'EDVLF_XYZ', };
declare class DistributionVectorConstant extends DistributionVector { 
	/**
	 * This FVector will be returned for all input times.
	*/
	Constant: Vector;
	/**
	 * If true, X == Y == Z ie. only one degree of freedom. If false, each axis is picked independently.
	*/
	bLockAxes: boolean;
	/**
	 * Locked Axes
	*/
	LockedAxes: EDistributionVectorLockFlags;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionVectorConstant;
	static Find(Outer: UObject, ResourceName: string): DistributionVectorConstant;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionVectorConstant;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVectorConstant;
	static C(Other: UObject): DistributionVectorConstant;
}

declare class DistributionVectorParameterBase extends DistributionVectorConstant { 
	/**
	 * Parameter Name
	*/
	ParameterName: string;
	/**
	 * Min Input
	*/
	MinInput: Vector;
	/**
	 * Max Input
	*/
	MaxInput: Vector;
	/**
	 * Min Output
	*/
	MinOutput: Vector;
	/**
	 * Max Output
	*/
	MaxOutput: Vector;
	/**
	 * Param Modes
	*/
	ParamModes: DistributionParamMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionVectorParameterBase;
	static Find(Outer: UObject, ResourceName: string): DistributionVectorParameterBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionVectorParameterBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVectorParameterBase;
	static C(Other: UObject): DistributionVectorParameterBase;
}

declare class DistributionVectorParticleParameter extends DistributionVectorParameterBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionVectorParticleParameter;
	static Find(Outer: UObject, ResourceName: string): DistributionVectorParticleParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionVectorParticleParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVectorParticleParameter;
	static C(Other: UObject): DistributionVectorParticleParameter;
}

declare class DistributionVectorConstantCurve extends DistributionVector { 
	/**
	 * Keyframe data for each component (X,Y,Z) over time.
	*/
	ConstantCurve: InterpCurveVector;
	/**
	 * If true, X == Y == Z ie. only one degree of freedom. If false, each axis is picked independently.
	*/
	bLockAxes: boolean;
	/**
	 * Locked Axes
	*/
	LockedAxes: EDistributionVectorLockFlags;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionVectorConstantCurve;
	static Find(Outer: UObject, ResourceName: string): DistributionVectorConstantCurve;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionVectorConstantCurve;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVectorConstantCurve;
	static C(Other: UObject): DistributionVectorConstantCurve;
}

declare type EDistributionVectorMirrorFlags = string | symbol;
declare var EDistributionVectorMirrorFlags = { EDVMF_Same:'EDVMF_Same',EDVMF_Different:'EDVMF_Different',EDVMF_Mirror:'EDVMF_Mirror', };
declare class DistributionVectorUniform extends DistributionVector { 
	/**
	 * Upper end of FVector magnitude range.
	*/
	Max: Vector;
	/**
	 * Lower end of FVector magnitude range.
	*/
	Min: Vector;
	/**
	 * If true, X == Y == Z ie. only one degree of freedom. If false, each axis is picked independently.
	*/
	bLockAxes: boolean;
	/**
	 * Locked Axes
	*/
	LockedAxes: EDistributionVectorLockFlags;
	/**
	 * Mirror Flags
	*/
	MirrorFlags: EDistributionVectorMirrorFlags;
	/**
	 * Use Extremes
	*/
	bUseExtremes: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionVectorUniform;
	static Find(Outer: UObject, ResourceName: string): DistributionVectorUniform;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionVectorUniform;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVectorUniform;
	static C(Other: UObject): DistributionVectorUniform;
}

declare class TwoVectors { 
	/**
	 * V 1
	*/
	v1: Vector;
	/**
	 * V 2
	*/
	v2: Vector;
	clone() : TwoVectors;
	static C(Other: UObject): TwoVectors;
}

declare class InterpCurvePointTwoVectors { 
	/**
	 * In Val
	*/
	InVal: number;
	/**
	 * Out Val
	*/
	OutVal: TwoVectors;
	/**
	 * Arrive Tangent
	*/
	ArriveTangent: TwoVectors;
	/**
	 * Leave Tangent
	*/
	LeaveTangent: TwoVectors;
	/**
	 * Interp Mode
	*/
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointTwoVectors;
	static C(Other: UObject): InterpCurvePointTwoVectors;
}

declare class InterpCurveTwoVectors { 
	/**
	 * Points
	*/
	Points: InterpCurvePointTwoVectors[];
	/**
	 * Is Looped
	*/
	bIsLooped: boolean;
	/**
	 * Loop Key Offset
	*/
	LoopKeyOffset: number;
	clone() : InterpCurveTwoVectors;
	static C(Other: UObject): InterpCurveTwoVectors;
}

declare class DistributionVectorUniformCurve extends DistributionVector { 
	/**
	 * Keyframe data for how output constant varies over time.
	*/
	ConstantCurve: InterpCurveTwoVectors;
	/**
	 * If true, X == Y == Z ie. only one degree of freedom. If false, each axis is picked independently.
	*/
	bLockAxes1: boolean;
	/**
	 * Lock Axes 2
	*/
	bLockAxes2: boolean;
	/**
	 * Locked Axes
	*/
	LockedAxes: EDistributionVectorLockFlags;
	/**
	 * Mirror Flags
	*/
	MirrorFlags: EDistributionVectorMirrorFlags;
	/**
	 * Use Extremes
	*/
	bUseExtremes: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionVectorUniformCurve;
	static Find(Outer: UObject, ResourceName: string): DistributionVectorUniformCurve;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionVectorUniformCurve;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVectorUniformCurve;
	static C(Other: UObject): DistributionVectorUniformCurve;
}

declare class BlueprintComponentDelegateBinding { 
	/**
	 * Name of component property that contains delegate we want to assign to.
	*/
	ComponentPropertyName: string;
	/**
	 * Name of property on the component that we want to assign to.
	*/
	DelegatePropertyName: string;
	/**
	 * Name of function that we want to bind to the delegate.
	*/
	FunctionNameToBind: string;
	clone() : BlueprintComponentDelegateBinding;
	static C(Other: UObject): BlueprintComponentDelegateBinding;
}

declare class ComponentDelegateBinding extends DynamicBlueprintBinding { 
	/**
	 * Component Delegate Bindings
	*/
	ComponentDelegateBindings: BlueprintComponentDelegateBinding[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ComponentDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): ComponentDelegateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ComponentDelegateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ComponentDelegateBinding;
	static C(Other: UObject): ComponentDelegateBinding;
}

declare class InputDelegateBinding extends DynamicBlueprintBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputDelegateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputDelegateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputDelegateBinding;
	static C(Other: UObject): InputDelegateBinding;
}

declare class BlueprintInputDelegateBinding { 
	/**
	 * Consume Input
	*/
	bConsumeInput: boolean;
	/**
	 * Execute when Paused
	*/
	bExecuteWhenPaused: boolean;
	/**
	 * Override Parent Binding
	*/
	bOverrideParentBinding: boolean;
	clone() : BlueprintInputDelegateBinding;
	static C(Other: UObject): BlueprintInputDelegateBinding;
}

declare class BlueprintInputActionDelegateBinding extends BlueprintInputDelegateBinding { 
	/**
	 * Input Action Name
	*/
	InputActionName: string;
	/**
	 * Input Key Event
	*/
	InputKeyEvent: EInputEvent;
	/**
	 * Function Name to Bind
	*/
	FunctionNameToBind: string;
	clone() : BlueprintInputActionDelegateBinding;
	static C(Other: UObject): BlueprintInputActionDelegateBinding;
}

declare class InputActionDelegateBinding extends InputDelegateBinding { 
	/**
	 * Input Action Delegate Bindings
	*/
	InputActionDelegateBindings: BlueprintInputActionDelegateBinding[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputActionDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputActionDelegateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputActionDelegateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputActionDelegateBinding;
	static C(Other: UObject): InputActionDelegateBinding;
}

declare class BlueprintInputAxisDelegateBinding extends BlueprintInputDelegateBinding { 
	/**
	 * Input Axis Name
	*/
	InputAxisName: string;
	/**
	 * Function Name to Bind
	*/
	FunctionNameToBind: string;
	clone() : BlueprintInputAxisDelegateBinding;
	static C(Other: UObject): BlueprintInputAxisDelegateBinding;
}

declare class InputAxisDelegateBinding extends InputDelegateBinding { 
	/**
	 * Input Axis Delegate Bindings
	*/
	InputAxisDelegateBindings: BlueprintInputAxisDelegateBinding[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputAxisDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputAxisDelegateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputAxisDelegateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputAxisDelegateBinding;
	static C(Other: UObject): InputAxisDelegateBinding;
}

declare class BlueprintInputAxisKeyDelegateBinding extends BlueprintInputDelegateBinding { 
	/**
	 * Axis Key
	*/
	AxisKey: Key;
	/**
	 * Function Name to Bind
	*/
	FunctionNameToBind: string;
	clone() : BlueprintInputAxisKeyDelegateBinding;
	static C(Other: UObject): BlueprintInputAxisKeyDelegateBinding;
}

declare class InputAxisKeyDelegateBinding extends InputDelegateBinding { 
	/**
	 * Input Axis Key Delegate Bindings
	*/
	InputAxisKeyDelegateBindings: BlueprintInputAxisKeyDelegateBinding[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputAxisKeyDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputAxisKeyDelegateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputAxisKeyDelegateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputAxisKeyDelegateBinding;
	static C(Other: UObject): InputAxisKeyDelegateBinding;
}

declare class InputVectorAxisDelegateBinding extends InputAxisKeyDelegateBinding { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputVectorAxisDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputVectorAxisDelegateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputVectorAxisDelegateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputVectorAxisDelegateBinding;
	static C(Other: UObject): InputVectorAxisDelegateBinding;
}

declare class BlueprintInputKeyDelegateBinding extends BlueprintInputDelegateBinding { 
	/**
	 * Input Chord
	*/
	InputChord: InputChord;
	/**
	 * Input Key Event
	*/
	InputKeyEvent: EInputEvent;
	/**
	 * Function Name to Bind
	*/
	FunctionNameToBind: string;
	clone() : BlueprintInputKeyDelegateBinding;
	static C(Other: UObject): BlueprintInputKeyDelegateBinding;
}

declare class InputKeyDelegateBinding extends InputDelegateBinding { 
	/**
	 * Input Key Delegate Bindings
	*/
	InputKeyDelegateBindings: BlueprintInputKeyDelegateBinding[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputKeyDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputKeyDelegateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputKeyDelegateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputKeyDelegateBinding;
	static C(Other: UObject): InputKeyDelegateBinding;
}

declare class BlueprintInputTouchDelegateBinding extends BlueprintInputDelegateBinding { 
	/**
	 * Input Key Event
	*/
	InputKeyEvent: EInputEvent;
	/**
	 * Function Name to Bind
	*/
	FunctionNameToBind: string;
	clone() : BlueprintInputTouchDelegateBinding;
	static C(Other: UObject): BlueprintInputTouchDelegateBinding;
}

declare class InputTouchDelegateBinding extends InputDelegateBinding { 
	/**
	 * Input Touch Delegate Bindings
	*/
	InputTouchDelegateBindings: BlueprintInputTouchDelegateBinding[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputTouchDelegateBinding;
	static Find(Outer: UObject, ResourceName: string): InputTouchDelegateBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputTouchDelegateBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputTouchDelegateBinding;
	static C(Other: UObject): InputTouchDelegateBinding;
}

declare class EdGraphNode_Documentation extends EdGraphNode { 
	/**
	 * Documentation Link
	*/
	Link: string;
	/**
	 * Documentation Excerpt
	*/
	Excerpt: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphNode_Documentation;
	static Find(Outer: UObject, ResourceName: string): EdGraphNode_Documentation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphNode_Documentation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphNode_Documentation;
	static C(Other: UObject): EdGraphNode_Documentation;
}

declare class ImportantToggleSettingInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ImportantToggleSettingInterface;
	static Find(Outer: UObject, ResourceName: string): ImportantToggleSettingInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ImportantToggleSettingInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImportantToggleSettingInterface;
	static C(Other: UObject): ImportantToggleSettingInterface;
}

declare class EndUserSettings extends UObject { 
	/**
	 * Determines whether the engine sends anonymous usage information about game sessions to Epic Games in order to improve Unreal Engine. Information will never be shared with 3rd parties.
	*/
	bSendAnonymousUsageDataToEpic: boolean;
	/**
	 * Determines whether the engine sends anonymous crash/abnormal-shutdown data about game sessions to Epic Games in order to improve Unreal Engine. Information will never be shared with 3rd parties.
	*/
	bSendMeanTimeBetweenFailureDataToEpic: boolean;
	/**
	 * If enabled, adds user identifying data to the otherwise anonymous reports sent to Epic Games.
	*/
	bAllowUserIdInUsageData: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EndUserSettings;
	static Find(Outer: UObject, ResourceName: string): EndUserSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EndUserSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndUserSettings;
	static C(Other: UObject): EndUserSettings;
}

declare class GameEngine extends Engine { 
	/**
	 * Maximium delta time the engine uses to populate FApp::DeltaTime. If 0, unbound.
	*/
	MaxDeltaTime: number;
	/**
	 * Maximium time (in seconds) between the flushes of the logs on the server (best effort). If 0, this will happen every tick.
	*/
	ServerFlushLogInterval: number;
	/**
	 * Game Instance
	*/
	GameInstance: GameInstance;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameEngine;
	static Find(Outer: UObject, ResourceName: string): GameEngine;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameEngine;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameEngine;
	static C(Other: UObject): GameEngine;
}

declare class EngineHandlerComponentFactory extends HandlerComponentFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EngineHandlerComponentFactory;
	static Find(Outer: UObject, ResourceName: string): EngineHandlerComponentFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EngineHandlerComponentFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineHandlerComponentFactory;
	static C(Other: UObject): EngineHandlerComponentFactory;
}

declare class HapticFeedbackEffect_Buffer extends HapticFeedbackEffect_Base { 
	/**
	 * Amplitudes
	*/
	Amplitudes: number[];
	/**
	 * Sample Rate
	*/
	SampleRate: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HapticFeedbackEffect_Buffer;
	static Find(Outer: UObject, ResourceName: string): HapticFeedbackEffect_Buffer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HapticFeedbackEffect_Buffer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HapticFeedbackEffect_Buffer;
	static C(Other: UObject): HapticFeedbackEffect_Buffer;
}

declare class HapticFeedbackDetails_Curve { 
	/**
	 * The frequency to vibrate the haptic device at.  Frequency ranges vary by device!
	*/
	Frequency: RuntimeFloatCurve;
	/**
	 * The amplitude to vibrate the haptic device at.  Amplitudes are normalized over the range [0.0, 1.0], with 1.0 being the max setting of the device
	*/
	Amplitude: RuntimeFloatCurve;
	clone() : HapticFeedbackDetails_Curve;
	static C(Other: UObject): HapticFeedbackDetails_Curve;
}

declare class HapticFeedbackEffect_Curve extends HapticFeedbackEffect_Base { 
	/**
	 * Haptic Details
	*/
	HapticDetails: HapticFeedbackDetails_Curve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HapticFeedbackEffect_Curve;
	static Find(Outer: UObject, ResourceName: string): HapticFeedbackEffect_Curve;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HapticFeedbackEffect_Curve;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HapticFeedbackEffect_Curve;
	static C(Other: UObject): HapticFeedbackEffect_Curve;
}

declare class SoundGroup { 
	/**
	 * The sound group enumeration we are setting values for
	*/
	SoundGroup: ESoundGroup;
	/**
	 * An override display name for custom game sound groups
	*/
	DisplayName: string;
	/**
	 * Whether sounds in this group should always decompress on load
	*/
	bAlwaysDecompressOnLoad: boolean;
	/**
	 * Sound duration in seconds below which sounds are entirely expanded to PCM at load time
	 * Disregarded if bAlwaysDecompressOnLoad is true
	*/
	DecompressedDuration: number;
	clone() : SoundGroup;
	static C(Other: UObject): SoundGroup;
}

declare class SoundGroups extends UObject { 
	/**
	 * The ini editable array of profiles
	*/
	SoundGroupProfiles: SoundGroup[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundGroups;
	static Find(Outer: UObject, ResourceName: string): SoundGroups;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundGroups;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundGroups;
	static C(Other: UObject): SoundGroups;
}

declare class HapticFeedbackEffect_SoundWave extends HapticFeedbackEffect_Base { 
	/**
	 * Sound Wave
	*/
	SoundWave: SoundWave;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HapticFeedbackEffect_SoundWave;
	static Find(Outer: UObject, ResourceName: string): HapticFeedbackEffect_SoundWave;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HapticFeedbackEffect_SoundWave;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HapticFeedbackEffect_SoundWave;
	static C(Other: UObject): HapticFeedbackEffect_SoundWave;
}

declare class InputAxisProperties { 
	/**
	 * What the dead zone of the axis is.  For control axes such as analog sticks.
	*/
	DeadZone: number;
	/**
	 * Scaling factor to multiply raw value by.
	*/
	Sensitivity: number;
	/**
	 * For applying curves to [0..1] axes, e.g. analog sticks
	*/
	Exponent: number;
	/**
	 * Inverts reported values for this axis
	*/
	bInvert: boolean;
	clone() : InputAxisProperties;
	static C(Other: UObject): InputAxisProperties;
}

declare class InputAxisConfigEntry { 
	/**
	 * Axis Key these properties apply to
	*/
	AxisKeyName: string;
	/**
	 * Properties for the Axis Key
	*/
	AxisProperties: InputAxisProperties;
	clone() : InputAxisConfigEntry;
	static C(Other: UObject): InputAxisConfigEntry;
}

declare type EMouseCaptureMode = string | symbol;
declare var EMouseCaptureMode = { NoCapture:'NoCapture',CapturePermanently:'CapturePermanently',CapturePermanently_IncludingInitialMouseDown:'CapturePermanently_IncludingInitialMouseDown',CaptureDuringMouseDown:'CaptureDuringMouseDown',CaptureDuringRightMouseDown:'CaptureDuringRightMouseDown', };
declare class InputActionKeyMapping { 
	/**
	 * Friendly name of action, e.g "jump"
	*/
	ActionName: string;
	/**
	 * Key to bind it to.
	*/
	Key: Key;
	/**
	 * true if one of the Shift keys must be down when the KeyEvent is received to be acknowledged
	*/
	bShift: boolean;
	/**
	 * true if one of the Ctrl keys must be down when the KeyEvent is received to be acknowledged
	*/
	bCtrl: boolean;
	/**
	 * true if one of the Alt keys must be down when the KeyEvent is received to be acknowledged
	*/
	bAlt: boolean;
	/**
	 * true if one of the Cmd keys must be down when the KeyEvent is received to be acknowledged
	*/
	bCmd: boolean;
	clone() : InputActionKeyMapping;
	static C(Other: UObject): InputActionKeyMapping;
}

declare class InputAxisKeyMapping { 
	/**
	 * Friendly name of axis, e.g "MoveForward"
	*/
	AxisName: string;
	/**
	 * Key to bind it to.
	*/
	Key: Key;
	/**
	 * Multiplier to use for the mapping when accumulating the axis value
	*/
	Scale: number;
	clone() : InputAxisKeyMapping;
	static C(Other: UObject): InputAxisKeyMapping;
}

declare class InputSettings extends UObject { 
	/**
	 * List of Axis Properties
	*/
	AxisConfig: InputAxisConfigEntry[];
	/**
	 * Alt Enter Toggles Fullscreen
	*/
	bAltEnterTogglesFullscreen: boolean;
	/**
	 * Allow mouse to be used for touch
	*/
	bUseMouseForTouch: boolean;
	/**
	 * Mouse smoothing control
	*/
	bEnableMouseSmoothing: boolean;
	/**
	 * Scale the mouse based on the player camera manager's field of view
	*/
	bEnableFOVScaling: boolean;
	/**
	 * The scaling value to multiply the field of view by
	*/
	FOVScale: number;
	/**
	 * If a key is pressed twice in this amount of time it is considered a "double click"
	*/
	DoubleClickTime: number;
	/**
	 * Controls if the viewport will capture the mouse on Launch of the application
	*/
	bCaptureMouseOnLaunch: boolean;
	/**
	 * The default mouse capture mode for the game viewport
	*/
	DefaultViewportMouseCaptureMode: EMouseCaptureMode;
	/**
	 * The default mouse lock state when the viewport acquires capture
	*/
	bDefaultViewportMouseLock: boolean;
	/**
	 * The default mouse lock state behavior when the viewport acquires capture
	*/
	DefaultViewportMouseLockMode: EMouseLockMode;
	/**
	 * List of Action Mappings
	*/
	ActionMappings: InputActionKeyMapping[];
	/**
	 * List of Axis Mappings
	*/
	AxisMappings: InputAxisKeyMapping[];
	/**
	 * Should the touch input interface be shown always, or only when the platform has a touch screen?
	*/
	bAlwaysShowTouchInterface: boolean;
	/**
	 * Whether or not to show the console on 4 finger tap, on mobile platforms
	*/
	bShowConsoleOnFourFingerTap: boolean;
	/**
	 * The default on-screen touch input interface for the game (can be null to disable the onscreen interface)
	*/
	DefaultTouchInterface: StringAssetReference;
	/**
	 * The key which opens the console.
	*/
	ConsoleKey: Key;
	/**
	 * The keys which open the console.
	*/
	ConsoleKeys: Key[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputSettings;
	static Find(Outer: UObject, ResourceName: string): InputSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputSettings;
	static C(Other: UObject): InputSettings;
}

declare class InterpFilter_Classes extends InterpFilter { 
	/**
	 * Which class to filter groups by.
	*/
	ClassToFilterBy: UnrealEngineClass;
	/**
	 * List of allowed track classes.  If empty, then all track classes will be included.  Only groups that
	 *               contain at least one of these types of tracks will be displayed.
	*/
	TrackClasses: UnrealEngineClass[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpFilter_Classes;
	static Find(Outer: UObject, ResourceName: string): InterpFilter_Classes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpFilter_Classes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpFilter_Classes;
	static C(Other: UObject): InterpFilter_Classes;
}

declare class InterpFilter_Custom extends InterpFilter { 
	/**
	 * Which groups are included in this filter.
	*/
	GroupsToInclude: InterpGroup[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpFilter_Custom;
	static Find(Outer: UObject, ResourceName: string): InterpFilter_Custom;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpFilter_Custom;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpFilter_Custom;
	static C(Other: UObject): InterpFilter_Custom;
}

declare class CameraPreviewInfo { 
	/**
	 * Pawn Class
	*/
	PawnClass: UnrealEngineClass;
	/**
	 * Anim Seq
	*/
	AnimSeq: AnimSequence;
	/**
	 * for now this is read-only. It has maintenance issue to be resolved if I enable this.
	*/
	Location: Vector;
	/**
	 * Rotation
	*/
	Rotation: Rotator;
	/**
	 * APawn Inst - CameraAnimInst doesn't really exist in editor *
	*/
	PawnInst: Pawn;
	clone() : CameraPreviewInfo;
	static C(Other: UObject): CameraPreviewInfo;
}

declare class InterpGroupCamera extends InterpGroup { 
	/**
	 * Camera Anim Inst
	*/
	CameraAnimInst: CameraAnim;
	/**
	 * this is interaction property info for CameraAnim
	 * this information isn't really saved with it
	*/
	Target: CameraPreviewInfo;
	/**
	 * When compress, tolerance option *
	*/
	CompressTolerance: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroupCamera;
	static Find(Outer: UObject, ResourceName: string): InterpGroupCamera;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroupCamera;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupCamera;
	static C(Other: UObject): InterpGroupCamera;
}

declare class InterpGroupInstCamera extends InterpGroupInst { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroupInstCamera;
	static Find(Outer: UObject, ResourceName: string): InterpGroupInstCamera;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroupInstCamera;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupInstCamera;
	static C(Other: UObject): InterpGroupInstCamera;
}

declare class InterpGroupInstDirector extends InterpGroupInst { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroupInstDirector;
	static Find(Outer: UObject, ResourceName: string): InterpGroupInstDirector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroupInstDirector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupInstDirector;
	static C(Other: UObject): InterpGroupInstDirector;
}

declare class BoolTrackKey { 
	/**
	 * Time
	*/
	Time: number;
	/**
	 * Value
	*/
	Value: boolean;
	clone() : BoolTrackKey;
	static C(Other: UObject): BoolTrackKey;
}

declare class InterpTrackBoolProp extends InterpTrack { 
	/**
	 * Array of booleans to set.
	*/
	BoolTrack: BoolTrackKey[];
	/**
	 * Name of property in Group  AActor  which this track will modify over time.
	*/
	PropertyName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackBoolProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackBoolProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackBoolProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackBoolProp;
	static C(Other: UObject): InterpTrackBoolProp;
}

declare class DirectorTrackCut { 
	/**
	 * Time to perform the cut.
	*/
	Time: number;
	/**
	 * Time taken to move view to new camera.
	*/
	TransitionTime: number;
	/**
	 * GroupName of UInterpGroup to cut viewpoint to.
	*/
	TargetCamGroup: string;
	/**
	 * Shot number for developer reference
	*/
	ShotNumber: number;
	clone() : DirectorTrackCut;
	static C(Other: UObject): DirectorTrackCut;
}

declare class InterpTrackDirector extends InterpTrack { 
	/**
	 * Array of cuts between cameras.
	*/
	CutTrack: DirectorTrackCut[];
	/**
	 * True to allow clients to simulate their own camera cuts.  Can help with latency-induced timing issues.
	*/
	bSimulateCameraCutsOnClients: boolean;
	/**
	 * The camera actor which the track is currently focused on. Only valid if this track or it's group is selected
	*/
	PreviewCamera: CameraActor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackDirector;
	static Find(Outer: UObject, ResourceName: string): InterpTrackDirector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackDirector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackDirector;
	static C(Other: UObject): InterpTrackDirector;
}

declare class EventTrackKey { 
	/**
	 * Time
	*/
	Time: number;
	/**
	 * Event Name
	*/
	EventName: string;
	clone() : EventTrackKey;
	static C(Other: UObject): EventTrackKey;
}

declare class InterpTrackEvent extends InterpTrack { 
	/**
	 * Array of events to fire off.
	*/
	EventTrack: EventTrackKey[];
	/**
	 * If events should be fired when passed playing the sequence forwards.
	*/
	bFireEventsWhenForwards: boolean;
	/**
	 * If events should be fired when passed playing the sequence backwards.
	*/
	bFireEventsWhenBackwards: boolean;
	/**
	 * If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic.
	*/
	bFireEventsWhenJumpingForwards: boolean;
	/**
	 * If checked each key's event name is the exact name of the custom event function in level script that will be called
	*/
	bUseCustomEventName: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackEvent;
	static Find(Outer: UObject, ResourceName: string): InterpTrackEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackEvent;
	static C(Other: UObject): InterpTrackEvent;
}

declare class InterpTrackFloatBase extends InterpTrack { 
	/**
	 * Actually track data containing keyframes of float as it varies over time.
	*/
	FloatTrack: InterpCurveFloat;
	/**
	 * Tension of curve, used for keypoints using automatic tangents.
	*/
	CurveTension: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackFloatBase;
	static Find(Outer: UObject, ResourceName: string): InterpTrackFloatBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackFloatBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackFloatBase;
	static C(Other: UObject): InterpTrackFloatBase;
}

declare class AnimControlTrackKey { 
	/**
	 * Position in the Matinee sequence to start playing this animation.
	*/
	StartTime: number;
	/**
	 * Animation Sequence to play
	*/
	AnimSeq: AnimSequence;
	/**
	 * Time to start playing AnimSequence at.
	*/
	AnimStartOffset: number;
	/**
	 * Time to end playing the AnimSequence at.
	*/
	AnimEndOffset: number;
	/**
	 * Playback speed of this animation.
	*/
	AnimPlayRate: number;
	/**
	 * Should this animation loop.
	*/
	bLooping: boolean;
	/**
	 * Whether to play the animation in reverse or not.
	*/
	bReverse: boolean;
	clone() : AnimControlTrackKey;
	static C(Other: UObject): AnimControlTrackKey;
}

declare class InterpTrackAnimControl extends InterpTrackFloatBase { 
	/**
	 * Name of slot to use when playing animation. Passed to Actor.
	 * When multiple tracks use the same slot name, they are each given a different ChannelIndex when SetAnimPosition is called.
	*/
	SlotName: string;
	/**
	 * Track of different animations to play and when to start playing them.
	*/
	AnimSeqs: AnimControlTrackKey[];
	/**
	 * Skip all anim notifiers *
	*/
	bSkipAnimNotifiers: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackAnimControl;
	static Find(Outer: UObject, ResourceName: string): InterpTrackAnimControl;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackAnimControl;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackAnimControl;
	static C(Other: UObject): InterpTrackAnimControl;
}

declare class InterpTrackFade extends InterpTrackFloatBase { 
	/**
	 * InterpTrackFade
	 * Special float property track that controls camera fading over time.
	 * Should live in a Director group.
	*/
	bPersistFade: boolean;
	/**
	 * True to set master audio volume along with the visual fade.
	*/
	bFadeAudio: boolean;
	/**
	 * Color to fade to.
	*/
	FadeColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackFade;
	static Find(Outer: UObject, ResourceName: string): InterpTrackFade;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackFade;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackFade;
	static C(Other: UObject): InterpTrackFade;
}

declare class InterpTrackFloatAnimBPParam extends InterpTrackFloatBase { 
	/**
	 * Anim Blueprint Class
	*/
	AnimBlueprintClass: UnrealEngineClass;
	/**
	 * Materials whose parameters we want to change and the references to those materials.
	*/
	AnimClass: UnrealEngineClass;
	/**
	 * Name of parameter in the MaterialInstance which this track will modify over time.
	*/
	ParamName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackFloatAnimBPParam;
	static Find(Outer: UObject, ResourceName: string): InterpTrackFloatAnimBPParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackFloatAnimBPParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackFloatAnimBPParam;
	static C(Other: UObject): InterpTrackFloatAnimBPParam;
}

declare class InterpTrackFloatMaterialParam extends InterpTrackFloatBase { 
	/**
	 * Materials whose parameters we want to change and the references to those materials.
	*/
	TargetMaterials: MaterialInterface[];
	/**
	 * Name of parameter in the MaterialInstance which this track will modify over time.
	*/
	ParamName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackFloatMaterialParam;
	static Find(Outer: UObject, ResourceName: string): InterpTrackFloatMaterialParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackFloatMaterialParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackFloatMaterialParam;
	static C(Other: UObject): InterpTrackFloatMaterialParam;
}

declare class InterpTrackFloatParticleParam extends InterpTrackFloatBase { 
	/**
	 * Name of property in the Emitter which this track mill modify over time.
	*/
	ParamName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackFloatParticleParam;
	static Find(Outer: UObject, ResourceName: string): InterpTrackFloatParticleParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackFloatParticleParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackFloatParticleParam;
	static C(Other: UObject): InterpTrackFloatParticleParam;
}

declare class InterpTrackFloatProp extends InterpTrackFloatBase { 
	/**
	 * Name of property in Group  AActor  which this track mill modify over time.
	*/
	PropertyName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackFloatProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackFloatProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackFloatProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackFloatProp;
	static C(Other: UObject): InterpTrackFloatProp;
}

declare type EInterpMoveAxis = string | symbol;
declare var EInterpMoveAxis = { AXIS_TranslationX:'AXIS_TranslationX',AXIS_TranslationY:'AXIS_TranslationY',AXIS_TranslationZ:'AXIS_TranslationZ',AXIS_RotationX:'AXIS_RotationX',AXIS_RotationY:'AXIS_RotationY',AXIS_RotationZ:'AXIS_RotationZ', };
declare class InterpTrackMoveAxis extends InterpTrackFloatBase { 
	/**
	 * The axis which this track will use when transforming an actor
	*/
	MoveAxis: EInterpMoveAxis;
	/**
	 * Lookup track to use when looking at different groups for transform information
	*/
	LookupTrack: InterpLookupTrack;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackMoveAxis;
	static Find(Outer: UObject, ResourceName: string): InterpTrackMoveAxis;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackMoveAxis;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackMoveAxis;
	static C(Other: UObject): InterpTrackMoveAxis;
}

declare class InterpTrackSlomo extends InterpTrackFloatBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackSlomo;
	static Find(Outer: UObject, ResourceName: string): InterpTrackSlomo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackSlomo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackSlomo;
	static C(Other: UObject): InterpTrackSlomo;
}

declare class InterpCurvePointLinearColor { 
	/**
	 * In Val
	*/
	InVal: number;
	/**
	 * Out Val
	*/
	OutVal: LinearColor;
	/**
	 * Arrive Tangent
	*/
	ArriveTangent: LinearColor;
	/**
	 * Leave Tangent
	*/
	LeaveTangent: LinearColor;
	/**
	 * Interp Mode
	*/
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointLinearColor;
	static C(Other: UObject): InterpCurvePointLinearColor;
}

declare class InterpCurveLinearColor { 
	/**
	 * Points
	*/
	Points: InterpCurvePointLinearColor[];
	/**
	 * Is Looped
	*/
	bIsLooped: boolean;
	/**
	 * Loop Key Offset
	*/
	LoopKeyOffset: number;
	clone() : InterpCurveLinearColor;
	static C(Other: UObject): InterpCurveLinearColor;
}

declare class InterpTrackLinearColorBase extends InterpTrack { 
	/**
	 * Actually track data containing keyframes of a FVector as it varies over time.
	*/
	LinearColorTrack: InterpCurveLinearColor;
	/**
	 * Tension of curve, used for keypoints using automatic tangents.
	*/
	CurveTension: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackLinearColorBase;
	static Find(Outer: UObject, ResourceName: string): InterpTrackLinearColorBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackLinearColorBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackLinearColorBase;
	static C(Other: UObject): InterpTrackLinearColorBase;
}

declare class InterpTrackLinearColorProp extends InterpTrackLinearColorBase { 
	/**
	 * Name of property in Group  AActor  which this track mill modify over time.
	*/
	PropertyName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackLinearColorProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackLinearColorProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackLinearColorProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackLinearColorProp;
	static C(Other: UObject): InterpTrackLinearColorProp;
}

declare class ParticleReplayTrackKey { 
	/**
	 * Position along timeline
	*/
	Time: number;
	/**
	 * Time length this clip should be captured/played for
	*/
	Duration: number;
	/**
	 * Replay clip ID number that identifies the clip we should capture to or playback from
	*/
	ClipIDNumber: number;
	clone() : ParticleReplayTrackKey;
	static C(Other: UObject): ParticleReplayTrackKey;
}

declare class InterpTrackParticleReplay extends InterpTrack { 
	/**
	 * Array of keys
	*/
	TrackKeys: ParticleReplayTrackKey[];
	/**
	 * True in the editor if track should be used to capture replay frames instead of play them back
	*/
	bIsCapturingReplay: boolean;
	/**
	 * Current replay fixed time quantum between frames (one over frame rate)
	*/
	FixedTimeStep: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackParticleReplay;
	static Find(Outer: UObject, ResourceName: string): InterpTrackParticleReplay;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackParticleReplay;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackParticleReplay;
	static C(Other: UObject): InterpTrackParticleReplay;
}

declare type ETrackToggleAction = string | symbol;
declare var ETrackToggleAction = { ETTA_Off:'ETTA_Off',ETTA_On:'ETTA_On',ETTA_Toggle:'ETTA_Toggle',ETTA_Trigger:'ETTA_Trigger', };
declare class ToggleTrackKey { 
	/**
	 * Time
	*/
	Time: number;
	/**
	 * Toggle Action
	*/
	ToggleAction: ETrackToggleAction;
	clone() : ToggleTrackKey;
	static C(Other: UObject): ToggleTrackKey;
}

declare class InterpTrackToggle extends InterpTrack { 
	/**
	 * Array of events to fire off.
	*/
	ToggleTrack: ToggleTrackKey[];
	/**
	 * If true, the track will call ActivateSystem on the emitter each update (the old 'incorrect' behavior).
	 * If false (the default), the System will only be activated if it was previously inactive.
	*/
	bActivateSystemEachUpdate: boolean;
	/**
	 * If true, the track will activate the system w/ the 'Just Attached' flag.
	*/
	bActivateWithJustAttachedFlag: boolean;
	/**
	 * If events should be fired when passed playing the sequence forwards.
	*/
	bFireEventsWhenForwards: boolean;
	/**
	 * If events should be fired when passed playing the sequence backwards.
	*/
	bFireEventsWhenBackwards: boolean;
	/**
	 * If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic.
	*/
	bFireEventsWhenJumpingForwards: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackToggle;
	static Find(Outer: UObject, ResourceName: string): InterpTrackToggle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackToggle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackToggle;
	static C(Other: UObject): InterpTrackToggle;
}

declare class InterpTrackVectorBase extends InterpTrack { 
	/**
	 * Actually track data containing keyframes of a FVector as it varies over time.
	*/
	VectorTrack: InterpCurveVector;
	/**
	 * Tension of curve, used for keypoints using automatic tangents.
	*/
	CurveTension: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackVectorBase;
	static Find(Outer: UObject, ResourceName: string): InterpTrackVectorBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackVectorBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackVectorBase;
	static C(Other: UObject): InterpTrackVectorBase;
}

declare class InterpTrackAudioMaster extends InterpTrackVectorBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackAudioMaster;
	static Find(Outer: UObject, ResourceName: string): InterpTrackAudioMaster;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackAudioMaster;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackAudioMaster;
	static C(Other: UObject): InterpTrackAudioMaster;
}

declare class InterpTrackColorProp extends InterpTrackVectorBase { 
	/**
	 * Name of property in Group  AActor  which this track mill modify over time.
	*/
	PropertyName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackColorProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackColorProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackColorProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackColorProp;
	static C(Other: UObject): InterpTrackColorProp;
}

declare class InterpTrackColorScale extends InterpTrackVectorBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackColorScale;
	static Find(Outer: UObject, ResourceName: string): InterpTrackColorScale;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackColorScale;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackColorScale;
	static C(Other: UObject): InterpTrackColorScale;
}

declare class SoundTrackKey { 
	/**
	 * Time
	*/
	Time: number;
	/**
	 * Volume
	*/
	Volume: number;
	/**
	 * Pitch
	*/
	Pitch: number;
	/**
	 * Sound
	*/
	Sound: SoundBase;
	clone() : SoundTrackKey;
	static C(Other: UObject): SoundTrackKey;
}

declare class InterpTrackSound extends InterpTrackVectorBase { 
	/**
	 * Array of sounds to play at specific times.
	*/
	Sounds: SoundTrackKey[];
	/**
	 * if set, sound plays only when playing the matinee in reverse instead of when the matinee plays forward
	*/
	bPlayOnReverse: boolean;
	/**
	 * If true, sounds on this track will not be forced to finish when the matinee sequence finishes.
	*/
	bContinueSoundOnMatineeEnd: boolean;
	/**
	 * If true, don't show subtitles for sounds played by this track.
	*/
	bSuppressSubtitles: boolean;
	/**
	 * If true and track is controlling a pawn, makes the pawn "speak" the given audio.
	*/
	bTreatAsDialogue: boolean;
	/**
	 * Attach
	*/
	bAttach: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackSound;
	static Find(Outer: UObject, ResourceName: string): InterpTrackSound;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackSound;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackSound;
	static C(Other: UObject): InterpTrackSound;
}

declare class InterpTrackVectorMaterialParam extends InterpTrackVectorBase { 
	/**
	 * Materials whose parameters we want to change and the references to those materials.
	*/
	TargetMaterials: MaterialInterface[];
	/**
	 * Name of parameter in the MaterialInstance which this track will modify over time.
	*/
	ParamName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackVectorMaterialParam;
	static Find(Outer: UObject, ResourceName: string): InterpTrackVectorMaterialParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackVectorMaterialParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackVectorMaterialParam;
	static C(Other: UObject): InterpTrackVectorMaterialParam;
}

declare class InterpTrackVectorProp extends InterpTrackVectorBase { 
	/**
	 * Name of property in Group  AActor  which this track mill modify over time.
	*/
	PropertyName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackVectorProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackVectorProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackVectorProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackVectorProp;
	static C(Other: UObject): InterpTrackVectorProp;
}

declare type EVisibilityTrackAction = string | symbol;
declare var EVisibilityTrackAction = { EVTA_Hide:'EVTA_Hide',EVTA_Show:'EVTA_Show',EVTA_Toggle:'EVTA_Toggle', };
declare type EVisibilityTrackCondition = string | symbol;
declare var EVisibilityTrackCondition = { EVTC_Always:'EVTC_Always',EVTC_GoreEnabled:'EVTC_GoreEnabled',EVTC_GoreDisabled:'EVTC_GoreDisabled', };
declare class VisibilityTrackKey { 
	/**
	 * Time
	*/
	Time: number;
	/**
	 * Action
	*/
	Action: EVisibilityTrackAction;
	/**
	 * Condition that must be satisfied for this key event to fire
	*/
	ActiveCondition: EVisibilityTrackCondition;
	clone() : VisibilityTrackKey;
	static C(Other: UObject): VisibilityTrackKey;
}

declare class InterpTrackVisibility extends InterpTrack { 
	/**
	 * Array of events to fire off.
	*/
	VisibilityTrack: VisibilityTrackKey[];
	/**
	 * If events should be fired when passed playing the sequence forwards.
	*/
	bFireEventsWhenForwards: boolean;
	/**
	 * If events should be fired when passed playing the sequence backwards.
	*/
	bFireEventsWhenBackwards: boolean;
	/**
	 * If true, events on this track are fired even when jumping forwads through a sequence - for example, skipping a cinematic.
	*/
	bFireEventsWhenJumpingForwards: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackVisibility;
	static Find(Outer: UObject, ResourceName: string): InterpTrackVisibility;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackVisibility;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackVisibility;
	static C(Other: UObject): InterpTrackVisibility;
}

declare class InterpTrackInstAnimControl extends InterpTrackInst { 
	/**
	 * Last Update Position
	*/
	LastUpdatePosition: number;
	/**
	 * Init Position
	*/
	InitPosition: Vector;
	/**
	 * Init Rotation
	*/
	InitRotation: Rotator;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstAnimControl;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstAnimControl;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstAnimControl;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstAnimControl;
	static C(Other: UObject): InterpTrackInstAnimControl;
}

declare class InterpTrackInstAudioMaster extends InterpTrackInst { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstAudioMaster;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstAudioMaster;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstAudioMaster;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstAudioMaster;
	static C(Other: UObject): InterpTrackInstAudioMaster;
}

declare class InterpTrackInstColorScale extends InterpTrackInst { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstColorScale;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstColorScale;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstColorScale;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstColorScale;
	static C(Other: UObject): InterpTrackInstColorScale;
}

declare class InterpTrackInstEvent extends InterpTrackInst { 
	/**
	 * Position we were in last time we evaluated Events.
	 * During UpdateTrack, events between this time and the current time will be fired.
	*/
	LastUpdatePosition: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstEvent;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstEvent;
	static C(Other: UObject): InterpTrackInstEvent;
}

declare class InterpTrackInstFade extends InterpTrackInst { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstFade;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstFade;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstFade;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstFade;
	static C(Other: UObject): InterpTrackInstFade;
}

declare class InterpTrackInstFloatAnimBPParam extends InterpTrackInst { 
	/**
	 * MIDs we're using to set the desired parameter.
	*/
	AnimScriptInstance: AnimInstance;
	/**
	 * Saved values for restoring state when exiting Matinee.
	*/
	ResetFloat: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstFloatAnimBPParam;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstFloatAnimBPParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstFloatAnimBPParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstFloatAnimBPParam;
	static C(Other: UObject): InterpTrackInstFloatAnimBPParam;
}

declare class PrimitiveMaterialRef { 
	/**
	 * Primitive
	*/
	Primitive: PrimitiveComponent;
	/**
	 * Decal
	*/
	Decal: DecalComponent;
	/**
	 * Element Index
	*/
	ElementIndex: number;
	clone() : PrimitiveMaterialRef;
	static C(Other: UObject): PrimitiveMaterialRef;
}

declare class InterpTrackInstFloatMaterialParam extends InterpTrackInst { 
	/**
	 * MIDs we're using to set the desired parameter.
	*/
	MaterialInstances: MaterialInstanceDynamic[];
	/**
	 * Saved values for restoring state when exiting Matinee.
	*/
	ResetFloats: number[];
	/**
	 * Primitive components on which materials have been overridden.
	*/
	PrimitiveMaterialRefs: PrimitiveMaterialRef[];
	/**
	 * track we are an instance of - used in the editor to propagate changes to the track's Materials array immediately
	*/
	InstancedTrack: InterpTrackFloatMaterialParam;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstFloatMaterialParam;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstFloatMaterialParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstFloatMaterialParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstFloatMaterialParam;
	static C(Other: UObject): InterpTrackInstFloatMaterialParam;
}

declare class InterpTrackInstFloatParticleParam extends InterpTrackInst { 
	/**
	 * Saved value for restoring state when exiting Matinee.
	*/
	ResetFloat: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstFloatParticleParam;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstFloatParticleParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstFloatParticleParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstFloatParticleParam;
	static C(Other: UObject): InterpTrackInstFloatParticleParam;
}

declare class InterpTrackInstParticleReplay extends InterpTrackInst { 
	/**
	 * Position we were in last time we evaluated.
	 * During UpdateTrack, events between this time and the current time will be processed.
	*/
	LastUpdatePosition: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstParticleReplay;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstParticleReplay;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstParticleReplay;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstParticleReplay;
	static C(Other: UObject): InterpTrackInstParticleReplay;
}

declare class InterpTrackInstProperty extends InterpTrackInst { 
	/**
	 * Function to call after updating the value of the color property.
	*/
	InterpProperty: Property;
	/**
	 * Pointer to the UObject instance that is the outer of the color property we are interpolating on, this is used to process the property update callback.
	*/
	PropertyOuterObjectInst: UObject;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstProperty;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstProperty;
	static C(Other: UObject): InterpTrackInstProperty;
}

declare class InterpTrackInstBoolProp extends InterpTrackInstProperty { 
	/**
	 * Mask that indicates which bit the boolean property actually uses of the value pointed to by BoolProp.
	*/
	BoolProperty: BoolProperty;
	/**
	 * Saved value for restoring state when exiting Matinee.
	*/
	ResetBool: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstBoolProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstBoolProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstBoolProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstBoolProp;
	static C(Other: UObject): InterpTrackInstBoolProp;
}

declare class InterpTrackInstColorProp extends InterpTrackInstProperty { 
	/**
	 * Saved value for restoring state when exiting Matinee.
	*/
	ResetColor: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstColorProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstColorProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstColorProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstColorProp;
	static C(Other: UObject): InterpTrackInstColorProp;
}

declare class InterpTrackInstFloatProp extends InterpTrackInstProperty { 
	/**
	 * Saved value for restoring state when exiting Matinee.
	*/
	ResetFloat: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstFloatProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstFloatProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstFloatProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstFloatProp;
	static C(Other: UObject): InterpTrackInstFloatProp;
}

declare class InterpTrackInstLinearColorProp extends InterpTrackInstProperty { 
	/**
	 * Saved value for restoring state when exiting Matinee.
	*/
	ResetColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstLinearColorProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstLinearColorProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstLinearColorProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstLinearColorProp;
	static C(Other: UObject): InterpTrackInstLinearColorProp;
}

declare class InterpTrackInstVectorProp extends InterpTrackInstProperty { 
	/**
	 * Saved value for restoring state when exiting Matinee.
	*/
	ResetVector: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstVectorProp;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstVectorProp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstVectorProp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstVectorProp;
	static C(Other: UObject): InterpTrackInstVectorProp;
}

declare class InterpTrackInstSlomo extends InterpTrackInst { 
	/**
	 * Backup of initial LevelInfo MatineeTimeDilation setting when interpolation started.
	*/
	OldTimeDilation: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstSlomo;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstSlomo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstSlomo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstSlomo;
	static C(Other: UObject): InterpTrackInstSlomo;
}

declare class InterpTrackInstSound extends InterpTrackInst { 
	/**
	 * Last Update Position
	*/
	LastUpdatePosition: number;
	/**
	 * Play Audio Comp
	*/
	PlayAudioComp: AudioComponent;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstSound;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstSound;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstSound;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstSound;
	static C(Other: UObject): InterpTrackInstSound;
}

declare class InterpTrackInstToggle extends InterpTrackInst { 
	/**
	 * Action
	*/
	Action: ETrackToggleAction;
	/**
	 * Position we were in last time we evaluated.
	 * During UpdateTrack, toggles between this time and the current time will be processed.
	*/
	LastUpdatePosition: number;
	/**
	 * Cached 'active' state for the toggleable actor before we possessed it; restored when Matinee exits
	*/
	bSavedActiveState: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstToggle;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstToggle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstToggle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstToggle;
	static C(Other: UObject): InterpTrackInstToggle;
}

declare class InterpTrackInstVectorMaterialParam extends InterpTrackInst { 
	/**
	 * MIDs we're using to set the desired parameter.
	*/
	MaterialInstances: MaterialInstanceDynamic[];
	/**
	 * Saved values for restoring state when exiting Matinee.
	*/
	ResetVectors: Vector[];
	/**
	 * Primitive components on which materials have been overridden.
	*/
	PrimitiveMaterialRefs: PrimitiveMaterialRef[];
	/**
	 * Track we are an instance of - used in the editor to propagate changes to the track's Materials array immediately.
	*/
	InstancedTrack: InterpTrackVectorMaterialParam;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstVectorMaterialParam;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstVectorMaterialParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstVectorMaterialParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstVectorMaterialParam;
	static C(Other: UObject): InterpTrackInstVectorMaterialParam;
}

declare class InterpTrackInstVisibility extends InterpTrackInst { 
	/**
	 * Action
	*/
	Action: EVisibilityTrackAction;
	/**
	 * Position we were in last time we evaluated.
	 * During UpdateTrack, events between this time and the current time will be processed.
	*/
	LastUpdatePosition: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstVisibility;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstVisibility;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstVisibility;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstVisibility;
	static C(Other: UObject): InterpTrackInstVisibility;
}

declare class IntSerialization extends UObject { 
	/**
	 * New types
	*/
	UnsignedInt16Variable: any;
	/**
	 * Unsigned Int 32Variable
	*/
	UnsignedInt32Variable: any;
	/**
	 * Unsigned Int 64Variable
	*/
	UnsignedInt64Variable: any;
	/**
	 * Signed Int 8Variable
	*/
	SignedInt8Variable: any;
	/**
	 * Signed Int 16Variable
	*/
	SignedInt16Variable: any;
	/**
	 * Signed Int 64Variable
	*/
	SignedInt64Variable: any;
	/**
	 * Existing types
	*/
	UnsignedInt8Variable: number;
	/**
	 * Signed Int 32Variable
	*/
	SignedInt32Variable: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): IntSerialization;
	static Find(Outer: UObject, ResourceName: string): IntSerialization;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): IntSerialization;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IntSerialization;
	static C(Other: UObject): IntSerialization;
}

declare class LevelStreamingAlwaysLoaded extends LevelStreaming { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelStreamingAlwaysLoaded;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingAlwaysLoaded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelStreamingAlwaysLoaded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingAlwaysLoaded;
	static C(Other: UObject): LevelStreamingAlwaysLoaded;
}

declare class LevelStreamingKismet extends LevelStreaming { 
	/**
	 * Whether the level should be loaded at startup
	*/
	bInitiallyLoaded: boolean;
	/**
	 * Whether the level should be visible at startup if it is loaded
	*/
	bInitiallyVisible: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelStreamingKismet;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingKismet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelStreamingKismet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingKismet;
	/**
	 * Stream in a level with a specific location and rotation. You can create multiple instances of the same level!
	 * The level to be loaded does not have to be in the persistent map's Levels list, however to ensure that the .umap does get
	 * packaged, please be sure to include the .umap in your Packaging Settings:
	 *   Project Settings -> Packaging -> List of Maps to Include in a Packaged Build (you may have to show advanced or type in filter)
	 * @param LevelName - Level package name, ex: /Game/Maps/MyMapName, specifying short name like MyMapName will force very slow search on disk
	 * @param Location - World space location where the level should be spawned
	 * @param Rotation - World space rotation for rotating the entire level
	 * @param bOutSuccess - Whether operation was successful (map was found and added to the sub-levels list)
	 * @return Streaming level object for a level instance
	*/
	static LoadLevelInstance(WorldContextObject: UObject,LevelName: string,Location: Vector,Rotation: Rotator,bOutSuccess?: boolean): {bOutSuccess: boolean, $: LevelStreamingKismet};
	static C(Other: UObject): LevelStreamingKismet;
}

declare class LevelStreamingPersistent extends LevelStreaming { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelStreamingPersistent;
	static Find(Outer: UObject, ResourceName: string): LevelStreamingPersistent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelStreamingPersistent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelStreamingPersistent;
	static C(Other: UObject): LevelStreamingPersistent;
}

declare class LightmappedSurfaceCollection extends UObject { 
	/**
	 * The UModel these surfaces come from.
	*/
	SourceModel: Model;
	/**
	 * An array of the surface indices grouped into a single static lighting mapping.
	*/
	Surfaces: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightmappedSurfaceCollection;
	static Find(Outer: UObject, ResourceName: string): LightmappedSurfaceCollection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightmappedSurfaceCollection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmappedSurfaceCollection;
	static C(Other: UObject): LightmappedSurfaceCollection;
}

declare class LightmassPrimitiveSettingsObject extends UObject { 
	/**
	 * Lightmass Settings
	*/
	LightmassSettings: LightmassPrimitiveSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightmassPrimitiveSettingsObject;
	static Find(Outer: UObject, ResourceName: string): LightmassPrimitiveSettingsObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightmassPrimitiveSettingsObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightmassPrimitiveSettingsObject;
	static C(Other: UObject): LightmassPrimitiveSettingsObject;
}

declare class EngineMessage extends LocalMessage { 
	/**
	 * Message displayed in message dialog when player pawn fails to spawn because no playerstart was available.
	*/
	FailedPlaceMessage: string;
	/**
	 * Message when player join attempt is refused because the server is at capacity.
	*/
	MaxedOutMessage: string;
	/**
	 * Message when a new player enters the game.
	*/
	EnteredMessage: string;
	/**
	 * Message when a player leaves the game.
	*/
	LeftMessage: string;
	/**
	 * Message when a player changes his name.
	*/
	GlobalNameChange: string;
	/**
	 * Message when a new spectator enters the server (if spectator has a player name).
	*/
	SpecEnteredMessage: string;
	/**
	 * Message when a new player enters the server (if player is unnamed).
	*/
	NewPlayerMessage: string;
	/**
	 * Message when a new spectator enters the server (if spectator is unnamed).
	*/
	NewSpecMessage: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EngineMessage;
	static Find(Outer: UObject, ResourceName: string): EngineMessage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EngineMessage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EngineMessage;
	static C(Other: UObject): EngineMessage;
}

declare class MaterialExpressionAbs extends MaterialExpression { 
	/**
	 * Link to the input expression to be evaluated
	*/
	Input: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionAbs;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAbs;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionAbs;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAbs;
	static C(Other: UObject): MaterialExpressionAbs;
}

declare class MaterialExpressionActorPositionWS extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionActorPositionWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionActorPositionWS;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionActorPositionWS;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionActorPositionWS;
	static C(Other: UObject): MaterialExpressionActorPositionWS;
}

declare class MaterialExpressionAdd extends MaterialExpression { 
	/**
	 * Defaults to 'ConstA' if not specified
	*/
	A: ExpressionInput;
	/**
	 * Defaults to 'ConstB' if not specified
	*/
	B: ExpressionInput;
	/**
	 * only used if A is not hooked up
	*/
	ConstA: number;
	/**
	 * only used if B is not hooked up
	*/
	ConstB: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionAdd;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAdd;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionAdd;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAdd;
	static C(Other: UObject): MaterialExpressionAdd;
}

declare class MaterialExpressionAppendVector extends MaterialExpression { 
	/**
	 * A
	*/
	A: ExpressionInput;
	/**
	 * B
	*/
	B: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionAppendVector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAppendVector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionAppendVector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAppendVector;
	static C(Other: UObject): MaterialExpressionAppendVector;
}

declare class MaterialExpressionAtmosphericFogColor extends MaterialExpression { 
	/**
	 * World Position
	*/
	WorldPosition: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionAtmosphericFogColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAtmosphericFogColor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionAtmosphericFogColor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAtmosphericFogColor;
	static C(Other: UObject): MaterialExpressionAtmosphericFogColor;
}

declare class MaterialExpressionBlackBody extends MaterialExpression { 
	/**
	 * Temperature
	*/
	Temp: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionBlackBody;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBlackBody;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionBlackBody;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBlackBody;
	static C(Other: UObject): MaterialExpressionBlackBody;
}

declare class MaterialExpressionBreakMaterialAttributes extends MaterialExpression { 
	/**
	 * Struct
	*/
	Struct: ExpressionInput;
	/**
	 * Material Attributes
	*/
	MaterialAttributes: MaterialAttributesInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionBreakMaterialAttributes;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBreakMaterialAttributes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionBreakMaterialAttributes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBreakMaterialAttributes;
	static C(Other: UObject): MaterialExpressionBreakMaterialAttributes;
}

declare class MaterialExpressionBumpOffset extends MaterialExpression { 
	/**
	 * Defaults to 'ConstCoordinate' if not specified
	*/
	Coordinate: ExpressionInput;
	/**
	 * Height
	*/
	Height: ExpressionInput;
	/**
	 * Height Ratio Input
	*/
	HeightRatioInput: ExpressionInput;
	/**
	 * Height Ratio
	*/
	HeightRatio: number;
	/**
	 * Perceived height as a fraction of width.
	*/
	ReferencePlane: number;
	/**
	 * only used if Coordinate is not hooked up
	*/
	ConstCoordinate: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionBumpOffset;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionBumpOffset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionBumpOffset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionBumpOffset;
	static C(Other: UObject): MaterialExpressionBumpOffset;
}

declare class MaterialExpressionCameraPositionWS extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionCameraPositionWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCameraPositionWS;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionCameraPositionWS;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCameraPositionWS;
	static C(Other: UObject): MaterialExpressionCameraPositionWS;
}

declare class MaterialExpressionCameraVectorWS extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionCameraVectorWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCameraVectorWS;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionCameraVectorWS;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCameraVectorWS;
	static C(Other: UObject): MaterialExpressionCameraVectorWS;
}

declare class MaterialExpressionCeil extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionCeil;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCeil;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionCeil;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCeil;
	static C(Other: UObject): MaterialExpressionCeil;
}

declare type EClampMode = string | symbol;
declare var EClampMode = { CMODE_Clamp:'CMODE_Clamp',CMODE_ClampMin:'CMODE_ClampMin',CMODE_ClampMax:'CMODE_ClampMax', };
declare class MaterialExpressionClamp extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	/**
	 * Defaults to 'MinDefault' if not specified
	*/
	Min: ExpressionInput;
	/**
	 * Defaults to 'MaxDefault' if not specified
	*/
	Max: ExpressionInput;
	/**
	 * Clamp Mode
	*/
	ClampMode: EClampMode;
	/**
	 * Min Default
	*/
	MinDefault: number;
	/**
	 * Max Default
	*/
	MaxDefault: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionClamp;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionClamp;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionClamp;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionClamp;
	static C(Other: UObject): MaterialExpressionClamp;
}

declare class MaterialExpressionCollectionParameter extends MaterialExpression { 
	/**
	 * The Parameter Collection to use.
	*/
	Collection: MaterialParameterCollection;
	/**
	 * Name of the parameter being referenced.
	*/
	ParameterName: string;
	/**
	 * Id that is set from the name, and used to handle renaming of collection parameters.
	*/
	ParameterId: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionCollectionParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCollectionParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionCollectionParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCollectionParameter;
	static C(Other: UObject): MaterialExpressionCollectionParameter;
}

declare class MaterialExpressionComponentMask extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	/**
	 * R
	*/
	R: boolean;
	/**
	 * G
	*/
	G: boolean;
	/**
	 * B
	*/
	B: boolean;
	/**
	 * A
	*/
	A: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionComponentMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionComponentMask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionComponentMask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionComponentMask;
	static C(Other: UObject): MaterialExpressionComponentMask;
}

declare class MaterialExpressionConstant extends MaterialExpression { 
	/**
	 * R
	*/
	R: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionConstant;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstant;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionConstant;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstant;
	static C(Other: UObject): MaterialExpressionConstant;
}

declare class MaterialExpressionConstant2Vector extends MaterialExpression { 
	/**
	 * R
	*/
	R: number;
	/**
	 * G
	*/
	G: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionConstant2Vector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstant2Vector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionConstant2Vector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstant2Vector;
	static C(Other: UObject): MaterialExpressionConstant2Vector;
}

declare class MaterialExpressionConstant3Vector extends MaterialExpression { 
	/**
	 * Constant
	*/
	Constant: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionConstant3Vector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstant3Vector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionConstant3Vector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstant3Vector;
	static C(Other: UObject): MaterialExpressionConstant3Vector;
}

declare class MaterialExpressionConstant4Vector extends MaterialExpression { 
	/**
	 * Constant
	*/
	Constant: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionConstant4Vector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstant4Vector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionConstant4Vector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstant4Vector;
	static C(Other: UObject): MaterialExpressionConstant4Vector;
}

declare class MaterialExpressionConstantBiasScale extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	/**
	 * Bias
	*/
	Bias: number;
	/**
	 * Scale
	*/
	Scale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionConstantBiasScale;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionConstantBiasScale;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionConstantBiasScale;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionConstantBiasScale;
	static C(Other: UObject): MaterialExpressionConstantBiasScale;
}

declare class MaterialExpressionCosine extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	/**
	 * Period
	*/
	Period: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionCosine;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCosine;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionCosine;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCosine;
	static C(Other: UObject): MaterialExpressionCosine;
}

declare class MaterialExpressionCrossProduct extends MaterialExpression { 
	/**
	 * A
	*/
	A: ExpressionInput;
	/**
	 * B
	*/
	B: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionCrossProduct;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCrossProduct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionCrossProduct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCrossProduct;
	static C(Other: UObject): MaterialExpressionCrossProduct;
}

declare type ECustomMaterialOutputType = string | symbol;
declare var ECustomMaterialOutputType = { CMOT_Float1:'CMOT_Float1',CMOT_Float2:'CMOT_Float2',CMOT_Float3:'CMOT_Float3',CMOT_Float4:'CMOT_Float4', };
declare class CustomInput { 
	/**
	 * Input Name
	*/
	InputName: string;
	/**
	 * Input
	*/
	Input: ExpressionInput;
	clone() : CustomInput;
	static C(Other: UObject): CustomInput;
}

declare class MaterialExpressionCustom extends MaterialExpression { 
	/**
	 * Code
	*/
	Code: string;
	/**
	 * Output Type
	*/
	OutputType: ECustomMaterialOutputType;
	/**
	 * Description
	*/
	Description: string;
	/**
	 * Inputs
	*/
	Inputs: CustomInput[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionCustom;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionCustom;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionCustom;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionCustom;
	static C(Other: UObject): MaterialExpressionCustom;
}

declare class MaterialExpressionClearCoatNormalCustomOutput extends MaterialExpressionCustomOutput { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionClearCoatNormalCustomOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionClearCoatNormalCustomOutput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionClearCoatNormalCustomOutput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionClearCoatNormalCustomOutput;
	static C(Other: UObject): MaterialExpressionClearCoatNormalCustomOutput;
}

declare class MaterialExpressionTangentOutput extends MaterialExpressionCustomOutput { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTangentOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTangentOutput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTangentOutput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTangentOutput;
	static C(Other: UObject): MaterialExpressionTangentOutput;
}

declare class MaterialExpressionDDX extends MaterialExpression { 
	/**
	 * The value we want to compute ddx/ddy from
	*/
	Value: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDDX;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDDX;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDDX;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDDX;
	static C(Other: UObject): MaterialExpressionDDX;
}

declare class MaterialExpressionDDY extends MaterialExpression { 
	/**
	 * The value we want to compute ddx/ddy from
	*/
	Value: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDDY;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDDY;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDDY;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDDY;
	static C(Other: UObject): MaterialExpressionDDY;
}

declare class MaterialExpressionDecalDerivative extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDecalDerivative;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDecalDerivative;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDecalDerivative;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDecalDerivative;
	static C(Other: UObject): MaterialExpressionDecalDerivative;
}

declare class MaterialExpressionDecalLifetimeOpacity extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDecalLifetimeOpacity;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDecalLifetimeOpacity;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDecalLifetimeOpacity;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDecalLifetimeOpacity;
	static C(Other: UObject): MaterialExpressionDecalLifetimeOpacity;
}

declare class MaterialExpressionDecalMipmapLevel extends MaterialExpression { 
	/**
	 * Defaults to '(Const Width, Const Height)' if not specified
	*/
	TextureSize: ExpressionInput;
	/**
	 * only used if TextureSize is not hooked up
	*/
	ConstWidth: number;
	/**
	 * Const Height
	*/
	ConstHeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDecalMipmapLevel;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDecalMipmapLevel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDecalMipmapLevel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDecalMipmapLevel;
	static C(Other: UObject): MaterialExpressionDecalMipmapLevel;
}

declare class MaterialExpressionDepthFade extends MaterialExpression { 
	/**
	 * Defaults to 'OpacityDefault' if not specified
	*/
	InOpacity: ExpressionInput;
	/**
	 * Defaults to 'FadeDistanceDefault' if not specified
	*/
	FadeDistance: ExpressionInput;
	/**
	 * Opacity which will be scaled by the result of the fade.  This is used when InOpacity is unconnected.
	*/
	OpacityDefault: number;
	/**
	 * World space distance over which the fade should take place.  This is used when FadeDistance is unconnected.
	*/
	FadeDistanceDefault: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDepthFade;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDepthFade;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDepthFade;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDepthFade;
	static C(Other: UObject): MaterialExpressionDepthFade;
}

declare type EDepthOfFieldFunctionValue = string | symbol;
declare var EDepthOfFieldFunctionValue = { TDOF_NearAndFarMask:'TDOF_NearAndFarMask',TDOF_NearMask:'TDOF_NearMask',TDOF_FarMask:'TDOF_FarMask',TDOF_CircleOfConfusionRadius:'TDOF_CircleOfConfusionRadius', };
declare class MaterialExpressionDepthOfFieldFunction extends MaterialExpression { 
	/**
	 * Determines the mapping place to use on the terrain.
	*/
	FunctionValue: EDepthOfFieldFunctionValue;
	/**
	 * usually nothing or PixelDepth
	*/
	Depth: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDepthOfFieldFunction;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDepthOfFieldFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDepthOfFieldFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDepthOfFieldFunction;
	static C(Other: UObject): MaterialExpressionDepthOfFieldFunction;
}

declare class MaterialExpressionDeriveNormalZ extends MaterialExpression { 
	/**
	 * In XY
	*/
	InXY: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDeriveNormalZ;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDeriveNormalZ;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDeriveNormalZ;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDeriveNormalZ;
	static C(Other: UObject): MaterialExpressionDeriveNormalZ;
}

declare class MaterialExpressionDesaturation extends MaterialExpression { 
	/**
	 * Outputs: Lerp(Input,dot(Input,LuminanceFactors)),Fraction)
	*/
	Input: ExpressionInput;
	/**
	 * Fraction
	*/
	Fraction: ExpressionInput;
	/**
	 * Luminance Factors
	*/
	LuminanceFactors: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDesaturation;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDesaturation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDesaturation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDesaturation;
	static C(Other: UObject): MaterialExpressionDesaturation;
}

declare class MaterialExpressionDistance extends MaterialExpression { 
	/**
	 * A
	*/
	A: ExpressionInput;
	/**
	 * B
	*/
	B: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDistance;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDistance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistance;
	static C(Other: UObject): MaterialExpressionDistance;
}

declare class MaterialExpressionDistanceCullFade extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDistanceCullFade;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistanceCullFade;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDistanceCullFade;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistanceCullFade;
	static C(Other: UObject): MaterialExpressionDistanceCullFade;
}

declare class MaterialExpressionDistanceFieldGradient extends MaterialExpression { 
	/**
	 * Defaults to current world position if not specified
	*/
	Position: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDistanceFieldGradient;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistanceFieldGradient;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDistanceFieldGradient;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistanceFieldGradient;
	static C(Other: UObject): MaterialExpressionDistanceFieldGradient;
}

declare class MaterialExpressionDistanceToNearestSurface extends MaterialExpression { 
	/**
	 * Defaults to current world position if not specified
	*/
	Position: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDistanceToNearestSurface;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDistanceToNearestSurface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDistanceToNearestSurface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDistanceToNearestSurface;
	static C(Other: UObject): MaterialExpressionDistanceToNearestSurface;
}

declare class MaterialExpressionDivide extends MaterialExpression { 
	/**
	 * Defaults to 'ConstA' if not specified
	*/
	A: ExpressionInput;
	/**
	 * Defaults to 'ConstB' if not specified
	*/
	B: ExpressionInput;
	/**
	 * only used if A is not hooked up
	*/
	ConstA: number;
	/**
	 * only used if B is not hooked up
	*/
	ConstB: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDivide;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDivide;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDivide;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDivide;
	static C(Other: UObject): MaterialExpressionDivide;
}

declare class MaterialExpressionDotProduct extends MaterialExpression { 
	/**
	 * A
	*/
	A: ExpressionInput;
	/**
	 * B
	*/
	B: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDotProduct;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDotProduct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDotProduct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDotProduct;
	static C(Other: UObject): MaterialExpressionDotProduct;
}

declare class MaterialExpressionDynamicParameter extends MaterialExpression { 
	/**
	 * The names of the parameters.
	 * These will show up in Cascade when editing a particle system
	 * that uses the material it is in...
	*/
	ParamNames: string[];
	/**
	 * Default Value
	*/
	DefaultValue: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionDynamicParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionDynamicParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionDynamicParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionDynamicParameter;
	static C(Other: UObject): MaterialExpressionDynamicParameter;
}

declare class MaterialExpressionEyeAdaptation extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionEyeAdaptation;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionEyeAdaptation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionEyeAdaptation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionEyeAdaptation;
	static C(Other: UObject): MaterialExpressionEyeAdaptation;
}

declare class MaterialExpressionFeatureLevelSwitch extends MaterialExpression { 
	/**
	 * Default connection, used when a certain feature level doesn't have an override.
	*/
	Default: ExpressionInput;
	/**
	 * Inputs
	*/
	Inputs: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFeatureLevelSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFeatureLevelSwitch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFeatureLevelSwitch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFeatureLevelSwitch;
	static C(Other: UObject): MaterialExpressionFeatureLevelSwitch;
}

declare class MaterialExpressionFloor extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFloor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFloor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFloor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFloor;
	static C(Other: UObject): MaterialExpressionFloor;
}

declare class MaterialExpressionFmod extends MaterialExpression { 
	/**
	 * A
	*/
	A: ExpressionInput;
	/**
	 * B
	*/
	B: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFmod;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFmod;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFmod;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFmod;
	static C(Other: UObject): MaterialExpressionFmod;
}

declare class MaterialExpressionFontSample extends MaterialExpression { 
	/**
	 * font resource that will be sampled
	*/
	Font: Font;
	/**
	 * allow access to the various font pages
	*/
	FontTexturePage: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFontSample;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFontSample;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFontSample;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFontSample;
	static C(Other: UObject): MaterialExpressionFontSample;
}

declare class MaterialExpressionFontSampleParameter extends MaterialExpressionFontSample { 
	/**
	 * name to be referenced when we want to find and set thsi parameter
	*/
	ParameterName: string;
	/**
	 * GUID that should be unique within the material, this is used for parameter renaming.
	*/
	ExpressionGUID: Guid;
	/**
	 * The name of the parameter Group to display in MaterialInstance Editor. Default is None group
	*/
	Group: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFontSampleParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFontSampleParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFontSampleParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFontSampleParameter;
	static C(Other: UObject): MaterialExpressionFontSampleParameter;
}

declare class MaterialExpressionFrac extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFrac;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFrac;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFrac;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFrac;
	static C(Other: UObject): MaterialExpressionFrac;
}

declare class MaterialExpressionFresnel extends MaterialExpression { 
	/**
	 * Defaults to 'Exponent' if not specified
	*/
	ExponentIn: ExpressionInput;
	/**
	 * The exponent to pass into the pow() function
	*/
	Exponent: number;
	/**
	 * Defaults to 'BaseReflectFraction' if not specified
	*/
	BaseReflectFractionIn: ExpressionInput;
	/**
	 * Specifies the fraction of specular reflection when the surfaces is viewed from straight on.
	 * A value of 1 effectively disables Fresnel.
	*/
	BaseReflectFraction: number;
	/**
	 * Defaults to Pixel World Normal if not specified
	*/
	Normal: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFresnel;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFresnel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFresnel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFresnel;
	static C(Other: UObject): MaterialExpressionFresnel;
}

declare type EFunctionInputType = string | symbol;
declare var EFunctionInputType = { FunctionInput_Scalar:'FunctionInput_Scalar',FunctionInput_Vector2:'FunctionInput_Vector2',FunctionInput_Vector3:'FunctionInput_Vector3',FunctionInput_Vector4:'FunctionInput_Vector4',FunctionInput_Texture2D:'FunctionInput_Texture2D',FunctionInput_TextureCube:'FunctionInput_TextureCube',FunctionInput_StaticBool:'FunctionInput_StaticBool',FunctionInput_MaterialAttributes:'FunctionInput_MaterialAttributes', };
declare class MaterialExpressionFunctionInput extends MaterialExpression { 
	/**
	 * Used for previewing when editing the function, also temporarily used to connect to the outside material when compiling that material.
	*/
	Preview: ExpressionInput;
	/**
	 * The input's name, which will be drawn on the connector in function call expressions that use this function.
	*/
	InputName: string;
	/**
	 * The input's description, which will be used as a tooltip on the connector in function call expressions that use this function.
	*/
	Description: string;
	/**
	 * Id of this input, used to maintain references through name changes.
	*/
	Id: Guid;
	/**
	 * Type of this input.
	 * Input code chunks will be cast to this type, and a compiler error will be emitted if the cast fails.
	*/
	InputType: EFunctionInputType;
	/**
	 * Value used to preview this input when editing the material function.
	*/
	PreviewValue: Vector4;
	/**
	 * Whether to use the preview value or texture as the default value for this input.
	*/
	bUsePreviewValueAsDefault: boolean;
	/**
	 * Controls where the input is displayed relative to the other inputs.
	*/
	SortPriority: number;
	/**
	 * true when this expression is being compiled in a function preview,
	 * false when this expression is being compiled into a material that uses the function.
	 * Only valid in Compile()
	*/
	bCompilingFunctionPreview: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFunctionInput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFunctionInput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFunctionInput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFunctionInput;
	static C(Other: UObject): MaterialExpressionFunctionInput;
}

declare class MaterialExpressionFunctionOutput extends MaterialExpression { 
	/**
	 * The output's name, which will be drawn on the connector in function call expressions that use this function.
	*/
	OutputName: string;
	/**
	 * The output's description, which will be used as a tooltip on the connector in function call expressions that use this function.
	*/
	Description: string;
	/**
	 * Controls where the output is displayed relative to the other outputs.
	*/
	SortPriority: number;
	/**
	 * Stores the expression in the material function connected to this output.
	*/
	A: ExpressionInput;
	/**
	 * Whether this output was previewed the last time this function was edited.
	*/
	bLastPreviewed: boolean;
	/**
	 * Id of this input, used to maintain references through name changes.
	*/
	Id: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionFunctionOutput;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionFunctionOutput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionFunctionOutput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionFunctionOutput;
	static C(Other: UObject): MaterialExpressionFunctionOutput;
}

declare class MaterialExpressionGIReplace extends MaterialExpression { 
	/**
	 * Used for direct lighting computations e.g. real-time shaders
	*/
	Default: ExpressionInput;
	/**
	 * Used for baked indirect lighting e.g. Lightmass
	*/
	StaticIndirect: ExpressionInput;
	/**
	 * Used for dynamic indirect lighting e.g. Light Propagation Volumes
	*/
	DynamicIndirect: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionGIReplace;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionGIReplace;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionGIReplace;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionGIReplace;
	static C(Other: UObject): MaterialExpressionGIReplace;
}

declare class MaterialExpressionIf extends MaterialExpression { 
	/**
	 * A
	*/
	A: ExpressionInput;
	/**
	 * Defaults to 'ConstB' if not specified
	*/
	B: ExpressionInput;
	/**
	 * AGreater Than B
	*/
	AGreaterThanB: ExpressionInput;
	/**
	 * Defaults to 'A > B' if not specified
	*/
	AEqualsB: ExpressionInput;
	/**
	 * ALess Than B
	*/
	ALessThanB: ExpressionInput;
	/**
	 * Equals Threshold
	*/
	EqualsThreshold: number;
	/**
	 * only used if B is not hooked up
	*/
	ConstB: number;
	/**
	 * Const AEquals B
	*/
	ConstAEqualsB: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionIf;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionIf;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionIf;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionIf;
	static C(Other: UObject): MaterialExpressionIf;
}

declare class MaterialExpressionLightmapUVs extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLightmapUVs;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLightmapUVs;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLightmapUVs;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLightmapUVs;
	static C(Other: UObject): MaterialExpressionLightmapUVs;
}

declare class MaterialExpressionLightmassReplace extends MaterialExpression { 
	/**
	 * Realtime
	*/
	Realtime: ExpressionInput;
	/**
	 * Lightmass
	*/
	Lightmass: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLightmassReplace;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLightmassReplace;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLightmassReplace;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLightmassReplace;
	static C(Other: UObject): MaterialExpressionLightmassReplace;
}

declare class MaterialExpressionLightVector extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLightVector;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLightVector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLightVector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLightVector;
	static C(Other: UObject): MaterialExpressionLightVector;
}

declare class MaterialExpressionLinearInterpolate extends MaterialExpression { 
	/**
	 * Defaults to 'ConstA' if not specified
	*/
	A: ExpressionInput;
	/**
	 * Defaults to 'ConstB' if not specified
	*/
	B: ExpressionInput;
	/**
	 * Defaults to 'ConstAlpha' if not specified
	*/
	Alpha: ExpressionInput;
	/**
	 * only used if A is not hooked up
	*/
	ConstA: number;
	/**
	 * only used if B is not hooked up
	*/
	ConstB: number;
	/**
	 * only used if Alpha is not hooked up
	*/
	ConstAlpha: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLinearInterpolate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLinearInterpolate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLinearInterpolate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLinearInterpolate;
	static C(Other: UObject): MaterialExpressionLinearInterpolate;
}

declare class MaterialExpressionLogarithm2 extends MaterialExpression { 
	/**
	 * X
	*/
	X: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionLogarithm2;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionLogarithm2;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionLogarithm2;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionLogarithm2;
	static C(Other: UObject): MaterialExpressionLogarithm2;
}

declare class MaterialExpressionMakeMaterialAttributes extends MaterialExpression { 
	/**
	 * Base Color
	*/
	BaseColor: ExpressionInput;
	/**
	 * Metallic
	*/
	Metallic: ExpressionInput;
	/**
	 * Specular
	*/
	Specular: ExpressionInput;
	/**
	 * Roughness
	*/
	Roughness: ExpressionInput;
	/**
	 * Emissive Color
	*/
	EmissiveColor: ExpressionInput;
	/**
	 * Opacity
	*/
	Opacity: ExpressionInput;
	/**
	 * Opacity Mask
	*/
	OpacityMask: ExpressionInput;
	/**
	 * Normal
	*/
	Normal: ExpressionInput;
	/**
	 * World Position Offset
	*/
	WorldPositionOffset: ExpressionInput;
	/**
	 * World Displacement
	*/
	WorldDisplacement: ExpressionInput;
	/**
	 * Tessellation Multiplier
	*/
	TessellationMultiplier: ExpressionInput;
	/**
	 * Subsurface Color
	*/
	SubsurfaceColor: ExpressionInput;
	/**
	 * Clear Coat
	*/
	ClearCoat: ExpressionInput;
	/**
	 * Clear Coat Roughness
	*/
	ClearCoatRoughness: ExpressionInput;
	/**
	 * Ambient Occlusion
	*/
	AmbientOcclusion: ExpressionInput;
	/**
	 * Refraction
	*/
	Refraction: ExpressionInput;
	/**
	 * Customized UVs
	*/
	CustomizedUVs: ExpressionInput;
	/**
	 * Pixel Depth Offset
	*/
	PixelDepthOffset: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionMakeMaterialAttributes;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMakeMaterialAttributes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionMakeMaterialAttributes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMakeMaterialAttributes;
	static C(Other: UObject): MaterialExpressionMakeMaterialAttributes;
}

declare class FunctionExpressionInput { 
	/**
	 * Reference to the FunctionInput in the material function.
	 * This is a reference to a private object so it can't be saved, and must be generated by UpdateFromFunctionResource or SetMaterialFunction.
	*/
	ExpressionInput: MaterialExpressionFunctionInput;
	/**
	 * Id of the FunctionInput, used to link ExpressionInput.
	*/
	ExpressionInputId: Guid;
	/**
	 * Actual input struct which stores information about how this input is connected in the material.
	*/
	Input: ExpressionInput;
	clone() : FunctionExpressionInput;
	static C(Other: UObject): FunctionExpressionInput;
}

declare class FunctionExpressionOutput { 
	/**
	 * Reference to the FunctionOutput in the material function.
	 * This is a reference to a private object so it can't be saved, and must be generated by UpdateFromFunctionResource or SetMaterialFunction.
	*/
	ExpressionOutput: MaterialExpressionFunctionOutput;
	/**
	 * Id of the FunctionOutput, used to link ExpressionOutput.
	*/
	ExpressionOutputId: Guid;
	/**
	 * Actual output struct which stores information about how this output is connected in the material.
	*/
	Output: ExpressionOutput;
	clone() : FunctionExpressionOutput;
	static C(Other: UObject): FunctionExpressionOutput;
}

declare class MaterialExpressionMaterialFunctionCall extends MaterialExpression { 
	/**
	 * The function to call.
	*/
	MaterialFunction: MaterialFunction;
	/**
	 * Array of all the function inputs that this function exposes.
	*/
	FunctionInputs: FunctionExpressionInput[];
	/**
	 * Array of all the function outputs that this function exposes.
	*/
	FunctionOutputs: FunctionExpressionOutput[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionMaterialFunctionCall;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMaterialFunctionCall;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionMaterialFunctionCall;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMaterialFunctionCall;
	static C(Other: UObject): MaterialExpressionMaterialFunctionCall;
}

declare class MaterialExpressionMaterialProxyReplace extends MaterialExpression { 
	/**
	 * Realtime
	*/
	Realtime: ExpressionInput;
	/**
	 * Material Proxy
	*/
	MaterialProxy: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionMaterialProxyReplace;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMaterialProxyReplace;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionMaterialProxyReplace;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMaterialProxyReplace;
	static C(Other: UObject): MaterialExpressionMaterialProxyReplace;
}

declare class MaterialExpressionMax extends MaterialExpression { 
	/**
	 * Defaults to 'ConstA' if not specified
	*/
	A: ExpressionInput;
	/**
	 * Defaults to 'ConstB' if not specified
	*/
	B: ExpressionInput;
	/**
	 * only used if A is not hooked up
	*/
	ConstA: number;
	/**
	 * only used if B is not hooked up
	*/
	ConstB: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionMax;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMax;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionMax;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMax;
	static C(Other: UObject): MaterialExpressionMax;
}

declare class MaterialExpressionMin extends MaterialExpression { 
	/**
	 * Defaults to 'ConstA' if not specified
	*/
	A: ExpressionInput;
	/**
	 * Defaults to 'ConstB' if not specified
	*/
	B: ExpressionInput;
	/**
	 * only used if A is not hooked up
	*/
	ConstA: number;
	/**
	 * only used if B is not hooked up
	*/
	ConstB: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionMin;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMin;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionMin;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMin;
	static C(Other: UObject): MaterialExpressionMin;
}

declare class MaterialExpressionMultiply extends MaterialExpression { 
	/**
	 * Defaults to 'ConstA' if not specified
	*/
	A: ExpressionInput;
	/**
	 * Defaults to 'ConstB' if not specified
	*/
	B: ExpressionInput;
	/**
	 * only used if A is not hooked up
	*/
	ConstA: number;
	/**
	 * only used if B is not hooked up
	*/
	ConstB: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionMultiply;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionMultiply;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionMultiply;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionMultiply;
	static C(Other: UObject): MaterialExpressionMultiply;
}

declare type ENoiseFunction = string | symbol;
declare var ENoiseFunction = { NOISEFUNCTION_SimplexTex:'NOISEFUNCTION_SimplexTex',NOISEFUNCTION_GradientTex:'NOISEFUNCTION_GradientTex',NOISEFUNCTION_GradientTex3D:'NOISEFUNCTION_GradientTex3D',NOISEFUNCTION_GradientALU:'NOISEFUNCTION_GradientALU',NOISEFUNCTION_ValueALU:'NOISEFUNCTION_ValueALU',NOISEFUNCTION_VoronoiALU:'NOISEFUNCTION_VoronoiALU', };
declare class MaterialExpressionNoise extends MaterialExpression { 
	/**
	 * 2 to 3 dimensional vector
	*/
	Position: ExpressionInput;
	/**
	 * scalar, to clamp the Levels at pixel level, can be computed like this: max(length(ddx(Position)), length(ddy(Position))
	*/
	FilterWidth: ExpressionInput;
	/**
	 * can also be done with a multiply on the Position
	*/
	Scale: number;
	/**
	 * Lower numbers are faster and lower quality, higher numbers are slower and higher quality
	*/
	Quality: number;
	/**
	 * Noise function, affects performance and look
	*/
	NoiseFunction: ENoiseFunction;
	/**
	 * How multiple frequencies are getting combined
	*/
	bTurbulence: boolean;
	/**
	 * 1 = fast but little detail, .. larger numbers cost more performance
	*/
	Levels: number;
	/**
	 * Output Min
	*/
	OutputMin: number;
	/**
	 * Output Max
	*/
	OutputMax: number;
	/**
	 * usually 2 but higher values allow efficient use of few levels
	*/
	LevelScale: number;
	/**
	 * Whether to use tiling noise pattern, useful for baking to seam-free repeating textures
	*/
	bTiling: boolean;
	/**
	 * How many units in each tile (if Tiling is on)
	*/
	RepeatSize: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionNoise;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionNoise;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionNoise;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionNoise;
	static C(Other: UObject): MaterialExpressionNoise;
}

declare class MaterialExpressionNormalize extends MaterialExpression { 
	/**
	 * Vector Input
	*/
	VectorInput: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionNormalize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionNormalize;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionNormalize;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionNormalize;
	static C(Other: UObject): MaterialExpressionNormalize;
}

declare class MaterialExpressionObjectBounds extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionObjectBounds;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionObjectBounds;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionObjectBounds;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionObjectBounds;
	static C(Other: UObject): MaterialExpressionObjectBounds;
}

declare class MaterialExpressionObjectOrientation extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionObjectOrientation;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionObjectOrientation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionObjectOrientation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionObjectOrientation;
	static C(Other: UObject): MaterialExpressionObjectOrientation;
}

declare class MaterialExpressionObjectPositionWS extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionObjectPositionWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionObjectPositionWS;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionObjectPositionWS;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionObjectPositionWS;
	static C(Other: UObject): MaterialExpressionObjectPositionWS;
}

declare class MaterialExpressionObjectRadius extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionObjectRadius;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionObjectRadius;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionObjectRadius;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionObjectRadius;
	static C(Other: UObject): MaterialExpressionObjectRadius;
}

declare class MaterialExpressionOneMinus extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionOneMinus;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionOneMinus;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionOneMinus;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionOneMinus;
	static C(Other: UObject): MaterialExpressionOneMinus;
}

declare class MaterialExpressionPanner extends MaterialExpression { 
	/**
	 * Defaults to 'ConstCoordinate' if not specified
	*/
	Coordinate: ExpressionInput;
	/**
	 * Defaults to Game Time if not specified
	*/
	Time: ExpressionInput;
	/**
	 * Vector2 speed scale, if specified
	*/
	Speed: ExpressionInput;
	/**
	 * Speed X
	*/
	SpeedX: number;
	/**
	 * Speed Y
	*/
	SpeedY: number;
	/**
	 * only used if Coordinate is not hooked up
	*/
	ConstCoordinate: any;
	/**
	 * Output only the fractional part of the pan calculation for greater precision.
	 * Output is greater than or equal to 0 and less than 1.
	*/
	bFractionalPart: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionPanner;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPanner;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionPanner;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPanner;
	static C(Other: UObject): MaterialExpressionPanner;
}

declare class MaterialExpressionParameter extends MaterialExpression { 
	/**
	 * The name of the parameter
	*/
	ParameterName: string;
	/**
	 * GUID that should be unique within the material, this is used for parameter renaming.
	*/
	ExpressionGUID: Guid;
	/**
	 * The name of the parameter Group to display in MaterialInstance Editor. Default is None group
	*/
	Group: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParameter;
	static C(Other: UObject): MaterialExpressionParameter;
}

declare class MaterialExpressionScalarParameter extends MaterialExpressionParameter { 
	/**
	 * Default Value
	*/
	DefaultValue: number;
	/**
	 * Sets the lower bound for the slider on this parameter in the material instance editor.
	*/
	SliderMin: number;
	/**
	 * Sets the upper bound for the slider on this parameter in the material instance editor.
	 * The slider will be disabled if SliderMax <= SliderMin.
	*/
	SliderMax: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionScalarParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionScalarParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionScalarParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionScalarParameter;
	static C(Other: UObject): MaterialExpressionScalarParameter;
}

declare class MaterialExpressionStaticBoolParameter extends MaterialExpressionParameter { 
	/**
	 * Default Value
	*/
	DefaultValue: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionStaticBoolParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticBoolParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionStaticBoolParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticBoolParameter;
	static C(Other: UObject): MaterialExpressionStaticBoolParameter;
}

declare class MaterialExpressionStaticSwitchParameter extends MaterialExpressionStaticBoolParameter { 
	/**
	 * A
	*/
	A: ExpressionInput;
	/**
	 * B
	*/
	B: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionStaticSwitchParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticSwitchParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionStaticSwitchParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticSwitchParameter;
	static C(Other: UObject): MaterialExpressionStaticSwitchParameter;
}

declare class MaterialExpressionStaticComponentMaskParameter extends MaterialExpressionParameter { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	/**
	 * Default R
	*/
	DefaultR: boolean;
	/**
	 * Default G
	*/
	DefaultG: boolean;
	/**
	 * Default B
	*/
	DefaultB: boolean;
	/**
	 * Default A
	*/
	DefaultA: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionStaticComponentMaskParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticComponentMaskParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionStaticComponentMaskParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticComponentMaskParameter;
	static C(Other: UObject): MaterialExpressionStaticComponentMaskParameter;
}

declare class MaterialExpressionVectorParameter extends MaterialExpressionParameter { 
	/**
	 * Default Value
	*/
	DefaultValue: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionVectorParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVectorParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionVectorParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVectorParameter;
	static C(Other: UObject): MaterialExpressionVectorParameter;
}

declare class MaterialExpressionParticleColor extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleColor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleColor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleColor;
	static C(Other: UObject): MaterialExpressionParticleColor;
}

declare class MaterialExpressionParticleDirection extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleDirection;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleDirection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleDirection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleDirection;
	static C(Other: UObject): MaterialExpressionParticleDirection;
}

declare class MaterialExpressionParticleMacroUV extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleMacroUV;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleMacroUV;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleMacroUV;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleMacroUV;
	static C(Other: UObject): MaterialExpressionParticleMacroUV;
}

declare class MaterialExpressionParticleMotionBlurFade extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleMotionBlurFade;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleMotionBlurFade;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleMotionBlurFade;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleMotionBlurFade;
	static C(Other: UObject): MaterialExpressionParticleMotionBlurFade;
}

declare class MaterialExpressionParticlePositionWS extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticlePositionWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticlePositionWS;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticlePositionWS;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticlePositionWS;
	static C(Other: UObject): MaterialExpressionParticlePositionWS;
}

declare class MaterialExpressionParticleRadius extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleRadius;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleRadius;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleRadius;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleRadius;
	static C(Other: UObject): MaterialExpressionParticleRadius;
}

declare class MaterialExpressionParticleRandom extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleRandom;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleRandom;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleRandom;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleRandom;
	static C(Other: UObject): MaterialExpressionParticleRandom;
}

declare class MaterialExpressionParticleRelativeTime extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleRelativeTime;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleRelativeTime;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleRelativeTime;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleRelativeTime;
	static C(Other: UObject): MaterialExpressionParticleRelativeTime;
}

declare class MaterialExpressionParticleSize extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleSize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleSize;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleSize;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleSize;
	static C(Other: UObject): MaterialExpressionParticleSize;
}

declare class MaterialExpressionParticleSpeed extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleSpeed;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleSpeed;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleSpeed;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleSpeed;
	static C(Other: UObject): MaterialExpressionParticleSpeed;
}

declare class MaterialExpressionPerInstanceFadeAmount extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionPerInstanceFadeAmount;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPerInstanceFadeAmount;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionPerInstanceFadeAmount;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPerInstanceFadeAmount;
	static C(Other: UObject): MaterialExpressionPerInstanceFadeAmount;
}

declare class MaterialExpressionPerInstanceRandom extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionPerInstanceRandom;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPerInstanceRandom;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionPerInstanceRandom;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPerInstanceRandom;
	static C(Other: UObject): MaterialExpressionPerInstanceRandom;
}

declare class MaterialExpressionPixelDepth extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionPixelDepth;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPixelDepth;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionPixelDepth;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPixelDepth;
	static C(Other: UObject): MaterialExpressionPixelDepth;
}

declare class MaterialExpressionPixelNormalWS extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionPixelNormalWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPixelNormalWS;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionPixelNormalWS;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPixelNormalWS;
	static C(Other: UObject): MaterialExpressionPixelNormalWS;
}

declare class MaterialExpressionPower extends MaterialExpression { 
	/**
	 * Base
	*/
	Base: ExpressionInput;
	/**
	 * Defaults to 'ConstExponent' if not specified
	*/
	Exponent: ExpressionInput;
	/**
	 * only used if Exponent is not hooked up
	*/
	ConstExponent: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionPower;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPower;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionPower;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPower;
	static C(Other: UObject): MaterialExpressionPower;
}

declare class MaterialExpressionPrecomputedAOMask extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionPrecomputedAOMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionPrecomputedAOMask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionPrecomputedAOMask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionPrecomputedAOMask;
	static C(Other: UObject): MaterialExpressionPrecomputedAOMask;
}

declare class MaterialExpressionQualitySwitch extends MaterialExpression { 
	/**
	 * Default connection, used when a specific quality level input is missing.
	*/
	Default: ExpressionInput;
	/**
	 * Inputs
	*/
	Inputs: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionQualitySwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionQualitySwitch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionQualitySwitch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionQualitySwitch;
	static C(Other: UObject): MaterialExpressionQualitySwitch;
}

declare class MaterialExpressionReflectionVectorWS extends MaterialExpression { 
	/**
	 * Defaults to Reflection Vector if not specified
	*/
	CustomWorldNormal: ExpressionInput;
	/**
	 * (true): The specified world normal will be normalized. (false): WorldNormal will just be used as is, faster but possible artifacts if normal length isn't 1
	*/
	bNormalizeCustomWorldNormal: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionReflectionVectorWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionReflectionVectorWS;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionReflectionVectorWS;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionReflectionVectorWS;
	static C(Other: UObject): MaterialExpressionReflectionVectorWS;
}

declare class MaterialExpressionRotateAboutAxis extends MaterialExpression { 
	/**
	 * Normalized Rotation Axis
	*/
	NormalizedRotationAxis: ExpressionInput;
	/**
	 * Rotation Angle
	*/
	RotationAngle: ExpressionInput;
	/**
	 * Pivot Point
	*/
	PivotPoint: ExpressionInput;
	/**
	 * Position
	*/
	Position: ExpressionInput;
	/**
	 * Period
	*/
	Period: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionRotateAboutAxis;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRotateAboutAxis;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionRotateAboutAxis;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRotateAboutAxis;
	static C(Other: UObject): MaterialExpressionRotateAboutAxis;
}

declare class MaterialExpressionRotator extends MaterialExpression { 
	/**
	 * Defaults to 'ConstCoordinate' if not specified
	*/
	Coordinate: ExpressionInput;
	/**
	 * Defaults to Game Time if not specified
	*/
	Time: ExpressionInput;
	/**
	 * Center X
	*/
	CenterX: number;
	/**
	 * Center Y
	*/
	CenterY: number;
	/**
	 * Speed
	*/
	Speed: number;
	/**
	 * only used if Coordinate is not hooked up
	*/
	ConstCoordinate: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionRotator;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionRotator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionRotator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionRotator;
	static C(Other: UObject): MaterialExpressionRotator;
}

declare type EMaterialSceneAttributeInputMode = string | symbol;
declare var EMaterialSceneAttributeInputMode = { Coordinates:'Coordinates',OffsetFraction:'OffsetFraction', };
declare class MaterialExpressionSceneColor extends MaterialExpression { 
	/**
	 * Coordinates - UV coordinates to apply to the scene color lookup.
	 * OffsetFraction -      An offset to apply to the scene color lookup in a 2d fraction of the screen.
	*/
	InputMode: EMaterialSceneAttributeInputMode;
	/**
	 * Defaults to 'ConstInput' if not specified
	*/
	Input: ExpressionInput;
	/**
	 * Offset Fraction
	*/
	OffsetFraction: ExpressionInput;
	/**
	 * only used if Input is not hooked up
	*/
	ConstInput: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSceneColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneColor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSceneColor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneColor;
	static C(Other: UObject): MaterialExpressionSceneColor;
}

declare class MaterialExpressionSceneDepth extends MaterialExpression { 
	/**
	 * Coordinates - UV coordinates to apply to the scene depth lookup.
	 * OffsetFraction - An offset to apply to the scene depth lookup in a 2d fraction of the screen.
	*/
	InputMode: EMaterialSceneAttributeInputMode;
	/**
	 * Defaults to 'ConstInput' if not specified
	*/
	Input: ExpressionInput;
	/**
	 * Coordinates
	*/
	Coordinates: ExpressionInput;
	/**
	 * only used if Input is not hooked up
	*/
	ConstInput: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSceneDepth;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneDepth;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSceneDepth;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneDepth;
	static C(Other: UObject): MaterialExpressionSceneDepth;
}

declare class MaterialExpressionSceneTexelSize extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSceneTexelSize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneTexelSize;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSceneTexelSize;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneTexelSize;
	static C(Other: UObject): MaterialExpressionSceneTexelSize;
}

declare type ESceneTextureId = string | symbol;
declare var ESceneTextureId = { PPI_SceneColor:'PPI_SceneColor',PPI_SceneDepth:'PPI_SceneDepth',PPI_DiffuseColor:'PPI_DiffuseColor',PPI_SpecularColor:'PPI_SpecularColor',PPI_SubsurfaceColor:'PPI_SubsurfaceColor',PPI_BaseColor:'PPI_BaseColor',PPI_Specular:'PPI_Specular',PPI_Metallic:'PPI_Metallic',PPI_WorldNormal:'PPI_WorldNormal',PPI_SeparateTranslucency:'PPI_SeparateTranslucency',PPI_Opacity:'PPI_Opacity',PPI_Roughness:'PPI_Roughness',PPI_MaterialAO:'PPI_MaterialAO',PPI_CustomDepth:'PPI_CustomDepth',PPI_PostProcessInput0:'PPI_PostProcessInput0',PPI_PostProcessInput1:'PPI_PostProcessInput1',PPI_PostProcessInput2:'PPI_PostProcessInput2',PPI_PostProcessInput3:'PPI_PostProcessInput3',PPI_PostProcessInput4:'PPI_PostProcessInput4',PPI_PostProcessInput5:'PPI_PostProcessInput5',PPI_PostProcessInput6:'PPI_PostProcessInput6',PPI_DecalMask:'PPI_DecalMask',PPI_ShadingModel:'PPI_ShadingModel',PPI_AmbientOcclusion:'PPI_AmbientOcclusion',PPI_CustomStencil:'PPI_CustomStencil',PPI_StoredBaseColor:'PPI_StoredBaseColor',PPI_StoredSpecular:'PPI_StoredSpecular', };
declare class MaterialExpressionSceneTexture extends MaterialExpression { 
	/**
	 * Ignored if not specified
	*/
	Coordinates: ExpressionInput;
	/**
	 * Which scene texture (screen aligned texture) we want to make a lookup into
	*/
	SceneTextureId: ESceneTextureId;
	/**
	 * Clamps texture coordinates to the range 0 to 1. Incurs a performance cost.
	*/
	bClampUVs: boolean;
	/**
	 * Whether to use point sampled texture lookup (default) or using [bi-linear] filtered (can be slower, avoid faceted lock with distortions), some SceneTextures cannot be filtered
	*/
	bFiltered: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSceneTexture;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSceneTexture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSceneTexture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSceneTexture;
	static C(Other: UObject): MaterialExpressionSceneTexture;
}

declare type EMaterialExpressionScreenPositionMapping = string | symbol;
declare var EMaterialExpressionScreenPositionMapping = { MESP_SceneTextureUV:'MESP_SceneTextureUV',MESP_ViewportUV:'MESP_ViewportUV', };
declare class MaterialExpressionScreenPosition extends MaterialExpression { 
	/**
	 * View input property to be accessed
	*/
	Mapping: EMaterialExpressionScreenPositionMapping;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionScreenPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionScreenPosition;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionScreenPosition;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionScreenPosition;
	static C(Other: UObject): MaterialExpressionScreenPosition;
}

declare class MaterialExpressionSine extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	/**
	 * Period
	*/
	Period: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSine;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSine;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSine;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSine;
	static C(Other: UObject): MaterialExpressionSine;
}

declare type ESpeedTreeGeometryType = string | symbol;
declare var ESpeedTreeGeometryType = { STG_Branch:'STG_Branch',STG_Frond:'STG_Frond',STG_Leaf:'STG_Leaf',STG_FacingLeaf:'STG_FacingLeaf',STG_Billboard:'STG_Billboard', };
declare type ESpeedTreeWindType = string | symbol;
declare var ESpeedTreeWindType = { STW_None:'STW_None',STW_Fastest:'STW_Fastest',STW_Fast:'STW_Fast',STW_Better:'STW_Better',STW_Best:'STW_Best',STW_Palm:'STW_Palm',STW_BestPlus:'STW_BestPlus', };
declare type ESpeedTreeLODType = string | symbol;
declare var ESpeedTreeLODType = { STLOD_Pop:'STLOD_Pop',STLOD_Smooth:'STLOD_Smooth', };
declare class MaterialExpressionSpeedTree extends MaterialExpression { 
	/**
	 * The type of SpeedTree geometry on which this material will be used
	*/
	GeometryType: ESpeedTreeGeometryType;
	/**
	 * The type of wind effect used on this tree. This can only go as high as it was in the SpeedTree Modeler, but you can set it to a lower option for lower quality wind and faster rendering.
	*/
	WindType: ESpeedTreeWindType;
	/**
	 * The type of LOD to use
	*/
	LODType: ESpeedTreeLODType;
	/**
	 * The threshold for triangles to be removed from the bilboard mesh when not facing the camera (0 = none pass, 1 = all pass).
	*/
	BillboardThreshold: number;
	/**
	 * Support accurate velocities from wind. This will incur extra cost per vertex.
	*/
	bAccurateWindVelocities: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSpeedTree;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSpeedTree;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSpeedTree;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSpeedTree;
	static C(Other: UObject): MaterialExpressionSpeedTree;
}

declare class MaterialExpressionSphereMask extends MaterialExpression { 
	/**
	 * 1 to 4 dimensional vector, should be the same type as B
	*/
	A: ExpressionInput;
	/**
	 * 1 to 4 dimensional vector, should be the same type as A
	*/
	B: ExpressionInput;
	/**
	 * Defaults to 'AttenuationRadius' if not specified
	*/
	Radius: ExpressionInput;
	/**
	 * Defaults to 'HardnessPercent' if not specified
	*/
	Hardness: ExpressionInput;
	/**
	 * in the unit that A and B are measured
	*/
	AttenuationRadius: number;
	/**
	 * in percent 0%=soft .. 100%=hard
	*/
	HardnessPercent: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSphereMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSphereMask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSphereMask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSphereMask;
	static C(Other: UObject): MaterialExpressionSphereMask;
}

declare class MaterialExpressionSphericalParticleOpacity extends MaterialExpression { 
	/**
	 * Defaults to 'ConstantDensity' if not specified
	*/
	Density: ExpressionInput;
	/**
	 * Constant density of the particle sphere.  Will be overridden if Density is connected.
	*/
	ConstantDensity: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSphericalParticleOpacity;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSphericalParticleOpacity;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSphericalParticleOpacity;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSphericalParticleOpacity;
	static C(Other: UObject): MaterialExpressionSphericalParticleOpacity;
}

declare class MaterialExpressionSquareRoot extends MaterialExpression { 
	/**
	 * Input
	*/
	Input: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSquareRoot;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSquareRoot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSquareRoot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSquareRoot;
	static C(Other: UObject): MaterialExpressionSquareRoot;
}

declare class MaterialExpressionStaticBool extends MaterialExpression { 
	/**
	 * Value
	*/
	Value: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionStaticBool;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticBool;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionStaticBool;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticBool;
	static C(Other: UObject): MaterialExpressionStaticBool;
}

declare class MaterialExpressionStaticSwitch extends MaterialExpression { 
	/**
	 * Default Value
	*/
	DefaultValue: boolean;
	/**
	 * A
	*/
	A: ExpressionInput;
	/**
	 * B
	*/
	B: ExpressionInput;
	/**
	 * Ignored if not specified
	*/
	Value: ExpressionInput;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionStaticSwitch;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionStaticSwitch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionStaticSwitch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionStaticSwitch;
	static C(Other: UObject): MaterialExpressionStaticSwitch;
}

declare class MaterialExpressionSubtract extends MaterialExpression { 
	/**
	 * Defaults to 'ConstA' if not specified
	*/
	A: ExpressionInput;
	/**
	 * Defaults to 'ConstB' if not specified
	*/
	B: ExpressionInput;
	/**
	 * only used if A is not hooked up
	*/
	ConstA: number;
	/**
	 * only used if B is not hooked up
	*/
	ConstB: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSubtract;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSubtract;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSubtract;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSubtract;
	static C(Other: UObject): MaterialExpressionSubtract;
}

declare type EMaterialSamplerType = string | symbol;
declare var EMaterialSamplerType = { SAMPLERTYPE_Color:'SAMPLERTYPE_Color',SAMPLERTYPE_Grayscale:'SAMPLERTYPE_Grayscale',SAMPLERTYPE_Alpha:'SAMPLERTYPE_Alpha',SAMPLERTYPE_Normal:'SAMPLERTYPE_Normal',SAMPLERTYPE_Masks:'SAMPLERTYPE_Masks',SAMPLERTYPE_DistanceFieldFont:'SAMPLERTYPE_DistanceFieldFont',SAMPLERTYPE_LinearColor:'SAMPLERTYPE_LinearColor',SAMPLERTYPE_LinearGrayscale:'SAMPLERTYPE_LinearGrayscale', };
declare class MaterialExpressionTextureBase extends MaterialExpression { 
	/**
	 * Texture
	*/
	Texture: Texture;
	/**
	 * Sampler Type
	*/
	SamplerType: EMaterialSamplerType;
	/**
	 * Is default selected texture when using mesh paint mode texture painting
	*/
	IsDefaultMeshpaintTexture: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureBase;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureBase;
	static C(Other: UObject): MaterialExpressionTextureBase;
}

declare class MaterialExpressionTextureObject extends MaterialExpressionTextureBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureObject;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureObject;
	static C(Other: UObject): MaterialExpressionTextureObject;
}

declare type ETextureMipValueMode = string | symbol;
declare var ETextureMipValueMode = { TMVM_None:'TMVM_None',TMVM_MipLevel:'TMVM_MipLevel',TMVM_MipBias:'TMVM_MipBias',TMVM_Derivative:'TMVM_Derivative', };
declare type ESamplerSourceMode = string | symbol;
declare var ESamplerSourceMode = { SSM_FromTextureAsset:'SSM_FromTextureAsset',SSM_Wrap_WorldGroupSettings:'SSM_Wrap_WorldGroupSettings',SSM_Clamp_WorldGroupSettings:'SSM_Clamp_WorldGroupSettings', };
declare class MaterialExpressionTextureSample extends MaterialExpressionTextureBase { 
	/**
	 * Defaults to 'ConstCoordinate' if not specified
	*/
	Coordinates: ExpressionInput;
	/**
	 * Defaults to 'Texture' if not specified
	*/
	TextureObject: ExpressionInput;
	/**
	 * Defaults to 'ConstMipValue' if not specified
	*/
	MipValue: ExpressionInput;
	/**
	 * Coordinates derivative over the X axis
	*/
	CoordinatesDX: ExpressionInput;
	/**
	 * Coordinates derivative over the Y axis
	*/
	CoordinatesDY: ExpressionInput;
	/**
	 * Defines how the MipValue property is applied to the texture lookup
	*/
	MipValueMode: ETextureMipValueMode;
	/**
	 * Controls where the sampler for this texture lookup will come from.
	 * Choose 'from texture asset' to make use of the UTexture addressing settings,
	 * Otherwise use one of the global samplers, which will not consume a sampler slot.
	 * This allows materials to use more than 16 unique textures on SM5 platforms.
	*/
	SamplerSource: ESamplerSourceMode;
	/**
	 * only used if Coordinates is not hooked up
	*/
	ConstCoordinate: any;
	/**
	 * only used if MipValue is not hooked up
	*/
	ConstMipValue: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureSample;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSample;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureSample;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSample;
	static C(Other: UObject): MaterialExpressionTextureSample;
}

declare class MaterialExpressionParticleSubUV extends MaterialExpressionTextureSample { 
	/**
	 * Blend
	*/
	bBlend: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionParticleSubUV;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionParticleSubUV;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionParticleSubUV;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionParticleSubUV;
	static C(Other: UObject): MaterialExpressionParticleSubUV;
}

declare class MaterialExpressionTextureSampleParameter extends MaterialExpressionTextureSample { 
	/**
	 * Parameter Name
	*/
	ParameterName: string;
	/**
	 * GUID that should be unique within the material, this is used for parameter renaming.
	*/
	ExpressionGUID: Guid;
	/**
	 * The name of the parameter Group to display in MaterialInstance Editor. Default is None group
	*/
	Group: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameter;
	static C(Other: UObject): MaterialExpressionTextureSampleParameter;
}

declare class MaterialExpressionTextureObjectParameter extends MaterialExpressionTextureSampleParameter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureObjectParameter;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureObjectParameter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureObjectParameter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureObjectParameter;
	static C(Other: UObject): MaterialExpressionTextureObjectParameter;
}

declare class MaterialExpressionTextureSampleParameter2D extends MaterialExpressionTextureSampleParameter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameter2D;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameter2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameter2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameter2D;
	static C(Other: UObject): MaterialExpressionTextureSampleParameter2D;
}

declare type ETextureColorChannel = string | symbol;
declare var ETextureColorChannel = { TCC_Red:'TCC_Red',TCC_Green:'TCC_Green',TCC_Blue:'TCC_Blue',TCC_Alpha:'TCC_Alpha', };
declare class MaterialExpressionAntialiasedTextureMask extends MaterialExpressionTextureSampleParameter2D { 
	/**
	 * Threshold
	*/
	Threshold: number;
	/**
	 * Channel
	*/
	Channel: ETextureColorChannel;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionAntialiasedTextureMask;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionAntialiasedTextureMask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionAntialiasedTextureMask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionAntialiasedTextureMask;
	static C(Other: UObject): MaterialExpressionAntialiasedTextureMask;
}

declare class MaterialExpressionTextureSampleParameterSubUV extends MaterialExpressionTextureSampleParameter2D { 
	/**
	 * Blend
	*/
	bBlend: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterSubUV;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterSubUV;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterSubUV;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterSubUV;
	static C(Other: UObject): MaterialExpressionTextureSampleParameterSubUV;
}

declare class MaterialExpressionTextureSampleParameterCube extends MaterialExpressionTextureSampleParameter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureSampleParameterCube;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureSampleParameterCube;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureSampleParameterCube;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureSampleParameterCube;
	static C(Other: UObject): MaterialExpressionTextureSampleParameterCube;
}

declare class MaterialExpressionTextureCoordinate extends MaterialExpression { 
	/**
	 * Texture coordinate index
	*/
	CoordinateIndex: number;
	/**
	 * Controls how much the texture tiles horizontally, by scaling the U component of the vertex UVs by the specified amount.
	*/
	UTiling: number;
	/**
	 * Controls how much the texture tiles vertically, by scaling the V component of the vertex UVs by the specified amount.
	*/
	VTiling: number;
	/**
	 * Would like to unmirror U or V
	 * - if the texture is mirrored and if you would like to undo mirroring for this texture sample, use this to unmirror
	*/
	UnMirrorU: boolean;
	/**
	 * Un Mirror V
	*/
	UnMirrorV: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureCoordinate;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureCoordinate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureCoordinate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureCoordinate;
	static C(Other: UObject): MaterialExpressionTextureCoordinate;
}

declare type EMaterialExposedTextureProperty = string | symbol;
declare var EMaterialExposedTextureProperty = { TMTM_TextureSize:'TMTM_TextureSize',TMTM_TexelSize:'TMTM_TexelSize', };
declare class MaterialExpressionTextureProperty extends MaterialExpression { 
	/**
	 * Texture Object to access the property from.
	*/
	TextureObject: ExpressionInput;
	/**
	 * Texture property to be accessed
	*/
	Property: EMaterialExposedTextureProperty;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTextureProperty;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTextureProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTextureProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTextureProperty;
	static C(Other: UObject): MaterialExpressionTextureProperty;
}

declare class MaterialExpressionTime extends MaterialExpression { 
	/**
	 * This time continues advancing regardless of whether the game is paused.
	*/
	bIgnorePause: boolean;
	/**
	 * Enables or disables the Period value.
	*/
	bOverride_Period: boolean;
	/**
	 * Period at which to wrap around time
	*/
	Period: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTime;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTime;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTime;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTime;
	static C(Other: UObject): MaterialExpressionTime;
}

declare type EMaterialVectorCoordTransformSource = string | symbol;
declare var EMaterialVectorCoordTransformSource = { TRANSFORMSOURCE_Tangent:'TRANSFORMSOURCE_Tangent',TRANSFORMSOURCE_Local:'TRANSFORMSOURCE_Local',TRANSFORMSOURCE_World:'TRANSFORMSOURCE_World',TRANSFORMSOURCE_View:'TRANSFORMSOURCE_View',TRANSFORMSOURCE_Camera:'TRANSFORMSOURCE_Camera',TRANSFORMSOURCE_ParticleWorld:'TRANSFORMSOURCE_ParticleWorld', };
declare type EMaterialVectorCoordTransform = string | symbol;
declare var EMaterialVectorCoordTransform = { TRANSFORM_Tangent:'TRANSFORM_Tangent',TRANSFORM_Local:'TRANSFORM_Local',TRANSFORM_World:'TRANSFORM_World',TRANSFORM_View:'TRANSFORM_View',TRANSFORM_Camera:'TRANSFORM_Camera',TRANSFORM_ParticleWorld:'TRANSFORM_ParticleWorld', };
declare class MaterialExpressionTransform extends MaterialExpression { 
	/**
	 * input expression for this transform
	*/
	Input: ExpressionInput;
	/**
	 * Source coordinate space of the FVector
	*/
	TransformSourceType: EMaterialVectorCoordTransformSource;
	/**
	 * Destination coordinate space of the FVector
	*/
	TransformType: EMaterialVectorCoordTransform;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTransform;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTransform;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTransform;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTransform;
	static C(Other: UObject): MaterialExpressionTransform;
}

declare type EMaterialPositionTransformSource = string | symbol;
declare var EMaterialPositionTransformSource = { TRANSFORMPOSSOURCE_Local:'TRANSFORMPOSSOURCE_Local',TRANSFORMPOSSOURCE_World:'TRANSFORMPOSSOURCE_World',TRANSFORMPOSSOURCE_TranslatedWorld:'TRANSFORMPOSSOURCE_TranslatedWorld',TRANSFORMPOSSOURCE_View:'TRANSFORMPOSSOURCE_View',TRANSFORMPOSSOURCE_Camera:'TRANSFORMPOSSOURCE_Camera',TRANSFORMPOSSOURCE_Particle:'TRANSFORMPOSSOURCE_Particle', };
declare class MaterialExpressionTransformPosition extends MaterialExpression { 
	/**
	 * input expression for this transform
	*/
	Input: ExpressionInput;
	/**
	 * source format of the position that will be transformed
	*/
	TransformSourceType: EMaterialPositionTransformSource;
	/**
	 * type of transform to apply to the input expression
	*/
	TransformType: EMaterialPositionTransformSource;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTransformPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTransformPosition;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTransformPosition;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTransformPosition;
	static C(Other: UObject): MaterialExpressionTransformPosition;
}

declare class MaterialExpressionTwoSidedSign extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionTwoSidedSign;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionTwoSidedSign;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionTwoSidedSign;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionTwoSidedSign;
	static C(Other: UObject): MaterialExpressionTwoSidedSign;
}

declare class MaterialExpressionVertexColor extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionVertexColor;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexColor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionVertexColor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexColor;
	static C(Other: UObject): MaterialExpressionVertexColor;
}

declare class MaterialExpressionVertexNormalWS extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionVertexNormalWS;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionVertexNormalWS;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionVertexNormalWS;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionVertexNormalWS;
	static C(Other: UObject): MaterialExpressionVertexNormalWS;
}

declare type EMaterialExposedViewProperty = string | symbol;
declare var EMaterialExposedViewProperty = { MEVP_BufferSize:'MEVP_BufferSize',MEVP_FieldOfView:'MEVP_FieldOfView',MEVP_TanHalfFieldOfView:'MEVP_TanHalfFieldOfView',MEVP_ViewSize:'MEVP_ViewSize',MEVP_WorldSpaceViewPosition:'MEVP_WorldSpaceViewPosition',MEVP_WorldSpaceCameraPosition:'MEVP_WorldSpaceCameraPosition', };
declare class MaterialExpressionViewProperty extends MaterialExpression { 
	/**
	 * View input property to be accessed
	*/
	Property: EMaterialExposedViewProperty;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionViewProperty;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionViewProperty;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionViewProperty;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionViewProperty;
	static C(Other: UObject): MaterialExpressionViewProperty;
}

declare class MaterialExpressionViewSize extends MaterialExpression { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionViewSize;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionViewSize;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionViewSize;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionViewSize;
	static C(Other: UObject): MaterialExpressionViewSize;
}

declare type EWorldPositionIncludedOffsets = string | symbol;
declare var EWorldPositionIncludedOffsets = { WPT_Default:'WPT_Default',WPT_ExcludeAllShaderOffsets:'WPT_ExcludeAllShaderOffsets',WPT_CameraRelative:'WPT_CameraRelative',WPT_CameraRelativeNoOffsets:'WPT_CameraRelativeNoOffsets', };
declare class MaterialExpressionWorldPosition extends MaterialExpression { 
	/**
	 * World Position Shader Offset
	*/
	WorldPositionShaderOffset: EWorldPositionIncludedOffsets;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionWorldPosition;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionWorldPosition;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionWorldPosition;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionWorldPosition;
	static C(Other: UObject): MaterialExpressionWorldPosition;
}

declare class MatineeInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MatineeInterface;
	static Find(Outer: UObject, ResourceName: string): MatineeInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MatineeInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeInterface;
	static C(Other: UObject): MatineeInterface;
}

declare class NavArea_Default extends NavArea { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavArea_Default;
	static Find(Outer: UObject, ResourceName: string): NavArea_Default;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavArea_Default;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Default;
	static C(Other: UObject): NavArea_Default;
}

declare class NavArea_LowHeight extends NavArea { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavArea_LowHeight;
	static Find(Outer: UObject, ResourceName: string): NavArea_LowHeight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavArea_LowHeight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_LowHeight;
	static C(Other: UObject): NavArea_LowHeight;
}

declare class NavArea_Null extends NavArea { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavArea_Null;
	static Find(Outer: UObject, ResourceName: string): NavArea_Null;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavArea_Null;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Null;
	static C(Other: UObject): NavArea_Null;
}

declare class NavArea_Obstacle extends NavArea { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavArea_Obstacle;
	static Find(Outer: UObject, ResourceName: string): NavArea_Obstacle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavArea_Obstacle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea_Obstacle;
	static C(Other: UObject): NavArea_Obstacle;
}

declare class NavAreaMeta extends NavArea { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavAreaMeta;
	static Find(Outer: UObject, ResourceName: string): NavAreaMeta;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavAreaMeta;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAreaMeta;
	static C(Other: UObject): NavAreaMeta;
}

declare class NavAreaMeta_SwitchByAgent extends NavAreaMeta { 
	/**
	 * Agent 0Area
	*/
	Agent0Area: UnrealEngineClass;
	/**
	 * Agent 1Area
	*/
	Agent1Area: UnrealEngineClass;
	/**
	 * Agent 2Area
	*/
	Agent2Area: UnrealEngineClass;
	/**
	 * Agent 3Area
	*/
	Agent3Area: UnrealEngineClass;
	/**
	 * Agent 4Area
	*/
	Agent4Area: UnrealEngineClass;
	/**
	 * Agent 5Area
	*/
	Agent5Area: UnrealEngineClass;
	/**
	 * Agent 6Area
	*/
	Agent6Area: UnrealEngineClass;
	/**
	 * Agent 7Area
	*/
	Agent7Area: UnrealEngineClass;
	/**
	 * Agent 8Area
	*/
	Agent8Area: UnrealEngineClass;
	/**
	 * Agent 9Area
	*/
	Agent9Area: UnrealEngineClass;
	/**
	 * Agent 10Area
	*/
	Agent10Area: UnrealEngineClass;
	/**
	 * Agent 11Area
	*/
	Agent11Area: UnrealEngineClass;
	/**
	 * Agent 12Area
	*/
	Agent12Area: UnrealEngineClass;
	/**
	 * Agent 13Area
	*/
	Agent13Area: UnrealEngineClass;
	/**
	 * Agent 14Area
	*/
	Agent14Area: UnrealEngineClass;
	/**
	 * Agent 15Area
	*/
	Agent15Area: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavAreaMeta_SwitchByAgent;
	static Find(Outer: UObject, ResourceName: string): NavAreaMeta_SwitchByAgent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavAreaMeta_SwitchByAgent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavAreaMeta_SwitchByAgent;
	static C(Other: UObject): NavAreaMeta_SwitchByAgent;
}

declare class RecastNavMeshDataChunk extends NavigationDataChunk { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): RecastNavMeshDataChunk;
	static Find(Outer: UObject, ResourceName: string): RecastNavMeshDataChunk;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RecastNavMeshDataChunk;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastNavMeshDataChunk;
	static C(Other: UObject): RecastNavMeshDataChunk;
}

declare class NavigationPathGenerator extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationPathGenerator;
	static Find(Outer: UObject, ResourceName: string): NavigationPathGenerator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationPathGenerator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationPathGenerator;
	static C(Other: UObject): NavigationPathGenerator;
}

declare class RecastFilter_UseDefaultArea extends NavigationQueryFilter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): RecastFilter_UseDefaultArea;
	static Find(Outer: UObject, ResourceName: string): RecastFilter_UseDefaultArea;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): RecastFilter_UseDefaultArea;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): RecastFilter_UseDefaultArea;
	static C(Other: UObject): RecastFilter_UseDefaultArea;
}

declare class NavLinkTrivial extends NavLinkDefinition { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavLinkTrivial;
	static Find(Outer: UObject, ResourceName: string): NavLinkTrivial;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavLinkTrivial;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavLinkTrivial;
	static C(Other: UObject): NavLinkTrivial;
}

declare class NavNodeInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavNodeInterface;
	static Find(Outer: UObject, ResourceName: string): NavNodeInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavNodeInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavNodeInterface;
	static C(Other: UObject): NavNodeInterface;
}

declare class PackageMapClient extends PackageMap { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PackageMapClient;
	static Find(Outer: UObject, ResourceName: string): PackageMapClient;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PackageMapClient;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackageMapClient;
	static C(Other: UObject): PackageMapClient;
}

declare class DemoNetConnection extends NetConnection { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DemoNetConnection;
	static Find(Outer: UObject, ResourceName: string): DemoNetConnection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DemoNetConnection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DemoNetConnection;
	static C(Other: UObject): DemoNetConnection;
}

declare class ObjectLibrary extends UObject { 
	/**
	 * Class that Objects must be of. If ContainsBlueprints is true, this is the native class that the blueprints are instances of and not UClass
	*/
	ObjectBaseClass: UnrealEngineClass;
	/**
	 * True if this library holds blueprint classes, false if it holds other objects
	*/
	bHasBlueprintClasses: boolean;
	/**
	 * List of Objects in library
	*/
	Objects: UObject[];
	/**
	 * Weak pointers to objects
	*/
	WeakObjects: any[];
	/**
	 * If this library should use weak pointers
	*/
	bUseWeakReferences: boolean;
	/**
	 * True if we've already fully loaded this library, can't do it twice
	*/
	bIsFullyLoaded: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ObjectLibrary;
	static Find(Outer: UObject, ResourceName: string): ObjectLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ObjectLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectLibrary;
	static C(Other: UObject): ObjectLibrary;
}

declare class ObjectReferencer extends UObject { 
	/**
	 * Array of objects being referenced.
	*/
	ReferencedObjects: UObject[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ObjectReferencer;
	static Find(Outer: UObject, ResourceName: string): ObjectReferencer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ObjectReferencer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ObjectReferencer;
	static C(Other: UObject): ObjectReferencer;
}

declare class OnlineBlueprintCallProxyBase extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): OnlineBlueprintCallProxyBase;
	static Find(Outer: UObject, ResourceName: string): OnlineBlueprintCallProxyBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineBlueprintCallProxyBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBlueprintCallProxyBase;
	/**
	 * Called to trigger the actual online action once the delegates have been bound
	*/
	Activate(): void;
	static C(Other: UObject): OnlineBlueprintCallProxyBase;
}

declare class OnlineEngineInterface extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): OnlineEngineInterface;
	static Find(Outer: UObject, ResourceName: string): OnlineEngineInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineEngineInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineEngineInterface;
	static C(Other: UObject): OnlineEngineInterface;
}

declare class ParticleSpriteEmitter extends ParticleEmitter { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSpriteEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleSpriteEmitter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSpriteEmitter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSpriteEmitter;
	static C(Other: UObject): ParticleSpriteEmitter;
}

declare class ParticleModuleOrientationBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleOrientationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrientationBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleOrientationBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrientationBase;
	static C(Other: UObject): ParticleModuleOrientationBase;
}

declare type EParticleAxisLock = string | symbol;
declare var EParticleAxisLock = { EPAL_NONE:'EPAL_NONE',EPAL_X:'EPAL_X',EPAL_Y:'EPAL_Y',EPAL_Z:'EPAL_Z',EPAL_NEGATIVE_X:'EPAL_NEGATIVE_X',EPAL_NEGATIVE_Y:'EPAL_NEGATIVE_Y',EPAL_NEGATIVE_Z:'EPAL_NEGATIVE_Z',EPAL_ROTATE_X:'EPAL_ROTATE_X',EPAL_ROTATE_Y:'EPAL_ROTATE_Y',EPAL_ROTATE_Z:'EPAL_ROTATE_Z', };
declare class ParticleModuleOrientationAxisLock extends ParticleModuleOrientationBase { 
	/**
	 * The lock axis flag setting.
	 * Can be one of the following:
	 *         EPAL_NONE                       No locking to an axis.
	 *         EPAL_X                          Lock the sprite facing towards +X.
	 *         EPAL_Y                          Lock the sprite facing towards +Y.
	 *         EPAL_Z                          Lock the sprite facing towards +Z.
	 *         EPAL_NEGATIVE_X         Lock the sprite facing towards -X.
	 *         EPAL_NEGATIVE_Y         Lock the sprite facing towards -Y.
	 *         EPAL_NEGATIVE_Z         Lock the sprite facing towards -Z.
	 *         EPAL_ROTATE_X           Lock the sprite rotation on the X-axis.
	 *         EPAL_ROTATE_Y           Lock the sprite rotation on the Y-axis.
	 *         EPAL_ROTATE_Z           Lock the sprite rotation on the Z-axis.
	*/
	LockAxisFlags: EParticleAxisLock;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleOrientationAxisLock;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrientationAxisLock;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleOrientationAxisLock;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrientationAxisLock;
	static C(Other: UObject): ParticleModuleOrientationAxisLock;
}

declare class ParticleModuleAccelerationBase extends ParticleModule { 
	/**
	 * If true, then treat the acceleration as world-space
	*/
	bAlwaysInWorldSpace: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAccelerationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAccelerationBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationBase;
	static C(Other: UObject): ParticleModuleAccelerationBase;
}

declare class ParticleModuleAcceleration extends ParticleModuleAccelerationBase { 
	/**
	 * The initial acceleration of the particle.
	 * Value is obtained using the EmitterTime at particle spawn.
	 * Each frame, the current and base velocity of the particle
	 * is then updated using the formula
	 *         velocity += acceleration * DeltaTime
	 * where DeltaTime is the time passed since the last frame.
	*/
	Acceleration: RawDistributionVector;
	/**
	 * If true, then apply the particle system components scale
	 * to the acceleration value.
	*/
	bApplyOwnerScale: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAcceleration;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAcceleration;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAcceleration;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAcceleration;
	static C(Other: UObject): ParticleModuleAcceleration;
}

declare class ParticleModuleAccelerationConstant extends ParticleModuleAccelerationBase { 
	/**
	 * Constant acceleration for particles in this system.
	*/
	Acceleration: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAccelerationConstant;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationConstant;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAccelerationConstant;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationConstant;
	static C(Other: UObject): ParticleModuleAccelerationConstant;
}

declare class ParticleModuleAccelerationDrag extends ParticleModuleAccelerationBase { 
	/**
	 * Per-particle drag coefficient. Evaluted using emitter time.
	*/
	DragCoefficient: DistributionFloat;
	/**
	 * Per-particle drag coefficient. Evaluted using emitter time.
	*/
	DragCoefficientRaw: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAccelerationDrag;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationDrag;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAccelerationDrag;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationDrag;
	static C(Other: UObject): ParticleModuleAccelerationDrag;
}

declare class ParticleModuleAccelerationDragScaleOverLife extends ParticleModuleAccelerationBase { 
	/**
	 * Per-particle drag scale. Evaluted using particle relative time.
	*/
	DragScale: DistributionFloat;
	/**
	 * Per-particle drag scale. Evaluted using particle relative time.
	*/
	DragScaleRaw: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAccelerationDragScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationDragScaleOverLife;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAccelerationDragScaleOverLife;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationDragScaleOverLife;
	static C(Other: UObject): ParticleModuleAccelerationDragScaleOverLife;
}

declare class ParticleModuleAccelerationOverLifetime extends ParticleModuleAccelerationBase { 
	/**
	 * The acceleration of the particle over its lifetime.
	 * Value is obtained using the RelativeTime of the partice.
	 * The current and base velocity values of the particle
	 * are then updated using the formula
	 *         velocity += acceleration* DeltaTime
	 * where DeltaTime is the time passed since the last frame.
	*/
	AccelOverLife: RawDistributionVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAccelerationOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAccelerationOverLifetime;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAccelerationOverLifetime;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAccelerationOverLifetime;
	static C(Other: UObject): ParticleModuleAccelerationOverLifetime;
}

declare class ParticleModuleAttractorBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAttractorBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAttractorBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorBase;
	static C(Other: UObject): ParticleModuleAttractorBase;
}

declare class ParticleModuleAttractorLine extends ParticleModuleAttractorBase { 
	/**
	 * The first endpoint of the line.
	*/
	EndPoint0: Vector;
	/**
	 * The second endpoint of the line.
	*/
	EndPoint1: Vector;
	/**
	 * The range of the line attractor.
	*/
	Range: RawDistributionFloat;
	/**
	 * The strength of the line attractor.
	*/
	Strength: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAttractorLine;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorLine;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAttractorLine;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorLine;
	static C(Other: UObject): ParticleModuleAttractorLine;
}

declare type EAttractorParticleSelectionMethod = string | symbol;
declare var EAttractorParticleSelectionMethod = { EAPSM_Random:'EAPSM_Random',EAPSM_Sequential:'EAPSM_Sequential', };
declare class ParticleModuleAttractorParticle extends ParticleModuleAttractorBase { 
	/**
	 * The source emitter for attractors
	*/
	EmitterName: string;
	/**
	 * The radial range of the attraction around the source particle.
	 * Particle-life relative.
	*/
	Range: RawDistributionFloat;
	/**
	 * The strength curve is a function of distance or of time.
	*/
	bStrengthByDistance: boolean;
	/**
	 * The strength of the attraction (negative values repel).
	 * Particle-life relative if StrengthByDistance is false.
	*/
	Strength: RawDistributionFloat;
	/**
	 * If true, the velocity adjustment will be applied to the base velocity.
	*/
	bAffectBaseVelocity: boolean;
	/**
	 * The method to use when selecting an attractor target particle from the emitter.
	 * One of the following:
	 * Random          - Randomly select a particle from the source emitter.
	 * Sequential  - Select a particle using a sequential order.
	*/
	SelectionMethod: EAttractorParticleSelectionMethod;
	/**
	 * Whether the particle should grab a new particle if it's source expires.
	*/
	bRenewSource: boolean;
	/**
	 * Whether the particle should inherit the source veloctiy if it expires.
	*/
	bInheritSourceVel: boolean;
	/**
	 * Last Sel Index
	*/
	LastSelIndex: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAttractorParticle;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorParticle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAttractorParticle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorParticle;
	static C(Other: UObject): ParticleModuleAttractorParticle;
}

declare class ParticleModuleAttractorPoint extends ParticleModuleAttractorBase { 
	/**
	 * The position of the point attractor from the source of the emitter.
	*/
	Position: RawDistributionVector;
	/**
	 * The radial range of the attractor.
	*/
	Range: RawDistributionFloat;
	/**
	 * The strength of the point attractor.
	*/
	Strength: RawDistributionFloat;
	/**
	 * The strength curve is a function of distance or of time.
	*/
	StrengthByDistance: boolean;
	/**
	 * If true, the velocity adjustment will be applied to the base velocity.
	*/
	bAffectBaseVelocity: boolean;
	/**
	 * If true, set the velocity.
	*/
	bOverrideVelocity: boolean;
	/**
	 * If true, treat the position as world space.  So don't transform the the point to localspace.
	*/
	bUseWorldSpacePosition: boolean;
	/**
	 * Whether particles can move along the positive X axis.
	*/
	Positive_X: boolean;
	/**
	 * Whether particles can move along the positive Y axis.
	*/
	Positive_Y: boolean;
	/**
	 * Whether particles can move along the positive Z axis.
	*/
	Positive_Z: boolean;
	/**
	 * Whether particles can move along the negative X axis.
	*/
	Negative_X: boolean;
	/**
	 * Whether particles can move along the negative Y axis.
	*/
	Negative_Y: boolean;
	/**
	 * Whether particles can move along the negative Z axis.
	*/
	Negative_Z: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAttractorPoint;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorPoint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAttractorPoint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorPoint;
	static C(Other: UObject): ParticleModuleAttractorPoint;
}

declare class ParticleModuleAttractorPointGravity extends ParticleModuleAttractorBase { 
	/**
	 * The position of the point gravity source.
	*/
	Position: Vector;
	/**
	 * The distance at which the influence of the point begins to falloff.
	*/
	Radius: number;
	/**
	 * The strength of the point source.
	*/
	Strength: DistributionFloat;
	/**
	 * The strength of the point source.
	*/
	StrengthRaw: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleAttractorPointGravity;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleAttractorPointGravity;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleAttractorPointGravity;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleAttractorPointGravity;
	static C(Other: UObject): ParticleModuleAttractorPointGravity;
}

declare class ParticleModuleBeamBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleBeamBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleBeamBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamBase;
	static C(Other: UObject): ParticleModuleBeamBase;
}

declare type BeamModifierType = string | symbol;
declare var BeamModifierType = { PEB2MT_Source:'PEB2MT_Source',PEB2MT_Target:'PEB2MT_Target', };
declare class BeamModifierOptions { 
	/**
	 * If true, modify the value associated with this grouping.
	*/
	bModify: boolean;
	/**
	 * If true, scale the associated value by the given value.
	*/
	bScale: boolean;
	/**
	 * If true, lock the modifier to the life of the particle.
	*/
	bLock: boolean;
	clone() : BeamModifierOptions;
	static C(Other: UObject): BeamModifierOptions;
}

declare class ParticleModuleBeamModifier extends ParticleModuleBeamBase { 
	/**
	 * Whether this module modifies the Source or the Target.
	*/
	ModifierType: BeamModifierType;
	/**
	 * The options associated with the position.
	*/
	PositionOptions: BeamModifierOptions;
	/**
	 * The value to use when modifying the position.
	*/
	Position: RawDistributionVector;
	/**
	 * The options associated with the Tangent.
	*/
	TangentOptions: BeamModifierOptions;
	/**
	 * The value to use when modifying the Tangent.
	*/
	Tangent: RawDistributionVector;
	/**
	 * If true, don't transform the tangent modifier into the tangent basis.
	*/
	bAbsoluteTangent: boolean;
	/**
	 * The options associated with the Strength.
	*/
	StrengthOptions: BeamModifierOptions;
	/**
	 * The value to use when modifying the Strength.
	*/
	Strength: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleBeamModifier;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamModifier;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleBeamModifier;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamModifier;
	static C(Other: UObject): ParticleModuleBeamModifier;
}

declare class ParticleModuleBeamNoise extends ParticleModuleBeamBase { 
	/**
	 * Is low frequency noise enabled.
	*/
	bLowFreq_Enabled: boolean;
	/**
	 * The frequency of noise points.
	*/
	Frequency: number;
	/**
	 * If not 0, then the frequency will select a random value in the range
	 *         [Frequency_LowRange..Frequency]
	*/
	Frequency_LowRange: number;
	/**
	 * The noise point ranges.
	*/
	NoiseRange: RawDistributionVector;
	/**
	 * A scale factor that will be applied to the noise range.
	*/
	NoiseRangeScale: RawDistributionFloat;
	/**
	 * If true,  the NoiseRangeScale will be grabbed based on the emitter time.
	 * If false, the NoiseRangeScale will be grabbed based on the particle time.
	*/
	bNRScaleEmitterTime: boolean;
	/**
	 * The speed with which to move each noise point.
	*/
	NoiseSpeed: RawDistributionVector;
	/**
	 * Whether the noise movement should be smooth or 'jerky'.
	*/
	bSmooth: boolean;
	/**
	 * Default target-point information to use if the beam method is endpoint.
	*/
	NoiseLockRadius: number;
	/**
	 * INTERNAL - Whether the noise points should be locked.
	*/
	bNoiseLock: boolean;
	/**
	 * Whether the noise points should be oscillate.
	*/
	bOscillate: boolean;
	/**
	 * How long the  noise points should be locked - 0.0 indicates forever.
	*/
	NoiseLockTime: number;
	/**
	 * The tension to apply to the tessellated noise line.
	*/
	NoiseTension: number;
	/**
	 * If true, calculate tangents at each noise point.
	*/
	bUseNoiseTangents: boolean;
	/**
	 * The strength of noise tangents, if enabled.
	*/
	NoiseTangentStrength: RawDistributionFloat;
	/**
	 * The amount of tessellation between noise points.
	*/
	NoiseTessellation: number;
	/**
	 * Whether to apply noise to the target point (or end of line in distance mode...)
	 * If true, the beam could potentially 'leave' the target...
	*/
	bTargetNoise: boolean;
	/**
	 * The distance at which to deposit noise points.
	 * If 0.0, then use the static frequency value.
	 * If not, distribute noise points at the given distance, up to the static Frequency value.
	 * At that point, evenly distribute them along the beam.
	*/
	FrequencyDistance: number;
	/**
	 * If true, apply the noise scale to the beam.
	*/
	bApplyNoiseScale: boolean;
	/**
	 * The scale factor to apply to noise range.
	 * The lookup value is determined by dividing the number of noise points present by the
	 * maximum number of noise points (Frequency).
	*/
	NoiseScale: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleBeamNoise;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamNoise;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleBeamNoise;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamNoise;
	static C(Other: UObject): ParticleModuleBeamNoise;
}

declare type Beam2SourceTargetMethod = string | symbol;
declare var Beam2SourceTargetMethod = { PEB2STM_Default:'PEB2STM_Default',PEB2STM_UserSet:'PEB2STM_UserSet',PEB2STM_Emitter:'PEB2STM_Emitter',PEB2STM_Particle:'PEB2STM_Particle',PEB2STM_Actor:'PEB2STM_Actor', };
declare type Beam2SourceTargetTangentMethod = string | symbol;
declare var Beam2SourceTargetTangentMethod = { PEB2STTM_Direct:'PEB2STTM_Direct',PEB2STTM_UserSet:'PEB2STTM_UserSet',PEB2STTM_Distribution:'PEB2STTM_Distribution',PEB2STTM_Emitter:'PEB2STTM_Emitter', };
declare class ParticleModuleBeamSource extends ParticleModuleBeamBase { 
	/**
	 * The method flag.
	*/
	SourceMethod: Beam2SourceTargetMethod;
	/**
	 * The strength of the tangent from the source point for each beam.
	*/
	SourceName: string;
	/**
	 * Whether to treat the as an absolute position in world space.
	*/
	bSourceAbsolute: boolean;
	/**
	 * Default source-point to use.
	*/
	Source: RawDistributionVector;
	/**
	 * Whether to lock the source to the life of the particle.
	*/
	bLockSource: boolean;
	/**
	 * The method to use for the source tangent.
	*/
	SourceTangentMethod: Beam2SourceTargetTangentMethod;
	/**
	 * The tangent for the source point for each beam.
	*/
	SourceTangent: RawDistributionVector;
	/**
	 * Whether to lock the source to the life of the particle.
	*/
	bLockSourceTangent: boolean;
	/**
	 * The strength of the tangent from the source point for each beam.
	*/
	SourceStrength: RawDistributionFloat;
	/**
	 * Whether to lock the source to the life of the particle.
	*/
	bLockSourceStength: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleBeamSource;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamSource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleBeamSource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamSource;
	static C(Other: UObject): ParticleModuleBeamSource;
}

declare class ParticleModuleBeamTarget extends ParticleModuleBeamBase { 
	/**
	 * The method flag.
	*/
	TargetMethod: Beam2SourceTargetMethod;
	/**
	 * The target point sources of each beam, when using the end point method.
	*/
	TargetName: string;
	/**
	 * Default target-point information to use if the beam method is endpoint.
	*/
	Target: RawDistributionVector;
	/**
	 * Whether to treat the as an absolute position in world space.
	*/
	bTargetAbsolute: boolean;
	/**
	 * Whether to lock the Target to the life of the particle.
	*/
	bLockTarget: boolean;
	/**
	 * The method to use for the Target tangent.
	*/
	TargetTangentMethod: Beam2SourceTargetTangentMethod;
	/**
	 * The tangent for the Target point for each beam.
	*/
	TargetTangent: RawDistributionVector;
	/**
	 * Whether to lock the Target to the life of the particle.
	*/
	bLockTargetTangent: boolean;
	/**
	 * The strength of the tangent from the Target point for each beam.
	*/
	TargetStrength: RawDistributionFloat;
	/**
	 * Whether to lock the Target to the life of the particle.
	*/
	bLockTargetStength: boolean;
	/**
	 * Default target-point information to use if the beam method is endpoint.
	*/
	LockRadius: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleBeamTarget;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleBeamTarget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleBeamTarget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleBeamTarget;
	static C(Other: UObject): ParticleModuleBeamTarget;
}

declare class ParticleModuleCameraBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleCameraBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCameraBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleCameraBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCameraBase;
	static C(Other: UObject): ParticleModuleCameraBase;
}

declare type EParticleCameraOffsetUpdateMethod = string | symbol;
declare var EParticleCameraOffsetUpdateMethod = { EPCOUM_DirectSet:'EPCOUM_DirectSet',EPCOUM_Additive:'EPCOUM_Additive',EPCOUM_Scalar:'EPCOUM_Scalar', };
declare class ParticleModuleCameraOffset extends ParticleModuleCameraBase { 
	/**
	 * The camera-relative offset to apply to sprite location
	*/
	CameraOffset: RawDistributionFloat;
	/**
	 * If true, the offset will only be processed at spawn time
	*/
	bSpawnTimeOnly: boolean;
	/**
	 * How to update the offset for this module.
	 * DirectSet - Set the value directly (overwrite any previous setting)
	 * Additive  - Add the offset of this module to the existing offset
	 * Scalar    - Scale the existing offset by the value of this module
	*/
	UpdateMethod: EParticleCameraOffsetUpdateMethod;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleCameraOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCameraOffset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleCameraOffset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCameraOffset;
	static C(Other: UObject): ParticleModuleCameraOffset;
}

declare class ParticleModuleCollisionBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleCollisionBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollisionBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleCollisionBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollisionBase;
	static C(Other: UObject): ParticleModuleCollisionBase;
}

declare type EParticleCollisionComplete = string | symbol;
declare var EParticleCollisionComplete = { EPCC_Kill:'EPCC_Kill',EPCC_Freeze:'EPCC_Freeze',EPCC_HaltCollisions:'EPCC_HaltCollisions',EPCC_FreezeTranslation:'EPCC_FreezeTranslation',EPCC_FreezeRotation:'EPCC_FreezeRotation',EPCC_FreezeMovement:'EPCC_FreezeMovement', };
declare class ParticleModuleCollision extends ParticleModuleCollisionBase { 
	/**
	 * How much to `slow' the velocity of the particle after a collision.
	 * Value is obtained using the EmitterTime at particle spawn.
	*/
	DampingFactor: RawDistributionVector;
	/**
	 * How much to `slow' the rotation of the particle after a collision.
	 * Value is obtained using the EmitterTime at particle spawn.
	*/
	DampingFactorRotation: RawDistributionVector;
	/**
	 * The maximum number of collisions a particle can have.
	 * Value is obtained using the EmitterTime at particle spawn.
	*/
	MaxCollisions: RawDistributionFloat;
	/**
	 * What to do once a particles MaxCollisions is reached.
	 * One of the following:
	 * EPCC_Kill
	 *         Kill the particle when MaxCollisions is reached
	 * EPCC_Freeze
	 *         Freeze in place, NO MORE UPDATES
	 * EPCC_HaltCollisions,
	 *         Stop collision checks, keep updating everything
	 * EPCC_FreezeTranslation,
	 *         Stop translations, keep updating everything else
	 * EPCC_FreezeRotation,
	 *         Stop rotations, keep updating everything else
	 * EPCC_FreezeMovement
	 *         Stop all movement, keep updating
	*/
	CollisionCompletionOption: EParticleCollisionComplete;
	/**
	 * Which ObjectTypes to collide with
	*/
	CollisionTypes: EObjectTypeQuery[];
	/**
	 * If true, physic will be applied between a particle and the
	 * object it collides with.
	 * This is one-way - particle --> object. The particle does
	 * not have physics applied to it - it just generates an
	 * impulse applied to the object it collides with.
	 * NOTE: having this on prevents the code from running off the game thread.
	*/
	bApplyPhysics: boolean;
	/**
	 * Any trigger volumes that are hit will be ignored. NOTE: This can be turned off if the TrigerVolume physics object type is not in the CollisionTypes array.
	 * Turning this off is strongly recommended as having it on prevents the code from running off the game thread.
	*/
	bIgnoreTriggerVolumes: boolean;
	/**
	 * The mass of the particle - for use when bApplyPhysics is true.
	 * Value is obtained using the EmitterTime at particle spawn.
	*/
	ParticleMass: RawDistributionFloat;
	/**
	 * The directional scalar value - used to scale the bounds to
	 * 'assist' in avoiding inter-penetration or large gaps.
	*/
	DirScalar: number;
	/**
	 * If true, then collisions with Pawns will still react, but
	 * the UsedMaxCollisions count will not be decremented.
	 * (ie., They don't 'count' as collisions)
	 * NOTE: Having this on prevents the code from running in parallel.
	*/
	bPawnsDoNotDecrementCount: boolean;
	/**
	 * If true, then collisions that do not have a vertical hit
	 * normal will still react, but UsedMaxCollisions count will
	 * not be decremented. (ie., They don't 'count' as collisions)
	 * Useful for having particles come to rest on floors.
	*/
	bOnlyVerticalNormalsDecrementCount: boolean;
	/**
	 * The fudge factor to use to determine vertical.
	 * True vertical will have a Hit.Normal.Z == 1.0
	 * This will allow for Z components in the range of
	 * [1.0-VerticalFudgeFactor..1.0]
	 * to count as vertical collisions.
	*/
	VerticalFudgeFactor: number;
	/**
	 * How long to delay before checking a particle for collisions.
	 * Value is retrieved using the EmitterTime.
	 * During update, the particle flag IgnoreCollisions will be
	 * set until the particle RelativeTime has surpassed the
	 * DelayAmount.
	*/
	DelayAmount: RawDistributionFloat;
	/**
	 * If true, when the World->bDropDetail flag is set, the module will be ignored.
	*/
	bDropDetail: boolean;
	/**
	 * If true, Particle collision only if particle system is currently being rendered.
	*/
	bCollideOnlyIfVisible: boolean;
	/**
	 * If true, then the source actor is ignored in collision checks.
	 * Defaults to true.
	*/
	bIgnoreSourceActor: boolean;
	/**
	 * Max distance at which particle collision will occur.
	*/
	MaxCollisionDistance: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleCollision;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollision;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleCollision;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollision;
	static C(Other: UObject): ParticleModuleCollision;
}

declare type EParticleCollisionResponse = string | symbol;
declare var EParticleCollisionResponse = { Bounce:'Bounce',Stop:'Stop',Kill:'Kill', };
declare type EParticleCollisionMode = string | symbol;
declare var EParticleCollisionMode = { SceneDepth:'SceneDepth',DistanceField:'DistanceField', };
declare class ParticleModuleCollisionGPU extends ParticleModuleCollisionBase { 
	/**
	 * The bounciness of the particle.
	*/
	Resilience: RawDistributionFloat;
	/**
	 * Scales the bounciness of the particle over its life.
	*/
	ResilienceScaleOverLife: RawDistributionFloat;
	/**
	 * Friction applied to all particles during a collision or while moving
	 * along a surface.
	*/
	Friction: number;
	/**
	 * Scale applied to the size of the particle to obtain the collision radius.
	*/
	RadiusScale: number;
	/**
	 * Bias applied to the collision radius.
	*/
	RadiusBias: number;
	/**
	 * How particles respond to a collision event.
	*/
	Response: EParticleCollisionResponse;
	/**
	 * Collision Mode
	*/
	CollisionMode: EParticleCollisionMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleCollisionGPU;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleCollisionGPU;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleCollisionGPU;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleCollisionGPU;
	static C(Other: UObject): ParticleModuleCollisionGPU;
}

declare class ParticleModuleColorBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleColorBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleColorBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorBase;
	static C(Other: UObject): ParticleModuleColorBase;
}

declare class ParticleModuleColor extends ParticleModuleColorBase { 
	/**
	 * Initial color for a particle as a function of Emitter time.
	*/
	StartColor: RawDistributionVector;
	/**
	 * Initial alpha for a particle as a function of Emitter time.
	*/
	StartAlpha: RawDistributionFloat;
	/**
	 * If true, the alpha value will be clamped to the [0..1] range.
	*/
	bClampAlpha: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleColor;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleColor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColor;
	static C(Other: UObject): ParticleModuleColor;
}

declare class ParticleRandomSeedInfo { 
	/**
	 * The name to expose to the placed instances for setting this seed
	*/
	ParameterName: string;
	/**
	 * If true, the module will attempt to get the seed from the owner
	 * instance. If that fails, it will fall back to getting it from
	 * the RandomSeeds array.
	*/
	bGetSeedFromInstance: boolean;
	/**
	 * If true, the seed value retrieved from the instance will be an
	 * index into the array of seeds.
	*/
	bInstanceSeedIsIndex: boolean;
	/**
	 * If true, then reset the seed upon the emitter looping.
	 * For looping environmental effects this should likely be set to false to avoid
	 * a repeating pattern.
	*/
	bResetSeedOnEmitterLooping: boolean;
	/**
	 * If true, then randomly select a seed entry from the RandomSeeds array
	*/
	bRandomlySelectSeedArray: boolean;
	/**
	 * The random seed values to utilize for the module.
	 * More than 1 means the instance will randomly select one.
	*/
	RandomSeeds: number[];
	clone() : ParticleRandomSeedInfo;
	static C(Other: UObject): ParticleRandomSeedInfo;
}

declare class ParticleModuleColor_Seeded extends ParticleModuleColor { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleColor_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColor_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleColor_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColor_Seeded;
	static C(Other: UObject): ParticleModuleColor_Seeded;
}

declare class ParticleModuleColorOverLife extends ParticleModuleColorBase { 
	/**
	 * The color to apply to the particle, as a function of the particle RelativeTime.
	*/
	ColorOverLife: RawDistributionVector;
	/**
	 * The alpha to apply to the particle, as a function of the particle RelativeTime.
	*/
	AlphaOverLife: RawDistributionFloat;
	/**
	 * If true, the alpha value will be clamped to the [0..1] range.
	*/
	bClampAlpha: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleColorOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorOverLife;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleColorOverLife;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorOverLife;
	static C(Other: UObject): ParticleModuleColorOverLife;
}

declare class ParticleModuleColorScaleOverLife extends ParticleModuleColorBase { 
	/**
	 * The scale factor for the color.
	*/
	ColorScaleOverLife: RawDistributionVector;
	/**
	 * The scale factor for the alpha.
	*/
	AlphaScaleOverLife: RawDistributionFloat;
	/**
	 * Whether it is EmitterTime or ParticleTime related.
	*/
	bEmitterTime: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleColorScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleColorScaleOverLife;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleColorScaleOverLife;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleColorScaleOverLife;
	static C(Other: UObject): ParticleModuleColorScaleOverLife;
}

declare class ParticleModuleEventReceiverKillParticles extends ParticleModuleEventReceiverBase { 
	/**
	 * If true, stop this emitter from spawning as well.
	*/
	bStopSpawning: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventReceiverKillParticles;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverKillParticles;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventReceiverKillParticles;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverKillParticles;
	static C(Other: UObject): ParticleModuleEventReceiverKillParticles;
}

declare class ParticleModuleEventReceiverSpawn extends ParticleModuleEventReceiverBase { 
	/**
	 * The number of particles to spawn.
	*/
	SpawnCount: RawDistributionFloat;
	/**
	 * For Death-based event receiving, if this is true, it indicates that the
	 * ParticleTime of the event should be used to look-up the SpawnCount.
	 * Otherwise (and in all other events received), use the emitter time of
	 * the event.
	*/
	bUseParticleTime: boolean;
	/**
	 * If true, use the location of the particle system component for spawning.
	 * if false (default), use the location of the particle event.
	*/
	bUsePSysLocation: boolean;
	/**
	 * If true, use the velocity of the dying particle as the start velocity of
	 * the spawned particle.
	*/
	bInheritVelocity: boolean;
	/**
	 * If bInheritVelocity is true, scale the velocity with this.
	*/
	InheritVelocityScale: RawDistributionVector;
	/**
	 * Array of physical materials that can be used to allow or ban a specific set of materials when receiving collision events.
	*/
	PhysicalMaterials: PhysicalMaterial[];
	/**
	 * When true, the PhysicalMaterials list is used to ban specified materials for collision events but allow all others.
	 * When false, the PhysicalMaterials list is used to allow only specified materials for collision events and ban all others.
	*/
	bBanPhysicalMaterials: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventReceiverSpawn;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverSpawn;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventReceiverSpawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverSpawn;
	static C(Other: UObject): ParticleModuleEventReceiverSpawn;
}

declare class ParticleModuleKillBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleKillBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleKillBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillBase;
	static C(Other: UObject): ParticleModuleKillBase;
}

declare class ParticleModuleKillBox extends ParticleModuleKillBase { 
	/**
	 * The lower left corner of the box.
	*/
	LowerLeftCorner: RawDistributionVector;
	/**
	 * The upper right corner of the box.
	*/
	UpperRightCorner: RawDistributionVector;
	/**
	 * If true, the box coordinates are in world space./
	*/
	bAbsolute: boolean;
	/**
	 * If true, particles INSIDE the box will be killed.
	 * If false (the default), particles OUTSIDE the box will be killed.
	*/
	bKillInside: boolean;
	/**
	 * If true, the box will always be axis aligned and non-scalable.
	*/
	bAxisAlignedAndFixedSize: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleKillBox;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleKillBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillBox;
	static C(Other: UObject): ParticleModuleKillBox;
}

declare class ParticleModuleKillHeight extends ParticleModuleKillBase { 
	/**
	 * The height at which to kill the particle.
	*/
	Height: RawDistributionFloat;
	/**
	 * If true, the height should be treated as a world-space position.
	*/
	bAbsolute: boolean;
	/**
	 * If true, the plane should be considered a floor - ie kill anything BELOW it.
	 * If false, if is a ceiling - ie kill anything ABOVE it.
	*/
	bFloor: boolean;
	/**
	 * If true, take the particle systems scale into account
	*/
	bApplyPSysScale: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleKillHeight;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleKillHeight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleKillHeight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleKillHeight;
	static C(Other: UObject): ParticleModuleKillHeight;
}

declare class ParticleModuleLifetimeBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLifetimeBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetimeBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLifetimeBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetimeBase;
	static C(Other: UObject): ParticleModuleLifetimeBase;
}

declare class ParticleModuleLifetime extends ParticleModuleLifetimeBase { 
	/**
	 * The lifetime of the particle, in seconds. Retrieved using the EmitterTime at the spawn of the particle.
	*/
	Lifetime: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetime;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLifetime;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetime;
	static C(Other: UObject): ParticleModuleLifetime;
}

declare class ParticleModuleLifetime_Seeded extends ParticleModuleLifetime { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLifetime_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLifetime_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLifetime_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLifetime_Seeded;
	static C(Other: UObject): ParticleModuleLifetime_Seeded;
}

declare class ParticleModuleLightBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLightBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLightBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLightBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLightBase;
	static C(Other: UObject): ParticleModuleLightBase;
}

declare class ParticleModuleLight extends ParticleModuleLightBase { 
	/**
	 * Whether to use physically based inverse squared falloff from the light.  If unchecked, the LightExponent distribution will be used instead.
	*/
	bUseInverseSquaredFalloff: boolean;
	/**
	 * Whether lights from this module should affect translucency.
	 * Use with caution.  Modules enabling this should only make a few particle lights at most, and the smaller they are, the less they will cost.
	*/
	bAffectsTranslucency: boolean;
	/**
	 * Will draw wireframe spheres to preview the light radius if enabled.
	 * Note: this is intended for previewing and the value will not be saved, it will always revert to disabled.
	*/
	bPreviewLightRadius: boolean;
	/**
	 * Fraction of particles in this emitter to create lights on.
	*/
	SpawnFraction: number;
	/**
	 * Scale that is applied to the particle's color to calculate the light's color, and can be setup as a curve over the particle's lifetime.
	*/
	ColorScaleOverLife: RawDistributionVector;
	/**
	 * Brightness scale for the light, which can be setup as a curve over the particle's lifetime.
	*/
	BrightnessOverLife: RawDistributionFloat;
	/**
	 * Scales the particle's radius, to calculate the light's radius.
	*/
	RadiusScale: RawDistributionFloat;
	/**
	 * Provides the light's exponent when inverse squared falloff is disabled.
	*/
	LightExponent: RawDistributionFloat;
	/**
	 * High Quality Lights
	*/
	bHighQualityLights: boolean;
	/**
	 * Shadow Casting Lights
	*/
	bShadowCastingLights: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLight;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLight;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLight;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLight;
	static C(Other: UObject): ParticleModuleLight;
}

declare class ParticleModuleLight_Seeded extends ParticleModuleLight { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLight_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLight_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLight_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLight_Seeded;
	static C(Other: UObject): ParticleModuleLight_Seeded;
}

declare class ParticleModuleLocationBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationBase;
	static C(Other: UObject): ParticleModuleLocationBase;
}

declare class ParticleModuleLocation extends ParticleModuleLocationBase { 
	/**
	 * The location the particle should be emitted.
	 * Relative in local space to the emitter by default.
	 * Relative in world space as a WorldOffset module or when the emitter's UseLocalSpace is off.
	 * Retrieved using the EmitterTime at the spawn of the particle.
	*/
	StartLocation: RawDistributionVector;
	/**
	 * When set to a non-zero value this will force the particles to only spawn on evenly distributed
	 * positions between the two points specified.
	*/
	DistributeOverNPoints: number;
	/**
	 * When DistributeOverNPoints is set to a non-zero value, this specifies the ratio of particles spawned
	 * that should use the distribution.  (For example setting this to 1 will cause all the particles to
	 * be distributed evenly whereas .75 would cause 1/4 of the particles to be randomly placed).
	*/
	DistributeThreshold: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocation;
	static C(Other: UObject): ParticleModuleLocation;
}

declare class ParticleModuleLocation_Seeded extends ParticleModuleLocation { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocation_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocation_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocation_Seeded;
	static C(Other: UObject): ParticleModuleLocation_Seeded;
}

declare class ParticleModuleLocationWorldOffset extends ParticleModuleLocation { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationWorldOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationWorldOffset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationWorldOffset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationWorldOffset;
	static C(Other: UObject): ParticleModuleLocationWorldOffset;
}

declare class ParticleModuleLocationWorldOffset_Seeded extends ParticleModuleLocationWorldOffset { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationWorldOffset_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationWorldOffset_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationWorldOffset_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationWorldOffset_Seeded;
	static C(Other: UObject): ParticleModuleLocationWorldOffset_Seeded;
}

declare type ELocationBoneSocketSource = string | symbol;
declare var ELocationBoneSocketSource = { BONESOCKETSOURCE_Bones:'BONESOCKETSOURCE_Bones',BONESOCKETSOURCE_Sockets:'BONESOCKETSOURCE_Sockets', };
declare class LocationBoneSocketInfo { 
	/**
	 * The name of the bone/socket on the skeletal mesh
	*/
	BoneSocketName: string;
	/**
	 * The offset from the bone/socket to use
	*/
	Offset: Vector;
	clone() : LocationBoneSocketInfo;
	static C(Other: UObject): LocationBoneSocketInfo;
}

declare type ELocationBoneSocketSelectionMethod = string | symbol;
declare var ELocationBoneSocketSelectionMethod = { BONESOCKETSEL_Sequential:'BONESOCKETSEL_Sequential',BONESOCKETSEL_Random:'BONESOCKETSEL_Random', };
declare class ParticleModuleLocationBoneSocket extends ParticleModuleLocationBase { 
	/**
	 * Whether the module uses Bones or Sockets for locations.
	 * BONESOCKETSOURCE_Bones          - Use Bones as the source locations.
	 * BONESOCKETSOURCE_Sockets        - Use Sockets as the source locations.
	*/
	SourceType: ELocationBoneSocketSource;
	/**
	 * An offset to apply to each bone/socket
	*/
	UniversalOffset: Vector;
	/**
	 * The name(s) of the bone/socket(s) to position at. If this is empty, the module will attempt to spawn from all bones or sockets.
	*/
	SourceLocations: LocationBoneSocketInfo[];
	/**
	 * The method by which to select the bone/socket to spawn at.
	 * SEL_Sequential                  - loop through the bone/socket array in order
	 * SEL_Random                              - randomly select a bone/socket from the array
	*/
	SelectionMethod: ELocationBoneSocketSelectionMethod;
	/**
	 * If true, update the particle locations each frame with that of the bone/socket
	*/
	bUpdatePositionEachFrame: boolean;
	/**
	 * If true, rotate mesh emitter meshes to orient w/ the socket
	*/
	bOrientMeshEmitters: boolean;
	/**
	 * If true, particles inherit the associated bone velocity when spawned
	*/
	bInheritBoneVelocity: boolean;
	/**
	 * A scale on how much of the bone's velocity a particle will inherit.
	*/
	InheritVelocityScale: number;
	/**
	 * The parameter name of the skeletal mesh actor that supplies the SkelMeshComponent for in-game.
	*/
	SkelMeshActorParamName: string;
	/**
	 * When we have no source locations and we need to track bone velocities due to bInheritBoneVelocity, we pre select a set of bones to use each frame. This property determines how big the list is.
	 * Too low and the randomness of selection may suffer, too high and memory will be wasted.
	*/
	NumPreSelectedIndices: number;
	/**
	 * The name of the skeletal mesh to use in the editor
	*/
	EditorSkelMesh: SkeletalMesh;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationBoneSocket;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationBoneSocket;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationBoneSocket;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationBoneSocket;
	static C(Other: UObject): ParticleModuleLocationBoneSocket;
}

declare class ParticleModuleLocationDirect extends ParticleModuleLocationBase { 
	/**
	 * The location of the particle at a give time. Retrieved using the particle RelativeTime.
	 * IMPORTANT: the particle location is set to this value, thereby over-writing any previous module impacts.
	*/
	Location: RawDistributionVector;
	/**
	 * An offset to apply to the position retrieved from the Location calculation.
	 * The offset is retrieved using the EmitterTime.
	 * The offset will remain constant over the life of the particle.
	*/
	LocationOffset: RawDistributionVector;
	/**
	 * Scales the velocity of the object at a given point in the time-line.
	*/
	ScaleFactor: RawDistributionVector;
	/**
	 * Currently unused.
	*/
	Direction: RawDistributionVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationDirect;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationDirect;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationDirect;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationDirect;
	static C(Other: UObject): ParticleModuleLocationDirect;
}

declare type ELocationEmitterSelectionMethod = string | symbol;
declare var ELocationEmitterSelectionMethod = { ELESM_Random:'ELESM_Random',ELESM_Sequential:'ELESM_Sequential', };
declare class ParticleModuleLocationEmitter extends ParticleModuleLocationBase { 
	/**
	 * The name of the emitter to use that the source location for particle.
	*/
	EmitterName: string;
	/**
	 * The method to use when selecting a spawn target particle from the emitter.
	 * Can be one of the following:
	 *         ELESM_Random            Randomly select a particle from the source emitter.
	 *         ELESM_Sequential        Step through each particle from the source emitter in order.
	*/
	SelectionMethod: ELocationEmitterSelectionMethod;
	/**
	 * If true, the spawned particle should inherit the velocity of the source particle.
	*/
	InheritSourceVelocity: boolean;
	/**
	 * Amount to scale the source velocity by when inheriting it.
	*/
	InheritSourceVelocityScale: number;
	/**
	 * If true, the spawned particle should inherit the rotation of the source particle.
	*/
	bInheritSourceRotation: boolean;
	/**
	 * Amount to scale the source rotation by when inheriting it.
	*/
	InheritSourceRotationScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationEmitter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationEmitter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationEmitter;
	static C(Other: UObject): ParticleModuleLocationEmitter;
}

declare class ParticleModuleLocationEmitterDirect extends ParticleModuleLocationBase { 
	/**
	 * The name of the emitter to use as a source for the location of the particles.
	*/
	EmitterName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationEmitterDirect;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationEmitterDirect;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationEmitterDirect;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationEmitterDirect;
	static C(Other: UObject): ParticleModuleLocationEmitterDirect;
}

declare class ParticleModuleLocationPrimitiveBase extends ParticleModuleLocationBase { 
	/**
	 * Whether the positive X axis is valid for spawning.
	*/
	Positive_X: boolean;
	/**
	 * Whether the positive Y axis is valid for spawning.
	*/
	Positive_Y: boolean;
	/**
	 * Whether the positive Z axis is valid for spawning.
	*/
	Positive_Z: boolean;
	/**
	 * Whether the negative X axis is valid for spawning.
	*/
	Negative_X: boolean;
	/**
	 * Whether the negative Y axis is valid for spawning.
	*/
	Negative_Y: boolean;
	/**
	 * Whether the negative Zaxis is valid for spawning.
	*/
	Negative_Z: boolean;
	/**
	 * Whether particles will only spawn on the surface of the primitive.
	*/
	SurfaceOnly: boolean;
	/**
	 * Whether the particle should get its velocity from the position within the primitive.
	*/
	Velocity: boolean;
	/**
	 * The scale applied to the velocity. (Only used if 'Velocity' is checked).
	*/
	VelocityScale: RawDistributionFloat;
	/**
	 * The location of the bounding primitive relative to the position of the emitter.
	*/
	StartLocation: RawDistributionVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveBase;
	static C(Other: UObject): ParticleModuleLocationPrimitiveBase;
}

declare type CylinderHeightAxis = string | symbol;
declare var CylinderHeightAxis = { PMLPC_HEIGHTAXIS_X:'PMLPC_HEIGHTAXIS_X',PMLPC_HEIGHTAXIS_Y:'PMLPC_HEIGHTAXIS_Y',PMLPC_HEIGHTAXIS_Z:'PMLPC_HEIGHTAXIS_Z', };
declare class ParticleModuleLocationPrimitiveCylinder extends ParticleModuleLocationPrimitiveBase { 
	/**
	 * If true, get the particle velocity form the radial distance inside the primitive.
	*/
	RadialVelocity: boolean;
	/**
	 * The radius of the cylinder.
	*/
	StartRadius: RawDistributionFloat;
	/**
	 * The height of the cylinder, centered about the location.
	*/
	StartHeight: RawDistributionFloat;
	/**
	 * Determine particle particle system axis that should represent the height of the cylinder.
	 * Can be one of the following:
	 *   PMLPC_HEIGHTAXIS_X - Orient the height along the particle system X-axis.
	 *   PMLPC_HEIGHTAXIS_Y - Orient the height along the particle system Y-axis.
	 *   PMLPC_HEIGHTAXIS_Z - Orient the height along the particle system Z-axis.
	*/
	HeightAxis: CylinderHeightAxis;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveCylinder;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveCylinder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveCylinder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveCylinder;
	static C(Other: UObject): ParticleModuleLocationPrimitiveCylinder;
}

declare class ParticleModuleLocationPrimitiveCylinder_Seeded extends ParticleModuleLocationPrimitiveCylinder { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveCylinder_Seeded;
	static C(Other: UObject): ParticleModuleLocationPrimitiveCylinder_Seeded;
}

declare class ParticleModuleLocationPrimitiveSphere extends ParticleModuleLocationPrimitiveBase { 
	/**
	 * The radius of the sphere. Retrieved using EmitterTime.
	*/
	StartRadius: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveSphere;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveSphere;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveSphere;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveSphere;
	static C(Other: UObject): ParticleModuleLocationPrimitiveSphere;
}

declare class ParticleModuleLocationPrimitiveSphere_Seeded extends ParticleModuleLocationPrimitiveSphere { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveSphere_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveSphere_Seeded;
	static C(Other: UObject): ParticleModuleLocationPrimitiveSphere_Seeded;
}

declare class ParticleModuleLocationPrimitiveTriangle extends ParticleModuleLocationBase { 
	/**
	 * Start Offset
	*/
	StartOffset: RawDistributionVector;
	/**
	 * Height
	*/
	Height: RawDistributionFloat;
	/**
	 * Angle
	*/
	Angle: RawDistributionFloat;
	/**
	 * Thickness
	*/
	Thickness: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationPrimitiveTriangle;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationPrimitiveTriangle;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationPrimitiveTriangle;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationPrimitiveTriangle;
	static C(Other: UObject): ParticleModuleLocationPrimitiveTriangle;
}

declare type ELocationSkelVertSurfaceSource = string | symbol;
declare var ELocationSkelVertSurfaceSource = { VERTSURFACESOURCE_Vert:'VERTSURFACESOURCE_Vert',VERTSURFACESOURCE_Surface:'VERTSURFACESOURCE_Surface', };
declare class ParticleModuleLocationSkelVertSurface extends ParticleModuleLocationBase { 
	/**
	 * Whether the module uses Verts or Surfaces for locations.
	 * VERTSURFACESOURCE_Vert          - Use Verts as the source locations.
	 * VERTSURFACESOURCE_Surface       - Use Surfaces as the source locations.
	*/
	SourceType: ELocationSkelVertSurfaceSource;
	/**
	 * An offset to apply to each vert/surface
	*/
	UniversalOffset: Vector;
	/**
	 * If true, update the particle locations each frame with that of the vert/surface
	*/
	bUpdatePositionEachFrame: boolean;
	/**
	 * If true, rotate mesh emitter meshes to orient w/ the vert/surface
	*/
	bOrientMeshEmitters: boolean;
	/**
	 * If true, particles inherit the associated bone velocity when spawned
	*/
	bInheritBoneVelocity: boolean;
	/**
	 * The parameter name of the skeletal mesh actor that supplies the SkelMeshComponent for in-game.
	*/
	SkelMeshActorParamName: string;
	/**
	 * The name of the skeletal mesh to use in the editor
	*/
	EditorSkelMesh: SkeletalMesh;
	/**
	 * This module will only spawn from verts or surfaces associated with the bones in this list
	*/
	ValidAssociatedBones: string[];
	/**
	 * When true use the RestrictToNormal and NormalTolerance values to check surface normals
	*/
	bEnforceNormalCheck: boolean;
	/**
	 * Use this normal to restrict spawning locations
	*/
	NormalToCompare: Vector;
	/**
	 * Normal tolerance.  0 degrees means it must be an exact match, 180 degrees means it can be any angle.
	*/
	NormalCheckToleranceDegrees: number;
	/**
	 * Normal tolerance.  Value between 1.0 and -1.0 with 1.0 being exact match, 0.0 being everything up to
	 *               perpendicular and -1.0 being any direction or don't restrict at all.
	*/
	NormalCheckTolerance: number;
	/**
	 * Array of material indices that are valid materials to spawn from.
	 * If empty, any material will be considered valid
	*/
	ValidMaterialIndices: number[];
	/**
	 * If true, particles inherit the associated vertex color on spawn. This feature is not supported for GPU particles.
	*/
	bInheritVertexColor: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleLocationSkelVertSurface;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleLocationSkelVertSurface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleLocationSkelVertSurface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleLocationSkelVertSurface;
	static C(Other: UObject): ParticleModuleLocationSkelVertSurface;
}

declare class ParticleModulePivotOffset extends ParticleModuleLocationBase { 
	/**
	 * Offset applied in UV space to the particle vertex positions. Defaults to (0.5,0.5) putting the pivot in the centre of the partilce.
	*/
	PivotOffset: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModulePivotOffset;
	static Find(Outer: UObject, ResourceName: string): ParticleModulePivotOffset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModulePivotOffset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModulePivotOffset;
	static C(Other: UObject): ParticleModulePivotOffset;
}

declare class ParticleModuleSourceMovement extends ParticleModuleLocationBase { 
	/**
	 * The scale factor to apply to the source movement before adding to the particle location.
	 * The value is looked up using the particles RELATIVE time [0..1].
	*/
	SourceMovementScale: RawDistributionVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSourceMovement;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSourceMovement;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSourceMovement;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSourceMovement;
	static C(Other: UObject): ParticleModuleSourceMovement;
}

declare class ParticleModuleMaterialBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleMaterialBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMaterialBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleMaterialBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMaterialBase;
	static C(Other: UObject): ParticleModuleMaterialBase;
}

declare class ParticleModuleMeshMaterial extends ParticleModuleMaterialBase { 
	/**
	 * The array of materials to apply to the mesh particles.
	*/
	MeshMaterials: MaterialInterface[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleMeshMaterial;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshMaterial;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleMeshMaterial;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshMaterial;
	static C(Other: UObject): ParticleModuleMeshMaterial;
}

declare class ParticleModuleParameterBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleParameterBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleParameterBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterBase;
	static C(Other: UObject): ParticleModuleParameterBase;
}

declare type EEmitterDynamicParameterValue = string | symbol;
declare var EEmitterDynamicParameterValue = { EDPV_UserSet:'EDPV_UserSet',EDPV_VelocityX:'EDPV_VelocityX',EDPV_VelocityY:'EDPV_VelocityY',EDPV_VelocityZ:'EDPV_VelocityZ',EDPV_VelocityMag:'EDPV_VelocityMag', };
declare class EmitterDynamicParameter { 
	/**
	 * The parameter name - from the material DynamicParameter expression. READ-ONLY
	*/
	ParamName: string;
	/**
	 * If true, use the EmitterTime to retrieve the value, otherwise use Particle RelativeTime.
	*/
	bUseEmitterTime: boolean;
	/**
	 * If true, only set the value at spawn time of the particle, otherwise update each frame.
	*/
	bSpawnTimeOnly: boolean;
	/**
	 * Where to get the parameter value from.
	*/
	ValueMethod: EEmitterDynamicParameterValue;
	/**
	 * If true, scale the velocity value selected in ValueMethod by the evaluated ParamValue.
	*/
	bScaleVelocityByParamValue: boolean;
	/**
	 * The distriubtion for the parameter value.
	*/
	ParamValue: RawDistributionFloat;
	clone() : EmitterDynamicParameter;
	static C(Other: UObject): EmitterDynamicParameter;
}

declare class ParticleModuleParameterDynamic extends ParticleModuleParameterBase { 
	/**
	 * The dynamic parameters this module uses.
	*/
	DynamicParams: EmitterDynamicParameter[];
	/**
	 * Flags for optimizing update
	*/
	UpdateFlags: number;
	/**
	 * Uses Velocity
	*/
	bUsesVelocity: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleParameterDynamic;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterDynamic;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleParameterDynamic;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterDynamic;
	static C(Other: UObject): ParticleModuleParameterDynamic;
}

declare class ParticleModuleParameterDynamic_Seeded extends ParticleModuleParameterDynamic { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleParameterDynamic_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleParameterDynamic_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleParameterDynamic_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleParameterDynamic_Seeded;
	static C(Other: UObject): ParticleModuleParameterDynamic_Seeded;
}

declare class ParticleModuleRotationBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRotationBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRotationBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationBase;
	static C(Other: UObject): ParticleModuleRotationBase;
}

declare class ParticleModuleMeshRotation extends ParticleModuleRotationBase { 
	/**
	 * Initial rotation in ROTATIONS PER SECOND (1 = 360 degrees).
	 * The value is retrieved using the EmitterTime.
	*/
	StartRotation: RawDistributionVector;
	/**
	 * If true, apply the parents rotation as well.
	*/
	bInheritParent: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleMeshRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleMeshRotation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotation;
	static C(Other: UObject): ParticleModuleMeshRotation;
}

declare class ParticleModuleMeshRotation_Seeded extends ParticleModuleMeshRotation { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleMeshRotation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotation_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleMeshRotation_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotation_Seeded;
	static C(Other: UObject): ParticleModuleMeshRotation_Seeded;
}

declare class ParticleModuleRotation extends ParticleModuleRotationBase { 
	/**
	 * Initial rotation of the particle (1 = 360 degrees).
	 * The value is retrieved using the EmitterTime.
	*/
	StartRotation: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRotation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotation;
	static C(Other: UObject): ParticleModuleRotation;
}

declare class ParticleModuleRotation_Seeded extends ParticleModuleRotation { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRotation_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotation_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRotation_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotation_Seeded;
	static C(Other: UObject): ParticleModuleRotation_Seeded;
}

declare class ParticleModuleRotationOverLifetime extends ParticleModuleRotationBase { 
	/**
	 * The rotation of the particle (1.0 = 360 degrees).
	 * The value is retrieved using the RelativeTime of the particle.
	*/
	RotationOverLife: RawDistributionFloat;
	/**
	 * If true,  the particle rotation is multiplied by the value retrieved from RotationOverLife.
	 * If false, the particle rotation is incremented by the value retrieved from RotationOverLife.
	*/
	Scale: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRotationOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationOverLifetime;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRotationOverLifetime;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationOverLifetime;
	static C(Other: UObject): ParticleModuleRotationOverLifetime;
}

declare class ParticleModuleRotationRateBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRotationRateBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRateBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRotationRateBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRateBase;
	static C(Other: UObject): ParticleModuleRotationRateBase;
}

declare class ParticleModuleMeshRotationRate extends ParticleModuleRotationRateBase { 
	/**
	 * Initial rotation rate, in rotations per second.
	 * The value is retrieved using the EmitterTime.
	*/
	StartRotationRate: RawDistributionVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleMeshRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleMeshRotationRate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRate;
	static C(Other: UObject): ParticleModuleMeshRotationRate;
}

declare class ParticleModuleRotationRate extends ParticleModuleRotationRateBase { 
	/**
	 * Initial rotation rate, in rotations per second.
	 * The value is retrieved using the EmitterTime.
	*/
	StartRotationRate: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRotationRate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRate;
	static C(Other: UObject): ParticleModuleRotationRate;
}

declare class ParticleModuleMeshRotationRate_Seeded extends ParticleModuleMeshRotationRate { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleMeshRotationRate_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRate_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleMeshRotationRate_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRate_Seeded;
	static C(Other: UObject): ParticleModuleMeshRotationRate_Seeded;
}

declare class ParticleModuleMeshRotationRateMultiplyLife extends ParticleModuleRotationRateBase { 
	/**
	 * The scale factor that should be applied to the rotation rate.
	 * The value is retrieved using the RelativeTime of the particle.
	*/
	LifeMultiplier: RawDistributionVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleMeshRotationRateMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRateMultiplyLife;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleMeshRotationRateMultiplyLife;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRateMultiplyLife;
	static C(Other: UObject): ParticleModuleMeshRotationRateMultiplyLife;
}

declare class ParticleModuleMeshRotationRateOverLife extends ParticleModuleRotationRateBase { 
	/**
	 * The rotation rate desired.
	 * The value is retrieved using the RelativeTime of the particle.
	*/
	RotRate: RawDistributionVector;
	/**
	 * If true, scale the current rotation rate by the value retrieved.
	 * Otherwise, set the rotation rate to the value retrieved.
	*/
	bScaleRotRate: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleMeshRotationRateOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleMeshRotationRateOverLife;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleMeshRotationRateOverLife;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleMeshRotationRateOverLife;
	static C(Other: UObject): ParticleModuleMeshRotationRateOverLife;
}

declare class ParticleModuleRotationRate_Seeded extends ParticleModuleRotationRate { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRotationRate_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRate_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRotationRate_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRate_Seeded;
	static C(Other: UObject): ParticleModuleRotationRate_Seeded;
}

declare class ParticleModuleRotationRateMultiplyLife extends ParticleModuleRotationRateBase { 
	/**
	 * The scale factor that should be applied to the rotation rate.
	 * The value is retrieved using the RelativeTime of the particle.
	*/
	LifeMultiplier: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRotationRateMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRotationRateMultiplyLife;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRotationRateMultiplyLife;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRotationRateMultiplyLife;
	static C(Other: UObject): ParticleModuleRotationRateMultiplyLife;
}

declare class ParticleModuleSizeBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSizeBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSizeBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeBase;
	static C(Other: UObject): ParticleModuleSizeBase;
}

declare class ParticleModuleSize extends ParticleModuleSizeBase { 
	/**
	 * The initial size that should be used for a particle.
	 * The value is retrieved using the EmitterTime during the spawn of a particle.
	 * It is added to the Size and BaseSize fields of the spawning particle.
	*/
	StartSize: RawDistributionVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSize;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSize;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSize;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSize;
	static C(Other: UObject): ParticleModuleSize;
}

declare class ParticleModuleSize_Seeded extends ParticleModuleSize { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSize_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSize_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSize_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSize_Seeded;
	static C(Other: UObject): ParticleModuleSize_Seeded;
}

declare class ParticleModuleSizeMultiplyLife extends ParticleModuleSizeBase { 
	/**
	 * The scale factor for the size that should be used for a particle.
	 * The value is retrieved using the RelativeTime of the particle during its update.
	*/
	LifeMultiplier: RawDistributionVector;
	/**
	 * If true, the X-component of the scale factor will be applied to the particle size X-component.
	 * If false, the X-component is left unaltered.
	*/
	MultiplyX: boolean;
	/**
	 * If true, the Y-component of the scale factor will be applied to the particle size Y-component.
	 * If false, the Y-component is left unaltered.
	*/
	MultiplyY: boolean;
	/**
	 * If true, the Z-component of the scale factor will be applied to the particle size Z-component.
	 * If false, the Z-component is left unaltered.
	*/
	MultiplyZ: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSizeMultiplyLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeMultiplyLife;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSizeMultiplyLife;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeMultiplyLife;
	static C(Other: UObject): ParticleModuleSizeMultiplyLife;
}

declare class ParticleModuleSizeScale extends ParticleModuleSizeBase { 
	/**
	 * The amount the BaseSize should be scaled before being used as the size of the particle.
	 * The value is retrieved using the RelativeTime of the particle during its update.
	 * NOTE: this module overrides any size adjustments made prior to this module in that frame.
	*/
	SizeScale: RawDistributionVector;
	/**
	 * Ignored
	*/
	EnableX: boolean;
	/**
	 * Ignored
	*/
	EnableY: boolean;
	/**
	 * Ignored
	*/
	EnableZ: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSizeScale;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeScale;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSizeScale;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeScale;
	static C(Other: UObject): ParticleModuleSizeScale;
}

declare class ParticleModuleSizeScaleBySpeed extends ParticleModuleSizeBase { 
	/**
	 * By how much speed affects the size of the particle in each dimension.
	*/
	SpeedScale: Vector2D;
	/**
	 * The maximum amount by which to scale a particle in each dimension.
	*/
	MaxScale: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSizeScaleBySpeed;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSizeScaleBySpeed;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSizeScaleBySpeed;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSizeScaleBySpeed;
	static C(Other: UObject): ParticleModuleSizeScaleBySpeed;
}

declare class ParticleModuleSpawnPerUnit extends ParticleModuleSpawnBase { 
	/**
	 * The scalar to apply to the distance traveled.
	 * The value from SpawnPerUnit is divided by this value to give the actual
	 * number of particles per unit.
	*/
	UnitScalar: number;
	/**
	 * The amount to spawn per meter distribution.
	 * The value is retrieved using the EmitterTime.
	*/
	SpawnPerUnit: RawDistributionFloat;
	/**
	 * If true, process the default spawn rate when not moving...
	 * When not moving, skip the default spawn rate.
	 * If false, return the bProcessSpawnRate setting.
	*/
	bIgnoreSpawnRateWhenMoving: boolean;
	/**
	 * The tolerance for moving vs. not moving w.r.t. the bIgnoreSpawnRateWhenMoving flag.
	 * Ie, if (DistanceMoved < (UnitScalar x MovementTolerance)) then consider it not moving.
	*/
	MovementTolerance: number;
	/**
	 * The maximum valid movement for a single frame.
	 * If 0.0, then the check is not performed.
	 * Currently, if the distance moved between frames is greater than this
	 * then NO particles will be spawned.
	 * This is primiarily intended to cover cases where the PSystem is
	 * attached to teleporting objects.
	*/
	MaxFrameDistance: number;
	/**
	 * If true, ignore the X-component of the movement
	*/
	bIgnoreMovementAlongX: boolean;
	/**
	 * If true, ignore the Y-component of the movement
	*/
	bIgnoreMovementAlongY: boolean;
	/**
	 * If true, ignore the Z-component of the movement
	*/
	bIgnoreMovementAlongZ: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSpawnPerUnit;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawnPerUnit;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSpawnPerUnit;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawnPerUnit;
	static C(Other: UObject): ParticleModuleSpawnPerUnit;
}

declare class ParticleModuleSubUVBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSubUVBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUVBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSubUVBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUVBase;
	static C(Other: UObject): ParticleModuleSubUVBase;
}

declare type ESubUVBoundingVertexCount = string | symbol;
declare var ESubUVBoundingVertexCount = { BVC_FourVertices:'BVC_FourVertices',BVC_EightVertices:'BVC_EightVertices', };
declare type EOpacitySourceMode = string | symbol;
declare var EOpacitySourceMode = { OSM_Alpha:'OSM_Alpha',OSM_ColorBrightness:'OSM_ColorBrightness',OSM_RedChannel:'OSM_RedChannel',OSM_GreenChannel:'OSM_GreenChannel',OSM_BlueChannel:'OSM_BlueChannel', };
declare class SubUVAnimation extends UObject { 
	/**
	 * Texture to generate bounding geometry from.
	*/
	SubUVTexture: Texture2D;
	/**
	 * The number of sub-images horizontally in the texture
	*/
	SubImages_Horizontal: number;
	/**
	 * The number of sub-images vertically in the texture
	*/
	SubImages_Vertical: number;
	/**
	 * More bounding vertices results in reduced overdraw, but adds more triangle overhead.
	 * The eight vertex mode is best used when the SubUV texture has a lot of space to cut out that is not captured by the four vertex version,
	 * and when the particles using the texture will be few and large.
	*/
	BoundingMode: ESubUVBoundingVertexCount;
	/**
	 * Opacity Source Mode
	*/
	OpacitySourceMode: EOpacitySourceMode;
	/**
	 * Alpha channel values larger than the threshold are considered occupied and will be contained in the bounding geometry.
	 * Raising this threshold slightly can reduce overdraw in particles using this animation asset.
	*/
	AlphaThreshold: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SubUVAnimation;
	static Find(Outer: UObject, ResourceName: string): SubUVAnimation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SubUVAnimation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubUVAnimation;
	static C(Other: UObject): SubUVAnimation;
}

declare class ParticleModuleSubUV extends ParticleModuleSubUVBase { 
	/**
	 * SubUV animation asset to use.
	 * When specified, optimal bounding geometry for each SubUV frame will be used when rendering the sprites for this emitter instead of full quads.
	 * This reduction in overdraw can reduce the GPU cost of rendering the emitter by 2x or 3x, depending on how much unused space was in the texture.
	 * The bounding geometry is generated off of the texture alpha setup in the SubUV Animation asset, so that has to match what the material is using for opacity, or clipping will occur.
	 * When specified, SubImages_Horizontal and SubImages_Vertical will come from the asset instead of the Required Module.
	*/
	Animation: SubUVAnimation;
	/**
	 * The index of the sub-image that should be used for the particle.
	 * The value is retrieved using the RelativeTime of the particles.
	*/
	SubImageIndex: RawDistributionFloat;
	/**
	 * If true, use *real* time when updating the image index.
	 * The movie will update regardless of the slomo settings of the game.
	*/
	bUseRealTime: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSubUV;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUV;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSubUV;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUV;
	static C(Other: UObject): ParticleModuleSubUV;
}

declare class ParticleModuleSubUVMovie extends ParticleModuleSubUV { 
	/**
	 * If true, use the emitter time to look up the frame rate.
	 * If false (default), use the particle relative time.
	*/
	bUseEmitterTime: boolean;
	/**
	 * The frame rate the SubUV images should be 'flipped' thru at.
	*/
	FrameRate: RawDistributionFloat;
	/**
	 * The starting image index for the SubUV (1 = the first frame).
	 * Assumes order of Left->Right, Top->Bottom
	 * If greater than the last frame, it will clamp to the last one.
	 * If 0, then randomly selects a starting frame.
	*/
	StartingFrame: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSubUVMovie;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSubUVMovie;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSubUVMovie;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSubUVMovie;
	static C(Other: UObject): ParticleModuleSubUVMovie;
}

declare class ParticleModuleTrailBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleTrailBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTrailBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleTrailBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTrailBase;
	static C(Other: UObject): ParticleModuleTrailBase;
}

declare type ETrail2SourceMethod = string | symbol;
declare var ETrail2SourceMethod = { PET2SRCM_Default:'PET2SRCM_Default',PET2SRCM_Particle:'PET2SRCM_Particle',PET2SRCM_Actor:'PET2SRCM_Actor', };
declare type EParticleSourceSelectionMethod = string | symbol;
declare var EParticleSourceSelectionMethod = { EPSSM_Random:'EPSSM_Random',EPSSM_Sequential:'EPSSM_Sequential', };
declare class ParticleModuleTrailSource extends ParticleModuleTrailBase { 
	/**
	 * The source method for the trail.
	*/
	SourceMethod: ETrail2SourceMethod;
	/**
	 * The name of the source - either the emitter or Actor.
	*/
	SourceName: string;
	/**
	 * The strength of the tangent from the source point for each Trail.
	*/
	SourceStrength: RawDistributionFloat;
	/**
	 * Whether to lock the source to the life of the particle.
	*/
	bLockSourceStength: boolean;
	/**
	 * SourceOffsetCount
	 * The number of source offsets that can be expected to be found on the instance.
	 * These must be named
	 *         TrailSourceOffset#
	*/
	SourceOffsetCount: number;
	/**
	 * Default offsets from the source(s).
	 * If there are < SourceOffsetCount slots, the grabbing of values will simply wrap.
	*/
	SourceOffsetDefaults: Vector[];
	/**
	 * Particle selection method, when using the SourceMethod of Particle.
	*/
	SelectionMethod: EParticleSourceSelectionMethod;
	/**
	 * Interhit particle rotation - only valid for SourceMethod of PET2SRCM_Particle.
	*/
	bInheritRotation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleTrailSource;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTrailSource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleTrailSource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTrailSource;
	static C(Other: UObject): ParticleModuleTrailSource;
}

declare class ParticleModuleTypeDataAnimTrail extends ParticleModuleTypeDataBase { 
	/**
	 * If true, when the system is deactivated, mark trails as dead.
	 * This means they will still render, but will not have more particles
	 * added to them, even if the system re-activates...
	*/
	bDeadTrailsOnDeactivate: boolean;
	/**
	 * If true, recalculate the previous tangent when a new particle is spawned
	*/
	bEnablePreviousTangentRecalculation: boolean;
	/**
	 * If true, recalculate tangents every frame to allow velocity/acceleration to be applied
	*/
	bTangentRecalculationEveryFrame: boolean;
	/**
	 * The (estimated) covered distance to tile the 2nd UV set at.
	 * If 0.0, a second UV set will not be passed in.
	*/
	TilingDistance: number;
	/**
	 * The distance step size for tessellation.
	 * # Tessellation Points = TruncToInt((Distance Between Spawned Particles) / DistanceTessellationStepSize)). If 0 then there is no distance tessellation.
	*/
	DistanceTessellationStepSize: number;
	/**
	 * The tangent scalar for tessellation.
	 * This is the degree change in the tangent direction [0...180] required to warrant an additional tessellation point. If 0 then there is no tangent tessellation.
	*/
	TangentTessellationStepSize: number;
	/**
	 * The width step size for tessellation.
	 * This is the number of world units change in the width required to warrant an additional tessellation point. If 0 then there is no width tessellation.
	*/
	WidthTessellationStepSize: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleTypeDataAnimTrail;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataAnimTrail;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleTypeDataAnimTrail;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataAnimTrail;
	static C(Other: UObject): ParticleModuleTypeDataAnimTrail;
}

declare type EBeam2Method = string | symbol;
declare var EBeam2Method = { PEB2M_Distance:'PEB2M_Distance',PEB2M_Target:'PEB2M_Target',PEB2M_Branch:'PEB2M_Branch', };
declare type EBeamTaperMethod = string | symbol;
declare var EBeamTaperMethod = { PEBTM_None:'PEBTM_None',PEBTM_Full:'PEBTM_Full',PEBTM_Partial:'PEBTM_Partial', };
declare class ParticleModuleTypeDataBeam2 extends ParticleModuleTypeDataBase { 
	/**
	 * The method with which to form the beam(s). Must be one of the following:
	 *         PEB2M_Distance  - Use the distance property to emit a beam along the X-axis of the emitter.
	 *         PEB2M_Target    - Emit a beam from the source to the supplied target.
	 *         PEB2M_Branch    - Currently unimplemented.
	*/
	BeamMethod: EBeam2Method;
	/**
	 * The number of times to tile the texture along each beam.
	 * Overridden by TextureTilingDistance if it is > 0.0.
	 *     1st UV set only. 2nd UV set does not Tile.
	*/
	TextureTile: number;
	/**
	 * The distance per texture tile.
	 *     1st UV set only. 2nd UV set does not Tile.
	*/
	TextureTileDistance: number;
	/**
	 * The number of sheets to render
	*/
	Sheets: number;
	/**
	 * The number of live beams
	*/
	MaxBeamCount: number;
	/**
	 * The speed at which the beam should move from source to target when firing up.
	 *     '0' indicates instantaneous
	*/
	Speed: number;
	/**
	 * Indicates whether the beam should be interpolated.
	 *     <= 0 --> no
	 *     >  0 --> yes (and is equal to the number of interpolation steps that should be taken.
	*/
	InterpolationPoints: number;
	/**
	 * If true, there will ALWAYS be a beam...
	*/
	bAlwaysOn: boolean;
	/**
	 * The approach to use for determining the Up vector(s) for the beam.
	 * 0 indicates that the Up FVector should be calculated at EVERY point in the beam.
	 * 1 indicates a single Up FVector should be determined at the start of the beam and used at every point.
	 * N indicates an Up FVector should be calculated every N points of the beam and interpolated between them.
	 *     [NOTE: This mode is currently unsupported.]
	*/
	UpVectorStepSize: number;
	/**
	 * The name of the emitter to branch from (if mode is PEB2M_Branch)
	 * MUST BE IN THE SAME PARTICLE SYSTEM!
	*/
	BranchParentName: string;
	/**
	 * The distance along the X-axis to stretch the beam
	 * Distance is only used if BeamMethod is PEB2M_Distance
	*/
	Distance: RawDistributionFloat;
	/**
	 * Tapering mode - one of the following:
	 * PEBTM_None              - No tapering is applied
	 * PEBTM_Full              - Taper the beam relative to source-->target, regardless of current beam length
	 * PEBTM_Partial   - Taper the beam relative to source-->location, 0=source,1=endpoint
	*/
	TaperMethod: EBeamTaperMethod;
	/**
	 * Tapering factor, 0 = source of beam, 1 = target
	*/
	TaperFactor: RawDistributionFloat;
	/**
	 * Tapering scaling
	 *     This is intended to be either a constant, uniform or a ParticleParam.
	 *     If a curve is used, 0/1 mapping of source/target... which could be integrated into
	 *     the taper factor itself, and therefore makes no sense.
	*/
	TaperScale: RawDistributionFloat;
	/**
	 * Beam Rendering Variables.
	*/
	RenderGeometry: boolean;
	/**
	 * Render Direct Line
	*/
	RenderDirectLine: boolean;
	/**
	 * Render Lines
	*/
	RenderLines: boolean;
	/**
	 * Render Tessellation
	*/
	RenderTessellation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleTypeDataBeam2;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataBeam2;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleTypeDataBeam2;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataBeam2;
	static C(Other: UObject): ParticleModuleTypeDataBeam2;
}

declare class GPUSpriteLocalVectorFieldInfo { 
	/**
	 * Local vector field to apply to this emitter.
	*/
	Field: VectorField;
	/**
	 * Local vector field transform.
	*/
	Transform: Transform;
	/**
	 * Minimum initial rotation.
	*/
	MinInitialRotation: Rotator;
	/**
	 * Maximum initial rotation.
	*/
	MaxInitialRotation: Rotator;
	/**
	 * Local vector field rotation rate.
	*/
	RotationRate: Rotator;
	/**
	 * Local vector field intensity.
	*/
	Intensity: number;
	/**
	 * Local vector field tightness.
	*/
	Tightness: number;
	/**
	 * Ignore Components Transform
	*/
	bIgnoreComponentTransform: boolean;
	/**
	 * Tile vector field in x axis?
	*/
	bTileX: boolean;
	/**
	 * Tile vector field in y axis?
	*/
	bTileY: boolean;
	/**
	 * Tile vector field in z axis?
	*/
	bTileZ: boolean;
	/**
	 * Use fix delta time in the simulation?
	*/
	bUseFixDT: boolean;
	clone() : GPUSpriteLocalVectorFieldInfo;
	static C(Other: UObject): GPUSpriteLocalVectorFieldInfo;
}

declare class FloatDistribution { 
	/**
	 * Table
	*/
	Table: DistributionLookupTable;
	clone() : FloatDistribution;
	static C(Other: UObject): FloatDistribution;
}

declare class GPUSpriteEmitterInfo { 
	/**
	 * The required module. Needed for now, but should be divorced from the runtime.
	*/
	RequiredModule: ParticleModuleRequired;
	/**
	 * The spawn module. Needed for now, but should be divorced from the runtime.
	*/
	SpawnModule: ParticleModuleSpawn;
	/**
	 * The spawn-per-unit module.
	*/
	SpawnPerUnitModule: ParticleModuleSpawnPerUnit;
	/**
	 * List of spawn modules that must be evaluated at runtime.
	*/
	SpawnModules: ParticleModule[];
	/**
	 * Local vector field info.
	*/
	LocalVectorField: GPUSpriteLocalVectorFieldInfo;
	/**
	 * Per-particle vector field scale.
	*/
	VectorFieldScale: FloatDistribution;
	/**
	 * Per-particle drag coefficient.
	*/
	DragCoefficient: FloatDistribution;
	/**
	 * Point attractor strength over time.
	*/
	PointAttractorStrength: FloatDistribution;
	/**
	 * Damping factor applied to particle collisions.
	*/
	Resilience: FloatDistribution;
	/**
	 * Constant acceleration to apply to particles.
	*/
	ConstantAcceleration: Vector;
	/**
	 * Point attractor position.
	*/
	PointAttractorPosition: Vector;
	/**
	 * Point attractor radius, squared.
	*/
	PointAttractorRadiusSq: number;
	/**
	 * Amount by which to offset particles when they are spawned.
	*/
	OrbitOffsetBase: Vector;
	/**
	 * Orbit Offset Range
	*/
	OrbitOffsetRange: Vector;
	/**
	 * One over the maximum size of a sprite particle.
	*/
	InvMaxSize: Vector2D;
	/**
	 * The inverse scale to apply to rotation rate.
	*/
	InvRotationRateScale: number;
	/**
	 * The maximum lifetime of particles in this emitter.
	*/
	MaxLifetime: number;
	/**
	 * The maximum number of particles expected for this emitter.
	*/
	MaxParticleCount: number;
	/**
	 * The method for aligning the particle based on the camera.
	*/
	ScreenAlignment: EParticleScreenAlignment;
	/**
	 * The method for locking the particles to a particular axis.
	*/
	LockAxisFlag: EParticleAxisLock;
	/**
	 * If true, collisions are enabled for this emitter.
	*/
	bEnableCollision: boolean;
	/**
	 * Collision Mode
	*/
	CollisionMode: EParticleCollisionMode;
	/**
	 * Dynamic color scale from the ColorOverLife module.
	*/
	DynamicColor: RawDistributionVector;
	/**
	 * Dynamic alpha scale from the ColorOverLife module.
	*/
	DynamicAlpha: RawDistributionFloat;
	/**
	 * Dynamic color scale from the ColorScaleOverLife module.
	*/
	DynamicColorScale: RawDistributionVector;
	/**
	 * Dynamic alpha scale from the ColorScaleOverLife module.
	*/
	DynamicAlphaScale: RawDistributionFloat;
	clone() : GPUSpriteEmitterInfo;
	static C(Other: UObject): GPUSpriteEmitterInfo;
}

declare class GPUSpriteResourceData { 
	/**
	 * Quantized color samples.
	*/
	QuantizedColorSamples: Color[];
	/**
	 * Quantized samples for misc curve attributes to be evaluated at runtime.
	*/
	QuantizedMiscSamples: Color[];
	/**
	 * Quantized samples for simulation attributes.
	*/
	QuantizedSimulationAttrSamples: Color[];
	/**
	 * Scale and bias to be applied to the color of sprites.
	*/
	ColorScale: Vector4;
	/**
	 * Color Bias
	*/
	ColorBias: Vector4;
	/**
	 * Scale and bias to be applied to the misc curve.
	*/
	MiscScale: Vector4;
	/**
	 * Misc Bias
	*/
	MiscBias: Vector4;
	/**
	 * Scale and bias to be applied to the simulation attribute curves.
	*/
	SimulationAttrCurveScale: Vector4;
	/**
	 * Simulation Attr Curve Bias
	*/
	SimulationAttrCurveBias: Vector4;
	/**
	 * Size of subimages. X:SubImageCountH Y:SubImageCountV Z:1/SubImageCountH W:1/SubImageCountV
	*/
	SubImageSize: Vector4;
	/**
	 * SizeBySpeed parameters. XY=SpeedScale ZW=MaxSpeedScale.
	*/
	SizeBySpeed: Vector4;
	/**
	 * Constant acceleration to apply to particles.
	*/
	ConstantAcceleration: Vector;
	/**
	 * Offset at which to orbit.
	*/
	OrbitOffsetBase: Vector;
	/**
	 * Orbit Offset Range
	*/
	OrbitOffsetRange: Vector;
	/**
	 * Frequency at which the particle orbits around each axis.
	*/
	OrbitFrequencyBase: Vector;
	/**
	 * Orbit Frequency Range
	*/
	OrbitFrequencyRange: Vector;
	/**
	 * Phase offset of orbit around each axis.
	*/
	OrbitPhaseBase: Vector;
	/**
	 * Orbit Phase Range
	*/
	OrbitPhaseRange: Vector;
	/**
	 * Scale to apply to global vector fields.
	*/
	GlobalVectorFieldScale: number;
	/**
	 * Tightness override value for the global vector fields.
	*/
	GlobalVectorFieldTightness: number;
	/**
	 * Scale to apply to per-particle vector field scale.
	*/
	PerParticleVectorFieldScale: number;
	/**
	 * Bias to apply to per-particle vector field scale.
	*/
	PerParticleVectorFieldBias: number;
	/**
	 * Scale to apply to per-particle drag coefficient.
	*/
	DragCoefficientScale: number;
	/**
	 * Bias to apply to per-particle drag coefficient.
	*/
	DragCoefficientBias: number;
	/**
	 * Scale to apply to per-particle damping factor.
	*/
	ResilienceScale: number;
	/**
	 * Bias to apply to per-particle damping factor.
	*/
	ResilienceBias: number;
	/**
	 * Scale to apply to per-particle size for collision.
	*/
	CollisionRadiusScale: number;
	/**
	 * Bias to apply to per-particle size for collision.
	*/
	CollisionRadiusBias: number;
	/**
	 * Bias applied to relative time upon collision.
	*/
	CollisionTimeBias: number;
	/**
	 * One minus the coefficient of friction applied to particles upon collision.
	*/
	OneMinusFriction: number;
	/**
	 * Scale to apply to per-particle rotation rate.
	*/
	RotationRateScale: number;
	/**
	 * How much to stretch sprites based on camera motion blur.
	*/
	CameraMotionBlurAmount: number;
	/**
	 * Screen alignment for particles.
	*/
	ScreenAlignment: EParticleScreenAlignment;
	/**
	 * The method for locking the particles to a particular axis.
	*/
	LockAxisFlag: EParticleAxisLock;
	/**
	 * Pivot offset in UV space for placing the verts of each particle.
	*/
	PivotOffset: Vector2D;
	clone() : GPUSpriteResourceData;
	static C(Other: UObject): GPUSpriteResourceData;
}

declare class ParticleModuleTypeDataGpu extends ParticleModuleTypeDataBase { 
	/**
	 * Information for runtime simulation.
	*/
	EmitterInfo: GPUSpriteEmitterInfo;
	/**
	 * Data used to initialize runtime resources.
	*/
	ResourceData: GPUSpriteResourceData;
	/**
	 * TEMP: How much to stretch sprites based on camera motion blur.
	*/
	CameraMotionBlurAmount: number;
	/**
	 * When true, all existing partilces are cleared when the emitter is initialized.
	*/
	bClearExistingParticlesOnInit: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleTypeDataGpu;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataGpu;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleTypeDataGpu;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataGpu;
	static C(Other: UObject): ParticleModuleTypeDataGpu;
}

declare type EMeshScreenAlignment = string | symbol;
declare var EMeshScreenAlignment = { PSMA_MeshFaceCameraWithRoll:'PSMA_MeshFaceCameraWithRoll',PSMA_MeshFaceCameraWithSpin:'PSMA_MeshFaceCameraWithSpin',PSMA_MeshFaceCameraWithLockedAxis:'PSMA_MeshFaceCameraWithLockedAxis', };
declare type EMeshCameraFacingUpAxis = string | symbol;
declare var EMeshCameraFacingUpAxis = { CameraFacing_NoneUP:'CameraFacing_NoneUP',CameraFacing_ZUp:'CameraFacing_ZUp',CameraFacing_NegativeZUp:'CameraFacing_NegativeZUp',CameraFacing_YUp:'CameraFacing_YUp',CameraFacing_NegativeYUp:'CameraFacing_NegativeYUp', };
declare type EMeshCameraFacingOptions = string | symbol;
declare var EMeshCameraFacingOptions = { XAxisFacing_NoUp:'XAxisFacing_NoUp',XAxisFacing_ZUp:'XAxisFacing_ZUp',XAxisFacing_NegativeZUp:'XAxisFacing_NegativeZUp',XAxisFacing_YUp:'XAxisFacing_YUp',XAxisFacing_NegativeYUp:'XAxisFacing_NegativeYUp',LockedAxis_ZAxisFacing:'LockedAxis_ZAxisFacing',LockedAxis_NegativeZAxisFacing:'LockedAxis_NegativeZAxisFacing',LockedAxis_YAxisFacing:'LockedAxis_YAxisFacing',LockedAxis_NegativeYAxisFacing:'LockedAxis_NegativeYAxisFacing',VelocityAligned_ZAxisFacing:'VelocityAligned_ZAxisFacing',VelocityAligned_NegativeZAxisFacing:'VelocityAligned_NegativeZAxisFacing',VelocityAligned_YAxisFacing:'VelocityAligned_YAxisFacing',VelocityAligned_NegativeYAxisFacing:'VelocityAligned_NegativeYAxisFacing', };
declare class ParticleModuleTypeDataMesh extends ParticleModuleTypeDataBase { 
	/**
	 * The static mesh to render at the particle positions
	*/
	Mesh: StaticMesh;
	/**
	 * If true, has the meshes cast shadows
	*/
	CastShadows: boolean;
	/**
	 * UNUSED (the collision module dictates doing collisions)
	*/
	DoCollisions: boolean;
	/**
	 * The alignment to use on the meshes emitted.
	 * The RequiredModule->ScreenAlignment MUST be set to PSA_TypeSpecific to use.
	 * One of the following:
	 * PSMA_MeshFaceCameraWithRoll
	 *         Face the camera allowing for rotation around the mesh-to-camera FVector
	 *         (amount provided by the standard particle sprite rotation).
	 * PSMA_MeshFaceCameraWithSpin
	 *         Face the camera allowing for the mesh to rotate about the tangential axis.
	 * PSMA_MeshFaceCameraWithLockedAxis
	 *         Face the camera while maintaining the up FVector as the locked direction.
	*/
	MeshAlignment: EMeshScreenAlignment;
	/**
	 * If true, use the emitter material when rendering rather than the one applied
	 * to the static mesh model.
	*/
	bOverrideMaterial: boolean;
	/**
	 * Override Default Motion Blur Settings
	*/
	bOverrideDefaultMotionBlurSettings: boolean;
	/**
	 * Enable Motion Blur
	*/
	bEnableMotionBlur: boolean;
	/**
	 * deprecated properties for initial orientation
	*/
	Pitch: number;
	/**
	 * Roll
	*/
	Roll: number;
	/**
	 * Yaw
	*/
	Yaw: number;
	/**
	 * The 'pre' rotation pitch (in degrees) to apply to the static mesh used.
	*/
	RollPitchYawRange: RawDistributionVector;
	/**
	 * The axis to lock the mesh on. This overrides TypeSpecific mesh alignment as well as the LockAxis module.
	 *         EPAL_NONE                -      No locking to an axis.
	 *         EPAL_X                   -      Lock the mesh X-axis facing towards +X.
	 *         EPAL_Y                   -      Lock the mesh X-axis facing towards +Y.
	 *         EPAL_Z                   -      Lock the mesh X-axis facing towards +Z.
	 *         EPAL_NEGATIVE_X  -      Lock the mesh X-axis facing towards -X.
	 *         EPAL_NEGATIVE_Y  -      Lock the mesh X-axis facing towards -Y.
	 *         EPAL_NEGATIVE_Z  -      Lock the mesh X-axis facing towards -Z.
	 *         EPAL_ROTATE_X    -      Ignored for mesh emitters. Treated as EPAL_NONE.
	 *         EPAL_ROTATE_Y    -      Ignored for mesh emitters. Treated as EPAL_NONE.
	 *         EPAL_ROTATE_Z    -      Ignored for mesh emitters. Treated as EPAL_NONE.
	*/
	AxisLockOption: EParticleAxisLock;
	/**
	 * If true, then point the X-axis of the mesh towards the camera.
	 * When set, AxisLockOption as well as all other locked axis/screen alignment settings are ignored.
	*/
	bCameraFacing: boolean;
	/**
	 * The axis of the mesh to point up when camera facing the X-axis.
	 *         CameraFacing_NoneUP                     No attempt to face an axis up or down.
	 *         CameraFacing_ZUp                        Z-axis of the mesh should attempt to point up.
	 *         CameraFacing_NegativeZUp        Z-axis of the mesh should attempt to point down.
	 *         CameraFacing_YUp                        Y-axis of the mesh should attempt to point up.
	 *         CameraFacing_NegativeYUp        Y-axis of the mesh should attempt to point down.
	*/
	CameraFacingUpAxisOption: EMeshCameraFacingUpAxis;
	/**
	 * The camera facing option to use:
	 * All camera facing options without locked axis assume X-axis will be facing the camera.
	 *         XAxisFacing_NoUp                                - X-axis camera facing, no attempt to face an axis up or down.
	 *         XAxisFacing_ZUp                                 - X-axis camera facing, Z-axis of the mesh should attempt to point up.
	 *         XAxisFacing_NegativeZUp                 - X-axis camera facing, Z-axis of the mesh should attempt to point down.
	 *         XAxisFacing_YUp                                 - X-axis camera facing, Y-axis of the mesh should attempt to point up.
	 *         XAxisFacing_NegativeYUp                 - X-axis camera facing, Y-axis of the mesh should attempt to point down.
	 * All axis-locked camera facing options assume the AxisLockOption is set. EPAL_NONE will be treated as EPAL_X.
	 *         LockedAxis_ZAxisFacing                  - X-axis locked on AxisLockOption axis, rotate Z-axis of the mesh to face towards camera.
	 *         LockedAxis_NegativeZAxisFacing  - X-axis locked on AxisLockOption axis, rotate Z-axis of the mesh to face away from camera.
	 *         LockedAxis_YAxisFacing                  - X-axis locked on AxisLockOption axis, rotate Y-axis of the mesh to face towards camera.
	 *         LockedAxis_NegativeYAxisFacing  - X-axis locked on AxisLockOption axis, rotate Y-axis of the mesh to face away from camera.
	 * All velocity-aligned options do NOT require the ScreenAlignment be set to PSA_Velocity.
	 * Doing so will result in additional work being performed... (it will orient the mesh twice).
	 *         VelocityAligned_ZAxisFacing         - X-axis aligned to the velocity, rotate the Z-axis of the mesh to face towards camera.
	 *         VelocityAligned_NegativeZAxisFacing - X-axis aligned to the velocity, rotate the Z-axis of the mesh to face away from camera.
	 *         VelocityAligned_YAxisFacing         - X-axis aligned to the velocity, rotate the Y-axis of the mesh to face towards camera.
	 *         VelocityAligned_NegativeYAxisFacing - X-axis aligned to the velocity, rotate the Y-axis of the mesh to face away from camera.
	*/
	CameraFacingOption: EMeshCameraFacingOptions;
	/**
	 * If true, apply 'sprite' particle rotation about the orientation axis (direction mesh is pointing).
	 * If false, apply 'sprite' particle rotation about the camera facing axis.
	*/
	bApplyParticleRotationAsSpin: boolean;
	/**
	 * If true, all camera facing options will point the mesh against the camera's view direction rather than pointing at the cameras location.
	 * If false, the camera facing will point to the cameras position as normal.
	*/
	bFaceCameraDirectionRatherThanPosition: boolean;
	/**
	 * If true, all collisions for mesh particle on this emitter will take the particle size into account.
	 * If false, particle size will be ignored in collision checks.
	*/
	bCollisionsConsiderPartilceSize: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleTypeDataMesh;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleTypeDataMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataMesh;
	static C(Other: UObject): ParticleModuleTypeDataMesh;
}

declare type ETrailsRenderAxisOption = string | symbol;
declare var ETrailsRenderAxisOption = { Trails_CameraUp:'Trails_CameraUp',Trails_SourceUp:'Trails_SourceUp',Trails_WorldUp:'Trails_WorldUp', };
declare class ParticleModuleTypeDataRibbon extends ParticleModuleTypeDataBase { 
	/**
	 * The maximum amount to tessellate between two particles of the trail.
	 * Depending on the distance between the particles and the tangent change, the
	 * system will select a number of tessellation points
	 *         [0..MaxTessellationBetweenParticles]
	*/
	MaxTessellationBetweenParticles: number;
	/**
	 * The number of sheets to render for the trail.
	*/
	SheetsPerTrail: number;
	/**
	 * The number of live trails
	*/
	MaxTrailCount: number;
	/**
	 * Max particles per trail
	*/
	MaxParticleInTrailCount: number;
	/**
	 * If true, when the system is deactivated, mark trails as dead.
	 * This means they will still render, but will not have more particles
	 * added to them, even if the system re-activates...
	*/
	bDeadTrailsOnDeactivate: boolean;
	/**
	 * If true, when the source of a trail is 'lost' (ie, the source particle
	 * dies), mark the current trail as dead.
	*/
	bDeadTrailsOnSourceLoss: boolean;
	/**
	 * If true, do not join the trail to the source position
	*/
	bClipSourceSegement: boolean;
	/**
	 * If true, recalculate the previous tangent when a new particle is spawned
	*/
	bEnablePreviousTangentRecalculation: boolean;
	/**
	 * If true, recalculate tangents every frame to allow velocity/acceleration to be applied
	*/
	bTangentRecalculationEveryFrame: boolean;
	/**
	 * If true, ribbon will spawn a particle when it first starts moving
	*/
	bSpawnInitialParticle: boolean;
	/**
	 * The 'render' axis for the trail (what axis the trail is stretched out on)
	 *         Trails_CameraUp - Traditional camera-facing trail.
	 *         Trails_SourceUp - Use the up axis of the source for each spawned particle.
	 *         Trails_WorldUp  - Use the world up axis.
	*/
	RenderAxis: ETrailsRenderAxisOption;
	/**
	 * The tangent scalar for spawning.
	 * Angles between tangent A and B are mapped to [0.0f .. 1.0f]
	 * This is then multiplied by TangentTessellationScalar to give the number of particles to spawn
	*/
	TangentSpawningScalar: number;
	/**
	 * If true, render the trail geometry (this should typically be on)
	*/
	bRenderGeometry: boolean;
	/**
	 * If true, render stars at each spawned particle point along the trail
	*/
	bRenderSpawnPoints: boolean;
	/**
	 * If true, render a line showing the tangent at each spawned particle point along the trail
	*/
	bRenderTangents: boolean;
	/**
	 * If true, render the tessellated path between spawned particles
	*/
	bRenderTessellation: boolean;
	/**
	 * The (estimated) covered distance to tile the 2nd UV set at.
	 * If 0.0, a second UV set will not be passed in.
	*/
	TilingDistance: number;
	/**
	 * The distance step size for tessellation.
	 * # Tessellation Points = TruncToInt((Distance Between Spawned Particles) / DistanceTessellationStepSize))
	*/
	DistanceTessellationStepSize: number;
	/**
	 * If this flag is enabled, the system will scale the number of interpolated vertices
	 * based on the difference in the tangents of neighboring particles.
	 * Each pair of neighboring particles will compute the following CheckTangent value:
	 *         CheckTangent = ((ParticleA Tangent DOT ParticleB Tangent) - 1.0f) * 0.5f
	 * If CheckTangent is LESS THAN 0.5, then the DistanceTessellationStepSize will be
	 * scaled based on the result. This will map so that from parallel to orthogonal
	 * (0..90 degrees) will scale from [0..1]. Anything greater than 90 degrees will clamp
	 * at a scale of 1.
	*/
	bEnableTangentDiffInterpScale: boolean;
	/**
	 * The tangent scalar for tessellation.
	 * Angles between tangent A and B are mapped to [0.0f .. 1.0f]
	 * This is then multiplied by TangentTessellationScalar to give the number of points to tessellate
	*/
	TangentTessellationScalar: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleTypeDataRibbon;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataRibbon;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleTypeDataRibbon;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataRibbon;
	static C(Other: UObject): ParticleModuleTypeDataRibbon;
}

declare class ParticleModuleVectorFieldBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVectorFieldBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVectorFieldBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldBase;
	static C(Other: UObject): ParticleModuleVectorFieldBase;
}

declare class ParticleModuleVectorFieldGlobal extends ParticleModuleVectorFieldBase { 
	/**
	 * Property override value for global vector field tightness.
	*/
	bOverrideGlobalVectorFieldTightness: boolean;
	/**
	 * Global vector field scale.
	*/
	GlobalVectorFieldScale: number;
	/**
	 * Global vector field tightness override.
	*/
	GlobalVectorFieldTightness: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVectorFieldGlobal;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldGlobal;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVectorFieldGlobal;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldGlobal;
	static C(Other: UObject): ParticleModuleVectorFieldGlobal;
}

declare class ParticleModuleVectorFieldLocal extends ParticleModuleVectorFieldBase { 
	/**
	 * Vector field asset to use.
	*/
	VectorField: VectorField;
	/**
	 * Translation of the vector field relative to the emitter.
	*/
	RelativeTranslation: Vector;
	/**
	 * Rotation of the vector field relative to the emitter.
	*/
	RelativeRotation: Rotator;
	/**
	 * Scale of the vector field relative to the emitter.
	*/
	RelativeScale3D: Vector;
	/**
	 * Intensity of the local vector field.
	*/
	Intensity: number;
	/**
	 * Tightness tweak value: 0: Force 1: Velocity.
	*/
	Tightness: number;
	/**
	 * Ignore component transform.
	*/
	bIgnoreComponentTransform: boolean;
	/**
	 * Tile vector field in x axis?
	*/
	bTileX: boolean;
	/**
	 * Tile vector field in y axis?
	*/
	bTileY: boolean;
	/**
	 * Tile vector field in z axis?
	*/
	bTileZ: boolean;
	/**
	 * Use fix delta time in the simulation?
	*/
	bUseFixDT: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVectorFieldLocal;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldLocal;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVectorFieldLocal;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldLocal;
	static C(Other: UObject): ParticleModuleVectorFieldLocal;
}

declare class ParticleModuleVectorFieldRotation extends ParticleModuleVectorFieldBase { 
	/**
	 * Minimum initial rotation applied to the local vector field.
	*/
	MinInitialRotation: Vector;
	/**
	 * Maximum initial rotation applied to the local vector field.
	*/
	MaxInitialRotation: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVectorFieldRotation;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldRotation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVectorFieldRotation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldRotation;
	static C(Other: UObject): ParticleModuleVectorFieldRotation;
}

declare class ParticleModuleVectorFieldRotationRate extends ParticleModuleVectorFieldBase { 
	/**
	 * Constant rotation rate applied to the local vector field.
	*/
	RotationRate: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVectorFieldRotationRate;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldRotationRate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVectorFieldRotationRate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldRotationRate;
	static C(Other: UObject): ParticleModuleVectorFieldRotationRate;
}

declare class ParticleModuleVectorFieldScale extends ParticleModuleVectorFieldBase { 
	/**
	 * Per-particle vector field scale. Evaluated using emitter time.
	*/
	VectorFieldScale: DistributionFloat;
	/**
	 * Per-particle vector field scale. Evaluated using emitter time.
	*/
	VectorFieldScaleRaw: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVectorFieldScale;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldScale;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVectorFieldScale;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldScale;
	static C(Other: UObject): ParticleModuleVectorFieldScale;
}

declare class ParticleModuleVectorFieldScaleOverLife extends ParticleModuleVectorFieldBase { 
	/**
	 * Per-particle vector field scale. Evaluated using particle relative time.
	*/
	VectorFieldScaleOverLife: DistributionFloat;
	/**
	 * Per-particle vector field scale. Evaluated using particle relative time.
	*/
	VectorFieldScaleOverLifeRaw: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVectorFieldScaleOverLife;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVectorFieldScaleOverLife;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVectorFieldScaleOverLife;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVectorFieldScaleOverLife;
	static C(Other: UObject): ParticleModuleVectorFieldScaleOverLife;
}

declare class ParticleModuleVelocityBase extends ParticleModule { 
	/**
	 * If true, then treat the velocity as world-space defined.
	 * NOTE: LocalSpace emitters that are moving will see strange results...
	*/
	bInWorldSpace: boolean;
	/**
	 * If true, then apply the particle system components scale to the velocity value.
	*/
	bApplyOwnerScale: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVelocityBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVelocityBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityBase;
	static C(Other: UObject): ParticleModuleVelocityBase;
}

declare class ParticleModuleVelocity extends ParticleModuleVelocityBase { 
	/**
	 * The velocity to apply to a particle when it is spawned.
	 * Value is retrieved using the EmitterTime of the emitter.
	*/
	StartVelocity: RawDistributionVector;
	/**
	 * The velocity to apply to a particle along its radial direction.
	 * Direction is determined by subtracting the location of the emitter from the particle location at spawn.
	 * Value is retrieved using the EmitterTime of the emitter.
	*/
	StartVelocityRadial: RawDistributionFloat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVelocity;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocity;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVelocity;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocity;
	static C(Other: UObject): ParticleModuleVelocity;
}

declare class ParticleModuleVelocity_Seeded extends ParticleModuleVelocity { 
	/**
	 * The random seed(s) to use for looking up values in StartLocation
	*/
	RandomSeedInfo: ParticleRandomSeedInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVelocity_Seeded;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocity_Seeded;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVelocity_Seeded;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocity_Seeded;
	static C(Other: UObject): ParticleModuleVelocity_Seeded;
}

declare class ParticleModuleVelocityCone extends ParticleModuleVelocityBase { 
	/**
	 * The Min value represents the inner cone angle value and the Max value represents the outer cone angle value.
	*/
	Angle: RawDistributionFloat;
	/**
	 * The initial velocity of the particles.
	*/
	Velocity: RawDistributionFloat;
	/**
	 * The direction FVector of the cone.
	*/
	Direction: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVelocityCone;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityCone;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVelocityCone;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityCone;
	static C(Other: UObject): ParticleModuleVelocityCone;
}

declare class ParticleModuleVelocityInheritParent extends ParticleModuleVelocityBase { 
	/**
	 * The scale to apply tot he parent velocity prior to adding it to the particle velocity during spawn.
	 * Value is retrieved using the EmitterTime of the emitter.
	*/
	Scale: RawDistributionVector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVelocityInheritParent;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityInheritParent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVelocityInheritParent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityInheritParent;
	static C(Other: UObject): ParticleModuleVelocityInheritParent;
}

declare class ParticleModuleVelocityOverLifetime extends ParticleModuleVelocityBase { 
	/**
	 * The scaling  value applied to the velocity.
	 * Value is retrieved using the RelativeTime of the particle.
	*/
	VelOverLife: RawDistributionVector;
	/**
	 * If true, the velocity will be SET to the value from the above dist.
	 * If false, the velocity will be scaled by the above dist.
	*/
	Absolute: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleVelocityOverLifetime;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleVelocityOverLifetime;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleVelocityOverLifetime;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleVelocityOverLifetime;
	static C(Other: UObject): ParticleModuleVelocityOverLifetime;
}

declare class DemoPendingNetGame extends PendingNetGame { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DemoPendingNetGame;
	static Find(Outer: UObject, ResourceName: string): DemoPendingNetGame;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DemoPendingNetGame;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DemoPendingNetGame;
	static C(Other: UObject): DemoPendingNetGame;
}

declare type EPlatformInterfaceDataType = string | symbol;
declare var EPlatformInterfaceDataType = { PIDT_None:'PIDT_None',PIDT_Int:'PIDT_Int',PIDT_Float:'PIDT_Float',PIDT_String:'PIDT_String',PIDT_Object:'PIDT_Object',PIDT_Custom:'PIDT_Custom', };
declare class PlatformInterfaceData { 
	/**
	 * An optional tag for this data
	*/
	DataName: string;
	/**
	 * Specifies which value is valid for this structure
	*/
	Type: EPlatformInterfaceDataType;
	/**
	 * Various typed result values
	*/
	IntValue: number;
	/**
	 * Float Value
	*/
	FloatValue: number;
	/**
	 * String Value
	*/
	StringValue: string;
	/**
	 * Object Value
	*/
	ObjectValue: UObject;
	clone() : PlatformInterfaceData;
	static C(Other: UObject): PlatformInterfaceData;
}

declare class PlatformInterfaceDelegateResult { 
	/**
	 * This is always usable, no matter the type
	*/
	bSuccessful: boolean;
	/**
	 * The result actual data
	*/
	Data: PlatformInterfaceData;
	clone() : PlatformInterfaceDelegateResult;
	static C(Other: UObject): PlatformInterfaceDelegateResult;
}

declare class DelegateArray { 
	/**
	 * Delegates
	*/
	Delegates: UnrealEngineDelegate<(Result: PlatformInterfaceDelegateResult) => void>[];
	clone() : DelegateArray;
	static C(Other: UObject): DelegateArray;
}

declare class PlatformInterfaceBase extends UObject { 
	/**
	 * Array of delegate arrays. Only add and remove via helper functions, and call via the helper delegate call function
	*/
	AllDelegates: DelegateArray[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PlatformInterfaceBase;
	static Find(Outer: UObject, ResourceName: string): PlatformInterfaceBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlatformInterfaceBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformInterfaceBase;
	static C(Other: UObject): PlatformInterfaceBase;
}

declare class CloudStorageBase extends PlatformInterfaceBase { 
	/**
	 * When using local storage (aka "cloud emulation"), this maintains a list of the file paths.
	*/
	LocalCloudFiles: string[];
	/**
	 * If true, delegate callbacks should be skipped.
	*/
	bSuppressDelegateCalls: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CloudStorageBase;
	static Find(Outer: UObject, ResourceName: string): CloudStorageBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CloudStorageBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CloudStorageBase;
	static C(Other: UObject): CloudStorageBase;
}

declare class InGameAdManager extends PlatformInterfaceBase { 
	/**
	 * If true, the game will pause when the user clicks on the ad, which could take over the screen
	*/
	bShouldPauseWhileAdOpen: boolean;
	/**
	 * @todo document
	*/
	ClickedBannerDelegates: UnrealEngineDelegate<() => void>[];
	/**
	 * @todo document
	*/
	ClosedAdDelegates: UnrealEngineDelegate<() => void>[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InGameAdManager;
	static Find(Outer: UObject, ResourceName: string): InGameAdManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InGameAdManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InGameAdManager;
	static C(Other: UObject): InGameAdManager;
}

declare class PurchaseInfo { 
	/**
	 * Unique identifier for the purchase
	*/
	Identifier: string;
	/**
	 * Name displayable to the user
	*/
	DisplayName: string;
	/**
	 * Description displayable to the user
	*/
	DisplayDescription: string;
	/**
	 * Price displayable to the user
	*/
	DisplayPrice: string;
	clone() : PurchaseInfo;
	static C(Other: UObject): PurchaseInfo;
}

declare class MicroTransactionBase extends PlatformInterfaceBase { 
	/**
	 * The list of products available to purchase, filled out by the time a MTD_PurchaseQueryComplete is fired
	*/
	AvailableProducts: PurchaseInfo[];
	/**
	 * In case of errors, this will describe the most recent error
	*/
	LastError: string;
	/**
	 * In case of errors, this will describe possible solutions (if there are any)
	*/
	LastErrorSolution: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MicroTransactionBase;
	static Find(Outer: UObject, ResourceName: string): MicroTransactionBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MicroTransactionBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MicroTransactionBase;
	static C(Other: UObject): MicroTransactionBase;
}

declare type ETwitterRequestMethod = string | symbol;
declare var ETwitterRequestMethod = { TRM_Get:'TRM_Get',TRM_Post:'TRM_Post',TRM_Delete:'TRM_Delete', };
declare class TwitterIntegrationBase extends PlatformInterfaceBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TwitterIntegrationBase;
	static Find(Outer: UObject, ResourceName: string): TwitterIntegrationBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TwitterIntegrationBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TwitterIntegrationBase;
	/**
	 * Kicks off a generic twitter request
	 * @param URL The URL for the twitter request
	 * @param KeysAndValues The extra parameters to pass to the request (request specific). Separate keys and values: < "key1", "value1", "key2", "value2" >
	 * @param Method The method for this request (get, post, delete)
	 * @param AccountIndex A user index if an account is needed, or -1 if an account isn't needed for the request
	 * @return true the request was sent off, and a TID_RequestComplete
	*/
	TwitterRequest(URL: string,ParamKeysAndValues: string[],RequestMethod: ETwitterRequestMethod,AccountIndex: number): boolean;
	/**
	 * Kicks off a tweet, using the platform to show the UI. If this returns false, or you are on a platform that doesn't support the UI,
	 * you can use the TwitterRequest method to perform a manual tweet using the Twitter API
	 * @param InitialMessage [optional] Initial message to show
	 * @param URL [optional] URL to attach to the tweet
	 * @param Picture [optional] Name of a picture (stored locally, platform subclass will do the searching for it) to add to the tweet
	 * @return true if a UI was displayed for the user to interact with, and a TID_TweetUIComplete will be sent
	*/
	ShowTweetUI(InitialMessage: string,URL: string,Picture: string): boolean;
	/**
	 * Perform any needed initialization
	*/
	Init(): void;
	/**
	 * @return The number of accounts that were authorized
	*/
	GetNumAccounts(): number;
	/**
	 * @return the display name of the given Twitter account
	*/
	GetAccountName(AccountIndex: number): string;
	/**
	 * @return true if the user is allowed to use the Tweet UI
	*/
	CanShowTweetUI(): boolean;
	/**
	 * Starts the process of authorizing the local user(s). When TID_AuthorizeComplete is called, then GetNumAccounts()
	 * will return a valid number of accounts
	 * @return true if the authorization process started, and TID_AuthorizeComplete delegates will be called
	*/
	AuthorizeAccounts(): boolean;
	static C(Other: UObject): TwitterIntegrationBase;
}

declare class PlatformInterfaceWebResponse extends UObject { 
	/**
	 * This holds the original requested URL
	*/
	OriginalURL: string;
	/**
	 * Result code from the response (200=OK, 404=Not Found, etc)
	*/
	ResponseCode: number;
	/**
	 * A user-specified tag specified with the request
	*/
	Tag: number;
	/**
	 * For string results, this is the response
	*/
	StringResponse: string;
	/**
	 * For non-string results, this is the response
	*/
	BinaryResponse: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PlatformInterfaceWebResponse;
	static Find(Outer: UObject, ResourceName: string): PlatformInterfaceWebResponse;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlatformInterfaceWebResponse;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformInterfaceWebResponse;
	/**
	 * @return the number of header/value pairs
	*/
	GetNumHeaders(): number;
	/**
	 * @return the value for the given header (or "" if no matching header)
	*/
	GetHeaderValue(HeaderName: string): string;
	/**
	 * Retrieve the header and value for the given index of header/value pair
	*/
	GetHeader(HeaderIndex: number,Header?: string,Value?: string): {Header: string, Value: string};
	static C(Other: UObject): PlatformInterfaceWebResponse;
}

declare class Polys extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Polys;
	static Find(Outer: UObject, ResourceName: string): Polys;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Polys;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Polys;
	static C(Other: UObject): Polys;
}

declare class SkeletalMeshLODGroupSettings { 
	/**
	 * The screen sizes to use for the respective LOD level
	*/
	ScreenSize: number;
	/**
	 * The optimization settings to use for the respective LOD level
	*/
	OptimizationSettings: SkeletalMeshOptimizationSettings;
	clone() : SkeletalMeshLODGroupSettings;
	static C(Other: UObject): SkeletalMeshLODGroupSettings;
}

declare class SkeletalMeshReductionSettings extends UObject { 
	/**
	 * Settings
	*/
	Settings: SkeletalMeshLODGroupSettings[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMeshReductionSettings;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshReductionSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMeshReductionSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshReductionSettings;
	static C(Other: UObject): SkeletalMeshReductionSettings;
}

declare class SlateTextureAtlasInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateTextureAtlasInterface;
	static Find(Outer: UObject, ResourceName: string): SlateTextureAtlasInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateTextureAtlasInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateTextureAtlasInterface;
	static C(Other: UObject): SlateTextureAtlasInterface;
}

declare class SoundWaveProcedural extends SoundWave { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundWaveProcedural;
	static Find(Outer: UObject, ResourceName: string): SoundWaveProcedural;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundWaveProcedural;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWaveProcedural;
	static C(Other: UObject): SoundWaveProcedural;
}

declare class SoundNodeAssetReferencer extends SoundNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeAssetReferencer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeAssetReferencer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeAssetReferencer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeAssetReferencer;
	static C(Other: UObject): SoundNodeAssetReferencer;
}

declare class SoundNodeWavePlayer extends SoundNodeAssetReferencer { 
	/**
	 * Sound Wave Asset Ptr
	*/
	SoundWaveAssetPtr: any;
	/**
	 * Sound Wave
	*/
	SoundWave: SoundWave;
	/**
	 * Looping
	*/
	bLooping: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeWavePlayer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeWavePlayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeWavePlayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeWavePlayer;
	static C(Other: UObject): SoundNodeWavePlayer;
}

declare class SoundNodeAttenuation extends SoundNode { 
	/**
	 * Attenuation Settings
	*/
	AttenuationSettings: SoundAttenuation;
	/**
	 * Attenuation Overrides
	*/
	AttenuationOverrides: AttenuationSettings;
	/**
	 * Override Attenuation
	*/
	bOverrideAttenuation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeAttenuation;
	static Find(Outer: UObject, ResourceName: string): SoundNodeAttenuation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeAttenuation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeAttenuation;
	static C(Other: UObject): SoundNodeAttenuation;
}

declare class SoundNodeBranch extends SoundNode { 
	/**
	 * The name of the boolean parameter to use to determine which branch we should take
	*/
	BoolParameterName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeBranch;
	static Find(Outer: UObject, ResourceName: string): SoundNodeBranch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeBranch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeBranch;
	static C(Other: UObject): SoundNodeBranch;
}

declare class SoundNodeConcatenator extends SoundNode { 
	/**
	 * Volume multiplier for each input.
	*/
	InputVolume: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeConcatenator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeConcatenator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeConcatenator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeConcatenator;
	static C(Other: UObject): SoundNodeConcatenator;
}

declare class SoundNodeDelay extends SoundNode { 
	/**
	 * The lower bound of delay time in seconds.
	*/
	DelayMin: number;
	/**
	 * The upper bound of delay time in seconds.
	*/
	DelayMax: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeDelay;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDelay;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeDelay;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDelay;
	static C(Other: UObject): SoundNodeDelay;
}

declare class DialogueWaveParameter { 
	/**
	 * The dialogue wave to play.
	*/
	DialogueWave: DialogueWave;
	/**
	 * The context to use for the dialogue wave.
	*/
	Context: DialogueContext;
	clone() : DialogueWaveParameter;
	static C(Other: UObject): DialogueWaveParameter;
}

declare class SoundNodeDialoguePlayer extends SoundNode { 
	/**
	 * Dialogue Wave Parameter
	*/
	DialogueWaveParameter: DialogueWaveParameter;
	/**
	 * Whether the dialogue line should be played looping
	*/
	bLooping: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeDialoguePlayer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDialoguePlayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeDialoguePlayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDialoguePlayer;
	static C(Other: UObject): SoundNodeDialoguePlayer;
}

declare class DistanceDatum { 
	/**
	 * The FadeInDistance at which to start hearing this sound.
	 *        * If you want to hear the sound up close then setting this to 0 might be a good option.
	*/
	FadeInDistanceStart: number;
	/**
	 * The distance at which this sound has faded in completely.
	*/
	FadeInDistanceEnd: number;
	/**
	 * The distance at which this sound starts fading out.
	*/
	FadeOutDistanceStart: number;
	/**
	 * The distance at which this sound is no longer audible.
	*/
	FadeOutDistanceEnd: number;
	/**
	 * The volume for which this Input should be played.
	*/
	Volume: number;
	clone() : DistanceDatum;
	static C(Other: UObject): DistanceDatum;
}

declare class SoundNodeDistanceCrossFade extends SoundNode { 
	/**
	 * Each input needs to have the correct data filled in so the SoundNodeDistanceCrossFade is able
	 * to determine which sounds to play
	*/
	CrossFadeInput: DistanceDatum[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeDistanceCrossFade;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDistanceCrossFade;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeDistanceCrossFade;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDistanceCrossFade;
	static C(Other: UObject): SoundNodeDistanceCrossFade;
}

declare class SoundNodeParamCrossFade extends SoundNodeDistanceCrossFade { 
	/**
	 * Parameter controlling cross fades.
	*/
	ParamName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeParamCrossFade;
	static Find(Outer: UObject, ResourceName: string): SoundNodeParamCrossFade;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeParamCrossFade;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeParamCrossFade;
	static C(Other: UObject): SoundNodeParamCrossFade;
}

declare class SoundNodeDoppler extends SoundNode { 
	/**
	 * How much to scale the doppler shift (1.0 is normal).
	*/
	DopplerIntensity: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeDoppler;
	static Find(Outer: UObject, ResourceName: string): SoundNodeDoppler;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeDoppler;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeDoppler;
	static C(Other: UObject): SoundNodeDoppler;
}

declare class SoundNodeEnveloper extends SoundNode { 
	/**
	 * The time in seconds where the envelope's loop begins.
	*/
	LoopStart: number;
	/**
	 * The time in seconds where the envelope's loop ends.
	*/
	LoopEnd: number;
	/**
	 * The time in seconds it takes the evelope to fade out after the last loop is completed.
	*/
	DurationAfterLoop: number;
	/**
	 * The number of times the envelope should loop if looping is enabled and the envelope is not set to loop indefinitely.
	*/
	LoopCount: number;
	/**
	 * If enabled, the envelope will continue to loop indefenitely regardless of the Loop Count value.
	*/
	bLoopIndefinitely: boolean;
	/**
	 * If enabled, the envelope will loop using the loop settings.
	*/
	bLoop: boolean;
	/**
	 * Volume Interp Curve
	*/
	VolumeInterpCurve: DistributionFloatConstantCurve;
	/**
	 * Pitch Interp Curve
	*/
	PitchInterpCurve: DistributionFloatConstantCurve;
	/**
	 * The distribution defining the volume envelope.
	*/
	VolumeCurve: RuntimeFloatCurve;
	/**
	 * The distribution defining the pitch envelope.
	*/
	PitchCurve: RuntimeFloatCurve;
	/**
	 * The lower bound of pitch (1.0 is no change)
	*/
	PitchMin: number;
	/**
	 * The upper bound of pitch (1.0 is no change)
	*/
	PitchMax: number;
	/**
	 * The lower bound of volume (1.0 is no change)
	*/
	VolumeMin: number;
	/**
	 * The upper bound of volume (1.0 is no change)
	*/
	VolumeMax: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeEnveloper;
	static Find(Outer: UObject, ResourceName: string): SoundNodeEnveloper;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeEnveloper;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeEnveloper;
	static C(Other: UObject): SoundNodeEnveloper;
}

declare class SoundNodeGroupControl extends SoundNode { 
	/**
	 * How many active sounds are allowed for each group
	*/
	GroupSizes: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeGroupControl;
	static Find(Outer: UObject, ResourceName: string): SoundNodeGroupControl;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeGroupControl;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeGroupControl;
	static C(Other: UObject): SoundNodeGroupControl;
}

declare class SoundNodeLooping extends SoundNode { 
	/**
	 * The amount of times to loop
	*/
	LoopCount: number;
	/**
	 * If enabled, the node will continue to loop indefinitely regardless of the Loop Count value.
	*/
	bLoopIndefinitely: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeLooping;
	static Find(Outer: UObject, ResourceName: string): SoundNodeLooping;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeLooping;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeLooping;
	static C(Other: UObject): SoundNodeLooping;
}

declare class SoundNodeMature extends SoundNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeMature;
	static Find(Outer: UObject, ResourceName: string): SoundNodeMature;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeMature;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeMature;
	static C(Other: UObject): SoundNodeMature;
}

declare class SoundNodeMixer extends SoundNode { 
	/**
	 * A volume for each input.  Automatically sized.
	*/
	InputVolume: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeMixer;
	static Find(Outer: UObject, ResourceName: string): SoundNodeMixer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeMixer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeMixer;
	static C(Other: UObject): SoundNodeMixer;
}

declare class SoundNodeModulator extends SoundNode { 
	/**
	 * The lower bound of pitch (1.0 is no change).
	*/
	PitchMin: number;
	/**
	 * The upper bound of pitch (1.0 is no change).
	*/
	PitchMax: number;
	/**
	 * The lower bound of volume (1.0 is no change).
	*/
	VolumeMin: number;
	/**
	 * The upper bound of volume (1.0 is no change).
	*/
	VolumeMax: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeModulator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeModulator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeModulator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeModulator;
	static C(Other: UObject): SoundNodeModulator;
}

declare type ModulationParamMode = string | symbol;
declare var ModulationParamMode = { MPM_Normal:'MPM_Normal',MPM_Abs:'MPM_Abs',MPM_Direct:'MPM_Direct', };
declare class ModulatorContinuousParams { 
	/**
	 * The name of the sound instance parameter that specifies the current value.
	*/
	ParameterName: string;
	/**
	 * The default value to be used if the parameter is not found.
	*/
	Default: number;
	/**
	 * The minimum input value. Values will be clamped to the [MinInput, MaxInput] range.
	*/
	MinInput: number;
	/**
	 * The maximum input value. Values will be clamped to the [MinInput, MaxInput] range.
	*/
	MaxInput: number;
	/**
	 * The minimum output value. The input value will be scaled from the range [MinInput, MaxInput] to [MinOut, MaxOutput]
	*/
	MinOutput: number;
	/**
	 * The maximum output value. The input value will be scaled from the range [MinInput, MaxInput] to [MinOut, MaxOutput]
	*/
	MaxOutput: number;
	/**
	 * The mode with which to treat the input value
	*/
	ParamMode: ModulationParamMode;
	clone() : ModulatorContinuousParams;
	static C(Other: UObject): ModulatorContinuousParams;
}

declare class SoundNodeModulatorContinuous extends SoundNode { 
	/**
	 * Pitch Modulation Params
	*/
	PitchModulationParams: ModulatorContinuousParams;
	/**
	 * Volume Modulation Params
	*/
	VolumeModulationParams: ModulatorContinuousParams;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeModulatorContinuous;
	static Find(Outer: UObject, ResourceName: string): SoundNodeModulatorContinuous;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeModulatorContinuous;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeModulatorContinuous;
	static C(Other: UObject): SoundNodeModulatorContinuous;
}

declare class SoundNodeOscillator extends SoundNode { 
	/**
	 * Whether to oscillate volume.
	*/
	bModulateVolume: boolean;
	/**
	 * Whether to oscillate pitch.
	*/
	bModulatePitch: boolean;
	/**
	 * An amplitude of 0.25 would oscillate between 0.75 and 1.25.
	*/
	AmplitudeMin: number;
	/**
	 * An amplitude of 0.25 would oscillate between 0.75 and 1.25.
	*/
	AmplitudeMax: number;
	/**
	 * A frequency of 20 would oscillate at 10Hz.
	*/
	FrequencyMin: number;
	/**
	 * A frequency of 20 would oscillate at 10Hz.
	*/
	FrequencyMax: number;
	/**
	 * Offset into the sine wave. Value modded by 2 * PI.
	*/
	OffsetMin: number;
	/**
	 * Offset into the sine wave. Value modded by 2 * PI.
	*/
	OffsetMax: number;
	/**
	 * A center of 0.5 would oscillate around 0.5.
	*/
	CenterMin: number;
	/**
	 * A center of 0.5 would oscillate around 0.5.
	*/
	CenterMax: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeOscillator;
	static Find(Outer: UObject, ResourceName: string): SoundNodeOscillator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeOscillator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeOscillator;
	static C(Other: UObject): SoundNodeOscillator;
}

declare class SoundNodeQualityLevel extends SoundNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeQualityLevel;
	static Find(Outer: UObject, ResourceName: string): SoundNodeQualityLevel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeQualityLevel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeQualityLevel;
	static C(Other: UObject): SoundNodeQualityLevel;
}

declare class SoundNodeRandom extends SoundNode { 
	/**
	 * Weights
	*/
	Weights: number[];
	/**
	 * If greater than 0, then upon each level load such a number of inputs will be randomly selected
	 * and the rest will be removed. This can be used to cut down the memory usage of large randomizing
	 * cues.
	*/
	PreselectAtLevelLoad: number;
	/**
	 * Determines whether or not this SoundNodeRandom should randomize with or without
	 * replacement.
	 * WithoutReplacement means that only nodes left will be valid for
	 * selection.  So with that, you are guarenteed to have only one occurrence of the
	 * sound played until all of the other sounds in the set have all been played.
	 * WithReplacement means that a node will be chosen and then placed back into the set.
	 * So one could play the same sound over and over if the probabilities don't go your way :-)
	*/
	bRandomizeWithoutReplacement: boolean;
	/**
	 * Internal state of which sounds have been played.  This is only used at runtime
	 * to keep track of which sounds have been played
	*/
	HasBeenUsed: boolean[];
	/**
	 * Counter var so we don't have to count all of the used sounds each time we choose a sound *
	*/
	NumRandomUsed: number;
	/**
	 * Editor only list of nodes hidden to duplicate behavior of PreselectAtLevelLoad
	*/
	PIEHiddenNodes: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeRandom;
	static Find(Outer: UObject, ResourceName: string): SoundNodeRandom;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeRandom;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeRandom;
	static C(Other: UObject): SoundNodeRandom;
}

declare class SoundNodeSoundClass extends SoundNode { 
	/**
	 * Sound Class Override
	*/
	SoundClassOverride: SoundClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeSoundClass;
	static Find(Outer: UObject, ResourceName: string): SoundNodeSoundClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeSoundClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeSoundClass;
	static C(Other: UObject): SoundNodeSoundClass;
}

declare class SoundNodeSwitch extends SoundNode { 
	/**
	 * The name of the integer parameter to use to determine which branch we should take
	*/
	IntParameterName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeSwitch;
	static Find(Outer: UObject, ResourceName: string): SoundNodeSwitch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeSwitch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeSwitch;
	static C(Other: UObject): SoundNodeSwitch;
}

declare class SoundNodeWaveParam extends SoundNode { 
	/**
	 * The name of the wave parameter to use to look up the SoundWave we should play
	*/
	WaveParameterName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundNodeWaveParam;
	static Find(Outer: UObject, ResourceName: string): SoundNodeWaveParam;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundNodeWaveParam;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundNodeWaveParam;
	static C(Other: UObject): SoundNodeWaveParam;
}

declare class TextPropertyTestObject extends UObject { 
	/**
	 * Defaulted Text
	*/
	DefaultedText: string;
	/**
	 * Undefaulted Text
	*/
	UndefaultedText: string;
	/**
	 * Transient Text
	*/
	TransientText: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextPropertyTestObject;
	static Find(Outer: UObject, ResourceName: string): TextPropertyTestObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextPropertyTestObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextPropertyTestObject;
	static C(Other: UObject): TextPropertyTestObject;
}

declare class LightMapTexture2D extends Texture2D { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightMapTexture2D;
	static Find(Outer: UObject, ResourceName: string): LightMapTexture2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightMapTexture2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightMapTexture2D;
	static C(Other: UObject): LightMapTexture2D;
}

declare type EShadowMapFlags = string | symbol;
declare var EShadowMapFlags = { SMF_None:'SMF_None',SMF_Streamed:'SMF_Streamed', };
declare class ShadowMapTexture2D extends Texture2D { 
	/**
	 * Bit-field with shadowmap flags.
	*/
	ShadowmapFlags: EShadowMapFlags;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ShadowMapTexture2D;
	static Find(Outer: UObject, ResourceName: string): ShadowMapTexture2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ShadowMapTexture2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShadowMapTexture2D;
	static C(Other: UObject): ShadowMapTexture2D;
}

declare class Texture2DDynamic extends Texture { 
	/**
	 * The format of the texture.
	*/
	Format: EPixelFormat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Texture2DDynamic;
	static Find(Outer: UObject, ResourceName: string): Texture2DDynamic;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Texture2DDynamic;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2DDynamic;
	static C(Other: UObject): Texture2DDynamic;
}

declare class CanvasRenderTarget2D extends TextureRenderTarget2D { 
	/**
	 * Called when this Canvas Render Target is asked to update its texture resource.
	*/
	OnCanvasRenderTargetUpdate: UnrealEngineMulticastDelegate<(Canvas: Canvas, Width: number, Height: number) => void>;
	/**
	 * The world this render target will be used with
	*/
	World: any;
	/**
	 * If true, clear the render target to green whenever OnReceiveUpdate() is called.  (Defaults to true.)
	 * If false, the render target will retain whatever values it had, allowing the user to update only areas that
	 * have changed.
	*/
	bShouldClearRenderTargetOnReceiveUpdate: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CanvasRenderTarget2D;
	static Find(Outer: UObject, ResourceName: string): CanvasRenderTarget2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CanvasRenderTarget2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasRenderTarget2D;
	/**
	 * Updates the the canvas render target texture's resource. This is where the render target will create or
	 * find a canvas object to use.  It also calls UpdateResourceImmediate() to clear the render target texture
	 * from the deferred rendering list, to stop the texture from being cleared the next frame. From there it
	 * will ask the rendering thread to set up the RHI viewport. The canvas is then set up for rendering and
	 * then the user's update delegate is called.  The canvas is then flushed and the RHI resolves the
	 * texture to make it available for rendering.
	*/
	UpdateResource(): void;
	/**
	 * Allows a Blueprint to implement how this Canvas Render Target 2D should be updated.
	 * @param       Canvas                          Canvas object that can be used to paint to the render target
	 * @param       Width                           Width of the render target.
	 * @param       Height                          Height of the render target.
	*/
	ReceiveUpdate(Canvas: Canvas,Width: number,Height: number): void;
	/**
	 * Gets a specific render target's size from the global map of canvas render targets.
	 * @param       Width   Output variable for the render target's width
	 * @param       Height  Output variable for the render target's height
	*/
	GetSize(Width?: number,Height?: number): {Width: number, Height: number};
	/**
	 * Creates a new canvas render target and initializes it to the specified dimensions
	 * @param       WorldContextObject      The world where this render target will be rendered for
	 * @param       CanvasRenderTarget2DClass       Class of the render target.  Unless you want to use a special sub-class, you can simply pass UCanvasRenderTarget2D::StaticClass() here.
	 * @param       Width                           Width of the render target.
	 * @param       Height                          Height of the render target.
	 * @return                                              Returns the instanced render target.
	*/
	static CreateCanvasRenderTarget2D(WorldContextObject: UObject,CanvasRenderTarget2DClass: UnrealEngineClass,Width: number,Height: number): CanvasRenderTarget2D;
	static C(Other: UObject): CanvasRenderTarget2D;
}

declare class UserDefinedEnum extends Enum { 
	/**
	 * Unique Name Index
	*/
	UniqueNameIndex: any;
	/**
	 * Names stored in "DisplayName" meta data. They are duplicated here,
	 * so functions like UKismetNodeHelperLibrary::GetEnumeratorUserFriendlyName can use them
	 * outside the editor. (When meta data are not loaded).
	 * To sync DisplayNames with meta-data use FEnumEditorUtils::EnsureAllDisplayNamesExist.
	*/
	DisplayNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UserDefinedEnum;
	static Find(Outer: UObject, ResourceName: string): UserDefinedEnum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UserDefinedEnum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UserDefinedEnum;
	static C(Other: UObject): UserDefinedEnum;
}

declare type EVectorFieldConstructionOp = string | symbol;
declare var EVectorFieldConstructionOp = { VFCO_Extrude:'VFCO_Extrude',VFCO_Revolve:'VFCO_Revolve', };
declare class VectorFieldStatic extends VectorField { 
	/**
	 * Size of the vector field volume.
	*/
	SizeX: number;
	/**
	 * Size of the vector field volume.
	*/
	SizeY: number;
	/**
	 * Size of the vector field volume.
	*/
	SizeZ: number;
	/**
	 * Source File Path
	*/
	SourceFilePath: string;
	/**
	 * Asset Import Data
	*/
	AssetImportData: AssetImportData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VectorFieldStatic;
	static Find(Outer: UObject, ResourceName: string): VectorFieldStatic;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VectorFieldStatic;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldStatic;
	static C(Other: UObject): VectorFieldStatic;
}

declare class VectorFieldAnimated extends VectorField { 
	/**
	 * The texture from which to create the vector field.
	*/
	Texture: Texture2D;
	/**
	 * The operation used to construct the vector field.
	*/
	ConstructionOp: EVectorFieldConstructionOp;
	/**
	 * The size of the volume. Valid sizes: 16, 32, 64.
	*/
	VolumeSizeX: number;
	/**
	 * The size of the volume. Valid sizes: 16, 32, 64.
	*/
	VolumeSizeY: number;
	/**
	 * The size of the volume. Valid sizes: 16, 32, 64.
	*/
	VolumeSizeZ: number;
	/**
	 * The number of horizontal subimages in the texture atlas.
	*/
	SubImagesX: number;
	/**
	 * The number of vertical subimages in the texture atlas.
	*/
	SubImagesY: number;
	/**
	 * The number of frames in the atlas.
	*/
	FrameCount: number;
	/**
	 * The rate at which to interpolate between frames.
	*/
	FramesPerSecond: number;
	/**
	 * Whether or not the simulation should loop.
	*/
	bLoop: boolean;
	/**
	 * A static vector field used to add noise.
	*/
	NoiseField: VectorFieldStatic;
	/**
	 * Scale to apply to vectors in the noise field.
	*/
	NoiseScale: number;
	/**
	 * The maximum magnitude of noise vectors to apply.
	*/
	NoiseMax: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VectorFieldAnimated;
	static Find(Outer: UObject, ResourceName: string): VectorFieldAnimated;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VectorFieldAnimated;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VectorFieldAnimated;
	static C(Other: UObject): VectorFieldAnimated;
}

declare class VisualLoggerAutomationTests extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VisualLoggerAutomationTests;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerAutomationTests;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VisualLoggerAutomationTests;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerAutomationTests;
	static C(Other: UObject): VisualLoggerAutomationTests;
}

declare class VisualLoggerDebugSnapshotInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VisualLoggerDebugSnapshotInterface;
	static Find(Outer: UObject, ResourceName: string): VisualLoggerDebugSnapshotInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VisualLoggerDebugSnapshotInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VisualLoggerDebugSnapshotInterface;
	static C(Other: UObject): VisualLoggerDebugSnapshotInterface;
}

declare class MoviePlayerSettings extends UObject { 
	/**
	 * If enabled, The game waits for startup movies to complete even if loading has finished.
	*/
	bWaitForMoviesToComplete: boolean;
	/**
	 * If enabled, Startup movies can be skipped by the user when a mouse button is pressed.
	*/
	bMoviesAreSkippable: boolean;
	/**
	 * Movies to play on startup. Note that these must be in your game's Game/Content/Movies directory.
	*/
	StartupMovies: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MoviePlayerSettings;
	static Find(Outer: UObject, ResourceName: string): MoviePlayerSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MoviePlayerSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MoviePlayerSettings;
	static C(Other: UObject): MoviePlayerSettings;
}

declare type EMinimumSupportedOS = string | symbol;
declare var EMinimumSupportedOS = { MSOS_Vista:'MSOS_Vista',MSOS_XP:'MSOS_XP', };
declare class WindowsTargetSettings extends UObject { 
	/**
	 * The collection of RHI's we want to support on this platform.
	 * This is not always the full list of RHI we can support.
	*/
	TargetedRHIs: string[];
	/**
	 * Determine the minimum supported
	*/
	MinimumOSVersion: EMinimumSupportedOS;
	/**
	 * The audio device name to use if not the default windows audio device. Leave blank to use default audio device.
	*/
	AudioDevice: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WindowsTargetSettings;
	static Find(Outer: UObject, ResourceName: string): WindowsTargetSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WindowsTargetSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WindowsTargetSettings;
	static C(Other: UObject): WindowsTargetSettings;
}

declare class LinuxTargetSettings extends UObject { 
	/**
	 * The collection of RHI's we want to support on this platform.
	 * This is not always the full list of RHI we can support.
	*/
	TargetedRHIs: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LinuxTargetSettings;
	static Find(Outer: UObject, ResourceName: string): LinuxTargetSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LinuxTargetSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LinuxTargetSettings;
	static C(Other: UObject): LinuxTargetSettings;
}

declare class NamedInterface { 
	/**
	 * The name to bind this object to
	*/
	InterfaceName: string;
	/**
	 * The object to store at this location
	*/
	InterfaceObject: UObject;
	clone() : NamedInterface;
	static C(Other: UObject): NamedInterface;
}

declare class NamedInterfaceDef { 
	/**
	 * The name to bind this object to
	*/
	InterfaceName: string;
	/**
	 * The class to load and create for the named interface
	*/
	InterfaceClassName: string;
	clone() : NamedInterfaceDef;
	static C(Other: UObject): NamedInterfaceDef;
}

declare class NamedInterfaces extends UObject { 
	/**
	 * Holds the set of registered named interfaces
	*/
	NamedInterfaces: NamedInterface[];
	/**
	 * The list of named interfaces to automatically create and store
	*/
	NamedInterfaceDefs: NamedInterfaceDef[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NamedInterfaces;
	static Find(Outer: UObject, ResourceName: string): NamedInterfaces;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NamedInterfaces;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NamedInterfaces;
	static C(Other: UObject): NamedInterfaces;
}

declare class TurnBasedMatchInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TurnBasedMatchInterface;
	static Find(Outer: UObject, ResourceName: string): TurnBasedMatchInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TurnBasedMatchInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TurnBasedMatchInterface;
	/**
	 * On Match Received Turn
	*/
	OnMatchReceivedTurn(Match: string,bDidBecomeActive: boolean): void;
	/**
	 * On Match Ended
	*/
	OnMatchEnded(Match: string): void;
	static C(Other: UObject): TurnBasedMatchInterface;
}

declare class AchievementBlueprintLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AchievementBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): AchievementBlueprintLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AchievementBlueprintLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementBlueprintLibrary;
	/**
	 * out
	*/
	static GetCachedAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Progress?: number): {bFoundID: boolean, Progress: number};
	/**
	 * out
	*/
	static GetCachedAchievementDescription(WorldContextObject: UObject,PlayerController: PlayerController,AchievementID: string,bFoundID?: boolean,Title?: string,LockedDescription?: string,UnlockedDescription?: string,bHidden?: boolean): {bFoundID: boolean, Title: string, LockedDescription: string, UnlockedDescription: string, bHidden: boolean};
	static C(Other: UObject): AchievementBlueprintLibrary;
}

declare class AchievementQueryCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when there is a successful query
	*/
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when there is an unsuccessful query
	*/
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AchievementQueryCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): AchievementQueryCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AchievementQueryCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementQueryCallbackProxy;
	/**
	 * Fetches and caches achievement progress from the default online subsystem
	*/
	static CacheAchievements(WorldContextObject: UObject,PlayerController: PlayerController): AchievementQueryCallbackProxy;
	/**
	 * Fetches and caches achievement descriptions from the default online subsystem
	*/
	static CacheAchievementDescriptions(WorldContextObject: UObject,PlayerController: PlayerController): AchievementQueryCallbackProxy;
	static C(Other: UObject): AchievementQueryCallbackProxy;
}

declare class AchievementWriteCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when there is a successful achievement write
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
	/**
	 * Called when there is an unsuccessful achievement write
	*/
	OnFailure: UnrealEngineMulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AchievementWriteCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): AchievementWriteCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AchievementWriteCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AchievementWriteCallbackProxy;
	/**
	 * Writes progress about an achievement to the default online subsystem
	 *   AchievementName is the ID of the achievement to update progress on
	 *   Progress is the reported progress toward accomplishing the achievement
	 *   UserTag is not used internally, but it is returned on success or failure
	*/
	static WriteAchievementProgress(WorldContextObject: UObject,PlayerController: PlayerController,AchievementName: string,Progress: number,UserTag: number): AchievementWriteCallbackProxy;
	static C(Other: UObject): AchievementWriteCallbackProxy;
}

declare class ConnectionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when there is a successful query
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(ErrorCode: number) => void>;
	/**
	 * Called when there is an unsuccessful query
	*/
	OnFailure: UnrealEngineMulticastDelegate<(ErrorCode: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ConnectionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): ConnectionCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ConnectionCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConnectionCallbackProxy;
	/**
	 * Connects to an online service such as Google Play
	*/
	static ConnectToService(WorldContextObject: UObject,PlayerController: PlayerController): ConnectionCallbackProxy;
	static C(Other: UObject): ConnectionCallbackProxy;
}

declare class CreateSessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when the session was created successfully
	*/
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when there was an error creating the session
	*/
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CreateSessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): CreateSessionCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CreateSessionCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CreateSessionCallbackProxy;
	/**
	 * Creates a session with the default online subsystem
	*/
	static CreateSession(WorldContextObject: UObject,PlayerController: PlayerController,PublicConnections: number,bUseLAN: boolean): CreateSessionCallbackProxy;
	static C(Other: UObject): CreateSessionCallbackProxy;
}

declare class DestroySessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when there is a successful destroy
	*/
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when there is an unsuccessful destroy
	*/
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DestroySessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): DestroySessionCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DestroySessionCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DestroySessionCallbackProxy;
	/**
	 * Destroys a session previously created by the default online subsystem
	*/
	static DestroySession(WorldContextObject: UObject,PlayerController: PlayerController): DestroySessionCallbackProxy;
	static C(Other: UObject): DestroySessionCallbackProxy;
}

declare class EndMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when the match ends successfully
	*/
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when ending the match fails
	*/
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EndMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): EndMatchCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EndMatchCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndMatchCallbackProxy;
	static C(Other: UObject): EndMatchCallbackProxy;
}

declare class EndTurnCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when there is a successful query
	*/
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when there is an unsuccessful query
	*/
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EndTurnCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): EndTurnCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EndTurnCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EndTurnCallbackProxy;
	static C(Other: UObject): EndTurnCallbackProxy;
}

declare class BlueprintSessionResult { 
	clone() : BlueprintSessionResult;
	static C(Other: UObject): BlueprintSessionResult;
}

declare class FindSessionsCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when there is a successful query
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(Results: BlueprintSessionResult[]) => void>;
	/**
	 * Called when there is an unsuccessful query
	*/
	OnFailure: UnrealEngineMulticastDelegate<(Results: BlueprintSessionResult[]) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FindSessionsCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): FindSessionsCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FindSessionsCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FindSessionsCallbackProxy;
	/**
	 * Get Server Name
	*/
	static GetServerName(Result: BlueprintSessionResult): string;
	/**
	 * Get Ping in Ms
	*/
	static GetPingInMs(Result: BlueprintSessionResult): number;
	/**
	 * Get Max Players
	*/
	static GetMaxPlayers(Result: BlueprintSessionResult): number;
	/**
	 * Get Current Players
	*/
	static GetCurrentPlayers(Result: BlueprintSessionResult): number;
	/**
	 * Searches for advertised sessions with the default online subsystem
	*/
	static FindSessions(WorldContextObject: UObject,PlayerController: PlayerController,MaxResults: number,bUseLAN: boolean): FindSessionsCallbackProxy;
	static C(Other: UObject): FindSessionsCallbackProxy;
}

declare class FindTurnBasedMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when matchmaking succeeded.
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(MatchID: string) => void>;
	/**
	 * Called when matchmaking failed
	*/
	OnFailure: UnrealEngineMulticastDelegate<(MatchID: string) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FindTurnBasedMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): FindTurnBasedMatchCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FindTurnBasedMatchCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FindTurnBasedMatchCallbackProxy;
	static C(Other: UObject): FindTurnBasedMatchCallbackProxy;
}

declare type EInAppPurchaseState = string | symbol;
declare var EInAppPurchaseState = { Unknown:'Unknown',Success:'Success',Failed:'Failed',Cancelled:'Cancelled',Invalid:'Invalid',NotAllowed:'NotAllowed',Restored:'Restored',AlreadyOwned:'AlreadyOwned', };
declare class InAppPurchaseProductInfo { 
	/**
	 * The unique product identifier
	*/
	Identifier: string;
	/**
	 * the unique transaction identifier
	*/
	TransactionIdentifier: string;
	/**
	 * The localized display name
	*/
	DisplayName: string;
	/**
	 * The localized display description name
	*/
	DisplayDescription: string;
	/**
	 * The localized display price name
	*/
	DisplayPrice: string;
	/**
	 * Raw price without currency code and symbol
	*/
	RawPrice: number;
	/**
	 * The localized currency code of the price
	*/
	CurrencyCode: string;
	/**
	 * The localized currency symbol of the price
	*/
	CurrencySymbol: string;
	/**
	 * The localized decimal separator used in the price
	*/
	DecimalSeparator: string;
	/**
	 * The localized grouping separator of the price
	*/
	GroupingSeparator: string;
	/**
	 * The localized display price name
	*/
	ReceiptData: string;
	clone() : InAppPurchaseProductInfo;
	static C(Other: UObject): InAppPurchaseProductInfo;
}

declare class InAppPurchaseProductRequest { 
	/**
	 * The unique product identifier that matches the one from your targeted store.
	*/
	ProductIdentifier: string;
	/**
	 * Flag to determine whether this is a consumable purchase, or not.
	*/
	bIsConsumable: boolean;
	clone() : InAppPurchaseProductRequest;
	static C(Other: UObject): InAppPurchaseProductRequest;
}

declare class InAppPurchaseCallbackProxy extends UObject { 
	/**
	 * Called when there is a successful In-App Purchase transaction
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(CompletionStatus: EInAppPurchaseState, InAppPurchaseInformation: InAppPurchaseProductInfo) => void>;
	/**
	 * Called when there is an unsuccessful In-App Purchase transaction
	*/
	OnFailure: UnrealEngineMulticastDelegate<(CompletionStatus: EInAppPurchaseState, InAppPurchaseInformation: InAppPurchaseProductInfo) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InAppPurchaseCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InAppPurchaseCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseCallbackProxy;
	/**
	 * Kicks off a transaction for the provided product identifier
	*/
	static CreateProxyObjectForInAppPurchase(PlayerController: PlayerController,ProductRequest: InAppPurchaseProductRequest): InAppPurchaseCallbackProxy;
	static C(Other: UObject): InAppPurchaseCallbackProxy;
}

declare class InAppPurchaseQueryCallbackProxy extends UObject { 
	/**
	 * Called when there is a successful InAppPurchase query
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(InAppPurchaseInformation: InAppPurchaseProductInfo[]) => void>;
	/**
	 * Called when there is an unsuccessful InAppPurchase query
	*/
	OnFailure: UnrealEngineMulticastDelegate<(InAppPurchaseInformation: InAppPurchaseProductInfo[]) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InAppPurchaseQueryCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseQueryCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InAppPurchaseQueryCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseQueryCallbackProxy;
	/**
	 * Queries a InAppPurchase for an integer value
	*/
	static ReadInAppPurchaseInformation(PlayerController: PlayerController,ProductIdentifiers: string[]): InAppPurchaseQueryCallbackProxy;
	static C(Other: UObject): InAppPurchaseQueryCallbackProxy;
}

declare class InAppPurchaseRestoreInfo { 
	/**
	 * The unique product identifier
	*/
	Identifier: string;
	/**
	 * The localized display price name
	*/
	ReceiptData: string;
	/**
	 * the unique transaction identifier
	*/
	TransactionIdentifier: string;
	clone() : InAppPurchaseRestoreInfo;
	static C(Other: UObject): InAppPurchaseRestoreInfo;
}

declare class InAppPurchaseRestoreCallbackProxy extends UObject { 
	/**
	 * Called when there is a successful In-App Purchase transaction
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(CompletionStatus: EInAppPurchaseState, InAppRestorePurchaseInformation: InAppPurchaseRestoreInfo[]) => void>;
	/**
	 * Called when there is an unsuccessful In-App Purchase transaction
	*/
	OnFailure: UnrealEngineMulticastDelegate<(CompletionStatus: EInAppPurchaseState, InAppRestorePurchaseInformation: InAppPurchaseRestoreInfo[]) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InAppPurchaseRestoreCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): InAppPurchaseRestoreCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InAppPurchaseRestoreCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InAppPurchaseRestoreCallbackProxy;
	/**
	 * Kicks off a transaction for the provided product identifier
	*/
	static CreateProxyObjectForInAppPurchaseRestore(ConsumableProductFlags: InAppPurchaseProductRequest[],PlayerController: PlayerController): InAppPurchaseRestoreCallbackProxy;
	static C(Other: UObject): InAppPurchaseRestoreCallbackProxy;
}

declare class IpConnection extends NetConnection { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): IpConnection;
	static Find(Outer: UObject, ResourceName: string): IpConnection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): IpConnection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IpConnection;
	static C(Other: UObject): IpConnection;
}

declare class IpNetDriver extends NetDriver { 
	/**
	 * Should port unreachable messages be logged
	*/
	LogPortUnreach: boolean;
	/**
	 * Does the game allow clients to remain after receiving ICMP port unreachable errors (handles flakey connections)
	*/
	AllowPlayerPortUnreach: boolean;
	/**
	 * Number of ports which will be tried if current one is not available for binding (i.e. if told to bind to port N, will try from N to N+MaxPortCountToTry inclusive)
	*/
	MaxPortCountToTry: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): IpNetDriver;
	static Find(Outer: UObject, ResourceName: string): IpNetDriver;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): IpNetDriver;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): IpNetDriver;
	static C(Other: UObject): IpNetDriver;
}

declare class JoinSessionCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when there is a successful join
	*/
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when there is an unsuccessful join
	*/
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JoinSessionCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): JoinSessionCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JoinSessionCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JoinSessionCallbackProxy;
	/**
	 * Joins a remote session with the default online subsystem
	*/
	static JoinSession(WorldContextObject: UObject,PlayerController: PlayerController,SearchResult: BlueprintSessionResult): JoinSessionCallbackProxy;
	static C(Other: UObject): JoinSessionCallbackProxy;
}

declare class LeaderboardBlueprintLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LeaderboardBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): LeaderboardBlueprintLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LeaderboardBlueprintLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardBlueprintLibrary;
	/**
	 * Writes an integer value to the specified leaderboard
	*/
	static WriteLeaderboardInteger(PlayerController: PlayerController,StatName: string,StatValue: number): boolean;
	static C(Other: UObject): LeaderboardBlueprintLibrary;
}

declare class LeaderboardFlushCallbackProxy extends UObject { 
	/**
	 * Called when there is a successful leaderboard flush
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(SessionName: string) => void>;
	/**
	 * Called when there is an unsuccessful leaderboard flush
	*/
	OnFailure: UnrealEngineMulticastDelegate<(SessionName: string) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LeaderboardFlushCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LeaderboardFlushCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LeaderboardFlushCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardFlushCallbackProxy;
	/**
	 * Called to perform the query internally
	*/
	static CreateProxyObjectForFlush(PlayerController: PlayerController,SessionName: string): LeaderboardFlushCallbackProxy;
	static C(Other: UObject): LeaderboardFlushCallbackProxy;
}

declare class LeaderboardQueryCallbackProxy extends UObject { 
	/**
	 * Called when there is a successful leaderboard query
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(LeaderboardValue: number) => void>;
	/**
	 * Called when there is an unsuccessful leaderboard query
	*/
	OnFailure: UnrealEngineMulticastDelegate<(LeaderboardValue: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LeaderboardQueryCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LeaderboardQueryCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LeaderboardQueryCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LeaderboardQueryCallbackProxy;
	/**
	 * Queries a leaderboard for an integer value
	*/
	static ReadLeaderboardInteger(PlayerController: PlayerController,StatName: string): LeaderboardQueryCallbackProxy;
	static C(Other: UObject): LeaderboardQueryCallbackProxy;
}

declare class LogoutCallbackProxy extends BlueprintAsyncActionBase { 
	/**
	 * Called when the logout completed successfully
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	/**
	 * Called when the logout completed unsuccessfully
	*/
	OnFailure: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LogoutCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): LogoutCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LogoutCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LogoutCallbackProxy;
	/**
	 * Logs out of the online service
	*/
	static Logout(WorldContextObject: UObject,PlayerController: PlayerController): LogoutCallbackProxy;
	static C(Other: UObject): LogoutCallbackProxy;
}

declare class OnlineBeacon extends Actor { 
	/**
	 * Time beacon will wait to establish a connection with the beacon host
	*/
	BeaconConnectionInitialTimeout: number;
	/**
	 * Time beacon will wait for packets after establishing a connection before giving up
	*/
	BeaconConnectionTimeout: number;
	/**
	 * Net driver routing network traffic
	*/
	NetDriver: NetDriver;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineBeacon;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeacon;
	static C(Other: UObject): OnlineBeacon;
}

declare class OnlineBeaconHostObject extends Actor { 
	/**
	 * Custom name for this beacon
	*/
	BeaconTypeName: string;
	/**
	 * Class reference for spawning client beacon actor
	*/
	ClientBeaconActorClass: UnrealEngineClass;
	/**
	 * List of all client beacon actors with active connections
	*/
	ClientActors: OnlineBeaconClient[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineBeaconHostObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconHostObject;
	static C(Other: UObject): OnlineBeaconHostObject;
}

declare type EBeaconConnectionState = string | symbol;
declare var EBeaconConnectionState = { Invalid:'Invalid',Closed:'Closed',Pending:'Pending',Open:'Open', };
declare class OnlineBeaconClient extends OnlineBeacon { 
	/**
	 * Owning beacon host of this beacon actor (server only)
	*/
	BeaconOwner: OnlineBeaconHostObject;
	/**
	 * Network connection associated with this beacon client instance
	*/
	BeaconConnection: NetConnection;
	/**
	 * State of the connection
	*/
	ConnectionState: EBeaconConnectionState;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineBeaconClient;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconClient;
	/**
	 * Called on the server side to open up the actor channel that will allow RPCs to occur
	 * (DO NOT OVERLOAD, implement OnConnected() instead)
	*/
	ClientOnConnected(): void;
	static C(Other: UObject): OnlineBeaconClient;
}

declare class PlayerReservation { 
	/**
	 * Unique id for this reservation
	*/
	UniqueId: UniqueNetIdRepl;
	/**
	 * Info needed to validate user credentials when joining a server
	*/
	ValidationStr: string;
	/**
	 * Elapsed time since player made reservation and was last seen
	*/
	ElapsedTime: number;
	clone() : PlayerReservation;
	static C(Other: UObject): PlayerReservation;
}

declare class PartyReservation { 
	/**
	 * Team assigned to this party
	*/
	TeamNum: number;
	/**
	 * Player initiating the request
	*/
	PartyLeader: UniqueNetIdRepl;
	/**
	 * All party members (including party leader) in the reservation
	*/
	PartyMembers: PlayerReservation[];
	clone() : PartyReservation;
	static C(Other: UObject): PartyReservation;
}

declare class PartyBeaconState extends UObject { 
	/**
	 * Session tied to the beacon
	*/
	SessionName: string;
	/**
	 * Number of currently consumed reservations
	*/
	NumConsumedReservations: number;
	/**
	 * Maximum allowed reservations
	*/
	MaxReservations: number;
	/**
	 * Number of teams in the game
	*/
	NumTeams: number;
	/**
	 * Number of players on each team for balancing
	*/
	NumPlayersPerTeam: number;
	/**
	 * Team assignment method
	*/
	TeamAssignmentMethod: string;
	/**
	 * Team that the host has been assigned to
	*/
	ReservedHostTeamNum: number;
	/**
	 * Team that everyone is forced to in single team games
	*/
	ForceTeamNum: number;
	/**
	 * Current reservations in the system
	*/
	Reservations: PartyReservation[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PartyBeaconState;
	static Find(Outer: UObject, ResourceName: string): PartyBeaconState;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PartyBeaconState;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconState;
	static C(Other: UObject): PartyBeaconState;
}

declare type EClientRequestType = string | symbol;
declare var EClientRequestType = { NonePending:'NonePending',ExistingSessionReservation:'ExistingSessionReservation',ReservationUpdate:'ReservationUpdate',EmptyServerReservation:'EmptyServerReservation',Reconnect:'Reconnect', };
declare type EPartyReservationResult = string | symbol;
declare var EPartyReservationResult = { NoResult:'NoResult',RequestPending:'RequestPending',GeneralError:'GeneralError',PartyLimitReached:'PartyLimitReached',IncorrectPlayerCount:'IncorrectPlayerCount',RequestTimedOut:'RequestTimedOut',ReservationDuplicate:'ReservationDuplicate',ReservationNotFound:'ReservationNotFound',ReservationAccepted:'ReservationAccepted',ReservationDenied:'ReservationDenied',ReservationDenied_Banned:'ReservationDenied_Banned',ReservationRequestCanceled:'ReservationRequestCanceled',ReservationInvalid:'ReservationInvalid',BadSessionId:'BadSessionId', };
declare class PartyBeaconClient extends OnlineBeaconClient { 
	/**
	 * Session Id of the destination host
	*/
	DestSessionId: string;
	/**
	 * Pending reservation that will be sent upon connection with the intended host
	*/
	PendingReservation: PartyReservation;
	/**
	 * Type of request currently being handled by this client beacon
	*/
	RequestType: EClientRequestType;
	/**
	 * Has the reservation request been delivered
	*/
	bPendingReservationSent: boolean;
	/**
	 * Has the reservation request been canceled
	*/
	bCancelReservation: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PartyBeaconClient;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconClient;
	/**
	 * Tell the server about the reservation update request being made
	 * @param SessionId expected session id on the other end (must match)
	 * @param ReservationUpdate pending reservation request to make with server
	*/
	ServerUpdateReservationRequest(SessionId: string,ReservationUpdate: PartyReservation): void;
	/**
	 * Tell the server about the reservation request being made
	 * @param SessionId expected session id on the other end (must match)
	 * @param Reservation pending reservation request to make with server
	*/
	ServerReservationRequest(SessionId: string,Reservation: PartyReservation): void;
	/**
	 * Tell the server to cancel a pending or existing reservation
	 * @param PartyLeader id of the party leader for the reservation to cancel
	*/
	ServerCancelReservationRequest(PartyLeader: UniqueNetIdRepl): void;
	/**
	 * Response from the host session that the reservation count has changed
	 * @param NumRemainingReservations number of slots remaining until a full session
	*/
	ClientSendReservationUpdates(NumRemainingReservations: number): void;
	/**
	 * Response from the host session that the reservation is full
	*/
	ClientSendReservationFull(): void;
	/**
	 * Response from the host session after making a reservation request
	 * @param ReservationResponse response from server
	*/
	ClientReservationResponse(ReservationResponse: EPartyReservationResult): void;
	/**
	 * Response from the host session after making a cancellation request
	 * @param ReservationResponse response from server
	*/
	ClientCancelReservationResponse(ReservationResponse: EPartyReservationResult): void;
	static C(Other: UObject): PartyBeaconClient;
}

declare class TestBeaconClient extends OnlineBeaconClient { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TestBeaconClient;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestBeaconClient;
	/**
	 * Send a pong RPC to the host
	*/
	ServerPong(): void;
	/**
	 * Send a ping RPC to the client
	*/
	ClientPing(): void;
	static C(Other: UObject): TestBeaconClient;
}

declare class OnlineBeaconHost extends OnlineBeacon { 
	/**
	 * Configured listen port for this beacon host
	*/
	ListenPort: number;
	/**
	 * List of all client beacon actors with active connections
	*/
	ClientActors: OnlineBeaconClient[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineBeaconHost;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineBeaconHost;
	static C(Other: UObject): OnlineBeaconHost;
}

declare class PartyBeaconHost extends OnlineBeaconHostObject { 
	/**
	 * State of the beacon
	*/
	State: PartyBeaconState;
	/**
	 * Do the timeouts below cause a player to be removed from the reservation list
	*/
	bLogoutOnSessionTimeout: boolean;
	/**
	 * Seconds that can elapse before a reservation is removed due to player not being registered with the session
	*/
	SessionTimeoutSecs: number;
	/**
	 * Seconds that can elapse before a reservation is removed due to player not being registered with the session during a travel
	*/
	TravelSessionTimeoutSecs: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PartyBeaconHost;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PartyBeaconHost;
	static C(Other: UObject): PartyBeaconHost;
}

declare class TestBeaconHost extends OnlineBeaconHostObject { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TestBeaconHost;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TestBeaconHost;
	static C(Other: UObject): TestBeaconHost;
}

declare class OnlineEngineInterfaceImpl extends OnlineEngineInterface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): OnlineEngineInterfaceImpl;
	static Find(Outer: UObject, ResourceName: string): OnlineEngineInterfaceImpl;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineEngineInterfaceImpl;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineEngineInterfaceImpl;
	static C(Other: UObject): OnlineEngineInterfaceImpl;
}

declare class PIELoginSettingsInternal { 
	/**
	 * Id of the user logging in (email, display name, facebook id, etc)
	*/
	Id: string;
	/**
	 * Credentials of the user logging in (password or auth token)
	*/
	Token: string;
	/**
	 * Type of account. Needed to identity the auth method to use (epic, internal, facebook, etc)
	*/
	Type: string;
	/**
	 * Token stored as an array of bytes, encrypted
	*/
	TokenBytes: number[];
	clone() : PIELoginSettingsInternal;
	static C(Other: UObject): PIELoginSettingsInternal;
}

declare class OnlinePIESettings extends DeveloperSettings { 
	/**
	 * Attempt to login with user credentials on a backend service before launching the PIE instance.
	*/
	bOnlinePIEEnabled: boolean;
	/**
	 * Login credentials, at least one for each instance of PIE that is intended to be run
	*/
	Logins: PIELoginSettingsInternal[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): OnlinePIESettings;
	static Find(Outer: UObject, ResourceName: string): OnlinePIESettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlinePIESettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlinePIESettings;
	static C(Other: UObject): OnlinePIESettings;
}

declare class OnlineSessionClient extends OnlineSession { 
	/**
	 * Is this join from an invite
	*/
	bIsFromInvite: boolean;
	/**
	 * Have we started returning to main menu already
	*/
	bHandlingDisconnect: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): OnlineSessionClient;
	static Find(Outer: UObject, ResourceName: string): OnlineSessionClient;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OnlineSessionClient;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OnlineSessionClient;
	static C(Other: UObject): OnlineSessionClient;
}

declare type EMPMatchOutcome = string | symbol;
declare var EMPMatchOutcome = { None:'None',Quit:'Quit',Won:'Won',Lost:'Lost',Tied:'Tied',TimeExpired:'TimeExpired',First:'First',Second:'Second',Third:'Third',Fourth:'Fourth', };
declare class QuitMatchCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when there is a successful query
	*/
	OnSuccess: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when there is an unsuccessful query
	*/
	OnFailure: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): QuitMatchCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): QuitMatchCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): QuitMatchCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QuitMatchCallbackProxy;
	/**
	 * Quits the turn based match
	*/
	static QuitMatch(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,Outcome: EMPMatchOutcome,TurnTimeoutInSeconds: number): QuitMatchCallbackProxy;
	static C(Other: UObject): QuitMatchCallbackProxy;
}

declare class ShowLoginUICallbackProxy extends BlueprintAsyncActionBase { 
	/**
	 * Called when there is a successful query
	*/
	OnSuccess: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	/**
	 * Called when there is an unsuccessful query
	*/
	OnFailure: UnrealEngineMulticastDelegate<(PlayerController: PlayerController) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ShowLoginUICallbackProxy;
	static Find(Outer: UObject, ResourceName: string): ShowLoginUICallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ShowLoginUICallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShowLoginUICallbackProxy;
	/**
	 * Shows the login UI for the currently active online subsystem, if the subsystem supports a login UI.
	*/
	static ShowExternalLoginUI(WorldContextObject: UObject,InPlayerController: PlayerController): ShowLoginUICallbackProxy;
	static C(Other: UObject): ShowLoginUICallbackProxy;
}

declare class TurnBasedBlueprintLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TurnBasedBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): TurnBasedBlueprintLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TurnBasedBlueprintLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TurnBasedBlueprintLibrary;
	/**
	 * Register Turn Based Match Interface Object
	*/
	static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: UObject,PlayerController: PlayerController,UObject: UObject): void;
	/**
	 * out
	*/
	static GetPlayerDisplayName(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex: number,PlayerDisplayName?: string): {PlayerDisplayName: string};
	/**
	 * out
	*/
	static GetMyPlayerIndex(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,PlayerIndex?: number): {PlayerIndex: number};
	/**
	 * out
	*/
	static GetIsMyTurn(WorldContextObject: UObject,PlayerController: PlayerController,MatchID: string,bIsMyTurn?: boolean): {bIsMyTurn: boolean};
	static C(Other: UObject): TurnBasedBlueprintLibrary;
}

declare class K2Node_InAppPurchase extends K2Node_BaseAsyncTask { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InAppPurchase;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InAppPurchase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchase;
	static C(Other: UObject): K2Node_InAppPurchase;
}

declare class K2Node_InAppPurchaseQuery extends K2Node_BaseAsyncTask { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InAppPurchaseQuery;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseQuery;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InAppPurchaseQuery;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseQuery;
	static C(Other: UObject): K2Node_InAppPurchaseQuery;
}

declare class K2Node_InAppPurchaseRestore extends K2Node_BaseAsyncTask { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_InAppPurchaseRestore;
	static Find(Outer: UObject, ResourceName: string): K2Node_InAppPurchaseRestore;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_InAppPurchaseRestore;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_InAppPurchaseRestore;
	static C(Other: UObject): K2Node_InAppPurchaseRestore;
}

declare class K2Node_LatentOnlineCall extends K2Node_BaseAsyncTask { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_LatentOnlineCall;
	static Find(Outer: UObject, ResourceName: string): K2Node_LatentOnlineCall;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_LatentOnlineCall;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LatentOnlineCall;
	static C(Other: UObject): K2Node_LatentOnlineCall;
}

declare class K2Node_LeaderboardFlush extends K2Node_BaseAsyncTask { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_LeaderboardFlush;
	static Find(Outer: UObject, ResourceName: string): K2Node_LeaderboardFlush;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_LeaderboardFlush;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LeaderboardFlush;
	static C(Other: UObject): K2Node_LeaderboardFlush;
}

declare class K2Node_LeaderboardQuery extends K2Node_BaseAsyncTask { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_LeaderboardQuery;
	static Find(Outer: UObject, ResourceName: string): K2Node_LeaderboardQuery;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_LeaderboardQuery;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LeaderboardQuery;
	static C(Other: UObject): K2Node_LeaderboardQuery;
}

declare class GearVRFunctionLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GearVRFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): GearVRFunctionLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GearVRFunctionLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GearVRFunctionLibrary;
	/**
	 * Set Gear VR CPU and GPU Levels
	*/
	static SetCPUAndGPULevels(CPULevel: number,GPULevel: number): void;
	/**
	 * Set Gear VR CPU and GPU Levels
	*/
	static IsPowerLevelStateThrottled(): boolean;
	/**
	 * Set Gear VR CPU and GPU Levels
	*/
	static IsPowerLevelStateMinimum(): boolean;
	/**
	 * Set Gear VR CPU and GPU Levels
	*/
	static GetTemperatureInCelsius(): number;
	/**
	 * Set Gear VR CPU and GPU Levels
	*/
	static GetBatteryLevel(): number;
	/**
	 * Set Gear VR CPU and GPU Levels
	*/
	static AreHeadPhonesPluggedIn(): boolean;
	static C(Other: UObject): GearVRFunctionLibrary;
}

declare type ETrackingStatus = string | symbol;
declare var ETrackingStatus = { NotTracked:'NotTracked',InertialOnly:'InertialOnly',Tracked:'Tracked', };
declare class MotionControllerComponent extends PrimitiveComponent { 
	/**
	 * Which player index this motion controller should automatically follow
	*/
	PlayerIndex: number;
	/**
	 * Which hand this component should automatically follow
	*/
	Hand: EControllerHand;
	/**
	 * If false, render transforms within the motion controller hierarchy will be updated a second time immediately before rendering.
	*/
	bDisableLowLatencyUpdate: boolean;
	/**
	 * The tracking status for the device (e.g. full tracking, inertial tracking only, no tracking)
	*/
	CurrentTrackingStatus: ETrackingStatus;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MotionControllerComponent;
	static Find(Outer: UObject, ResourceName: string): MotionControllerComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MotionControllerComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MotionControllerComponent;
	/**
	 * Whether or not this component had a valid tracked device this frame
	*/
	IsTracked(): boolean;
	static C(Other: UObject): MotionControllerComponent;
}

declare class VRNotificationsComponent extends ActorComponent { 
	/**
	 * This will be called when the application is asked for VR headset recenter.
	*/
	HMDRecenteredDelegate: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * This will be called when connection to HMD is lost.
	*/
	HMDLostDelegate: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * This will be called when connection to HMD is restored.
	*/
	HMDReconnectedDelegate: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VRNotificationsComponent;
	static Find(Outer: UObject, ResourceName: string): VRNotificationsComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VRNotificationsComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VRNotificationsComponent;
	static C(Other: UObject): VRNotificationsComponent;
}

declare class SceneCubemapCapturer extends UObject { 
	/**
	 * Capture Components
	*/
	CaptureComponents: SceneCaptureComponent2D[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SceneCubemapCapturer;
	static Find(Outer: UObject, ResourceName: string): SceneCubemapCapturer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SceneCubemapCapturer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneCubemapCapturer;
	static C(Other: UObject): SceneCubemapCapturer;
}

declare class SourceCodeAccessSettings extends UObject { 
	/**
	 * The source code editor we prefer to use.
	*/
	PreferredAccessor: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SourceCodeAccessSettings;
	static Find(Outer: UObject, ResourceName: string): SourceCodeAccessSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SourceCodeAccessSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SourceCodeAccessSettings;
	static C(Other: UObject): SourceCodeAccessSettings;
}

declare class MovieSceneCaptureInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneCaptureInterface;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneCaptureInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureInterface;
	static C(Other: UObject): MovieSceneCaptureInterface;
}

declare class MovieSceneCaptureProtocolSettings extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneCaptureProtocolSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureProtocolSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneCaptureProtocolSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureProtocolSettings;
	static C(Other: UObject): MovieSceneCaptureProtocolSettings;
}

declare class CaptureProtocolID { 
	/**
	 * Identifier
	*/
	Identifier: string;
	clone() : CaptureProtocolID;
	static C(Other: UObject): CaptureProtocolID;
}

declare class CaptureResolution { 
	/**
	 * Res X
	*/
	ResX: any;
	/**
	 * Res Y
	*/
	ResY: any;
	clone() : CaptureResolution;
	static C(Other: UObject): CaptureResolution;
}

declare class MovieSceneCaptureSettings { 
	/**
	 * The directory to output the captured file(s) in
	*/
	OutputDirectory: DirectoryPath;
	/**
	 * Whether to save temporary copies of all of the levels before capturing the movie.  This allows you to record movies of temporary work, or work that isn't yet saved, but it will take much longer for capturing to begin.
	*/
	bCreateTemporaryCopiesOfLevels: boolean;
	/**
	 * Optional game mode to override the map's default game mode with.  This can be useful if the game's normal mode displays UI elements or loading screens that you don't want captured.
	*/
	GameModeOverride: UnrealEngineClass;
	/**
	 * The format to use for the resulting filename. Extension will be added automatically. Any tokens of the form {token} will be replaced with the corresponding value:
	 * {fps}                - The captured framerate
	 * {frame}              - The current frame number (only relevant for image sequences)
	 * {width}              - The width of the captured frames
	 * {height}             - The height of the captured frames
	 * {world}              - The name of the current world
	 * {quality}    - The image compression quality setting
	 * {material}   - The material/render pass
	 * {shot}       - The name of the level sequence asset shot being played
	*/
	OutputFormat: string;
	/**
	 * Whether to overwrite existing files or not
	*/
	bOverwriteExisting: boolean;
	/**
	 * True if frame numbers in the output files should be relative to zero, rather than the actual frame numbers in the originating animation content
	*/
	bUseRelativeFrameNumbers: boolean;
	/**
	 * How much to zero-pad frame numbers on filenames
	*/
	ZeroPadFrameNumbers: number;
	/**
	 * The frame rate at which to capture
	*/
	FrameRate: number;
	/**
	 * The resolution at which to capture
	*/
	Resolution: CaptureResolution;
	/**
	 * Whether to texture streaming should be enabled while capturing.  Turning off texture streaming may cause much more memory to be used, but also reduces the chance of blurry textures in your captured video.
	*/
	bEnableTextureStreaming: boolean;
	/**
	 * Whether to enable cinematic mode whilst capturing
	*/
	bCinematicMode: boolean;
	/**
	 * Whether to allow player movement whilst capturing
	*/
	bAllowMovement: boolean;
	/**
	 * Whether to allow player rotation whilst capturing
	*/
	bAllowTurning: boolean;
	/**
	 * Whether to show the local player whilst capturing
	*/
	bShowPlayer: boolean;
	/**
	 * Whether to show the in-game HUD whilst capturing
	*/
	bShowHUD: boolean;
	clone() : MovieSceneCaptureSettings;
	static C(Other: UObject): MovieSceneCaptureSettings;
}

declare class MovieSceneCapture extends UObject { 
	/**
	 * The type of capture protocol to use
	*/
	CaptureType: CaptureProtocolID;
	/**
	 * Settings specific to the capture protocol
	*/
	ProtocolSettings: MovieSceneCaptureProtocolSettings;
	/**
	 * Settings that define how to capture
	*/
	Settings: MovieSceneCaptureSettings;
	/**
	 * Whether to capture the movie in a separate process or not
	*/
	bUseSeparateProcess: boolean;
	/**
	 * When enabled, the editor will shutdown when the capture starts
	*/
	bCloseEditorWhenCaptureStarts: boolean;
	/**
	 * Additional command line arguments to pass to the external process when capturing
	*/
	AdditionalCommandLineArguments: string;
	/**
	 * Command line arguments inherited from this process
	*/
	InheritedCommandLineArguments: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneCapture;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCapture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCapture;
	static C(Other: UObject): MovieSceneCapture;
}

declare class AutomatedLevelSequenceCapture extends MovieSceneCapture { 
	/**
	 * When enabled, the StartFrame setting will override the default starting frame number
	*/
	bUseCustomStartFrame: boolean;
	/**
	 * Frame number to start capturing.  The frame number range depends on whether the bUseRelativeFrameNumbers option is enabled.
	*/
	StartFrame: number;
	/**
	 * When enabled, the EndFrame setting will override the default ending frame number
	*/
	bUseCustomEndFrame: boolean;
	/**
	 * Frame number to end capturing.  The frame number range depends on whether the bUseRelativeFrameNumbers option is enabled.
	*/
	EndFrame: number;
	/**
	 * The number of extra frames to play before the sequence's start frame, to "warm up" the animation.  This is useful if your
	 *           animation contains particles or other runtime effects that are spawned into the scene earlier than your capture start frame
	*/
	WarmUpFrameCount: number;
	/**
	 * The number of seconds to wait (in real-time) before we start playing back the warm up frames.  Useful for allowing post processing effects to settle down before capturing the animation.
	*/
	DelayBeforeWarmUp: number;
	/**
	 * Burn in Options
	*/
	BurnInOptions: LevelSequenceBurnInOptions;
	/**
	 * Whether to write edit decision lists (EDLs) if the sequence contains shots
	*/
	bWriteEditDecisionList: boolean;
	/**
	 * A level sequence asset to playback at runtime - used where the level sequence does not already exist in the world.
	*/
	LevelSequenceAsset: StringAssetReference;
	/**
	 * The pre-existing level sequence actor to use for capture that specifies playback settings
	*/
	LevelSequenceActor: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AutomatedLevelSequenceCapture;
	static Find(Outer: UObject, ResourceName: string): AutomatedLevelSequenceCapture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AutomatedLevelSequenceCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomatedLevelSequenceCapture;
	static C(Other: UObject): AutomatedLevelSequenceCapture;
}

declare class LevelCapture extends MovieSceneCapture { 
	/**
	 * Specifies whether the capture should start immediately, or whether it will be invoked externally (through StartMovieCapture/StopMovieCapture exec commands)
	*/
	bAutoStartCapture: boolean;
	/**
	 * Copy of the ID from PrerequisiteActor. Required because JSON serialization exports the path of the object, rather that its GUID
	*/
	PrerequisiteActorId: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelCapture;
	static Find(Outer: UObject, ResourceName: string): LevelCapture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelCapture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelCapture;
	static C(Other: UObject): LevelCapture;
}

declare class MovieSceneCaptureEnvironment extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneCaptureEnvironment;
	static Find(Outer: UObject, ResourceName: string): MovieSceneCaptureEnvironment;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneCaptureEnvironment;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneCaptureEnvironment;
	/**
	 * Get the frame number of the current capture
	*/
	static GetCaptureFrameNumber(): number;
	/**
	 * Get the total elapsed time of the current capture in seconds
	*/
	static GetCaptureElapsedTime(): number;
	static C(Other: UObject): MovieSceneCaptureEnvironment;
}

declare class FrameGrabberProtocolSettings extends MovieSceneCaptureProtocolSettings { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FrameGrabberProtocolSettings;
	static Find(Outer: UObject, ResourceName: string): FrameGrabberProtocolSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FrameGrabberProtocolSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FrameGrabberProtocolSettings;
	static C(Other: UObject): FrameGrabberProtocolSettings;
}

declare class BmpImageCaptureSettings extends MovieSceneCaptureProtocolSettings { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BmpImageCaptureSettings;
	static Find(Outer: UObject, ResourceName: string): BmpImageCaptureSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BmpImageCaptureSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BmpImageCaptureSettings;
	static C(Other: UObject): BmpImageCaptureSettings;
}

declare class ImageCaptureSettings extends FrameGrabberProtocolSettings { 
	/**
	 * Level of compression to apply to the image, between 1 (worst quality, best compression) and 100 (best quality, worst compression)
	*/
	CompressionQuality: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ImageCaptureSettings;
	static Find(Outer: UObject, ResourceName: string): ImageCaptureSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ImageCaptureSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ImageCaptureSettings;
	static C(Other: UObject): ImageCaptureSettings;
}

declare class CompositionGraphCapturePasses { 
	/**
	 * Value
	*/
	Value: string[];
	clone() : CompositionGraphCapturePasses;
	static C(Other: UObject): CompositionGraphCapturePasses;
}

declare type EHDRCaptureGamut = string | symbol;
declare var EHDRCaptureGamut = { HCGM_Rec709:'HCGM_Rec709',HCGM_P3DCI:'HCGM_P3DCI',HCGM_Rec2020:'HCGM_Rec2020',HCGM_ACES:'HCGM_ACES',HCGM_ACEScg:'HCGM_ACEScg', };
declare class CompositionGraphCaptureSettings extends MovieSceneCaptureProtocolSettings { 
	/**
	 * A list of render passes to include in the capture. Leave empty to export all available passes.
	*/
	IncludeRenderPasses: CompositionGraphCapturePasses;
	/**
	 * Whether to capture the frames as HDR textures (*.exr format)
	*/
	bCaptureFramesInHDR: boolean;
	/**
	 * Compression Quality for HDR Frames (0 for no compression, 1 for default compression which can be slow)
	*/
	HDRCompressionQuality: number;
	/**
	 * The color gamut to use when storing HDR captured data. The gamut depends on whether the bCaptureFramesInHDR option is enabled.
	*/
	CaptureGamut: EHDRCaptureGamut;
	/**
	 * Custom post processing material to use for rendering
	*/
	PostProcessingMaterial: StringAssetReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CompositionGraphCaptureSettings;
	static Find(Outer: UObject, ResourceName: string): CompositionGraphCaptureSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CompositionGraphCaptureSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CompositionGraphCaptureSettings;
	static C(Other: UObject): CompositionGraphCaptureSettings;
}

declare class VideoCaptureSettings extends FrameGrabberProtocolSettings { 
	/**
	 * Use Compression
	*/
	bUseCompression: boolean;
	/**
	 * Compression Quality
	*/
	CompressionQuality: number;
	/**
	 * Video Codec
	*/
	VideoCodec: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VideoCaptureSettings;
	static Find(Outer: UObject, ResourceName: string): VideoCaptureSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VideoCaptureSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VideoCaptureSettings;
	static C(Other: UObject): VideoCaptureSettings;
}

declare class ActorRecordingSettings { 
	/**
	 * External settings objects for recorders that supply them. Displayed via a details customization
	*/
	Settings: UObject[];
	clone() : ActorRecordingSettings;
	static C(Other: UObject): ActorRecordingSettings;
}

declare class AnimationRecordingSettings { 
	/**
	 * Whether to record animation in world space, defaults to true
	*/
	bRecordInWorldSpace: boolean;
	/**
	 * Whether to remove the root bone transform from the animation
	*/
	bRemoveRootAnimation: boolean;
	/**
	 * Whether to auto-save asset when recording is completed. Defaults to false
	*/
	bAutoSaveAsset: boolean;
	/**
	 * Sample rate of the recorded animation (in Hz)
	*/
	SampleRate: number;
	/**
	 * Maximum length of the animation recorded (in seconds). If zero the animation will keep on recording until stopped.
	*/
	Length: number;
	clone() : AnimationRecordingSettings;
	static C(Other: UObject): AnimationRecordingSettings;
}

declare class ActorRecording extends UObject { 
	/**
	 * Actor Settings
	*/
	ActorSettings: ActorRecordingSettings;
	/**
	 * Whether we should specify the target animation or auto-create it
	*/
	bSpecifyTargetAnimation: boolean;
	/**
	 * The target animation we want to record to
	*/
	TargetAnimation: any;
	/**
	 * The settings to apply to this actor's animation
	*/
	AnimationSettings: AnimationRecordingSettings;
	/**
	 * Whether to record to 'possessable' (i.e. level-owned) or 'spawnable' (i.e. sequence-owned) actors. Defaults to the global setting.
	*/
	bRecordToPossessable: boolean;
	/**
	 * The actor we want to record
	*/
	ActorToRecord: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorRecording;
	static Find(Outer: UObject, ResourceName: string): ActorRecording;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorRecording;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorRecording;
	static C(Other: UObject): ActorRecording;
}

declare class MovieScene3DTransformSectionRecorderSettings extends UObject { 
	/**
	 * Whether to record actor transforms. This can be useful if you want the actors to end up in specific locations after the sequence.
	 * By default we rely on animations to provide transforms, but this can be changed using the "Record In World Space" animation setting.
	*/
	bRecordTransforms: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): MovieScene3DTransformSectionRecorderSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieScene3DTransformSectionRecorderSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieScene3DTransformSectionRecorderSettings;
	static C(Other: UObject): MovieScene3DTransformSectionRecorderSettings;
}

declare class SequenceRecorderBlueprintLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SequenceRecorderBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderBlueprintLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SequenceRecorderBlueprintLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderBlueprintLibrary;
	/**
	 * Stop recording the current sequence, if any
	*/
	static StopRecordingSequence(): void;
	/**
	 * Start recording the passed-in actors to a level sequence.
	 * @param       ActorsToRecord  The actors to record
	*/
	static StartRecordingSequence(ActorsToRecord: Actor[]): void;
	/**
	 * Are we currently recording a sequence
	*/
	static IsRecordingSequence(): boolean;
	static C(Other: UObject): SequenceRecorderBlueprintLibrary;
}

declare class SequenceRecorderActorFilter { 
	/**
	 * Actor classes to accept for recording
	*/
	ActorClassesToRecord: UnrealEngineClass[];
	clone() : SequenceRecorderActorFilter;
	static C(Other: UObject): SequenceRecorderActorFilter;
}

declare class PropertiesToRecordForClass { 
	/**
	 * The class of the object we can record
	*/
	Class: UnrealEngineClass;
	/**
	 * List of properties we want to record for this class
	*/
	Properties: string[];
	clone() : PropertiesToRecordForClass;
	static C(Other: UObject): PropertiesToRecordForClass;
}

declare class SettingsForActorClass { 
	/**
	 * The class of the actor we want to record
	*/
	Class: UnrealEngineClass;
	/**
	 * Whether to record to 'possessable' (i.e. level-owned) or 'spawnable' (i.e. sequence-owned) actors.
	*/
	bRecordToPossessable: boolean;
	clone() : SettingsForActorClass;
	static C(Other: UObject): SettingsForActorClass;
}

declare class SequenceRecorderSettings extends UObject { 
	/**
	 * Whether to create a level sequence when recording. Actors and animations will be inserted into this sequence
	*/
	bCreateLevelSequence: boolean;
	/**
	 * Whether to maximize the viewport when recording
	*/
	bImmersiveMode: boolean;
	/**
	 * The length of the recorded sequence
	*/
	SequenceLength: number;
	/**
	 * Delay that we will use before starting recording
	*/
	RecordingDelay: number;
	/**
	 * The base name of the sequence to record to. This name will also be used to auto-generate any assets created by this recording.
	*/
	SequenceName: string;
	/**
	 * Base path for this recording. Sub-assets will be created in subdirectories as specified
	*/
	SequenceRecordingBasePath: DirectoryPath;
	/**
	 * The name of the subdirectory animations will be placed in. Leave this empty to place into the same directory as the sequence base path
	*/
	AnimationSubDirectory: string;
	/**
	 * Whether to record nearby spawned actors.
	*/
	bRecordNearbySpawnedActors: boolean;
	/**
	 * Proximity to currently recorded actors to record newly spawned actors.
	*/
	NearbyActorRecordingProximity: number;
	/**
	 * Whether to record the world settings actor in the sequence (some games use this to attach world SFX)
	*/
	bRecordWorldSettingsActor: boolean;
	/**
	 * Filter to check spawned actors against to see if they should be recorded
	*/
	ActorFilter: SequenceRecorderActorFilter;
	/**
	 * Sequence actors to trigger playback on when recording starts (e.g. for recording synchronized sequences)
	*/
	LevelSequenceActorsToTrigger: any[];
	/**
	 * Default settings applied to animation recording
	*/
	DefaultAnimationSettings: AnimationRecordingSettings;
	/**
	 * Whether to record actors that are spawned by sequencer itself (this is usually disabled as results can be unexpected)
	*/
	bRecordSequencerSpawnedActors: boolean;
	/**
	 * The properties to record for specified classes. Component classes specified here will be recorded. If an actor does not contain one of these classes it will be ignored.
	*/
	ClassesAndPropertiesToRecord: PropertiesToRecordForClass[];
	/**
	 * Settings applied to actors of a specified class
	*/
	PerActorSettings: SettingsForActorClass[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SequenceRecorderSettings;
	static Find(Outer: UObject, ResourceName: string): SequenceRecorderSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SequenceRecorderSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequenceRecorderSettings;
	static C(Other: UObject): SequenceRecorderSettings;
}

declare class SequencerSettingsContainer extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SequencerSettingsContainer;
	static Find(Outer: UObject, ResourceName: string): SequencerSettingsContainer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SequencerSettingsContainer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettingsContainer;
	static C(Other: UObject): SequencerSettingsContainer;
}

declare type EAutoKeyMode = string | symbol;
declare var EAutoKeyMode = { KeyAll:'KeyAll',KeyAnimated:'KeyAnimated',KeyNone:'KeyNone', };
declare type EMovieSceneKeyInterpolation = string | symbol;
declare var EMovieSceneKeyInterpolation = { Auto:'Auto',User:'User',Break:'Break',Linear:'Linear',Constant:'Constant', };
declare type ESequencerSpawnPosition = string | symbol;
declare var ESequencerSpawnPosition = { SSP_Origin:'SSP_Origin',SSP_PlaceInFrontOfCamera:'SSP_PlaceInFrontOfCamera', };
declare type ESequencerZoomPosition = string | symbol;
declare var ESequencerZoomPosition = { SZP_CurrentTime:'SZP_CurrentTime',SZP_MousePosition:'SZP_MousePosition', };
declare class SequencerSettings extends UObject { 
	/**
	 * Enable or disable autokeying.
	*/
	AutoKeyMode: EAutoKeyMode;
	/**
	 * Enable or disable keying all channels when any are keyed.
	*/
	bKeyAllEnabled: boolean;
	/**
	 * Enable or disable only keyframing properties marked with the 'Interp' keyword.
	*/
	bKeyInterpPropertiesOnly: boolean;
	/**
	 * The interpolation type for newly created keyframes
	*/
	KeyInterpolation: EMovieSceneKeyInterpolation;
	/**
	 * The default location of a spawnable when it is first dragged into the viewport from the content browser.
	*/
	SpawnPosition: ESequencerSpawnPosition;
	/**
	 * Enable or disable creating of spawnable cameras whenever cameras are created.
	*/
	bCreateSpawnableCameras: boolean;
	/**
	 * Show frame numbers or time in the timeline.
	*/
	bShowFrameNumbers: boolean;
	/**
	 * Show the in/out range in the timeline with respect to the start/end range.
	*/
	bShowRangeSlider: boolean;
	/**
	 * Enable or disable snapping in the timeline.
	*/
	bIsSnapEnabled: boolean;
	/**
	 * The time snapping interval in the timeline.
	*/
	TimeSnapInterval: number;
	/**
	 * Enable or disable snapping keys to the time snapping interval.
	*/
	bSnapKeyTimesToInterval: boolean;
	/**
	 * Enable or disable snapping keys to other keys.
	*/
	bSnapKeyTimesToKeys: boolean;
	/**
	 * Enable or disable snapping sections to the time snapping interval.
	*/
	bSnapSectionTimesToInterval: boolean;
	/**
	 * Enable or disable snapping sections to other sections.
	*/
	bSnapSectionTimesToSections: boolean;
	/**
	 * Enable or disable snapping the current time to keys of the selected track while scrubbing.
	*/
	bSnapPlayTimeToKeys: boolean;
	/**
	 * Enable or disable snapping the current time to the time snapping interval while scrubbing.
	*/
	bSnapPlayTimeToInterval: boolean;
	/**
	 * Enable or disable snapping the current time to the dragged or pressed key.
	*/
	bSnapPlayTimeToDraggedKey: boolean;
	/**
	 * Enable or disable snapping the curve value to the curve value interval.
	*/
	bSnapCurveValueToInterval: boolean;
	/**
	 * Enable or disable the label browser.
	*/
	bLabelBrowserVisible: boolean;
	/**
	 * Defines whether to jump back to the start of the sequence when a recording is started
	*/
	bRewindOnRecord: boolean;
	/**
	 * Whether to zoom in on the current position or the current time in the timeline.
	*/
	ZoomPosition: ESequencerZoomPosition;
	/**
	 * Enable or disable auto scroll in the timeline.
	*/
	bAutoScrollEnabled: boolean;
	/**
	 * Enable or disable curve editor tooltips.
	*/
	bShowCurveEditorCurveToolTips: boolean;
	/**
	 * Enable or disable linking the curve editor time range to the sequencer timeline's time range.
	*/
	bLinkCurveEditorTimeRange: boolean;
	/**
	 * Enable or disable looping playback in the timeline.
	*/
	bLooping: boolean;
	/**
	 * Enable or disable keeping the cursor in the current playback range during playback.
	*/
	bKeepCursorInPlayRange: boolean;
	/**
	 * Enable or disable keeping the playback range constrained to the section bounds.
	*/
	bKeepPlayRangeInSectionBounds: boolean;
	/**
	 * The number of zeros to pad the frame numbers by.
	*/
	ZeroPadFrames: number;
	/**
	 * Enable or disable the combined keyframes at the top node level. Disabling can improve editor performance.
	*/
	bShowCombinedKeyframes: boolean;
	/**
	 * Enable or disable setting key area sections as infinite by default.
	*/
	bInfiniteKeyAreas: boolean;
	/**
	 * Enable or disable displaying channel bar colors for vector properties.
	*/
	bShowChannelColors: boolean;
	/**
	 * Enable or disable transport controls in the viewport.
	*/
	bShowViewportTransportControls: boolean;
	/**
	 * When enabled, sequencer is able to possess viewports that represent PIE worlds
	*/
	bAllowPossessionOfPIEViewports: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SequencerSettings;
	static Find(Outer: UObject, ResourceName: string): SequencerSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SequencerSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SequencerSettings;
	static C(Other: UObject): SequencerSettings;
}

declare class MovieSceneToolsPropertyTrackSettings { 
	/**
	 * Optional ActorComponent tag (when keying a component property).
	*/
	ComponentName: string;
	/**
	 * Name to the keyed property within the Actor or ActorComponent.
	*/
	PropertyName: string;
	clone() : MovieSceneToolsPropertyTrackSettings;
	static C(Other: UObject): MovieSceneToolsPropertyTrackSettings;
}

declare class MovieSceneToolsFbxSettings { 
	/**
	 * The name of the fbx property
	*/
	FbxPropertyName: string;
	/**
	 * The property track setting to map to
	*/
	PropertyPath: MovieSceneToolsPropertyTrackSettings;
	clone() : MovieSceneToolsFbxSettings;
	static C(Other: UObject): MovieSceneToolsFbxSettings;
}

declare class MovieSceneToolsProjectSettings extends UObject { 
	/**
	 * The default start time for new level sequences, in seconds.
	*/
	DefaultStartTime: number;
	/**
	 * The default duration for new level sequences in seconds.
	*/
	DefaultDuration: number;
	/**
	 * The default directory for the shots.
	*/
	ShotDirectory: string;
	/**
	 * The default prefix for shot names.
	*/
	ShotPrefix: string;
	/**
	 * The first shot number.
	*/
	FirstShotNumber: any;
	/**
	 * The default shot increment.
	*/
	ShotIncrement: any;
	/**
	 * The number of digits for the shot number.
	*/
	ShotNumDigits: any;
	/**
	 * The number of digits for the take number.
	*/
	TakeNumDigits: any;
	/**
	 * The first take number.
	*/
	FirstTakeNumber: any;
	/**
	 * A single character separator between the shot number and the take number.
	*/
	TakeSeparator: string;
	/**
	 * Mapping between fbx property name and property track path
	*/
	FbxSettings: MovieSceneToolsFbxSettings[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneToolsProjectSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneToolsProjectSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneToolsProjectSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneToolsProjectSettings;
	static C(Other: UObject): MovieSceneToolsProjectSettings;
}

declare type EThumbnailQuality = string | symbol;
declare var EThumbnailQuality = { Draft:'Draft',Normal:'Normal',Best:'Best', };
declare class MovieSceneUserThumbnailSettings extends UObject { 
	/**
	 * Whether to draw thumbnails or not
	*/
	bDrawThumbnails: boolean;
	/**
	 * Whether to draw thumbnails or not
	*/
	bDrawSingleThumbnails: boolean;
	/**
	 * Size at which to draw thumbnails on thumbnail sections
	*/
	ThumbnailSize: IntPoint;
	/**
	 * Quality to render the thumbnails with
	*/
	Quality: EThumbnailQuality;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovieSceneUserThumbnailSettings;
	static Find(Outer: UObject, ResourceName: string): MovieSceneUserThumbnailSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovieSceneUserThumbnailSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovieSceneUserThumbnailSettings;
	static C(Other: UObject): MovieSceneUserThumbnailSettings;
}

declare type ELocalizationTargetConflictStatus = string | symbol;
declare var ELocalizationTargetConflictStatus = { Unknown:'Unknown',ConflictsPresent:'ConflictsPresent',Clear:'Clear', };
declare class GatherTextSearchDirectory { 
	/**
	 * Path
	*/
	Path: string;
	clone() : GatherTextSearchDirectory;
	static C(Other: UObject): GatherTextSearchDirectory;
}

declare class GatherTextExcludePath { 
	/**
	 * Pattern
	*/
	Pattern: string;
	clone() : GatherTextExcludePath;
	static C(Other: UObject): GatherTextExcludePath;
}

declare class GatherTextFileExtension { 
	/**
	 * Pattern
	*/
	Pattern: string;
	clone() : GatherTextFileExtension;
	static C(Other: UObject): GatherTextFileExtension;
}

declare class GatherTextFromTextFilesConfiguration { 
	/**
	 * If enabled, text from text files will be gathered according to this configuration.
	*/
	IsEnabled: boolean;
	/**
	 * The paths of directories to be searched recursively for text files, specified relative to the project's root, which may be parsed for text to gather.
	*/
	SearchDirectories: GatherTextSearchDirectory[];
	/**
	 * Text files whose paths match these wildcard patterns will be excluded from gathering.
	*/
	ExcludePathWildcards: GatherTextExcludePath[];
	/**
	 * Text files whose names match these wildcard patterns may be parsed for text to gather.
	*/
	FileExtensions: GatherTextFileExtension[];
	/**
	 * If enabled, data that is specified as editor-only may be processed for gathering.
	*/
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromTextFilesConfiguration;
	static C(Other: UObject): GatherTextFromTextFilesConfiguration;
}

declare class GatherTextIncludePath { 
	/**
	 * Pattern
	*/
	Pattern: string;
	clone() : GatherTextIncludePath;
	static C(Other: UObject): GatherTextIncludePath;
}

declare class GatherTextFromPackagesConfiguration { 
	/**
	 * If enabled, text from packages will be gathered according to this configuration.
	*/
	IsEnabled: boolean;
	/**
	 * Packages whose paths match these wildcard patterns, specified relative to the project's root, may be processed for gathering.
	*/
	IncludePathWildcards: GatherTextIncludePath[];
	/**
	 * Packages whose paths match these wildcard patterns will be excluded from gathering.
	*/
	ExcludePathWildcards: GatherTextExcludePath[];
	/**
	 * Packages whose names match these wildcard patterns may be processed for text to gather.
	*/
	FileExtensions: GatherTextFileExtension[];
	/**
	 * If enabled, data that is specified as editor-only may be processed for gathering.
	*/
	ShouldGatherFromEditorOnlyData: boolean;
	/**
	 * Should we ignore the cached text in the package header and perform a full package load instead?
	*/
	SkipGatherCache: boolean;
	clone() : GatherTextFromPackagesConfiguration;
	static C(Other: UObject): GatherTextFromPackagesConfiguration;
}

declare class MetaDataKeyName { 
	/**
	 * Name
	*/
	Name: string;
	clone() : MetaDataKeyName;
	static C(Other: UObject): MetaDataKeyName;
}

declare class MetaDataTextKeyPattern { 
	/**
	 * Pattern
	*/
	Pattern: string;
	clone() : MetaDataTextKeyPattern;
	static C(Other: UObject): MetaDataTextKeyPattern;
}

declare class MetaDataKeyGatherSpecification { 
	/**
	 * The metadata key for which values will be gathered as text.
	*/
	MetaDataKey: MetaDataKeyName;
	/**
	 * The localization namespace in which the gathered text will be output.
	*/
	TextNamespace: string;
	/**
	 * The pattern which will be formatted to form the localization key for the metadata value gathered as text.
	 *       Placeholder - Description
	 *       {FieldPath} - The fully qualified name of the object upon which the metadata resides.
	 *       {MetaDataValue} - The value associated with the metadata key.
	*/
	TextKeyPattern: MetaDataTextKeyPattern;
	clone() : MetaDataKeyGatherSpecification;
	static C(Other: UObject): MetaDataKeyGatherSpecification;
}

declare class GatherTextFromMetaDataConfiguration { 
	/**
	 * If enabled, metadata will be gathered according to this configuration.
	*/
	IsEnabled: boolean;
	/**
	 * Metadata from source files whose paths match these wildcard patterns, specified relative to the project's root, may be processed for gathering.
	*/
	IncludePathWildcards: GatherTextIncludePath[];
	/**
	 * Metadata from source files whose paths match these wildcard patterns will be excluded from gathering.
	*/
	ExcludePathWildcards: GatherTextExcludePath[];
	/**
	 * Specifications for how to gather text from specific metadata keys.
	*/
	KeySpecifications: MetaDataKeyGatherSpecification[];
	/**
	 * If enabled, data that is specified as editor-only may be processed for gathering.
	*/
	ShouldGatherFromEditorOnlyData: boolean;
	clone() : GatherTextFromMetaDataConfiguration;
	static C(Other: UObject): GatherTextFromMetaDataConfiguration;
}

declare class LocalizationExportingSettings { 
	/**
	 * Should user comments in existing PO files be persisted after export? Useful if using a third party service that stores editor/translator notes in the PO format's comment fields.
	*/
	ShouldPersistCommentsOnExport: boolean;
	/**
	 * Should source locations be added to PO file entries as comments? Useful if a third party service doesn't expose PO file reference comments, which typically store the source location.
	*/
	ShouldAddSourceLocationsAsComments: boolean;
	clone() : LocalizationExportingSettings;
	static C(Other: UObject): LocalizationExportingSettings;
}

declare class LocalizationImportDialogueSettings { 
	/**
	 * Path to the folder to import the audio from. This folder is expected to contain culture sub-folders, which in turn contain the raw WAV files to import.
	*/
	RawAudioPath: DirectoryPath;
	/**
	 * Folder in which to create the generated sound waves. This is relative to the root of the L10N culture folder (or the root content folder if importing native dialogue as source dialogue).
	*/
	ImportedDialogueFolder: string;
	/**
	 * Should the dialogue for the native culture be imported as if it were source audio? If false, the native culture dialogue will be imported as localized data for the native culture.
	*/
	bImportNativeAsSource: boolean;
	clone() : LocalizationImportDialogueSettings;
	static C(Other: UObject): LocalizationImportDialogueSettings;
}

declare class CultureStatistics { 
	/**
	 * The ISO name for this culture.
	*/
	CultureName: string;
	/**
	 * The estimated number of words that have been localized for this culture.
	*/
	WordCount: any;
	clone() : CultureStatistics;
	static C(Other: UObject): CultureStatistics;
}

declare class LocalizationTargetSettings { 
	/**
	 * Unique name for the target.
	*/
	Name: string;
	/**
	 * Guid
	*/
	Guid: Guid;
	/**
	 * Whether the target has outstanding conflicts that require resolution.
	*/
	ConflictStatus: ELocalizationTargetConflictStatus;
	/**
	 * Text present in these targets will not be duplicated in this target.
	*/
	TargetDependencies: Guid[];
	/**
	 * Text present in these manifests will not be duplicated in this target.
	*/
	AdditionalManifestDependencies: FilePath[];
	/**
	 * The names of modules which must be loaded when gathering text. Use to gather from packages or metadata sourced from a module that isn't the primary game module.
	*/
	RequiredModuleNames: string[];
	/**
	 * Parameters for defining what text is gathered from text files and how.
	*/
	GatherFromTextFiles: GatherTextFromTextFilesConfiguration;
	/**
	 * Parameters for defining what text is gathered from packages and how.
	*/
	GatherFromPackages: GatherTextFromPackagesConfiguration;
	/**
	 * Parameters for defining what text is gathered from metadata and how.
	*/
	GatherFromMetaData: GatherTextFromMetaDataConfiguration;
	/**
	 * Settings for exporting translations.
	*/
	ExportSettings: LocalizationExportingSettings;
	/**
	 * Settings for importing dialogue from WAV files.
	*/
	ImportDialogueSettings: LocalizationImportDialogueSettings;
	/**
	 * The index of the native culture among the supported cultures.
	*/
	NativeCultureIndex: number;
	/**
	 * Cultures for which the source text is being localized for.
	*/
	SupportedCulturesStatistics: CultureStatistics[];
	clone() : LocalizationTargetSettings;
	static C(Other: UObject): LocalizationTargetSettings;
}

declare class LocalizationTarget extends UObject { 
	/**
	 * Settings
	*/
	Settings: LocalizationTargetSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LocalizationTarget;
	static Find(Outer: UObject, ResourceName: string): LocalizationTarget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LocalizationTarget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTarget;
	static C(Other: UObject): LocalizationTarget;
}

declare class LocalizationTargetSet extends UObject { 
	/**
	 * Target Objects
	*/
	TargetObjects: LocalizationTarget[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LocalizationTargetSet;
	static Find(Outer: UObject, ResourceName: string): LocalizationTargetSet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LocalizationTargetSet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationTargetSet;
	static C(Other: UObject): LocalizationTargetSet;
}

declare class LocalizationSettings extends UObject { 
	/**
	 * Engine Target Set
	*/
	EngineTargetSet: LocalizationTargetSet;
	/**
	 * Engine Targets Settings
	*/
	EngineTargetsSettings: LocalizationTargetSettings[];
	/**
	 * Game Target Set
	*/
	GameTargetSet: LocalizationTargetSet;
	/**
	 * Game Targets Settings
	*/
	GameTargetsSettings: LocalizationTargetSettings[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LocalizationSettings;
	static Find(Outer: UObject, ResourceName: string): LocalizationSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LocalizationSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalizationSettings;
	static C(Other: UObject): LocalizationSettings;
}

declare class InternationalizationSettingsModel extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InternationalizationSettingsModel;
	static Find(Outer: UObject, ResourceName: string): InternationalizationSettingsModel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InternationalizationSettingsModel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationSettingsModel;
	static C(Other: UObject): InternationalizationSettingsModel;
}

declare class PropertyConfigFileDisplayRow extends UObject { 
	/**
	 * Config File Name
	*/
	ConfigFileName: string;
	/**
	 * External Property
	*/
	ExternalProperty: Property;
	/**
	 * Is File Writable
	*/
	bIsFileWritable: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PropertyConfigFileDisplayRow;
	static Find(Outer: UObject, ResourceName: string): PropertyConfigFileDisplayRow;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PropertyConfigFileDisplayRow;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyConfigFileDisplayRow;
	static C(Other: UObject): PropertyConfigFileDisplayRow;
}

declare class ConfigHierarchyPropertyView extends UObject { 
	/**
	 * Edit Property
	*/
	EditProperty: any;
	/**
	 * Config File Property Objects
	*/
	ConfigFilePropertyObjects: PropertyConfigFileDisplayRow[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ConfigHierarchyPropertyView;
	static Find(Outer: UObject, ResourceName: string): ConfigHierarchyPropertyView;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ConfigHierarchyPropertyView;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ConfigHierarchyPropertyView;
	static C(Other: UObject): ConfigHierarchyPropertyView;
}

declare class K2Node_CreateDragDropOperation extends K2Node_ConstructObjectFromClass { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CreateDragDropOperation;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateDragDropOperation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CreateDragDropOperation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateDragDropOperation;
	static C(Other: UObject): K2Node_CreateDragDropOperation;
}

declare class K2Node_CreateWidget extends K2Node_ConstructObjectFromClass { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_CreateWidget;
	static Find(Outer: UObject, ResourceName: string): K2Node_CreateWidget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_CreateWidget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_CreateWidget;
	static C(Other: UObject): K2Node_CreateWidget;
}

declare class SlateVectorArtDataFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SlateVectorArtDataFactory;
	static Find(Outer: UObject, ResourceName: string): SlateVectorArtDataFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SlateVectorArtDataFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SlateVectorArtDataFactory;
	static C(Other: UObject): SlateVectorArtDataFactory;
}

declare class EditorPropertyPathSegment { 
	/**
	 * The owner of the path segment (ie. What class or structure was this property from)
	*/
	Struct: Struct;
	/**
	 * The member name in the structure this segment represents.
	*/
	MemberName: string;
	/**
	 * The member guid in this structure this segment represents.  If this is valid it should
	 * be used instead of Name to get the true name.
	*/
	MemberGuid: Guid;
	/**
	 * true if property, false if function
	*/
	IsProperty: boolean;
	clone() : EditorPropertyPathSegment;
	static C(Other: UObject): EditorPropertyPathSegment;
}

declare class EditorPropertyPath { 
	/**
	 * The path of properties.
	*/
	Segments: EditorPropertyPathSegment[];
	clone() : EditorPropertyPath;
	static C(Other: UObject): EditorPropertyPath;
}

declare class DelegateEditorBinding { 
	/**
	 * The member widget the binding is on, must be a direct variable of the UUserWidget.
	*/
	ObjectName: string;
	/**
	 * The property on the ObjectName that we are binding to.
	*/
	PropertyName: string;
	/**
	 * The function that was generated to return the SourceProperty
	*/
	FunctionName: string;
	/**
	 * The property we are bindings to directly on the source object.
	*/
	SourceProperty: string;
	/**
	 * Source Path
	*/
	SourcePath: EditorPropertyPath;
	/**
	 * If it's an actual Function Graph in the blueprint that we're bound to, there's a GUID we can use to lookup that function, to deal with renames better.  This is that GUID.
	*/
	MemberGuid: Guid;
	/**
	 * Kind
	*/
	Kind: EBindingKind;
	clone() : DelegateEditorBinding;
	static C(Other: UObject): DelegateEditorBinding;
}

declare class WidgetAnimation_DEPRECATED { 
	/**
	 * Movie Scene
	*/
	MovieScene: MovieScene;
	/**
	 * Animation Bindings
	*/
	AnimationBindings: WidgetAnimationBinding[];
	clone() : WidgetAnimation_DEPRECATED;
	static C(Other: UObject): WidgetAnimation_DEPRECATED;
}

declare class WidgetBlueprint extends Blueprint { 
	/**
	 * A tree of the widget templates to be created
	*/
	WidgetTree: WidgetTree;
	/**
	 * Bindings
	*/
	Bindings: DelegateEditorBinding[];
	/**
	 * Animation Data
	*/
	AnimationData: WidgetAnimation_DEPRECATED[];
	/**
	 * Animations
	*/
	Animations: WidgetAnimation[];
	/**
	 * Don't directly modify this property to change the palette category.  The actual value is stored
	 * in the CDO of the UUserWidget, but a copy is stored here so that it's available in the serialized
	 * Tag data in the asset header for access in the FAssetData.
	*/
	PaletteCategory: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetBlueprint;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetBlueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprint;
	static C(Other: UObject): WidgetBlueprint;
}

declare class WidgetBlueprintFactory extends Factory { 
	/**
	 * The type of blueprint that will be created
	*/
	BlueprintType: EBlueprintType;
	/**
	 * The parent class of the created blueprint
	*/
	ParentClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetBlueprintFactory;
	static Find(Outer: UObject, ResourceName: string): WidgetBlueprintFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetBlueprintFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetBlueprintFactory;
	static C(Other: UObject): WidgetBlueprintFactory;
}

declare class WidgetDesignerSettings extends UObject { 
	/**
	 * If enabled, actor positions will snap to the grid.
	*/
	GridSnapEnabled: boolean;
	/**
	 * Grid Snap Size
	*/
	GridSnapSize: number;
	/**
	 * Lock to Panel on Drag by Default
	*/
	bLockToPanelOnDragByDefault: boolean;
	/**
	 * Show Outlines
	*/
	bShowOutlines: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetDesignerSettings;
	static Find(Outer: UObject, ResourceName: string): WidgetDesignerSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetDesignerSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetDesignerSettings;
	static C(Other: UObject): WidgetDesignerSettings;
}

declare class WidgetGraphSchema extends EdGraphSchema_K2 { 
	/**
	 * NAME Never as Pin
	*/
	NAME_NeverAsPin: string;
	/**
	 * NAME Pin Hidden by Default
	*/
	NAME_PinHiddenByDefault: string;
	/**
	 * NAME Pin Shown by Default
	*/
	NAME_PinShownByDefault: string;
	/**
	 * NAME Always as Pin
	*/
	NAME_AlwaysAsPin: string;
	/**
	 * NAME on Evaluate
	*/
	NAME_OnEvaluate: string;
	/**
	 * Default Evaluation Handler Name
	*/
	DefaultEvaluationHandlerName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetGraphSchema;
	static Find(Outer: UObject, ResourceName: string): WidgetGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetGraphSchema;
	static C(Other: UObject): WidgetGraphSchema;
}

declare class WidgetSlotPair extends UObject { 
	/**
	 * Widget Name
	*/
	WidgetName: string;
	/**
	 * Slot Property Names
	*/
	SlotPropertyNames: string[];
	/**
	 * Slot Property Values
	*/
	SlotPropertyValues: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetSlotPair;
	static Find(Outer: UObject, ResourceName: string): WidgetSlotPair;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetSlotPair;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetSlotPair;
	static C(Other: UObject): WidgetSlotPair;
}

declare class NiagaraActor extends Actor { 
	/**
	 * Niagara Component
	*/
	NiagaraComponent: NiagaraComponent;
	/**
	 * Sprite Component
	*/
	SpriteComponent: BillboardComponent;
	/**
	 * Arrow Component
	*/
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraActor;
	static C(Other: UObject): NiagaraActor;
}

declare class NiagaraMeshRendererProperties extends NiagaraEffectRendererProperties { 
	/**
	 * Particle Mesh
	*/
	ParticleMesh: StaticMesh;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraMeshRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraMeshRendererProperties;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraMeshRendererProperties;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraMeshRendererProperties;
	static C(Other: UObject): NiagaraMeshRendererProperties;
}

declare class NiagaraRibbonRendererProperties extends NiagaraEffectRendererProperties { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraRibbonRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraRibbonRendererProperties;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraRibbonRendererProperties;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraRibbonRendererProperties;
	static C(Other: UObject): NiagaraRibbonRendererProperties;
}

declare class NiagaraSpriteRendererProperties extends NiagaraEffectRendererProperties { 
	/**
	 * Sub Image Info
	*/
	SubImageInfo: Vector2D;
	/**
	 * BVelocity Aligned
	*/
	bBVelocityAligned: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraSpriteRendererProperties;
	static Find(Outer: UObject, ResourceName: string): NiagaraSpriteRendererProperties;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraSpriteRendererProperties;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSpriteRendererProperties;
	static C(Other: UObject): NiagaraSpriteRendererProperties;
}

declare class NiagaraEventReceiverEmitterAction_SpawnParticles extends NiagaraEventReceiverEmitterAction { 
	/**
	 * Number of particles to spawn per event received.
	*/
	NumParticles: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraEventReceiverEmitterAction_SpawnParticles;
	static Find(Outer: UObject, ResourceName: string): NiagaraEventReceiverEmitterAction_SpawnParticles;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraEventReceiverEmitterAction_SpawnParticles;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraEventReceiverEmitterAction_SpawnParticles;
	static C(Other: UObject): NiagaraEventReceiverEmitterAction_SpawnParticles;
}

declare class NiagaraFunctionLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): NiagaraFunctionLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraFunctionLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraFunctionLibrary;
	/**
	 * Spawn Effect Attached
	*/
	static SpawnEffectAttached(EffectTemplate: NiagaraEffect,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bAutoDestroy: boolean): NiagaraComponent;
	/**
	 * Spawns a Niagara effect at the specified world location/rotation
	 * @return                       The spawned UNiagaraComponent
	*/
	static SpawnEffectAtLocation(WorldContextObject: UObject,EffectTemplate: NiagaraEffect,Location: Vector,Rotation: Rotator,bAutoDestroy: boolean): NiagaraComponent;
	/**
	 * Set Update Script Constant
	*/
	static SetUpdateScriptConstant(Component: NiagaraComponent,EmitterName: string,ConstantName: string,Value: Vector): void;
	static C(Other: UObject): NiagaraFunctionLibrary;
}

declare class NiagaraSequence extends MovieSceneSequence { 
	/**
	 * Pointer to the movie scene that controls this sequence.
	*/
	MovieScene: MovieScene;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NiagaraSequence;
	static Find(Outer: UObject, ResourceName: string): NiagaraSequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NiagaraSequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NiagaraSequence;
	static C(Other: UObject): NiagaraSequence;
}

declare class AutomationPerformaceHelper extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AutomationPerformaceHelper;
	static Find(Outer: UObject, ResourceName: string): AutomationPerformaceHelper;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AutomationPerformaceHelper;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AutomationPerformaceHelper;
	/**
	 * Writes the current set of performance stats records to a csv file in the profiling directory. An additional directory and an extension override can also be used.
	*/
	WriteLogFile(CaptureDir: string,CaptureExtension: string): void;
	/**
	 * Will trigger a GPU trace next time the current test falls below GPU budget.
	*/
	TriggerGPUTraceIfRecordFallsBelowBudget(): void;
	/**
	 * Begin basic stat recording
	*/
	Tick(DeltaSeconds: number): void;
	/**
	 * Communicates with external profiler to end a CPU capture.
	*/
	StopCPUProfiling(): void;
	/**
	 * Communicates with external profiler to being a CPU capture.
	*/
	StartCPUProfiling(): void;
	/**
	 * Adds a sample to the stats counters for the current performance stats record.
	*/
	Sample(DeltaSeconds: number): void;
	/**
	 * Does any init work across all tests..
	*/
	OnBeginTests(): void;
	/**
	 * Does any final work needed as all tests are complete.
	*/
	OnAllTestsComplete(): void;
	/**
	 * Returns true if this stats tracker is currently recording performance stats.
	*/
	IsRecording(): boolean;
	/**
	 * Is Current Record Within Render Thread Budget
	*/
	IsCurrentRecordWithinRenderThreadBudget(): boolean;
	/**
	 * Is Current Record Within GPUBudget
	*/
	IsCurrentRecordWithinGPUBudget(): boolean;
	/**
	 * Is Current Record Within Game Thread Budget
	*/
	IsCurrentRecordWithinGameThreadBudget(): boolean;
	/**
	 * Ends recording stats to a file.
	*/
	EndStatsFile(): void;
	/**
	 * Stops recording the baseline and moves to the main record.
	*/
	EndRecordingBaseline(): void;
	/**
	 * Stops recording performance stats.
	*/
	EndRecording(): void;
	/**
	 * Begins recording stats to a file.
	*/
	BeginStatsFile(RecordName: string): void;
	/**
	 * Begins recording a new named performance stats record. We start by recording the baseline
	*/
	BeginRecordingBaseline(RecordName: string): void;
	/**
	 * Begins recording a new named performance stats record. We start by recording the baseline.
	*/
	BeginRecording(RecordName: string,InGPUBudget: number,InRenderThreadBudget: number,InGameThreadBudget: number): void;
	static C(Other: UObject): AutomationPerformaceHelper;
}

declare type EFunctionalTestResult = string | symbol;
declare var EFunctionalTestResult = { Invalid:'Invalid',Error:'Error',Running:'Running',Failed:'Failed',Succeeded:'Succeeded', };
declare class FuncTestRenderingComponent extends PrimitiveComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FuncTestRenderingComponent;
	static Find(Outer: UObject, ResourceName: string): FuncTestRenderingComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FuncTestRenderingComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FuncTestRenderingComponent;
	static C(Other: UObject): FuncTestRenderingComponent;
}

declare class FunctionalTest extends Actor { 
	/**
	 * Sprite Component
	*/
	SpriteComponent: BillboardComponent;
	/**
	 * Result
	*/
	Result: EFunctionalTestResult;
	/**
	 * If test is limited by time this is the result that will be returned when time runs out
	*/
	TimesUpResult: EFunctionalTestResult;
	/**
	 * Test's time limit. '0' means no limit
	*/
	TimeLimit: number;
	/**
	 * Times Up Message
	*/
	TimesUpMessage: string;
	/**
	 * Observation Point
	*/
	ObservationPoint: Actor;
	/**
	 * Called when the test is started
	*/
	OnTestStart: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when the test is finished. Use it to clean up
	*/
	OnTestFinished: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Auto Destroy Actors
	*/
	AutoDestroyActors: Actor[];
	/**
	 * Random Numbers Stream
	*/
	RandomNumbersStream: RandomStream;
	/**
	 * Description
	*/
	Description: string;
	/**
	 * Render Comp
	*/
	RenderComp: FuncTestRenderingComponent;
	/**
	 * Is Enabled
	*/
	bIsEnabled: boolean;
	/**
	 * Is Running
	*/
	bIsRunning: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FunctionalTest;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTest;
	/**
	 * Set Time Limit
	*/
	SetTimeLimit(NewTimeLimit: number,ResultWhenTimeRunsOut: EFunctionalTestResult): void;
	/**
	 * ACtors registered this way will be automatically destroyed (by limiting their lifespan)
	 *     on test finish
	*/
	RegisterAutoDestroyActor(ActorToAutoDestroy: Actor): void;
	/**
	 * retrieves information whether test wants to have another run just after finishing
	*/
	OnWantsReRunCheck(): boolean;
	/**
	 * On Additional Test Finished Message Request
	*/
	OnAdditionalTestFinishedMessageRequest(TestResult: EFunctionalTestResult): string;
	/**
	 * Log Message
	*/
	LogMessage(Message: string): void;
	/**
	 * Returns the current re-run reason if we're in a named re-run.
	*/
	GetCurrentRerunReason(): string;
	/**
	 * Finish Test
	*/
	FinishTest(TestResult: EFunctionalTestResult,Message: string): void;
	/**
	 * Used by debug drawing to gather actors this test is using and point at them on the level to better understand test's setup
	*/
	DebugGatherRelevantActors(): Actor[];
	/**
	 * Causes the test to be rerun for a specific named reason.
	*/
	AddRerun(Reason: string): void;
	static C(Other: UObject): FunctionalTest;
}

declare class GenericTeamId { 
	/**
	 * Team ID
	*/
	TeamID: number;
	clone() : GenericTeamId;
	static C(Other: UObject): GenericTeamId;
}

declare class AITestSpawnInfo { 
	/**
	 * Determines AI to be spawned
	*/
	PawnClass: UnrealEngineClass;
	/**
	 * class to override default pawn's controller class. If None the default will be used
	*/
	ControllerClass: UnrealEngineClass;
	/**
	 * Team ID
	*/
	TeamID: GenericTeamId;
	/**
	 * if set will be applied to spawned AI
	*/
	BehaviorTree: BehaviorTree;
	/**
	 * Where should AI be spawned
	*/
	SpawnLocation: Actor;
	/**
	 * Number to Spawn
	*/
	NumberToSpawn: number;
	/**
	 * delay between consecutive spawn attempts
	*/
	SpawnDelay: number;
	/**
	 * delay before attempting first spawn
	*/
	PreSpawnDelay: number;
	clone() : AITestSpawnInfo;
	static C(Other: UObject): AITestSpawnInfo;
}

declare class AITestSpawnSet { 
	/**
	 * what to spawn
	*/
	SpawnInfoContainer: AITestSpawnInfo[];
	/**
	 * give the set a name to help identify it if need be
	*/
	Name: string;
	/**
	 * Enabled
	*/
	bEnabled: boolean;
	/**
	 * location used for spawning if spawn info doesn't define one
	*/
	FallbackSpawnLocation: Actor;
	clone() : AITestSpawnSet;
	static C(Other: UObject): AITestSpawnSet;
}

declare class PendingDelayedSpawn extends AITestSpawnInfo { 
	clone() : PendingDelayedSpawn;
	static C(Other: UObject): PendingDelayedSpawn;
}

declare class FunctionalAITest extends FunctionalTest { 
	/**
	 * Spawn Sets
	*/
	SpawnSets: AITestSpawnSet[];
	/**
	 * Spawn Location Randomization Range
	*/
	SpawnLocationRandomizationRange: number;
	/**
	 * Spawned Pawns
	*/
	SpawnedPawns: Pawn[];
	/**
	 * Pending Delayed Spawns
	*/
	PendingDelayedSpawns: PendingDelayedSpawn[];
	/**
	 * Called when a single AI finished spawning
	*/
	OnAISpawned: UnrealEngineMulticastDelegate<(Controller: AIController, Pawn: Pawn) => void>;
	/**
	 * Called when a all AI finished spawning
	*/
	OnAllAISPawned: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * if set, ftest will postpone start until navmesh is fully generated
	*/
	bWaitForNavMesh: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FunctionalAITest;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalAITest;
	/**
	 * Is One Of Spawned Pawns
	*/
	IsOneOfSpawnedPawns(Actor: Actor): boolean;
	static C(Other: UObject): FunctionalAITest;
}

declare class FunctionalTestingManager extends BlueprintFunctionLibrary { 
	/**
	 * Tests Left
	*/
	TestsLeft: FunctionalTest[];
	/**
	 * All Tests
	*/
	AllTests: FunctionalTest[];
	/**
	 * On Setup Tests
	*/
	OnSetupTests: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * On Tests Complete
	*/
	OnTestsComplete: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * On Tests Begin
	*/
	OnTestsBegin: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FunctionalTestingManager;
	static Find(Outer: UObject, ResourceName: string): FunctionalTestingManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FunctionalTestingManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FunctionalTestingManager;
	/**
	 * Triggers in sequence all functional tests found on the level.
	 *     @return true if any tests have been triggered
	*/
	static RunAllFunctionalTests(WorldContext: UObject,bNewLog: boolean,bRunLooped: boolean,bWaitForNavigationBuildFinish: boolean,FailedTestsReproString: string): boolean;
	static C(Other: UObject): FunctionalTestingManager;
}

declare class PhasedAutomationActorBase extends Actor { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhasedAutomationActorBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhasedAutomationActorBase;
	/**
	 * On Functional Testing Complete
	*/
	OnFunctionalTestingComplete(): void;
	/**
	 * On Functional Testing Begin
	*/
	OnFunctionalTestingBegin(): void;
	static C(Other: UObject): PhasedAutomationActorBase;
}

declare class AIGraph extends EdGraph { 
	/**
	 * Graph Version
	*/
	GraphVersion: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIGraph;
	static Find(Outer: UObject, ResourceName: string): AIGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraph;
	static C(Other: UObject): AIGraph;
}

declare class GraphNodeClassData { 
	/**
	 * path to class if it's not loaded yet
	*/
	AssetName: string;
	/**
	 * Generated Class Package
	*/
	GeneratedClassPackage: string;
	/**
	 * resolved name of class from asset data
	*/
	ClassName: string;
	/**
	 * User-defined category for this class
	*/
	Category: string;
	clone() : GraphNodeClassData;
	static C(Other: UObject): GraphNodeClassData;
}

declare class AIGraphNode extends EdGraphNode { 
	/**
	 * instance class
	*/
	ClassData: GraphNodeClassData;
	/**
	 * Node Instance
	*/
	NodeInstance: UObject;
	/**
	 * Parent Node
	*/
	ParentNode: AIGraphNode;
	/**
	 * Sub Nodes
	*/
	SubNodes: AIGraphNode[];
	/**
	 * subnode index assigned during copy operation to connect nodes again on paste
	*/
	CopySubNodeIndex: number;
	/**
	 * if set, all modifications (including delete/cut) are disabled
	*/
	bIsReadOnly: boolean;
	/**
	 * if set, this node will be always considered as subnode
	*/
	bIsSubNode: boolean;
	/**
	 * error message for node
	*/
	ErrorMessage: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIGraphNode;
	static Find(Outer: UObject, ResourceName: string): AIGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraphNode;
	static C(Other: UObject): AIGraphNode;
}

declare class AIGraphSchema extends EdGraphSchema { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIGraphSchema;
	static Find(Outer: UObject, ResourceName: string): AIGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIGraphSchema;
	static C(Other: UObject): AIGraphSchema;
}

declare class BehaviorTreeDecoratorGraph extends EdGraph { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeDecoratorGraph;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeDecoratorGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraph;
	static C(Other: UObject): BehaviorTreeDecoratorGraph;
}

declare class BehaviorTreeDecoratorGraphNode extends EdGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode;
	static C(Other: UObject): BehaviorTreeDecoratorGraphNode;
}

declare class BehaviorTreeEditorTypes extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeEditorTypes;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeEditorTypes;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeEditorTypes;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeEditorTypes;
	static C(Other: UObject): BehaviorTreeEditorTypes;
}

declare class BehaviorTreeDecoratorGraphNode_Decorator extends BehaviorTreeDecoratorGraphNode { 
	/**
	 * Node Instance
	*/
	NodeInstance: UObject;
	/**
	 * Class Data
	*/
	ClassData: GraphNodeClassData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode_Decorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode_Decorator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode_Decorator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode_Decorator;
	static C(Other: UObject): BehaviorTreeDecoratorGraphNode_Decorator;
}

declare type EDecoratorLogicMode = string | symbol;
declare var EDecoratorLogicMode = { Sink:'Sink',And:'And',Or:'Or',Not:'Not', };
declare class BehaviorTreeDecoratorGraphNode_Logic extends BehaviorTreeDecoratorGraphNode { 
	/**
	 * Logic Mode
	*/
	LogicMode: EDecoratorLogicMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeDecoratorGraphNode_Logic;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeDecoratorGraphNode_Logic;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeDecoratorGraphNode_Logic;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeDecoratorGraphNode_Logic;
	static C(Other: UObject): BehaviorTreeDecoratorGraphNode_Logic;
}

declare class BehaviorTreeFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeFactory;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeFactory;
	static C(Other: UObject): BehaviorTreeFactory;
}

declare class BehaviorTreeGraph extends AIGraph { 
	/**
	 * increased with every graph rebuild, used to refresh data from subtrees
	*/
	ModCounter: number;
	/**
	 * Is Using Mod Counter
	*/
	bIsUsingModCounter: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraph;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraph;
	static C(Other: UObject): BehaviorTreeGraph;
}

declare class BehaviorTreeGraphNode extends AIGraphNode { 
	/**
	 * only some of behavior tree nodes support decorators
	*/
	Decorators: BehaviorTreeGraphNode[];
	/**
	 * only some of behavior tree nodes support services
	*/
	Services: BehaviorTreeGraphNode[];
	/**
	 * if set, this node was injected from subtree and shouldn't be edited
	*/
	bInjectedNode: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode;
	static C(Other: UObject): BehaviorTreeGraphNode;
}

declare class BehaviorTreeGraphNode_Composite extends BehaviorTreeGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode_Composite;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Composite;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode_Composite;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Composite;
	static C(Other: UObject): BehaviorTreeGraphNode_Composite;
}

declare class BehaviorTreeGraphNode_SimpleParallel extends BehaviorTreeGraphNode_Composite { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode_SimpleParallel;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_SimpleParallel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode_SimpleParallel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_SimpleParallel;
	static C(Other: UObject): BehaviorTreeGraphNode_SimpleParallel;
}

declare class BehaviorTreeGraphNode_CompositeDecorator extends BehaviorTreeGraphNode { 
	/**
	 * The logic graph for this decorator (returning a boolean)
	*/
	BoundGraph: EdGraph;
	/**
	 * Composite Name
	*/
	CompositeName: string;
	/**
	 * if set, all logic operations will be shown in description
	*/
	bShowOperations: boolean;
	/**
	 * updated with internal graph changes, set when decorators inside can abort flow
	*/
	bCanAbortFlow: boolean;
	/**
	 * Parent Node Instance
	*/
	ParentNodeInstance: BTCompositeNode;
	/**
	 * Cached Description
	*/
	CachedDescription: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode_CompositeDecorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_CompositeDecorator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode_CompositeDecorator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_CompositeDecorator;
	static C(Other: UObject): BehaviorTreeGraphNode_CompositeDecorator;
}

declare class BehaviorTreeGraphNode_Decorator extends BehaviorTreeGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode_Decorator;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Decorator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode_Decorator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Decorator;
	static C(Other: UObject): BehaviorTreeGraphNode_Decorator;
}

declare class BehaviorTreeGraphNode_Root extends BehaviorTreeGraphNode { 
	/**
	 * Blackboard Asset
	*/
	BlackboardAsset: BlackboardData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode_Root;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Root;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode_Root;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Root;
	static C(Other: UObject): BehaviorTreeGraphNode_Root;
}

declare class BehaviorTreeGraphNode_Service extends BehaviorTreeGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode_Service;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Service;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode_Service;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Service;
	static C(Other: UObject): BehaviorTreeGraphNode_Service;
}

declare class BehaviorTreeGraphNode_Task extends BehaviorTreeGraphNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode_Task;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_Task;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode_Task;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_Task;
	static C(Other: UObject): BehaviorTreeGraphNode_Task;
}

declare class BehaviorTreeGraphNode_SubtreeTask extends BehaviorTreeGraphNode_Task { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeGraphNode_SubtreeTask;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeGraphNode_SubtreeTask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeGraphNode_SubtreeTask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeGraphNode_SubtreeTask;
	static C(Other: UObject): BehaviorTreeGraphNode_SubtreeTask;
}

declare class BlackboardDataFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardDataFactory;
	static Find(Outer: UObject, ResourceName: string): BlackboardDataFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardDataFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardDataFactory;
	static C(Other: UObject): BlackboardDataFactory;
}

declare class EdGraphSchema_BehaviorTree extends AIGraphSchema { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphSchema_BehaviorTree;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_BehaviorTree;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphSchema_BehaviorTree;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_BehaviorTree;
	static C(Other: UObject): EdGraphSchema_BehaviorTree;
}

declare class EdGraphSchema_BehaviorTreeDecorator extends EdGraphSchema { 
	/**
	 * PC Boolean
	*/
	PC_Boolean: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphSchema_BehaviorTreeDecorator;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema_BehaviorTreeDecorator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphSchema_BehaviorTreeDecorator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema_BehaviorTreeDecorator;
	static C(Other: UObject): EdGraphSchema_BehaviorTreeDecorator;
}

declare class K2Node_LatentGameplayTaskCall extends K2Node_BaseAsyncTask { 
	/**
	 * Spawn Param Pins
	*/
	SpawnParamPins: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): K2Node_LatentGameplayTaskCall;
	static Find(Outer: UObject, ResourceName: string): K2Node_LatentGameplayTaskCall;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): K2Node_LatentGameplayTaskCall;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): K2Node_LatentGameplayTaskCall;
	static C(Other: UObject): K2Node_LatentGameplayTaskCall;
}

declare class GizmoHandle { 
	clone() : GizmoHandle;
	static C(Other: UObject): GizmoHandle;
}

declare class GizmoHandleGroup extends SceneComponent { 
	/**
	 * Gizmo material (opaque)
	*/
	GizmoMaterial: MaterialInterface;
	/**
	 * Gizmo material (translucent)
	*/
	TranslucentGizmoMaterial: MaterialInterface;
	/**
	 * All the StaticMeshes for this handle type
	*/
	Handles: GizmoHandle[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): GizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GizmoHandleGroup;
	static C(Other: UObject): GizmoHandleGroup;
}

declare class ViewportInteractor extends UObject { 
	/**
	 * The owning world interaction
	*/
	WorldInteraction: ViewportWorldInteraction;
	/**
	 * The paired interactor by the world interaction
	*/
	OtherInteractor: ViewportInteractor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ViewportInteractor;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ViewportInteractor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractor;
	static C(Other: UObject): ViewportInteractor;
}

declare class ViewportWorldInteraction extends UObject { 
	/**
	 * All the interactors registered to modify the world
	*/
	Interactors: ViewportInteractor[];
	/**
	 * Transform gizmo actor, for manipulating selected actor(s)
	*/
	TransformGizmoActor: BaseTransformGizmo;
	/**
	 * Actor for the snap grid
	*/
	SnapGridActor: Actor;
	/**
	 * The plane mesh we use to draw a snap grid under selected objects
	*/
	SnapGridMeshComponent: StaticMeshComponent;
	/**
	 * MID for the snap grid, so we can update snap values on the fly
	*/
	SnapGridMID: MaterialInstanceDynamic;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ViewportWorldInteraction;
	static Find(Outer: UObject, ResourceName: string): ViewportWorldInteraction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ViewportWorldInteraction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportWorldInteraction;
	static C(Other: UObject): ViewportWorldInteraction;
}

declare class BaseTransformGizmo extends Actor { 
	/**
	 * Scene component root of this actor
	*/
	SceneComponent: SceneComponent;
	/**
	 * Gizmo material (opaque)
	*/
	GizmoMaterial: MaterialInterface;
	/**
	 * Gizmo material (translucent)
	*/
	TranslucentGizmoMaterial: MaterialInterface;
	/**
	 * All gizmo components
	*/
	AllHandleGroups: GizmoHandleGroup[];
	/**
	 * Owning object
	*/
	WorldInteraction: ViewportWorldInteraction;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BaseTransformGizmo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BaseTransformGizmo;
	static C(Other: UObject): BaseTransformGizmo;
}

declare class AxisGizmoHandleGroup extends GizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AxisGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): AxisGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AxisGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AxisGizmoHandleGroup;
	static C(Other: UObject): AxisGizmoHandleGroup;
}

declare class UniformScaleGizmoHandleGroup extends GizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UniformScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): UniformScaleGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UniformScaleGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformScaleGizmoHandleGroup;
	static C(Other: UObject): UniformScaleGizmoHandleGroup;
}

declare class PivotTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PivotTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotTranslationGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PivotTranslationGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTranslationGizmoHandleGroup;
	static C(Other: UObject): PivotTranslationGizmoHandleGroup;
}

declare class PivotScaleGizmoHandleGroup extends AxisGizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PivotScaleGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotScaleGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PivotScaleGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotScaleGizmoHandleGroup;
	static C(Other: UObject): PivotScaleGizmoHandleGroup;
}

declare class PivotPlaneTranslationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotPlaneTranslationGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PivotPlaneTranslationGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotPlaneTranslationGizmoHandleGroup;
	static C(Other: UObject): PivotPlaneTranslationGizmoHandleGroup;
}

declare class PivotRotationGizmoHandleGroup extends AxisGizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PivotRotationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): PivotRotationGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PivotRotationGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotRotationGizmoHandleGroup;
	static C(Other: UObject): PivotRotationGizmoHandleGroup;
}

declare class StretchGizmoHandleGroup extends GizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StretchGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): StretchGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StretchGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StretchGizmoHandleGroup;
	static C(Other: UObject): StretchGizmoHandleGroup;
}

declare class PivotTransformGizmo extends BaseTransformGizmo { 
	/**
	 * Uniform scale handle group component
	*/
	UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
	/**
	 * Translation handle group component
	*/
	TranslationGizmoHandleGroup: PivotTranslationGizmoHandleGroup;
	/**
	 * Scale handle group component
	*/
	ScaleGizmoHandleGroup: PivotScaleGizmoHandleGroup;
	/**
	 * Plane translation handle group component
	*/
	PlaneTranslationGizmoHandleGroup: PivotPlaneTranslationGizmoHandleGroup;
	/**
	 * Rotation handle group component
	*/
	RotationGizmoHandleGroup: PivotRotationGizmoHandleGroup;
	/**
	 * Stretch handle group component
	*/
	StretchGizmoHandleGroup: StretchGizmoHandleGroup;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PivotTransformGizmo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PivotTransformGizmo;
	static C(Other: UObject): PivotTransformGizmo;
}

declare class ViewportDragOperation extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ViewportDragOperation;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ViewportDragOperation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperation;
	static C(Other: UObject): ViewportDragOperation;
}

declare class ViewportDragOperationComponent extends ActorComponent { 
	/**
	 * The actual dragging implementation
	*/
	DragOperation: ViewportDragOperation;
	/**
	 * The next class that will be used as drag operation
	*/
	DragOperationSubclass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ViewportDragOperationComponent;
	static Find(Outer: UObject, ResourceName: string): ViewportDragOperationComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ViewportDragOperationComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportDragOperationComponent;
	static C(Other: UObject): ViewportDragOperationComponent;
}

declare class ViewportInteractableInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ViewportInteractableInterface;
	static Find(Outer: UObject, ResourceName: string): ViewportInteractableInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ViewportInteractableInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportInteractableInterface;
	static C(Other: UObject): ViewportInteractableInterface;
}

declare class MouseCursorInteractor extends ViewportInteractor { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MouseCursorInteractor;
	static Find(Outer: UObject, ResourceName: string): MouseCursorInteractor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MouseCursorInteractor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MouseCursorInteractor;
	static C(Other: UObject): MouseCursorInteractor;
}

declare class ViewportWorldInteractionInterface extends Interface { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ViewportWorldInteractionInterface;
	static Find(Outer: UObject, ResourceName: string): ViewportWorldInteractionInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ViewportWorldInteractionInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ViewportWorldInteractionInterface;
	static C(Other: UObject): ViewportWorldInteractionInterface;
}

declare class VREditorBaseActor extends Actor { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorBaseActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorBaseActor;
	static C(Other: UObject): VREditorBaseActor;
}

declare class VREditorBaseUserWidget extends UserWidget { 
	/**
	 * The UI system that owns this widget
	*/
	Owner: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorBaseUserWidget;
	static Find(Outer: UObject, ResourceName: string): VREditorBaseUserWidget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorBaseUserWidget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorBaseUserWidget;
	static C(Other: UObject): VREditorBaseUserWidget;
}

declare type EVREditorWidgetDrawingPolicy = string | symbol;
declare var EVREditorWidgetDrawingPolicy = { Always:'Always',Hovering:'Hovering', };
declare class VREditorWidgetComponent extends WidgetComponent { 
	/**
	 * High level redrawing policy for the widget component.
	*/
	DrawingPolicy: EVREditorWidgetDrawingPolicy;
	/**
	 * Controls if we draw, the VREditorWidget allows for manual enabling or
	 * disabling of updating the slate widget.
	*/
	bIsHovering: boolean;
	/**
	 * Recorders if we've drawn at least once, that way we can always draw the first
	 * frame then go manual after that.
	*/
	bHasEverDrawn: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorWidgetComponent;
	static Find(Outer: UObject, ResourceName: string): VREditorWidgetComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorWidgetComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorWidgetComponent;
	static C(Other: UObject): VREditorWidgetComponent;
}

declare class VREditorFloatingUI extends VREditorBaseActor { 
	/**
	 * UMG user widget we're drawing, or nullptr if we're drawing a Slate widget
	*/
	UserWidget: VREditorBaseUserWidget;
	/**
	 * When in a spawned state, this is the widget component to represent the widget
	*/
	WidgetComponent: VREditorWidgetComponent;
	/**
	 * Class of the UMG widget we're spawning
	*/
	UserWidgetClass: UnrealEngineClass;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorFloatingUI;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorFloatingUI;
	static C(Other: UObject): VREditorFloatingUI;
}

declare class VREditorDockableWindow extends VREditorFloatingUI { 
	/**
	 * The dockable window mesh
	*/
	WindowMeshComponent: StaticMeshComponent;
	/**
	 * Mesh underneath the window for easy selecting and dragging
	*/
	SelectionBarMeshComponent: StaticMeshComponent;
	/**
	 * Mesh that represents the close button for this UI
	*/
	CloseButtonMeshComponent: StaticMeshComponent;
	/**
	 * Selection bar dynamic material  (opaque)
	*/
	SelectionBarMID: MaterialInstanceDynamic;
	/**
	 * Select bar dynamic material (translucent)
	*/
	SelectionBarTranslucentMID: MaterialInstanceDynamic;
	/**
	 * Close button dynamic material  (opaque)
	*/
	CloseButtonMID: MaterialInstanceDynamic;
	/**
	 * Close button dynamic material (translucent)
	*/
	CloseButtonTranslucentMID: MaterialInstanceDynamic;
	/**
	 * Drag Operation Component
	*/
	DragOperationComponent: ViewportDragOperationComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorDockableWindow;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorDockableWindow;
	static C(Other: UObject): VREditorDockableWindow;
}

declare class DockableWindowDragOperation extends ViewportDragOperation { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DockableWindowDragOperation;
	static Find(Outer: UObject, ResourceName: string): DockableWindowDragOperation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DockableWindowDragOperation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DockableWindowDragOperation;
	static C(Other: UObject): DockableWindowDragOperation;
}

declare class FloatingText extends Actor { 
	/**
	 * Scene component root of this actor
	*/
	SceneComponent: SceneComponent;
	/**
	 * First line segment component.  Starts at the designation location, goes toward the line connection point.
	*/
	FirstLineComponent: StaticMeshComponent;
	/**
	 * Sphere that connects the two line segments and makes the joint look smooth and round
	*/
	JointSphereComponent: StaticMeshComponent;
	/**
	 * Second line segment component.  Starts at the connection point and goes toward the 3D text.
	*/
	SecondLineComponent: StaticMeshComponent;
	/**
	 * The 3D text we're drawing.  Positioned at the end of the second line.
	*/
	TextComponent: TextRenderComponent;
	/**
	 * Masked text material.  Used after faded in
	*/
	MaskedTextMaterial: MaterialInterface;
	/**
	 * Translucent text material.  Used during fading
	*/
	TranslucentTextMaterial: MaterialInterface;
	/**
	 * Material to use for the line meshes
	*/
	LineMaterial: MaterialInterface;
	/**
	 * Dynamic material instance for fading lines in and out
	*/
	LineMaterialMID: MaterialInstanceDynamic;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FloatingText;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FloatingText;
	static C(Other: UObject): FloatingText;
}

declare class TransformGizmoMeasurement { 
	/**
	 * The text that displays the actual measurement and units
	*/
	MeasurementText: TextRenderComponent;
	clone() : TransformGizmoMeasurement;
	static C(Other: UObject): TransformGizmoMeasurement;
}

declare class VREditorTranslationGizmoHandleGroup extends GizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): VREditorTranslationGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorTranslationGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorTranslationGizmoHandleGroup;
	static C(Other: UObject): VREditorTranslationGizmoHandleGroup;
}

declare class VREditorPlaneTranslationGizmoHandleGroup extends GizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorPlaneTranslationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): VREditorPlaneTranslationGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorPlaneTranslationGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorPlaneTranslationGizmoHandleGroup;
	static C(Other: UObject): VREditorPlaneTranslationGizmoHandleGroup;
}

declare class VREditorRotationGizmoHandleGroup extends GizmoHandleGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorRotationGizmoHandleGroup;
	static Find(Outer: UObject, ResourceName: string): VREditorRotationGizmoHandleGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorRotationGizmoHandleGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorRotationGizmoHandleGroup;
	static C(Other: UObject): VREditorRotationGizmoHandleGroup;
}

declare class TransformGizmo extends BaseTransformGizmo { 
	/**
	 * Measurements, one for each axis
	*/
	Measurements: TransformGizmoMeasurement;
	/**
	 * Bounding box translation handles
	*/
	TranslationGizmoHandleGroup: VREditorTranslationGizmoHandleGroup;
	/**
	 * Bounding box plane translation handles
	*/
	PlaneTranslationGizmoHandleGroup: VREditorPlaneTranslationGizmoHandleGroup;
	/**
	 * Bounding box rotation handles
	*/
	RotationGizmoHandleGroup: VREditorRotationGizmoHandleGroup;
	/**
	 * Bounding box stretch handles
	*/
	StretchGizmoHandleGroup: StretchGizmoHandleGroup;
	/**
	 * Bounding box uniform scale handle
	*/
	UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TransformGizmo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TransformGizmo;
	static C(Other: UObject): TransformGizmo;
}

declare class VREditorAvatarActor extends Actor { 
	/**
	 * Our avatar's head mesh
	*/
	HeadMeshComponent: StaticMeshComponent;
	/**
	 * The grid that appears while the user is dragging the world around
	*/
	WorldMovementGridMeshComponent: StaticMeshComponent;
	/**
	 * Grid mesh component dynamic material instance to set the opacity
	*/
	WorldMovementGridMID: MaterialInstanceDynamic;
	/**
	 * Opacity of the movement grid and post process
	*/
	WorldMovementGridOpacity: number;
	/**
	 * True if we're currently drawing our world movement post process
	*/
	bIsDrawingWorldMovementPostProcess: boolean;
	/**
	 * Post process material for "greying out" the world while in world movement mode
	*/
	WorldMovementPostProcessMaterial: MaterialInstanceDynamic;
	/**
	 * Background progressbar scaling mesh
	*/
	ScaleProgressMeshComponent: StaticMeshComponent;
	/**
	 * Current scale progressbar mesh
	*/
	CurrentScaleProgressMeshComponent: StaticMeshComponent;
	/**
	 * Current scale text
	*/
	UserScaleIndicatorText: TextRenderComponent;
	/**
	 * Base dynamic material for the user scale fixed progressbar
	*/
	FixedUserScaleMID: MaterialInstanceDynamic;
	/**
	 * Translucent dynamic material for the user scale fixed progressbar
	*/
	TranslucentFixedUserScaleMID: MaterialInstanceDynamic;
	/**
	 * Base dynamic material for the current user scale progressbar
	*/
	CurrentUserScaleMID: MaterialInstanceDynamic;
	/**
	 * Translucent dynamic material for the current user scale progressbar
	*/
	TranslucentCurrentUserScaleMID: MaterialInstanceDynamic;
	/**
	 * Post process for drawing VR-specific post effects
	*/
	PostProcessComponent: PostProcessComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorAvatarActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorAvatarActor;
	static C(Other: UObject): VREditorAvatarActor;
}

declare class VREditorButton extends VREditorBaseActor { 
	/**
	 * Mesh for the button to interact with
	*/
	ButtonMeshComponent: StaticMeshComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorButton;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorButton;
	static C(Other: UObject): VREditorButton;
}

declare class VREditorQuickMenu extends VREditorBaseUserWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorQuickMenu;
	static Find(Outer: UObject, ResourceName: string): VREditorQuickMenu;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorQuickMenu;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorQuickMenu;
	/**
	 * Refresh UI
	*/
	Refresh(): void;
	/**
	 * On World Settings Button Clicked
	*/
	OnWorldSettingsButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On World Outliner Button Clicked
	*/
	OnWorldOutlinerButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Undo Button Clicked
	*/
	OnUndoButtonClicked(): void;
	/**
	 * On Tutorial Button Clicked
	*/
	OnTutorialButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Translation Snap Size Button Clicked
	*/
	OnTranslationSnapSizeButtonClicked(): string;
	/**
	 * On Translation Snap Button Clicked
	*/
	OnTranslationSnapButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Simulate Button Clicked
	*/
	OnSimulateButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Screenshot Button Clicked
	*/
	OnScreenshotButtonClicked(): void;
	/**
	 * On Scale Snap Size Button Clicked
	*/
	OnScaleSnapSizeButtonClicked(): string;
	/**
	 * On Scale Snap Button Clicked
	*/
	OnScaleSnapButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Rotation Snap Size Button Clicked
	*/
	OnRotationSnapSizeButtonClicked(): string;
	/**
	 * On Rotation Snap Button Clicked
	*/
	OnRotationSnapButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Redo Button Clicked
	*/
	OnRedoButtonClicked(): void;
	/**
	 * On Play Button Clicked
	*/
	OnPlayButtonClicked(): void;
	/**
	 * On Paste Button Clicked
	*/
	OnPasteButtonClicked(): void;
	/**
	 * On Modes Button Clicked
	*/
	OnModesButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Light Button Clicked
	*/
	OnLightButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Gizmo Mode Button Clicked
	*/
	OnGizmoModeButtonClicked(): string;
	/**
	 * On Gizmo Coordinate System Button Clicked
	*/
	OnGizmoCoordinateSystemButtonClicked(): string;
	/**
	 * On Game Mode Button Clicked
	*/
	OnGameModeButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * Event handlers.  These are called from the Blueprint when buttons are clicked.
	*/
	OnExitVRButtonClicked(): void;
	/**
	 * On Delete Button Clicked
	*/
	OnDeleteButtonClicked(): void;
	/**
	 * On Copy Button Clicked
	*/
	OnCopyButtonClicked(): void;
	/**
	 * On Content Browser Button Clicked
	*/
	OnContentBrowserButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Asset Editor Button Clicked
	*/
	OnAssetEditorButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * On Actor Details Button Clicked
	*/
	OnActorDetailsButtonClicked(bIsChecked: boolean): boolean;
	/**
	 * Is World Settings Visible
	*/
	IsWorldSettingsVisible(): boolean;
	/**
	 * Is World Outliner Visible
	*/
	IsWorldOutlinerVisible(): boolean;
	/**
	 * Is Tutorial Visible
	*/
	IsTutorialVisible(): boolean;
	/**
	 * Is Translation Snap Enabled
	*/
	IsTranslationSnapEnabled(): boolean;
	/**
	 * Is Simulating Enabled
	*/
	IsSimulatingEnabled(): boolean;
	/**
	 * Is Scale Snap Enabled
	*/
	IsScaleSnapEnabled(): boolean;
	/**
	 * Is Rotation Snap Enabled
	*/
	IsRotationSnapEnabled(): boolean;
	/**
	 * Is Modes Visible
	*/
	IsModesVisible(): boolean;
	/**
	 * Is Light Visible
	*/
	IsLightVisible(): boolean;
	/**
	 * Is Game Mode Enabled
	*/
	IsGameModeEnabled(): boolean;
	/**
	 * Is Content Browser Visible
	*/
	IsContentBrowserVisible(): boolean;
	/**
	 * Is Asset Editor Visible
	*/
	IsAssetEditorVisible(): boolean;
	/**
	 * Is Actor Details Visible
	*/
	IsActorDetailsVisible(): boolean;
	/**
	 * Get Translation Snap Size Text
	*/
	GetTranslationSnapSizeText(): string;
	/**
	 * Get Scale Snap Size Text
	*/
	GetScaleSnapSizeText(): string;
	/**
	 * Get Rotation Snap Size Text
	*/
	GetRotationSnapSizeText(): string;
	/**
	 * Get Gizmo Mode Text
	*/
	GetGizmoModeText(): string;
	/**
	 * Get Gizmo Coordinate System Text
	*/
	GetGizmoCoordinateSystemText(): string;
	static C(Other: UObject): VREditorQuickMenu;
}

declare class VREditorRadialMenuItem extends VREditorBaseUserWidget { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorRadialMenuItem;
	static Find(Outer: UObject, ResourceName: string): VREditorRadialMenuItem;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorRadialMenuItem;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorRadialMenuItem;
	/**
	 * Changes the text for this widget
	*/
	SetLabel(Text: string): void;
	/**
	 * Broadcasts the PressedDelegate
	*/
	OnPressed(): void;
	/**
	 * Update UI visuals
	*/
	OnLeaveHover(): void;
	/**
	 * Update UI visuals
	*/
	OnEnterHover(): void;
	/**
	 * Gets the angle from the pivot
	*/
	GetAngle(): number;
	static C(Other: UObject): VREditorRadialMenuItem;
}

declare class VREditorRadialMenu extends VREditorBaseUserWidget { 
	/**
	 * Current position of the trackpad to render line in UMG
	*/
	TrackpadPosition: Vector2D;
	/**
	 * Current angle of the trackpad position (-180 to 180) to visualize in UMG
	*/
	TrackpadAngle: number;
	/**
	 * All the buttons in the radial menu
	*/
	MenuItems: VREditorRadialMenuItem[];
	/**
	 * The current widget currently selected
	*/
	CurrentItem: VREditorRadialMenuItem;
	/**
	 * The previous item that was selected
	*/
	PreviousItem: VREditorRadialMenuItem;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorRadialMenu;
	static Find(Outer: UObject, ResourceName: string): VREditorRadialMenu;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorRadialMenu;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorRadialMenu;
	/**
	 * To bind the buttons from UMG
	*/
	SetButtons(InitTopItem: VREditorRadialMenuItem,InitTopRightItem: VREditorRadialMenuItem,InitRightItem: VREditorRadialMenuItem,InitBottomRightItem: VREditorRadialMenuItem,InitBottomItem: VREditorRadialMenuItem,InitLeftBottomItem: VREditorRadialMenuItem,InitLeftItem: VREditorRadialMenuItem,InitTopLeftItem: VREditorRadialMenuItem): void;
	static C(Other: UObject): VREditorRadialMenu;
}

declare class VREditorInteractor extends ViewportInteractor { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorInteractor;
	static Find(Outer: UObject, ResourceName: string): VREditorInteractor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorInteractor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorInteractor;
	static C(Other: UObject): VREditorInteractor;
}

declare class VREditorMotionControllerInteractor extends VREditorInteractor { 
	/**
	 * Motion controller component which handles late-frame transform updates of all parented sub-components
	*/
	MotionControllerComponent: MotionControllerComponent;
	/**
	 * Mesh for this hand
	*/
	HandMeshComponent: StaticMeshComponent;
	/**
	 * Mesh for this hand's laser pointer
	*/
	LaserPointerMeshComponent: StaticMeshComponent;
	/**
	 * MID for laser pointer material (opaque parts)
	*/
	LaserPointerMID: MaterialInstanceDynamic;
	/**
	 * MID for laser pointer material (translucent parts)
	*/
	TranslucentLaserPointerMID: MaterialInstanceDynamic;
	/**
	 * Hover impact indicator mesh
	*/
	HoverMeshComponent: StaticMeshComponent;
	/**
	 * Hover point light
	*/
	HoverPointLightComponent: PointLightComponent;
	/**
	 * MID for hand mesh
	*/
	HandMeshMID: MaterialInstanceDynamic;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorMotionControllerInteractor;
	static Find(Outer: UObject, ResourceName: string): VREditorMotionControllerInteractor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorMotionControllerInteractor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorMotionControllerInteractor;
	static C(Other: UObject): VREditorMotionControllerInteractor;
}

declare class VREditorTeleporter extends UObject { 
	/**
	 * Teleport sound
	*/
	TeleportSound: SoundCue;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorTeleporter;
	static Find(Outer: UObject, ResourceName: string): VREditorTeleporter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorTeleporter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorTeleporter;
	static C(Other: UObject): VREditorTeleporter;
}

declare class VREditorUISystem extends UObject { 
	/**
	 * All of the floating UIs.  These may or may not be visible (spawned)
	*/
	FloatingUIs: VREditorFloatingUI[];
	/**
	 * Our Quick Menu UI
	*/
	QuickMenuUI: VREditorFloatingUI;
	/**
	 * Editor UI panels
	*/
	EditorUIPanels: VREditorFloatingUI[];
	/**
	 * The Radial Menu UI
	*/
	QuickRadialMenu: VREditorFloatingUI;
	/**
	 * The current UI that is being dragged
	*/
	DraggingUI: VREditorDockableWindow;
	/**
	 * Start dragging UI sound
	*/
	StartDragUISound: SoundCue;
	/**
	 * Stop dragging UI sound
	*/
	StopDragUISound: SoundCue;
	/**
	 * Hide UI sound
	*/
	HideUISound: SoundCue;
	/**
	 * Show UI sound
	*/
	ShowUISound: SoundCue;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorUISystem;
	static Find(Outer: UObject, ResourceName: string): VREditorUISystem;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorUISystem;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorUISystem;
	static C(Other: UObject): VREditorUISystem;
}

declare class VREditorWorldInteraction extends ViewportWorldInteraction { 
	/**
	 * Sound for dropping materials and textures
	*/
	DropMaterialOrMaterialSound: SoundCue;
	/**
	 * The UI used to drag an asset into the level
	*/
	FloatingUIAssetDraggedFrom: WidgetComponent;
	/**
	 * The material or texture asset we're dragging to place on an object
	*/
	PlacingMaterialOrTextureAsset: UObject;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VREditorWorldInteraction;
	static Find(Outer: UObject, ResourceName: string): VREditorWorldInteraction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VREditorWorldInteraction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VREditorWorldInteraction;
	static C(Other: UObject): VREditorWorldInteraction;
}

declare class ContentBrowserFrontEndFilterExtension extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static Find(Outer: UObject, ResourceName: string): ContentBrowserFrontEndFilterExtension;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ContentBrowserFrontEndFilterExtension;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ContentBrowserFrontEndFilterExtension;
	static C(Other: UObject): ContentBrowserFrontEndFilterExtension;
}

declare class GameplayTagSearchFilter extends ContentBrowserFrontEndFilterExtension { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagSearchFilter;
	static Find(Outer: UObject, ResourceName: string): GameplayTagSearchFilter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagSearchFilter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagSearchFilter;
	static C(Other: UObject): GameplayTagSearchFilter;
}

declare class GameplayTagsK2Node_LiteralGameplayTag extends K2Node { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsK2Node_LiteralGameplayTag;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_LiteralGameplayTag;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsK2Node_LiteralGameplayTag;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_LiteralGameplayTag;
	static C(Other: UObject): GameplayTagsK2Node_LiteralGameplayTag;
}

declare class GameplayTagsK2Node_MultiCompareBase extends K2Node { 
	/**
	 * Number Of Pins
	*/
	NumberOfPins: number;
	/**
	 * Pin Names
	*/
	PinNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareBase;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareBase;
	static C(Other: UObject): GameplayTagsK2Node_MultiCompareBase;
}

declare class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface extends GameplayTagsK2Node_MultiCompareBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
	static C(Other: UObject): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
}

declare class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags extends GameplayTagsK2Node_MultiCompareBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
	static C(Other: UObject): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
}

declare class GameplayTagsK2Node_MultiCompareGameplayTagContainer extends GameplayTagsK2Node_MultiCompareBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
	static C(Other: UObject): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
}

declare class GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags extends GameplayTagsK2Node_MultiCompareBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
	static C(Other: UObject): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
}

declare class GameplayTagsK2Node_SwitchGameplayTag extends K2Node_Switch { 
	/**
	 * Pin Tags
	*/
	PinTags: GameplayTag[];
	/**
	 * UPROPERTY(EditAnywhere, Category = PinOptions)
	 * bool UseInputsOnGraph;
	*/
	PinNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsK2Node_SwitchGameplayTag;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_SwitchGameplayTag;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsK2Node_SwitchGameplayTag;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_SwitchGameplayTag;
	static C(Other: UObject): GameplayTagsK2Node_SwitchGameplayTag;
}

declare class GameplayTagsK2Node_SwitchGameplayTagContainer extends K2Node_Switch { 
	/**
	 * Pin Containers
	*/
	PinContainers: GameplayTagContainer[];
	/**
	 * UPROPERTY(EditAnywhere, Category = PinOptions)
	 * bool UseInputsOnGraph;
	*/
	PinNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTagsK2Node_SwitchGameplayTagContainer;
	static Find(Outer: UObject, ResourceName: string): GameplayTagsK2Node_SwitchGameplayTagContainer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTagsK2Node_SwitchGameplayTagContainer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTagsK2Node_SwitchGameplayTagContainer;
	static C(Other: UObject): GameplayTagsK2Node_SwitchGameplayTagContainer;
}

declare class GameLiveStreamingFunctionLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameLiveStreamingFunctionLibrary;
	static Find(Outer: UObject, ResourceName: string): GameLiveStreamingFunctionLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameLiveStreamingFunctionLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameLiveStreamingFunctionLibrary;
	/**
	 * Stops the web camera, if it's currently capturing
	*/
	static StopWebCam(): void;
	/**
	 * Stops broadcasting the game
	*/
	static StopBroadcastingGame(): void;
	/**
	 * Starts capturing and displaying web camera video, if one is plugged in
	 * @param       DesiredWebCamWidth                      Desired web cam capture resolution width.  The web cam may only support a limited number of resolutions, so we'll choose one that matches as closely to this as possible
	 * @param       DesiredWebCamHeight                     Desired web cam capture resolution height.
	 * @param       bMirrorWebCamImage                      You can enable this to flip the web camera image horizontally, so that it looks like a mirror
	 * @param       bDrawSimpleWebCamVideo          If enabled, the engine will draw a simple web cam image on top of the game viewport.  If you turn this off, it's up to you to draw the web cam image yourself.  You can access the web cam texture by calling IGameLiveStreaming::Get().GetWebCamTexture().
	*/
	static StartWebCam(DesiredWebCamWidth: number,DesiredWebCamHeight: number,bMirrorWebCamImage: boolean,bDrawSimpleWebCamVideo: boolean): void;
	/**
	 * Starts broadcasting the game's video (and optionally audio) using an internet streaming service, if one is available
	 * @param       FrameRate                                       Frame rate to stream video from when broadcasting to services like Twitch.
	 * @param       ScreenScaling                           How much to scale the broadcast video resolution down to reduce streaming bandwidth.  We recommend broadcasting at resolutions of 1280x720 or lower.  Some live streaming providers will not be able to transcode your video to a lower resolution, so using a high resolution stream may prevent low-bandwidth users from having a good viewing experience.
	 * @param       bStartWebCam                            Starts your web camera right away.  When the web camera is active, video from your web camera will be captured and displayed while broadcasting, so that your viewers can see your presence.
	 * @param       DesiredWebCamWidth                      Desired web cam capture resolution width.  The web cam may only support a limited number of resolutions, so we'll choose one that matches as closely to this as possible
	 * @param       DesiredWebCamHeight                     Desired web cam capture resolution height.
	 * @param       bMirrorWebCamImage                      You can enable this to flip the web camera image horizontally, so that it looks like a mirror
	 * @param       bDrawSimpleWebCamVideo          If enabled, the engine will draw a simple web cam image on top of the game viewport.  If you turn this off, it's up to you to draw the web cam image yourself.  You can access the web cam texture by calling IGameLiveStreaming::Get().GetWebCamTexture().
	 * @param       bCaptureAudioFromComputer       Enables broadcast of audio being played by your computer, such as in-game sounds
	 * @param       bCaptureAudioFromMicrophone     Enables broadcast of audio from your default microphone recording device
	 * @param       CoverUpImage                            Optional image to broadcast, instead of what you're looking at on screen.  This is useful if you don't want to publicly share the visuals on screen.
	*/
	static StartBroadcastingGame(LoginUserName: string,LoginPassword: string,FrameRate: number,ScreenScaling: number,bStartWebCam: boolean,DesiredWebCamWidth: number,DesiredWebCamHeight: number,bMirrorWebCamImage: boolean,bDrawSimpleWebCamVideo: boolean,bCaptureAudioFromComputer: boolean,bCaptureAudioFromMicrophone: boolean,CoverUpImage: Texture2D): void;
	/**
	 * Returns whether or not the web camera is actively capturing
	 * @return      True if the web camera is available and currently capturing
	*/
	static IsWebCamEnabled(): boolean;
	/**
	 * Checks to see if we are currently broadcasting live video (and possibly audio) from the game's viewport
	 * @return      True if we are currently transmitting
	*/
	static IsBroadcastingGame(): boolean;
	static C(Other: UObject): GameLiveStreamingFunctionLibrary;
}

declare class BlueprintLiveStreamInfo { 
	/**
	 * Name of the game that is streaming
	*/
	GameName: string;
	/**
	 * The title of the stream itself
	*/
	StreamName: string;
	/**
	 * URL for the stream
	*/
	URL: string;
	clone() : BlueprintLiveStreamInfo;
	static C(Other: UObject): BlueprintLiveStreamInfo;
}

declare class QueryLiveStreamsCallbackProxy extends OnlineBlueprintCallProxyBase { 
	/**
	 * Called when the asynchronous request for live streams completes, passing along the list of live streams currently active, along with a boolean value that indicates whether the request was successful at all
	*/
	OnQueriedLiveStreams: UnrealEngineMulticastDelegate<(LiveStreams: BlueprintLiveStreamInfo[], bWasSuccessful: boolean) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): QueryLiveStreamsCallbackProxy;
	static Find(Outer: UObject, ResourceName: string): QueryLiveStreamsCallbackProxy;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): QueryLiveStreamsCallbackProxy;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): QueryLiveStreamsCallbackProxy;
	/**
	 * Requests a list of live internet streams for the specified game name.  This will usually hit the internet so it could take a second or two.
	*/
	static QueryLiveStreams(GameName: string): QueryLiveStreamsCallbackProxy;
	static C(Other: UObject): QueryLiveStreamsCallbackProxy;
}

declare class MediaTexture extends Texture { 
	/**
	 * The addressing mode to use for the X axis.
	*/
	AddressX: TextureAddress;
	/**
	 * The addressing mode to use for the Y axis.
	*/
	AddressY: TextureAddress;
	/**
	 * The color used to clear the texture if CloseAction is set to Clear (default = black).
	*/
	ClearColor: LinearColor;
	/**
	 * Media Player
	*/
	MediaPlayer: MediaPlayer;
	/**
	 * Video Track Index
	*/
	VideoTrackIndex: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaTexture;
	static Find(Outer: UObject, ResourceName: string): MediaTexture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaTexture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaTexture;
	static C(Other: UObject): MediaTexture;
}

declare class MediaSource extends UObject { 
	/**
	 * Name of the default native media player for all platforms (Empty = find one automatically).
	*/
	DefaultPlayer: string;
	/**
	 * Override native media player plug-ins per platform (Empty = find one automatically).
	*/
	PlatformPlayers: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaSource;
	static Find(Outer: UObject, ResourceName: string): MediaSource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaSource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaSource;
	static C(Other: UObject): MediaSource;
}

declare class MediaPlaylist extends UObject { 
	/**
	 * List of media sources to play.
	*/
	Items: MediaSource[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaPlaylist;
	static Find(Outer: UObject, ResourceName: string): MediaPlaylist;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaPlaylist;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlaylist;
	/**
	 * Remove the media source at the specified position.
	 * @param Index The index of the media source to remove.
	 * @see Add, Insert, RemoveAll
	*/
	RemoveAt(Index: number): void;
	/**
	 * Remove all occurrences of the given media source in the play list.
	 * @param MediaSource The media source to remove.
	 * @see Add, Insert, Remove
	*/
	Remove(MediaSource: MediaSource): void;
	/**
	 * Get the number of media sources in the play list.
	 * @return Number of media sources.
	*/
	Num(): number;
	/**
	 * Insert a media source into the play list at the given position.
	 * @param MediaSource The media source to insert.
	 * @param Index The index to insert into.
	 * @see Add, Remove, RemoveAll
	*/
	Insert(MediaSource: MediaSource,Index: number): void;
	/**
	 * Get a random media source in the play list.
	 * @param InOutIndex Index of the current media source (will contain the new index).
	 * @return The random media source, or nullptr if the list is empty.
	 * @see Get, GetNext, GetPrevious
	*/
	GetRandom(InOutIndex?: number): {InOutIndex: number, $: MediaSource};
	/**
	 * Get the previous media source in the play list.
	 * @param InOutIndex Index of the current media source (will contain the new index).
	 * @return The media source before the current one, or nullptr if the list is empty.
	 * @see , GetNext, GetRandom
	*/
	GetPrevious(InOutIndex?: number): {InOutIndex: number, $: MediaSource};
	/**
	 * Get the next media source in the play list.
	 * @param InOutIndex Index of the current media source (will contain the new index).
	 * @return The media source after the current one, or nullptr if the list is empty.
	 * @see , GetPrevious, GetRandom
	*/
	GetNext(InOutIndex?: number): {InOutIndex: number, $: MediaSource};
	/**
	 * Get the media source at the specified index.
	 * @param Index The index of the media source to get.
	 * @return The media source, or nullptr if the index doesn't exist.
	 * @see GetNext, GetRandom
	*/
	Get(Index: number): MediaSource;
	/**
	 * Add a media source to the play list.
	 * @param MediaSource The media source to append.
	 * @see Insert, RemoveAll, Remove
	*/
	Add(MediaSource: MediaSource): void;
	static C(Other: UObject): MediaPlaylist;
}

declare class MediaSoundWave extends SoundWave { 
	/**
	 * Audio Track Index
	*/
	AudioTrackIndex: number;
	/**
	 * Media Player
	*/
	MediaPlayer: MediaPlayer;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaSoundWave;
	static Find(Outer: UObject, ResourceName: string): MediaSoundWave;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaSoundWave;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaSoundWave;
	static C(Other: UObject): MediaSoundWave;
}

declare type EMediaPlayerTrack = string | symbol;
declare var EMediaPlayerTrack = { Audio:'Audio',Binary:'Binary',Caption:'Caption',Image:'Image',Script:'Script',Video:'Video', };
declare class MediaPlayer extends UObject { 
	/**
	 * A delegate that is invoked when playback has reached the end of the media.
	*/
	OnEndReached: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * A delegate that is invoked when a media source has been closed.
	*/
	OnMediaClosed: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * A delegate that is invoked when a media source has been opened.
	 * Depending on whether the underlying player implementation opens the media
	 * synchronously or asynchronously, this event may be executed before or
	 * after the call top OpenSource / OpenUrl returns.
	*/
	OnMediaOpened: UnrealEngineMulticastDelegate<(OpenedUrl: string) => void>;
	/**
	 * A delegate that is invoked when a media source has failed to open.
	 * This delegate is only executed if OpenSource / OpenUrl returned true and
	 * the media failed to open asynchronously later. It is not executed if
	 * OpenSource / OpenUrl returned false, indicating an immediate failure.
	*/
	OnMediaOpenFailed: UnrealEngineMulticastDelegate<(FailedUrl: string) => void>;
	/**
	 * A delegate that is invoked when media playback has been resumed.
	*/
	OnPlaybackResumed: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * A delegate that is invoked when media playback has been suspended.
	*/
	OnPlaybackSuspended: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Name of the desired native player, if any.
	*/
	DesiredPlayerName: string;
	/**
	 * Automatically start playback after media opened successfully.
	*/
	PlayOnOpen: boolean;
	/**
	 * Whether playback should shuffle media sources in the play list.
	*/
	Shuffle: boolean;
	/**
	 * The media texture to output the image track frames to.
	*/
	ImageTexture: MediaTexture;
	/**
	 * Whether the player should loop when media playback reaches the end.
	*/
	Loop: boolean;
	/**
	 * The play list to use, if any.
	*/
	Playlist: MediaPlaylist;
	/**
	 * The current index of the source in the play list being played.
	*/
	PlaylistIndex: number;
	/**
	 * The media sound wave to output the audio track samples to.
	*/
	SoundWave: MediaSoundWave;
	/**
	 * The media texture to output the video track frames to.
	*/
	VideoTexture: MediaTexture;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaPlayer;
	static Find(Outer: UObject, ResourceName: string): MediaPlayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaPlayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlayer;
	/**
	 * Checks whether the currently loaded media can jump to a certain position.
	 * @return true if seeking is supported, false otherwise.
	 * @see SupportsRate, SupportsScrubbing
	*/
	SupportsSeeking(): boolean;
	/**
	 * Checks whether the currently loaded media supports scrubbing.
	 * @return true if scrubbing is supported, false otherwise.
	 * @see SupportsRate, SupportsSeeking
	*/
	SupportsScrubbing(): boolean;
	/**
	 * Checks whether the specified playback rate is supported.
	 * @param Rate The playback rate to check.
	 * @param Unthinned Whether no frames should be dropped at the given rate.
	 * @see SupportsScrubbing, SupportsSeeking
	*/
	SupportsRate(Rate: number,Unthinned: boolean): boolean;
	/**
	 * Assign the given texture to the player's video sink.
	 * @param NewTexture The texture to set.
	 * @see SetImageTexture, SetSoundWave
	*/
	SetVideoTexture(NewTexture: MediaTexture): void;
	/**
	 * Assign the given sound wave to the player's audio sink.
	 * @param NewSoundWave The sound wave to set.
	 * @see SetImageTexture, SetVideoTexture
	*/
	SetSoundWave(NewSoundWave: MediaSoundWave): void;
	/**
	 * Changes the media's playback rate.
	 * @param Rate The playback rate to set.
	 * @return true on success, false otherwise.
	 * @see GetRate, SupportsRate
	*/
	SetRate(Rate: number): boolean;
	/**
	 * Enables or disables playback looping.
	 * @param Looping Whether playback should be looped.
	 * @return true on success, false otherwise.
	 * @see IsLooping
	*/
	SetLooping(InLooping: boolean): boolean;
	/**
	 * Assign the given texture to the player's image sink.
	 * @param NewTexture The texture to set.
	 * @see SetSoundWave, SetVideoTexture
	*/
	SetImageTexture(NewTexture: MediaTexture): void;
	/**
	 * Select the active track of the given type.
	 * Only one track of a given type can be active at any time.
	 * @param TrackType The type of track to select.
	 * @param TrackIndex The index of the track to select, or INDEX_NONE to deselect.
	 * @return true if the track was selected, false otherwise.
	 * @see GetNumTracks, GetSelectedTrack
	*/
	SelectTrack(TrackType: EMediaPlayerTrack,TrackIndex: number): boolean;
	/**
	 * Seeks to the specified playback time.
	 * @param InTime The playback time to set.
	 * @return true on success, false otherwise.
	 * @see GetTime, Rewind
	*/
	Seek(InTime: Timespan): boolean;
	/**
	 * Rewinds the media to the beginning.
	 * This is the same as seeking to zero time.
	 * @return true if rewinding, false otherwise.
	 * @see GetTime, Seek
	*/
	Rewind(): boolean;
	/**
	 * Reopens the currently opened media or play list.
	 * @return true if the media will be opened, false otherwise.
	 * @see Close, Open, OpenPlaylist, OpenPlaylistIndex, OpenSource, OpenUrl
	*/
	Reopen(): boolean;
	/**
	 * Open the previous item in the current play list.
	 * The player will start playing the new media source if it was playing
	 * something previously, otherwise it will only open the media source.
	 * @return true on success, false otherwise.
	 * @see Close, Next, OpenUrl, OpenSource, Play, SetPlaylist
	*/
	Previous(): boolean;
	/**
	 * Starts media playback.
	 * This is the same as setting the playback rate to 1.0.
	 * @return true if playback is starting, false otherwise.
	 * @see CanPlay, GetRate, Next, Pause, Previous, SetRate
	*/
	Play(): boolean;
	/**
	 * Pauses media playback.
	 * This is the same as setting the playback rate to 0.0.
	 * @return true if playback is being paused, false otherwise.
	 * @see CanPause, Close, Next, Play, Previous, Rewind, Seek
	*/
	Pause(): boolean;
	/**
	 * Opens the specified media URL.
	 * A return value of true indicates that the player will attempt to open
	 * the media, but it may fail to do so later for other reasons, i.e. if
	 * a connection to the media server timed out. Use the OnMediaOpened and
	 * OnMediaOpenFailed delegates to detect if and when the media is ready!
	 * @param Url The URL to open.
	 * @return true if the URL will be opened, false otherwise.
	 * @see GetUrl, Close, OpenPlaylist, OpenPlaylistIndex, OpenSource, Reopen
	*/
	OpenUrl(Url: string): boolean;
	/**
	 * Open the specified media source.
	 * A return value of true indicates that the player will attempt to open
	 * the media, but it may fail to do so later for other reasons, i.e. if
	 * a connection to the media server timed out. Use the OnMediaOpened and
	 * OnMediaOpenFailed delegates to detect if and when the media is ready!
	 * @param MediaSource The media source to open.
	 * @return true if the source will be opened, false otherwise.
	 * @see Close, OpenPlaylist, OpenPlaylistIndex, OpenUrl, Reopen
	*/
	OpenSource(MediaSource: MediaSource): boolean;
	/**
	 * Open a particular media source in the specified play list.
	 * @param InPlaylist The play list to open.
	 * @param Index The index of the source to open.
	 * @return true if the source will be opened, false otherwise.
	 * @see Close, OpenPlaylist, OpenSource, OpenUrl, Reopen
	*/
	OpenPlaylistIndex(InPlaylist: MediaPlaylist,Index: number): boolean;
	/**
	 * Open the first media source in the specified play list.
	 * @param InPlaylist The play list to open.
	 * @return true if the source will be opened, false otherwise.
	 * @see Close, OpenPlaylistIndex, OpenSource, OpenUrl, Reopen
	*/
	OpenPlaylist(InPlaylist: MediaPlaylist): boolean;
	/**
	 * Open the next item in the current play list.
	 * The player will start playing the new media source if it was playing
	 * something previously, otherwise it will only open the media source.
	 * @return true on success, false otherwise.
	 * @see Close, OpenUrl, OpenSource, Play, Previous, SetPlaylist
	*/
	Next(): boolean;
	/**
	 * Checks whether media is ready for playback.
	 * A player is ready for playback if it has a media source opened that
	 * finished preparing and is not in an error state.
	 * @return true if media is ready, false otherwise.
	 * @see IsPaused, IsPlaying, Stop
	*/
	IsReady(): boolean;
	/**
	 * Checks whether the media is currently opening or buffering.
	 * @return true if playback is being prepared, false otherwise.
	 * @see CanPlay, IsPaused, IsReady, Play
	*/
	IsPreparing(): boolean;
	/**
	 * Checks whether playback has started.
	 * @return true if playback has started, false otherwise.
	 * @see CanPlay, IsPaused, IsReady, Play
	*/
	IsPlaying(): boolean;
	/**
	 * Checks whether playback is currently paused.
	 * @return true if playback is paused, false otherwise.
	 * @see CanPause, IsPlaying, IsReady, Pause
	*/
	IsPaused(): boolean;
	/**
	 * Checks whether playback is looping.
	 * @return true if looping, false otherwise.
	 * @see SetLooping
	*/
	IsLooping(): boolean;
	/**
	 * Get the URL of the currently loaded media, if any.
	 * @return Media URL, or empty string if no media was loaded.
	 * @see OpenUrl
	*/
	GetUrl(): string;
	/**
	 * Get the language tag of the specified track.
	 * @param TrackType The type of track.
	 * @param TrackIndex The index of the track.
	 * @return Language tag, i.e. "en-US" for English, or "und" for undefined.
	 * @see GetNumTracks, GetTrackDisplayName
	*/
	GetTrackLanguage(TrackType: EMediaPlayerTrack,TrackIndex: number): string;
	/**
	 * Get the human readable name of the specified track.
	 * @param TrackType The type of track.
	 * @param TrackIndex The index of the track.
	 * @return Display name.
	 * @see GetNumTracks, GetTrackLanguage
	*/
	GetTrackDisplayName(TrackType: EMediaPlayerTrack,TrackIndex: number): string;
	/**
	 * Get the media's current playback time.
	 * @return Playback time.
	 * @see GetDuration, Seek
	*/
	GetTime(): Timespan;
	/**
	 * Get the index of the currently selected track of the given type.
	 * @param TrackType The type of track to get.
	 * @return The index of the selected track, or INDEX_NONE if no track is active.
	 * @see GetNumTracks, SelectTrack
	*/
	GetSelectedTrack(TrackType: EMediaPlayerTrack): number;
	/**
	 * Get the supported reverse playback rates.
	 * @param Unthinned Whether the rates are for unthinned playback (default = true).
	 * @return The range of supported rates.
	 * @see GetForwardRates
	*/
	GetReverseRates(Unthinned: boolean): FloatRange;
	/**
	 * Get the media's current playback rate.
	 * @return The playback rate.
	 * @see SetRate, SupportsRate
	*/
	GetRate(): number;
	/**
	 * Get the name of the current native media player.
	 * @return Player name.
	*/
	GetPlayerName(): string;
	/**
	 * Get the number of tracks of the given type.
	 * @param TrackType The type of media tracks.
	 * @return Number of tracks.
	 * @see GetSelectedTrack, SelectTrack
	*/
	GetNumTracks(TrackType: EMediaPlayerTrack): number;
	/**
	 * Get the supported forward playback rates.
	 * @param Unthinned Whether the rates are for unthinned playback (default = true).
	 * @return The range of supported rates.
	 * @see GetReverseRates
	*/
	GetForwardRates(Unthinned: boolean): FloatRange;
	/**
	 * Get the media's duration.
	 * @return A time span representing the duration.
	 * @see GetTime, Seek
	*/
	GetDuration(): Timespan;
	/**
	 * Get the current caption/subtitle text, if any.
	 * @return Caption text.
	*/
	GetCaptionText(): string;
	/**
	 * Close the currently open media, if any.
	 * @see OnMediaClosed, OpenPlaylist, OpenPlaylistIndex, OpenSource, OpenUrl, Pause, Play
	*/
	Close(): void;
	/**
	 * Checks whether media playback can be paused right now.
	 * Playback can be paused if the media supports pausing and if it is currently playing.
	 * @return true if pausing playback can be paused, false otherwise.
	 * @see CanPlay, Pause
	*/
	CanPause(): boolean;
	static C(Other: UObject): MediaPlayer;
}

declare class FileMediaSource extends MediaSource { 
	/**
	 * The path to the media file to be played.
	 * @see SetFilePath
	*/
	FilePath: string;
	/**
	 * Load entire media file into memory and play from there (if possible).
	*/
	PrecacheFile: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FileMediaSource;
	static Find(Outer: UObject, ResourceName: string): FileMediaSource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FileMediaSource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FileMediaSource;
	/**
	 * Set the path to the media file that this source represents.
	 * Automatically converts full paths to media sources that reside in the
	 * Engine's or project's /Content/Movies directory into relative paths.
	 * @param Path The path to set.
	 * @see FilePath, GetFilePath
	*/
	SetFilePath(Path: string): void;
	static C(Other: UObject): FileMediaSource;
}

declare class PlatformMediaSource extends MediaSource { 
	/**
	 * Default media source.
	 * This media source will be used if no source was specified for a target platform.
	*/
	DefaultSource: MediaSource;
	/**
	 * Media sources per platform.
	*/
	MediaSources: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PlatformMediaSource;
	static Find(Outer: UObject, ResourceName: string): PlatformMediaSource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlatformMediaSource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformMediaSource;
	static C(Other: UObject): PlatformMediaSource;
}

declare class StreamMediaSource extends MediaSource { 
	/**
	 * The URL to the media stream to be played.
	*/
	StreamUrl: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StreamMediaSource;
	static Find(Outer: UObject, ResourceName: string): StreamMediaSource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StreamMediaSource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StreamMediaSource;
	static C(Other: UObject): StreamMediaSource;
}

declare class WmfMediaSettings extends UObject { 
	/**
	 * Whether to allow the loading of media that uses non-standard codecs.
	 * By default, the player will attempt to detect audio and video codecs that
	 * are not supported by the operating system out of the box, but may require
	 * the user to install additional codec packs. Enable this option to skip
	 * this check and allow the usage of non-standard codecs.
	*/
	AllowNonStandardCodecs: boolean;
	/**
	 * Play audio tracks via the operating system's native sound mixer.
	*/
	NativeAudioOut: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WmfMediaSettings;
	static Find(Outer: UObject, ResourceName: string): WmfMediaSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WmfMediaSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WmfMediaSettings;
	static C(Other: UObject): WmfMediaSettings;
}

declare class MaterialExpressionSpriteTextureSampler extends MaterialExpressionTextureSampleParameter2D { 
	/**
	 * Is this a sampler for the default SourceTexture or the AdditionalSourceTextures list?
	*/
	bSampleAdditionalTextures: boolean;
	/**
	 * This is the slot index into the AdditionalSourceTextures array
	*/
	AdditionalSlotIndex: number;
	/**
	 * Friendly label for the texture slot, displayed in the Sprite Editor if not empty
	*/
	SlotDisplayName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionSpriteTextureSampler;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionSpriteTextureSampler;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionSpriteTextureSampler;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionSpriteTextureSampler;
	static C(Other: UObject): MaterialExpressionSpriteTextureSampler;
}

declare class PaperSpriteSocket { 
	/**
	 * Transform in pivot space (*not* texture space)
	*/
	LocalTransform: Transform;
	/**
	 * Name of the socket
	*/
	SocketName: string;
	clone() : PaperSpriteSocket;
	static C(Other: UObject): PaperSpriteSocket;
}

declare type ESpriteCollisionMode = string | symbol;
declare var ESpriteCollisionMode = { None:'None',Use2DPhysics:'Use2DPhysics',Use3DPhysics:'Use3DPhysics', };
declare type ESpritePivotMode = string | symbol;
declare var ESpritePivotMode = { Top_Left:'Top_Left',Top_Center:'Top_Center',Top_Right:'Top_Right',Center_Left:'Center_Left',Center_Center:'Center_Center',Center_Right:'Center_Right',Bottom_Left:'Bottom_Left',Bottom_Center:'Bottom_Center',Bottom_Right:'Bottom_Right',Custom:'Custom', };
declare type ESpriteShapeType = string | symbol;
declare var ESpriteShapeType = { Box:'Box',Circle:'Circle',Polygon:'Polygon', };
declare class SpriteGeometryShape { 
	/**
	 * The type of this piece of geometry
	*/
	ShapeType: ESpriteShapeType;
	/**
	 * Vertices for the polygon (valid for Box and Polygon, but empty for Circle)
	*/
	Vertices: Vector2D[];
	/**
	 * Size of the box or major/minor dimensions of the circle
	 * Note: Only valid when GeometryType is Box or Circle
	*/
	BoxSize: Vector2D;
	/**
	 * Center of the box or circle, acts as the pivot point for polygons (but may not be at the center of them)
	*/
	BoxPosition: Vector2D;
	/**
	 * Rotation of the shape (in degrees)
	*/
	Rotation: number;
	/**
	 * For Polygon geometry, this tells us if the winding should be negative (CW) regardless of the order in Vertices
	*/
	bNegativeWinding: boolean;
	clone() : SpriteGeometryShape;
	static C(Other: UObject): SpriteGeometryShape;
}

declare type ESpritePolygonMode = string | symbol;
declare var ESpritePolygonMode = { SourceBoundingBox:'SourceBoundingBox',TightBoundingBox:'TightBoundingBox',ShrinkWrapped:'ShrinkWrapped',FullyCustom:'FullyCustom',Diced:'Diced', };
declare class SpriteGeometryCollection { 
	/**
	 * List of shapes
	*/
	Shapes: SpriteGeometryShape[];
	/**
	 * The geometry type (automatic / manual)
	*/
	GeometryType: ESpritePolygonMode;
	/**
	 * Size of a single subdivision (in pixels) in X (for Diced mode)
	*/
	PixelsPerSubdivisionX: number;
	/**
	 * Size of a single subdivision (in pixels) in Y (for Diced mode)
	*/
	PixelsPerSubdivisionY: number;
	/**
	 * Experimental: Hint to the triangulation routine that extra vertices should be preserved
	*/
	bAvoidVertexMerging: boolean;
	/**
	 * Alpha threshold for a transparent pixel (range 0..1, anything equal or below this value will be considered unimportant)
	*/
	AlphaThreshold: number;
	/**
	 * Amount to detail to consider when shrink-wrapping (range 0..1, 0 = low detail, 1 = high detail)
	*/
	DetailAmount: number;
	/**
	 * This is the threshold below which multiple vertices will be merged together when doing shrink-wrapping.  Higher values result in fewer vertices.
	*/
	SimplifyEpsilon: number;
	clone() : SpriteGeometryCollection;
	static C(Other: UObject): SpriteGeometryCollection;
}

declare type EPaperSpriteAtlasPadding = string | symbol;
declare var EPaperSpriteAtlasPadding = { DilateBorder:'DilateBorder',PadWithZero:'PadWithZero', };
declare class PaperSpriteAtlasSlot { 
	/**
	 * Sprite Ref
	*/
	SpriteRef: any;
	/**
	 * Atlas Index
	*/
	AtlasIndex: number;
	/**
	 * X
	*/
	X: number;
	/**
	 * Y
	*/
	Y: number;
	/**
	 * Width
	*/
	Width: number;
	/**
	 * Height
	*/
	Height: number;
	clone() : PaperSpriteAtlasSlot;
	static C(Other: UObject): PaperSpriteAtlasSlot;
}

declare class PaperSpriteAtlas extends UObject { 
	/**
	 * Description of this atlas, which shows up in the content browser tooltip
	*/
	AtlasDescription: string;
	/**
	 * Maximum atlas page width (single pages might be smaller)
	*/
	MaxWidth: number;
	/**
	 * Maximum atlas page height (single pages might be smaller)
	*/
	MaxHeight: number;
	/**
	 * Maximum atlas page height (single pages might be smaller)
	*/
	MipCount: number;
	/**
	 * The type of padding performed on this atlas
	*/
	PaddingType: EPaperSpriteAtlasPadding;
	/**
	 * The number of pixels of padding
	*/
	Padding: number;
	/**
	 * Compression settings to use on atlas texture
	*/
	CompressionSettings: TextureCompressionSettings;
	/**
	 * Texture filtering mode when sampling these textures
	*/
	Filter: TextureFilter;
	/**
	 * List of generated atlas textures
	*/
	GeneratedTextures: Texture[];
	/**
	 * The GUID of the atlas group, used to match up sprites that belong to this group even thru atlas renames
	*/
	AtlasGUID: Guid;
	/**
	 * Slots in the atlas
	*/
	bRebuildAtlas: boolean;
	/**
	 * Slots in the atlas
	*/
	AtlasSlots: PaperSpriteAtlasSlot[];
	/**
	 * Track the number of incremental builds
	*/
	NumIncrementalBuilds: number;
	/**
	 * Values used when building this atlas
	*/
	BuiltWidth: number;
	/**
	 * Built Height
	*/
	BuiltHeight: number;
	/**
	 * Built Padding
	*/
	BuiltPadding: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteAtlas;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteAtlas;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteAtlas;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteAtlas;
	static C(Other: UObject): PaperSpriteAtlas;
}

declare class PaperSprite extends UObject { 
	/**
	 * Origin within SourceImage, prior to atlasing
	*/
	OriginInSourceImageBeforeTrimming: Vector2D;
	/**
	 * Dimensions of SourceImage
	*/
	SourceImageDimensionBeforeTrimming: Vector2D;
	/**
	 * This texture is trimmed, consider the values above
	*/
	bTrimmedInSourceImage: boolean;
	/**
	 * This texture is rotated in the atlas
	*/
	bRotatedInSourceImage: boolean;
	/**
	 * Dimension of the texture when this sprite was created
	 * Used when the sprite is resized at some point
	*/
	SourceTextureDimension: Vector2D;
	/**
	 * Position within SourceTexture (in pixels)
	*/
	SourceUV: Vector2D;
	/**
	 * Dimensions within SourceTexture (in pixels)
	*/
	SourceDimension: Vector2D;
	/**
	 * The source texture that the sprite comes from
	*/
	SourceTexture: Texture2D;
	/**
	 * Additional source textures for other slots
	*/
	AdditionalSourceTextures: Texture[];
	/**
	 * Position within BakedSourceTexture (in pixels)
	*/
	BakedSourceUV: Vector2D;
	/**
	 * Dimensions within BakedSourceTexture (in pixels)
	*/
	BakedSourceDimension: Vector2D;
	/**
	 * Baked Source Texture
	*/
	BakedSourceTexture: Texture2D;
	/**
	 * The material to use on a sprite instance if not overridden (this is the default material when only one is being used, and is the translucent/masked material for Diced render geometry, slot 0)
	*/
	DefaultMaterial: MaterialInterface;
	/**
	 * The alternate material to use on a sprite instance if not overridden (this is only used for Diced render geometry, and will be the opaque material in that case, slot 1)
	*/
	AlternateMaterial: MaterialInterface;
	/**
	 * List of sockets on this sprite
	*/
	Sockets: PaperSpriteSocket[];
	/**
	 * Collision domain (no collision, 2D, or 3D)
	*/
	SpriteCollisionDomain: ESpriteCollisionMode;
	/**
	 * The scaling factor between pixels and Unreal units (cm) (e.g., 0.64 would make a 64 pixel wide sprite take up 100 cm)
	*/
	PixelsPerUnrealUnit: number;
	/**
	 * Baked physics data.
	*/
	BodySetup: BodySetup;
	/**
	 * Pivot mode
	*/
	PivotMode: ESpritePivotMode;
	/**
	 * Custom pivot point (relative to the sprite rectangle)
	*/
	CustomPivotPoint: Vector2D;
	/**
	 * Should the pivot be snapped to a pixel boundary?
	*/
	bSnapPivotToPixelGrid: boolean;
	/**
	 * Custom collision geometry polygons (in texture space)
	*/
	CollisionGeometry: SpriteGeometryCollection;
	/**
	 * The extrusion thickness of collision geometry when using a 3D collision domain
	*/
	CollisionThickness: number;
	/**
	 * Custom render geometry polygons (in texture space)
	*/
	RenderGeometry: SpriteGeometryCollection;
	/**
	 * Spritesheet group that this sprite belongs to
	*/
	AtlasGroup: PaperSpriteAtlas;
	/**
	 * The point at which the alternate material takes over in the baked render data (or INDEX_NONE)
	*/
	AlternateMaterialSplitIndex: number;
	/**
	 * Baked render data (triangle vertices, stored as XY UV tuples)
	 *   XY is the XZ position in world space, relative to the pivot
	 *   UV is normalized (0..1)
	 *   There should always be a multiple of three elements in this array
	*/
	BakedRenderData: Vector4[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSprite;
	static Find(Outer: UObject, ResourceName: string): PaperSprite;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSprite;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSprite;
	static C(Other: UObject): PaperSprite;
}

declare class PaperFlipbookKeyFrame { 
	/**
	 * Sprite
	*/
	Sprite: PaperSprite;
	/**
	 * Frame Run
	*/
	FrameRun: number;
	clone() : PaperFlipbookKeyFrame;
	static C(Other: UObject): PaperFlipbookKeyFrame;
}

declare type EFlipbookCollisionMode = string | symbol;
declare var EFlipbookCollisionMode = { NoCollision:'NoCollision',FirstFrameCollision:'FirstFrameCollision',EachFrameCollision:'EachFrameCollision', };
declare class PaperFlipbook extends UObject { 
	/**
	 * The nominal frame rate to play this flipbook animation back at
	*/
	FramesPerSecond: number;
	/**
	 * The set of key frames for this flipbook animation (each one has a duration and a sprite to display)
	*/
	KeyFrames: PaperFlipbookKeyFrame[];
	/**
	 * The material to use on a flipbook player instance if not overridden
	*/
	DefaultMaterial: MaterialInterface;
	/**
	 * Collision source
	*/
	CollisionSource: EFlipbookCollisionMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperFlipbook;
	static Find(Outer: UObject, ResourceName: string): PaperFlipbook;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperFlipbook;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbook;
	/**
	 * Is the specified Index within the valid range of key frames?
	*/
	IsValidKeyFrameIndex(Index: number): boolean;
	/**
	 * Returns the total duration in seconds
	*/
	GetTotalDuration(): number;
	/**
	 * Returns the sprite at the specified time (in seconds), or nullptr if none exists.
	 * When bClampToEnds is true, it will choose the first or last sprite if the time is out of range.
	*/
	GetSpriteAtTime(Time: number,bClampToEnds: boolean): PaperSprite;
	/**
	 * Returns the sprite at the specified keyframe index, or nullptr if none exists
	*/
	GetSpriteAtFrame(FrameIndex: number): PaperSprite;
	/**
	 * Returns the number of key frames
	*/
	GetNumKeyFrames(): number;
	/**
	 * Returns the total number of frames
	*/
	GetNumFrames(): number;
	/**
	 * Returns the keyframe index that covers the specified time (in seconds), or INDEX_NONE if none exists.
	 * When bClampToEnds is true, it will choose the first or last keyframe if the time is out of range.
	*/
	GetKeyFrameIndexAtTime(Time: number,bClampToEnds: boolean): number;
	static C(Other: UObject): PaperFlipbook;
}

declare class PaperFlipbookComponent extends MeshComponent { 
	/**
	 * Flipbook currently being played
	*/
	SourceFlipbook: PaperFlipbook;
	/**
	 * DEPRECATED in 4.5: The material override for this flipbook component (if any); replaced by the Materials array inherited from UMeshComponent
	*/
	Material: MaterialInterface;
	/**
	 * Current play rate of the flipbook
	*/
	PlayRate: number;
	/**
	 * Whether the flipbook should loop when it reaches the end, or stop
	*/
	bLooping: boolean;
	/**
	 * If playback should move the current position backwards instead of forwards
	*/
	bReversePlayback: boolean;
	/**
	 * Are we currently playing (moving Position)
	*/
	bPlaying: boolean;
	/**
	 * Current position in the timeline
	*/
	AccumulatedTime: number;
	/**
	 * Last frame index calculated
	*/
	CachedFrameIndex: number;
	/**
	 * Vertex color to apply to the frames
	*/
	SpriteColor: LinearColor;
	/**
	 * The cached body setup
	*/
	CachedBodySetup: BodySetup;
	/**
	 * Event called whenever a non-looping flipbook finishes playing (either reaching the beginning or the end, depending on the play direction)
	*/
	OnFinishedPlaying: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperFlipbookComponent;
	static Find(Outer: UObject, ResourceName: string): PaperFlipbookComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperFlipbookComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbookComponent;
	/**
	 * Stop playback of flipbook
	*/
	Stop(): void;
	/**
	 * Set color of the sprite
	*/
	SetSpriteColor(NewColor: LinearColor): void;
	/**
	 * Sets the new play rate for this flipbook
	*/
	SetPlayRate(NewRate: number): void;
	/**
	 * Jump to a position in the flipbook (expressed in frames). If bFireEvents is true, event functions will fire, otherwise they will not.
	*/
	SetPlaybackPositionInFrames(NewFramePosition: number,bFireEvents: boolean): void;
	/**
	 * Jump to a position in the flipbook (expressed in seconds). If bFireEvents is true, event functions will fire, otherwise they will not.
	*/
	SetPlaybackPosition(NewPosition: number,bFireEvents: boolean): void;
	/**
	 * Set the new playback position time to use
	*/
	SetNewTime(NewTime: number): void;
	/**
	 * true means we should loop, false means we should not.
	*/
	SetLooping(bNewLooping: boolean): void;
	/**
	 * Change the flipbook used by this instance (will reset the play time to 0 if it is a new flipbook).
	*/
	SetFlipbook(NewFlipbook: PaperFlipbook): boolean;
	/**
	 * Start playback of flipbook in reverse from the end
	*/
	ReverseFromEnd(): void;
	/**
	 * Start playback of flipbook in reverse
	*/
	Reverse(): void;
	/**
	 * Start playback of flipbook from the start
	*/
	PlayFromStart(): void;
	/**
	 * Start playback of flipbook
	*/
	Play(): void;
	/**
	 * On Rep Source Flipbook
	*/
	OnRep_SourceFlipbook(OldFlipbook: PaperFlipbook): void;
	/**
	 * Get whether we are reversing or not
	*/
	IsReversing(): boolean;
	/**
	 * Get whether this flipbook is playing or not.
	*/
	IsPlaying(): boolean;
	/**
	 * Get whether we are looping or not
	*/
	IsLooping(): boolean;
	/**
	 * Get Sprite Material
	*/
	GetSpriteMaterial(): MaterialInterface;
	/**
	 * Get the current play rate for this flipbook
	*/
	GetPlayRate(): number;
	/**
	 * Get the current playback position (in frames) of the flipbook
	*/
	GetPlaybackPositionInFrames(): number;
	/**
	 * Get the current playback position (in seconds) of the flipbook
	*/
	GetPlaybackPosition(): number;
	/**
	 * Get length of the flipbook (in frames)
	*/
	GetFlipbookLengthInFrames(): number;
	/**
	 * Get length of the flipbook (in seconds)
	*/
	GetFlipbookLength(): number;
	/**
	 * Get the nominal framerate that the flipbook will be played back at (ignoring PlayRate), in frames per second
	*/
	GetFlipbookFramerate(): number;
	/**
	 * Gets the flipbook used by this instance.
	*/
	GetFlipbook(): PaperFlipbook;
	static C(Other: UObject): PaperFlipbookComponent;
}

declare class PaperCharacter extends Character { 
	/**
	 * The main skeletal mesh associated with this Character (optional sub-object).
	*/
	Sprite: PaperFlipbookComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperCharacter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperCharacter;
	static C(Other: UObject): PaperCharacter;
}

declare class PaperFlipbookActor extends Actor { 
	/**
	 * Render Component
	*/
	RenderComponent: PaperFlipbookComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperFlipbookActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbookActor;
	static C(Other: UObject): PaperFlipbookActor;
}

declare class SpriteInstanceData { 
	/**
	 * Transform
	*/
	Transform: Matrix;
	/**
	 * Source Sprite
	*/
	SourceSprite: PaperSprite;
	/**
	 * Vertex Color
	*/
	VertexColor: Color;
	/**
	 * Material Index
	*/
	MaterialIndex: number;
	clone() : SpriteInstanceData;
	static C(Other: UObject): SpriteInstanceData;
}

declare class PaperGroupedSpriteComponent extends MeshComponent { 
	/**
	 * Array of materials used by the instances
	*/
	InstanceMaterials: MaterialInterface[];
	/**
	 * Array of instances
	*/
	PerInstanceSpriteData: SpriteInstanceData[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperGroupedSpriteComponent;
	static Find(Outer: UObject, ResourceName: string): PaperGroupedSpriteComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperGroupedSpriteComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperGroupedSpriteComponent;
	/**
	 * Update the transform for the instance specified. Instance is given in local space of this component unless bWorldSpace is set.  Returns True on success.
	*/
	UpdateInstanceTransform(InstanceIndex: number,NewInstanceTransform: Transform,bWorldSpace: boolean,bMarkRenderStateDirty: boolean,bTeleport: boolean): boolean;
	/**
	 * Update the color for the instance specified. Returns True on success.
	*/
	UpdateInstanceColor(InstanceIndex: number,NewInstanceColor: LinearColor,bMarkRenderStateDirty: boolean): boolean;
	/**
	 * Sort all instances by their world space position along the specified axis
	*/
	SortInstancesAlongAxis(WorldSpaceSortAxis: Vector): void;
	/**
	 * Remove the instance specified. Returns True on success.
	*/
	RemoveInstance(InstanceIndex: number): boolean;
	/**
	 * Get the transform for the instance specified. Instance is returned in local space of this component unless bWorldSpace is set.  Returns True on success.
	*/
	GetInstanceTransform(InstanceIndex: number,OutInstanceTransform?: Transform,bWorldSpace?: boolean): {OutInstanceTransform: Transform, $: boolean};
	/**
	 * Get the number of instances in this component
	*/
	GetInstanceCount(): number;
	/**
	 * Clear all instances being rendered by this component
	*/
	ClearInstances(): void;
	/**
	 * Add an instance to this component. Transform can be given either in the local space of this component or world space.
	*/
	AddInstance(Transform: Transform,Sprite: PaperSprite,bWorldSpace: boolean,Color: LinearColor): number;
	static C(Other: UObject): PaperGroupedSpriteComponent;
}

declare class PaperGroupedSpriteActor extends Actor { 
	/**
	 * Render Component
	*/
	RenderComponent: PaperGroupedSpriteComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperGroupedSpriteActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperGroupedSpriteActor;
	static C(Other: UObject): PaperGroupedSpriteActor;
}

declare class PaperRuntimeSettings extends UObject { 
	/**
	 * Enables experimental *incomplete and unsupported* texture atlas groups that sprites can be assigned to
	*/
	bEnableSpriteAtlasGroups: boolean;
	/**
	 * Enables experimental *incomplete and unsupported* 2D terrain spline editing. Note: You need to restart the editor when enabling this setting for the change to fully take effect.
	*/
	bEnableTerrainSplineEditing: boolean;
	/**
	 * Enables automatic resizing of various sprite data that is authored in texture space if the source texture gets resized (sockets, the pivot, render and collision geometry, etc...)
	*/
	bResizeSpriteDataToMatchTextures: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperRuntimeSettings;
	static Find(Outer: UObject, ResourceName: string): PaperRuntimeSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperRuntimeSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperRuntimeSettings;
	static C(Other: UObject): PaperRuntimeSettings;
}

declare class PaperSpriteComponent extends MeshComponent { 
	/**
	 * The sprite asset used by this component
	*/
	SourceSprite: PaperSprite;
	/**
	 * DEPRECATED in 4.4: The material override for this sprite component (if any); replaced by the Materials array inherited from UMeshComponent
	*/
	MaterialOverride: MaterialInterface;
	/**
	 * The color of the sprite (passed to the sprite material as a vertex color)
	*/
	SpriteColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteComponent;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteComponent;
	/**
	 * Set color of the sprite
	*/
	SetSpriteColor(NewColor: LinearColor): void;
	/**
	 * Change the PaperSprite used by this instance.
	*/
	SetSprite(NewSprite: PaperSprite): boolean;
	/**
	 * Gets the PaperSprite used by this instance.
	*/
	GetSprite(): PaperSprite;
	static C(Other: UObject): PaperSpriteComponent;
}

declare class PaperSpriteActor extends Actor { 
	/**
	 * Render Component
	*/
	RenderComponent: PaperSpriteComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteActor;
	static C(Other: UObject): PaperSpriteActor;
}

declare class PaperTerrainSplineComponent extends SplineComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTerrainSplineComponent;
	static Find(Outer: UObject, ResourceName: string): PaperTerrainSplineComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTerrainSplineComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTerrainSplineComponent;
	static C(Other: UObject): PaperTerrainSplineComponent;
}

declare class PaperTerrainMaterialRule { 
	/**
	 * The sprite to use at the 'left' (closest to spline start) edge of the terrain segment
	*/
	StartCap: PaperSprite;
	/**
	 * A set of sprites to randomly choose to fill up the interior space between the caps in a terrain segment
	*/
	Body: PaperSprite[];
	/**
	 * The sprite to use at the 'right' (closest to spline end) edge of the terrain segment
	*/
	EndCap: PaperSprite;
	/**
	 * Minimum slope angle (in degrees) to apply this rule
	*/
	MinimumAngle: number;
	/**
	 * Maximum slope angle (in degrees) to apply this rule
	*/
	MaximumAngle: number;
	/**
	 * If true, collision is enabled for sections matching this rule
	*/
	bEnableCollision: boolean;
	/**
	 * How much should the collision be lofted from the spline (positive values go out from the spline, negative values go in to the spline)
	*/
	CollisionOffset: number;
	/**
	 * Specify a draw order for different materials in a spline. Smaller draw orders are drawn first, negative values are allowed.
	*/
	DrawOrder: number;
	/**
	 * Readable description for the rule (unused anywhere, just for clarity when editing the material)
	*/
	Description: string;
	clone() : PaperTerrainMaterialRule;
	static C(Other: UObject): PaperTerrainMaterialRule;
}

declare class PaperTerrainMaterial extends DataAsset { 
	/**
	 * Rules
	*/
	Rules: PaperTerrainMaterialRule[];
	/**
	 * The sprite to use for an interior region fill
	*/
	InteriorFill: PaperSprite;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTerrainMaterial;
	static Find(Outer: UObject, ResourceName: string): PaperTerrainMaterial;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTerrainMaterial;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTerrainMaterial;
	static C(Other: UObject): PaperTerrainMaterial;
}

declare class PaperTerrainComponent extends PrimitiveComponent { 
	/**
	 * The terrain material to apply to this component (set of rules for which sprites are used on different surfaces or the interior)
	*/
	TerrainMaterial: PaperTerrainMaterial;
	/**
	 * Closed Spline
	*/
	bClosedSpline: boolean;
	/**
	 * Filled Spline
	*/
	bFilledSpline: boolean;
	/**
	 * Associated Spline
	*/
	AssociatedSpline: PaperTerrainSplineComponent;
	/**
	 * Random seed used for choosing which spline meshes to use.
	*/
	RandomSeed: number;
	/**
	 * The overlap amount between segments
	*/
	SegmentOverlapAmount: number;
	/**
	 * The color of the terrain (passed to the sprite material as a vertex color)
	*/
	TerrainColor: LinearColor;
	/**
	 * Number of steps per spline segment to place in the reparameterization table
	*/
	ReparamStepsPerSegment: number;
	/**
	 * Collision domain (no collision, 2D (experimental), or 3D)
	*/
	SpriteCollisionDomain: ESpriteCollisionMode;
	/**
	 * The extrusion thickness of collision geometry when using a 3D collision domain
	*/
	CollisionThickness: number;
	/**
	 * Description of collision
	*/
	CachedBodySetup: BodySetup;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTerrainComponent;
	static Find(Outer: UObject, ResourceName: string): PaperTerrainComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTerrainComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTerrainComponent;
	/**
	 * Set color of the terrain
	*/
	SetTerrainColor(NewColor: LinearColor): void;
	static C(Other: UObject): PaperTerrainComponent;
}

declare class PaperTerrainActor extends Actor { 
	/**
	 * Dummy Root
	*/
	DummyRoot: SceneComponent;
	/**
	 * Spline Component
	*/
	SplineComponent: PaperTerrainSplineComponent;
	/**
	 * Render Component
	*/
	RenderComponent: PaperTerrainComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTerrainActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTerrainActor;
	static C(Other: UObject): PaperTerrainActor;
}

declare class IntMargin { 
	/**
	 * Holds the margin to the left.
	*/
	Left: number;
	/**
	 * Holds the margin to the top.
	*/
	Top: number;
	/**
	 * Holds the margin to the right.
	*/
	Right: number;
	/**
	 * Holds the margin to the bottom.
	*/
	Bottom: number;
	clone() : IntMargin;
	static C(Other: UObject): IntMargin;
}

declare class PaperTileMetadata { 
	/**
	 * A tag that can be used for grouping and categorizing (consider using it as the index into a UDataTable asset).
	*/
	UserDataName: string;
	/**
	 * Collision data for the tile
	*/
	CollisionData: SpriteGeometryCollection;
	/**
	 * Indexes into the Terrains array of the owning tile set, in counterclockwise order starting from top-left
	 * 0xFF indicates no membership.
	*/
	TerrainMembership: number;
	clone() : PaperTileMetadata;
	static C(Other: UObject): PaperTileMetadata;
}

declare class PaperTileSetTerrain { 
	/**
	 * Terrain Name
	*/
	TerrainName: string;
	/**
	 * Center Tile Index
	*/
	CenterTileIndex: number;
	clone() : PaperTileSetTerrain;
	static C(Other: UObject): PaperTileSetTerrain;
}

declare class PaperTileSet extends UObject { 
	/**
	 * The width and height of a single tile (in pixels)
	*/
	TileSize: IntPoint;
	/**
	 * The tile sheet texture associated with this tile set
	*/
	TileSheet: Texture2D;
	/**
	 * The amount of padding around the border of the tile sheet (in pixels)
	*/
	BorderMargin: IntMargin;
	/**
	 * The amount of padding between tiles in the tile sheet (in pixels)
	*/
	PerTileSpacing: IntPoint;
	/**
	 * The drawing offset for tiles from this set (in pixels)
	*/
	DrawingOffset: IntPoint;
	/**
	 * The background color displayed in the tile set viewer
	*/
	BackgroundColor: LinearColor;
	/**
	 * Cached width of this tile set (in tiles)
	*/
	WidthInTiles: number;
	/**
	 * Cached height of this tile set (in tiles)
	*/
	HeightInTiles: number;
	/**
	 * Allocated width of the per-tile data
	*/
	AllocatedWidth: number;
	/**
	 * Allocated height of the per-tile data
	*/
	AllocatedHeight: number;
	/**
	 * Per-tile information
	*/
	PerTileData: PaperTileMetadata[];
	/**
	 * Terrain information
	 * @TODO: TileMapTerrains: (EditAnywhere, Category=Sprite)
	*/
	Terrains: PaperTileSetTerrain[];
	/**
	 * Tile Width
	*/
	TileWidth: number;
	/**
	 * Tile Height
	*/
	TileHeight: number;
	/**
	 * Margin
	*/
	Margin: number;
	/**
	 * Spacing
	*/
	Spacing: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTileSet;
	static Find(Outer: UObject, ResourceName: string): PaperTileSet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileSet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileSet;
	static C(Other: UObject): PaperTileSet;
}

declare class PaperTileInfo { 
	/**
	 * The tile set that this tile comes from
	*/
	TileSet: PaperTileSet;
	/**
	 * This is the index of the current tile within the tile set
	*/
	PackedTileIndex: number;
	clone() : PaperTileInfo;
	static C(Other: UObject): PaperTileInfo;
	/**
	 * Breaks out the information for a tile
	*/
	BreakTile(TileIndex?: number,TileSet?: PaperTileSet,bFlipH?: boolean,bFlipV?: boolean,bFlipD?: boolean): {TileIndex: number, TileSet: PaperTileSet, bFlipH: boolean, bFlipV: boolean, bFlipD: boolean};
	/**
	 * Returns the transform for a tile
	*/
	GetTileTransform(): Transform;
	/**
	 * Returns the user data name for the specified tile, or NAME_None if there is no user-specified data
	*/
	GetTileUserData(): string;
	/**
	 * Breaks out the information for a tile
	*/
	static BreakTile(Tile: PaperTileInfo,TileIndex?: number,TileSet?: PaperTileSet,bFlipH?: boolean,bFlipV?: boolean,bFlipD?: boolean): {TileIndex: number, TileSet: PaperTileSet, bFlipH: boolean, bFlipV: boolean, bFlipD: boolean};
	/**
	 * Returns the transform for a tile
	*/
	static GetTileTransform(Tile: PaperTileInfo): Transform;
	/**
	 * Returns the user data name for the specified tile, or NAME_None if there is no user-specified data
	*/
	static GetTileUserData(Tile: PaperTileInfo): string;
	/**
	 * Creates a tile from the specified information
	*/
	static MakeTile(TileIndex: number,TileSet: PaperTileSet,bFlipH: boolean,bFlipV: boolean,bFlipD: boolean): PaperTileInfo;
}

declare class PaperTileLayer extends UObject { 
	/**
	 * Name of the layer
	*/
	LayerName: string;
	/**
	 * Width of the layer (in tiles)
	*/
	LayerWidth: number;
	/**
	 * Height of the layer (in tiles)
	*/
	LayerHeight: number;
	/**
	 * Is this layer currently hidden in the editor?
	*/
	bHiddenInEditor: boolean;
	/**
	 * Should this layer be hidden in the game?
	*/
	bHiddenInGame: boolean;
	/**
	 * Should this layer generate collision?
	 * Note: This only has an effect if the owning tile map has collision enabled
	*/
	bLayerCollides: boolean;
	/**
	 * Should this layer use a custom thickness for generated collision instead of the thickness setting in the tile map?
	*/
	bOverrideCollisionThickness: boolean;
	/**
	 * Should this layer use a custom offset for generated collision instead of the layer drawing offset?
	*/
	bOverrideCollisionOffset: boolean;
	/**
	 * The override thickness of the collision for this layer (when bOverrideCollisionThickness is set)
	*/
	CollisionThicknessOverride: number;
	/**
	 * The override offset of the collision for this layer (when bOverrideCollisionOffset is set)
	 * Note: This is measured in Unreal Units (cm) from the center of the tile map component, not from the previous layer.
	*/
	CollisionOffsetOverride: number;
	/**
	 * The color of this layer (multiplied with the tile map color and passed to the material as a vertex color)
	*/
	LayerColor: LinearColor;
	/**
	 * The allocated width of the tile data (used to handle resizing without data loss)
	*/
	AllocatedWidth: number;
	/**
	 * The allocated height of the tile data (used to handle resizing without data loss)
	*/
	AllocatedHeight: number;
	/**
	 * The allocated tile data
	*/
	AllocatedCells: PaperTileInfo[];
	/**
	 * Tile Set
	*/
	TileSet: PaperTileSet;
	/**
	 * Allocated Grid
	*/
	AllocatedGrid: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTileLayer;
	static Find(Outer: UObject, ResourceName: string): PaperTileLayer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileLayer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileLayer;
	static C(Other: UObject): PaperTileLayer;
}

declare type ETileMapProjectionMode = string | symbol;
declare var ETileMapProjectionMode = { Orthogonal:'Orthogonal',IsometricDiamond:'IsometricDiamond',IsometricStaggered:'IsometricStaggered',HexagonalStaggered:'HexagonalStaggered', };
declare class PaperTileMap extends UObject { 
	/**
	 * Width of map (in tiles)
	*/
	MapWidth: number;
	/**
	 * Height of map (in tiles)
	*/
	MapHeight: number;
	/**
	 * Width of one tile (in pixels)
	*/
	TileWidth: number;
	/**
	 * Height of one tile (in pixels)
	*/
	TileHeight: number;
	/**
	 * The scaling factor between pixels and Unreal units (cm) (e.g., 0.64 would make a 64 pixel wide tile take up 100 cm)
	*/
	PixelsPerUnrealUnit: number;
	/**
	 * The Z-separation incurred as you travel in X (not strictly applied, batched tiles will be put at the same Z level)
	*/
	SeparationPerTileX: number;
	/**
	 * The Z-separation incurred as you travel in Y (not strictly applied, batched tiles will be put at the same Z level)
	*/
	SeparationPerTileY: number;
	/**
	 * The Z-separation between each layer of the tile map
	*/
	SeparationPerLayer: number;
	/**
	 * Last tile set that was selected when editing the tile map
	*/
	SelectedTileSet: any;
	/**
	 * The material to use on a tile map instance if not overridden
	*/
	Material: MaterialInterface;
	/**
	 * The list of layers
	*/
	TileLayers: PaperTileLayer[];
	/**
	 * The extrusion thickness of collision geometry when using a 3D collision domain
	*/
	CollisionThickness: number;
	/**
	 * Collision domain (no collision, 2D, or 3D)
	*/
	SpriteCollisionDomain: ESpriteCollisionMode;
	/**
	 * Tile map type
	*/
	ProjectionMode: ETileMapProjectionMode;
	/**
	 * The vertical height of the sides of the hex cell for a tile.
	 * Note: This value should already be included as part of the TileHeight, and is purely cosmetic; it only affects how the tile cursor preview is drawn.
	*/
	HexSideLength: number;
	/**
	 * Baked physics data.
	*/
	BodySetup: BodySetup;
	/**
	 * Importing data and options used for this tile map
	*/
	AssetImportData: AssetImportData;
	/**
	 * The currently selected layer index
	*/
	SelectedLayerIndex: number;
	/**
	 * The background color displayed in the tile map editor
	*/
	BackgroundColor: LinearColor;
	/**
	 * The naming index to start at when trying to create a new layer
	*/
	LayerNameIndex: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTileMap;
	static Find(Outer: UObject, ResourceName: string): PaperTileMap;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileMap;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileMap;
	static C(Other: UObject): PaperTileMap;
}

declare class PaperTileMapComponent extends MeshComponent { 
	/**
	 * Map Width
	*/
	MapWidth: number;
	/**
	 * Map Height
	*/
	MapHeight: number;
	/**
	 * Tile Width
	*/
	TileWidth: number;
	/**
	 * Tile Height
	*/
	TileHeight: number;
	/**
	 * Default Layer Tile Set
	*/
	DefaultLayerTileSet: PaperTileSet;
	/**
	 * Material
	*/
	Material: MaterialInterface;
	/**
	 * Tile Layers
	*/
	TileLayers: PaperTileLayer[];
	/**
	 * The color of the tile map (multiplied with the per-layer color and passed to the material as a vertex color)
	*/
	TileMapColor: LinearColor;
	/**
	 * The index of the single layer to use if enabled
	*/
	UseSingleLayerIndex: number;
	/**
	 * Should we draw a single layer?
	*/
	bUseSingleLayer: boolean;
	/**
	 * The tile map used by this component
	*/
	TileMap: PaperTileMap;
	/**
	 * Should this component show a tile grid when the component is selected?
	*/
	bShowPerTileGridWhenSelected: boolean;
	/**
	 * Should this component show an outline around each layer when the component is selected?
	*/
	bShowPerLayerGridWhenSelected: boolean;
	/**
	 * Should this component show an outline around the first layer when the component is not selected?
	*/
	bShowOutlineWhenUnselected: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTileMapComponent;
	static Find(Outer: UObject, ResourceName: string): PaperTileMapComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileMapComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileMapComponent;
	/**
	 * Sets the tile map global color multiplier (multiplied with the per-layer color and passed to the material as a vertex color)
	*/
	SetTileMapColor(NewColor: LinearColor): void;
	/**
	 * Change the PaperTileMap used by this instance.
	*/
	SetTileMap(NewTileMap: PaperTileMap): boolean;
	/**
	 * Modifies the contents of a specified tile cell (Note: This will only work on components that own their own tile map (OwnsTileMap returns true), you cannot modify standalone tile map assets)
	 * Note: Does not update collision by default, call RebuildCollision after all edits have been done in a frame if necessary
	*/
	SetTile(X: number,Y: number,Layer: number,NewValue: PaperTileInfo): void;
	/**
	 * Sets the per-layer color multiplier for a specific layer (multiplied with the tile map color and passed to the material as a vertex color)
	 * Note: This will only work on components that own their own tile map (OwnsTileMap returns true), you cannot modify standalone tile map assets
	*/
	SetLayerColor(NewColor: LinearColor,Layer: number): void;
	/**
	 * Sets the collision thickness for a specific layer
	 * Note: This will only work on components that own their own tile map (OwnsTileMap returns true), you cannot modify standalone tile map assets
	*/
	SetLayerCollision(Layer: number,bHasCollision: boolean,bOverrideThickness: boolean,CustomThickness: number,bOverrideOffset: boolean,CustomOffset: number,bRebuildCollision: boolean): void;
	/**
	 * Sets the default thickness for any layers that don't override the collision thickness
	 * Note: This will only work on components that own their own tile map (OwnsTileMap returns true), you cannot modify standalone tile map assets
	*/
	SetDefaultCollisionThickness(Thickness: number,bRebuildCollision: boolean): void;
	/**
	 * Resizes the tile map (Note: This will only work on components that own their own tile map (OwnsTileMap returns true), you cannot modify standalone tile map assets)
	*/
	ResizeMap(NewWidthInTiles: number,NewHeightInTiles: number): void;
	/**
	 * Rebuilds collision for the tile map
	*/
	RebuildCollision(): void;
	/**
	 * Does this component own the tile map (is it instanced instead of being an asset reference)?
	*/
	OwnsTileMap(): boolean;
	/**
	 * Makes the tile map asset pointed to by this component editable.  Nothing happens if it was already instanced, but
	 * if the tile map is an asset reference, it is cloned to make a unique instance.
	*/
	MakeTileMapEditable(): void;
	/**
	 * Returns the polygon for the specified tile (will be 4 or 6 vertices as a rectangle, diamond, or hexagon)
	*/
	GetTilePolygon(TileX: number,TileY: number,Points?: Vector[],LayerIndex?: number,bWorldSpace?: boolean): {Points: Vector[]};
	/**
	 * Gets the tile map global color multiplier (multiplied with the per-layer color and passed to the material as a vertex color)
	*/
	GetTileMapColor(): LinearColor;
	/**
	 * Returns the position of the top left corner of the specified tile
	*/
	GetTileCornerPosition(TileX: number,TileY: number,LayerIndex: number,bWorldSpace: boolean): Vector;
	/**
	 * Returns the position of the center of the specified tile
	*/
	GetTileCenterPosition(TileX: number,TileY: number,LayerIndex: number,bWorldSpace: boolean): Vector;
	/**
	 * Returns the contents of a specified tile cell
	*/
	GetTile(X: number,Y: number,Layer: number): PaperTileInfo;
	/**
	 * Returns the size of the tile map
	*/
	GetMapSize(MapWidth?: number,MapHeight?: number,NumLayers?: number): {MapWidth: number, MapHeight: number, NumLayers: number};
	/**
	 * Gets the per-layer color multiplier for a specific layer (multiplied with the tile map color and passed to the material as a vertex color)
	*/
	GetLayerColor(Layer: number): LinearColor;
	/**
	 * Creates a new tile map of the specified size, replacing the TileMap reference (or dropping the previous owned one)
	 * @param MapWidth Width of the map (in tiles)
	 * @param MapHeight Height of the map (in tiles)
	 * @param TileWidth Width of one tile (in pixels)
	 * @param TileHeight Height of one tile (in pixels)
	 * @param bCreateLayer Should an empty layer be created?
	*/
	CreateNewTileMap(MapWidth: number,MapHeight: number,TileWidth: number,TileHeight: number,PixelsPerUnrealUnit: number,bCreateLayer: boolean): void;
	/**
	 * Creates and adds a new layer to the tile map
	 * Note: This will only work on components that own their own tile map (OwnsTileMap returns true), you cannot modify standalone tile map assets
	*/
	AddNewLayer(): PaperTileLayer;
	static C(Other: UObject): PaperTileMapComponent;
}

declare class PaperTileMapActor extends Actor { 
	/**
	 * Render Component
	*/
	RenderComponent: PaperTileMapComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileMapActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileMapActor;
	static C(Other: UObject): PaperTileMapActor;
}

declare class TileMapBlueprintLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TileMapBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): TileMapBlueprintLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TileMapBlueprintLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileMapBlueprintLibrary;
	/**
	 * Creates a tile from the specified information
	*/
	static MakeTile(TileIndex: number,TileSet: PaperTileSet,bFlipH: boolean,bFlipV: boolean,bFlipD: boolean): PaperTileInfo;
	/**
	 * Returns the user data name for the specified tile, or NAME_None if there is no user-specified data
	*/
	static GetTileUserData(Tile: PaperTileInfo): string;
	/**
	 * Returns the transform for a tile
	*/
	static GetTileTransform(Tile: PaperTileInfo): Transform;
	/**
	 * Breaks out the information for a tile
	*/
	static BreakTile(Tile: PaperTileInfo,TileIndex?: number,TileSet?: PaperTileSet,bFlipH?: boolean,bFlipV?: boolean,bFlipD?: boolean): {TileIndex: number, TileSet: PaperTileSet, bFlipH: boolean, bFlipV: boolean, bFlipD: boolean};
	static C(Other: UObject): TileMapBlueprintLibrary;
}

declare class LightPropagationVolumeSettings { 
	/**
	 * Override LPVIntensity
	*/
	bOverride_LPVIntensity: boolean;
	/**
	 * Override LPVDirectional Occlusion Intensity
	*/
	bOverride_LPVDirectionalOcclusionIntensity: boolean;
	/**
	 * Override LPVDirectional Occlusion Radius
	*/
	bOverride_LPVDirectionalOcclusionRadius: boolean;
	/**
	 * Override LPVDiffuse Occlusion Exponent
	*/
	bOverride_LPVDiffuseOcclusionExponent: boolean;
	/**
	 * Override LPVSpecular Occlusion Exponent
	*/
	bOverride_LPVSpecularOcclusionExponent: boolean;
	/**
	 * Override LPVDiffuse Occlusion Intensity
	*/
	bOverride_LPVDiffuseOcclusionIntensity: boolean;
	/**
	 * Override LPVSpecular Occlusion Intensity
	*/
	bOverride_LPVSpecularOcclusionIntensity: boolean;
	/**
	 * Override LPVSize
	*/
	bOverride_LPVSize: boolean;
	/**
	 * Override LPVSecondary Occlusion Intensity
	*/
	bOverride_LPVSecondaryOcclusionIntensity: boolean;
	/**
	 * Override LPVSecondary Bounce Intensity
	*/
	bOverride_LPVSecondaryBounceIntensity: boolean;
	/**
	 * Override LPVGeometry Volume Bias
	*/
	bOverride_LPVGeometryVolumeBias: boolean;
	/**
	 * Override LPVVpl Injection Bias
	*/
	bOverride_LPVVplInjectionBias: boolean;
	/**
	 * Override LPVEmissive Injection Intensity
	*/
	bOverride_LPVEmissiveInjectionIntensity: boolean;
	/**
	 * How strong the dynamic GI from the LPV should be. 0.0 is off, 1.0 is the "normal" value, but higher values can be used to boost the effect
	*/
	LPVIntensity: number;
	/**
	 * Bias applied to light injected into the LPV in cell units. Increase to reduce bleeding through thin walls
	*/
	LPVVplInjectionBias: number;
	/**
	 * The size of the LPV volume, in Unreal units
	*/
	LPVSize: number;
	/**
	 * Secondary occlusion strength (bounce light shadows). Set to 0 to disable
	*/
	LPVSecondaryOcclusionIntensity: number;
	/**
	 * Secondary bounce light strength (bounce light shadows). Set to 0 to disable
	*/
	LPVSecondaryBounceIntensity: number;
	/**
	 * Bias applied to the geometry volume in cell units. Increase to reduce darkening due to secondary occlusion
	*/
	LPVGeometryVolumeBias: number;
	/**
	 * LPVEmissive Injection Intensity
	*/
	LPVEmissiveInjectionIntensity: number;
	/**
	 * Controls the amount of directional occlusion. Requires LPV. Values very close to 1.0 are recommended
	*/
	LPVDirectionalOcclusionIntensity: number;
	/**
	 * Occlusion Radius - 16 is recommended for most scenes
	*/
	LPVDirectionalOcclusionRadius: number;
	/**
	 * Diffuse occlusion exponent - increase for more contrast. 1 to 2 is recommended
	*/
	LPVDiffuseOcclusionExponent: number;
	/**
	 * Specular occlusion exponent - increase for more contrast. 6 to 9 is recommended
	*/
	LPVSpecularOcclusionExponent: number;
	/**
	 * Diffuse occlusion intensity - higher values provide increased diffuse occlusion.
	*/
	LPVDiffuseOcclusionIntensity: number;
	/**
	 * Specular occlusion intensity - higher values provide increased specular occlusion.
	*/
	LPVSpecularOcclusionIntensity: number;
	clone() : LightPropagationVolumeSettings;
	static C(Other: UObject): LightPropagationVolumeSettings;
}

declare class LightPropagationVolumeBlendable extends UObject { 
	/**
	 * Settings
	*/
	Settings: LightPropagationVolumeSettings;
	/**
	 * 0:no effect, 1:full effect
	*/
	BlendWeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightPropagationVolumeBlendable;
	static Find(Outer: UObject, ResourceName: string): LightPropagationVolumeBlendable;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightPropagationVolumeBlendable;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightPropagationVolumeBlendable;
	static C(Other: UObject): LightPropagationVolumeBlendable;
}

declare class DirectoryWatcher extends UObject { 
	/**
	 * Added
	*/
	Added: string[];
	/**
	 * Modified
	*/
	Modified: string[];
	/**
	 * Removed
	*/
	Removed: string[];
	/**
	 * On Changed
	*/
	OnChanged: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DirectoryWatcher;
	static Find(Outer: UObject, ResourceName: string): DirectoryWatcher;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DirectoryWatcher;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DirectoryWatcher;
	/**
	 * Watch
	*/
	Watch(Directory: string): void;
	/**
	 * Unwatch
	*/
	Unwatch(): void;
	/**
	 * Contains
	*/
	Contains(File: string): boolean;
	static C(Other: UObject): DirectoryWatcher;
}

declare class JavascriptContext extends UObject { 
	/**
	 * Paths
	*/
	Paths: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptContext;
	static Find(Outer: UObject, ResourceName: string): JavascriptContext;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptContext;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptContext;
	/**
	 * Write DTS
	*/
	WriteDTS(Target: string,bIncludingTooltip: boolean): boolean;
	/**
	 * Write Aliases
	*/
	WriteAliases(Target: string): boolean;
	/**
	 * Set Context Id
	*/
	SetContextId(Name: string): void;
	/**
	 * Set as Debug Context
	*/
	SetAsDebugContext(): void;
	/**
	 * Run Script
	*/
	RunScript(Script: string,bOutput: boolean): string;
	/**
	 * Run File
	*/
	RunFile(Filename: string): void;
	/**
	 * Reset as Debug Context
	*/
	ResetAsDebugContext(): void;
	/**
	 * Read Script File
	*/
	ReadScriptFile(Filename: string): string;
	/**
	 * Is Debug Context
	*/
	IsDebugContext(): boolean;
	/**
	 * Get Script File Full Path
	*/
	GetScriptFileFullPath(Filename: string): string;
	/**
	 * Expose
	*/
	Expose(Name: string,UObject: UObject): void;
	static C(Other: UObject): JavascriptContext;
}

declare class JavascriptAsset { 
	/**
	 * Name
	*/
	Name: string;
	/**
	 * Asset
	*/
	Asset: StringAssetReference;
	clone() : JavascriptAsset;
	static C(Other: UObject): JavascriptAsset;
}

declare class JavascriptClassAsset { 
	/**
	 * Name
	*/
	Name: string;
	/**
	 * Class
	*/
	Class: UnrealEngineClass;
	clone() : JavascriptClassAsset;
	static C(Other: UObject): JavascriptClassAsset;
}

declare class JavascriptComponent extends ActorComponent { 
	/**
	 * Script Source File
	*/
	ScriptSourceFile: string;
	/**
	 * Active Within Editor
	*/
	bActiveWithinEditor: boolean;
	/**
	 * Javascript Context
	*/
	JavascriptContext: JavascriptContext;
	/**
	 * On Tick
	*/
	OnTick: UnrealEngineDelegate<(DeltaSeconds: number) => void>;
	/**
	 * On Begin Play
	*/
	OnBeginPlay: UnrealEngineDelegate<() => void>;
	/**
	 * On End Play
	*/
	OnEndPlay: UnrealEngineDelegate<() => void>;
	/**
	 * On Invoke
	*/
	OnInvoke: UnrealEngineDelegate<(Name: string) => void>;
	/**
	 * Assets
	*/
	Assets: JavascriptAsset[];
	/**
	 * Class Assets
	*/
	ClassAssets: JavascriptClassAsset[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptComponent;
	static Find(Outer: UObject, ResourceName: string): JavascriptComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptComponent;
	/**
	 * Resolve Class
	*/
	ResolveClass(Name: string): UnrealEngineClass;
	/**
	 * Resolve Asset
	*/
	ResolveAsset(Name: string,bTryLoad: boolean): UObject;
	/**
	 * Invoke
	*/
	Invoke(Name: string): void;
	/**
	 * Begin UActorComponent interface.
	*/
	ForceGC(): void;
	/**
	 * Expose
	*/
	Expose(ExposedAs: string,UObject: UObject): void;
	static C(Other: UObject): JavascriptComponent;
}

declare class JavascriptDelegate extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptDelegate;
	static Find(Outer: UObject, ResourceName: string): JavascriptDelegate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptDelegate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptDelegate;
	/**
	 * Fire
	*/
	Fire(): void;
	static C(Other: UObject): JavascriptDelegate;
}

declare class JavascriptGeneratedClass extends BlueprintGeneratedClass { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptGeneratedClass;
	static Find(Outer: UObject, ResourceName: string): JavascriptGeneratedClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptGeneratedClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptGeneratedClass;
	static C(Other: UObject): JavascriptGeneratedClass;
}

declare class JavascriptGeneratedClass_Native extends BlueprintGeneratedClass { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptGeneratedClass_Native;
	static Find(Outer: UObject, ResourceName: string): JavascriptGeneratedClass_Native;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptGeneratedClass_Native;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptGeneratedClass_Native;
	static C(Other: UObject): JavascriptGeneratedClass_Native;
}

declare class JavascriptGeneratedFunction extends UFunction { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptGeneratedFunction;
	static Find(Outer: UObject, ResourceName: string): JavascriptGeneratedFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptGeneratedFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptGeneratedFunction;
	static C(Other: UObject): JavascriptGeneratedFunction;
}

declare class JavascriptGlobalDelegates extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptGlobalDelegates;
	static Find(Outer: UObject, ResourceName: string): JavascriptGlobalDelegates;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptGlobalDelegates;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptGlobalDelegates;
	/**
	 * Unbind All
	*/
	UnbindAll(): void;
	/**
	 * Unbind
	*/
	Unbind(Key: string): void;
	/**
	 * Redirector Followed
	*/
	RedirectorFollowed(PackageName: string,Redirector: UObject): void;
	/**
	 * Pre Load Map
	*/
	PreLoadMap(MapName: string): void;
	/**
	 * Pre Garbage Collect
	*/
	PreGarbageCollect(): void;
	/**
	 * Post Load Map
	*/
	PostLoadMap(): void;
	/**
	 * Post Garbage Collect
	*/
	PostGarbageCollect(): void;
	/**
	 * Post Demo Play
	*/
	PostDemoPlay(): void;
	/**
	 * Post Apply Level Offset
	*/
	PostApplyLevelOffset(Level: Level,World: World,Offset: Vector,Flag: boolean): void;
	/**
	 * Package Created for Load
	*/
	PackageCreatedForLoad(InPackage: Package): void;
	/**
	 * On World Cleanup
	*/
	OnWorldCleanup(World: World,bSessionEnded: boolean,bCleanupResources: boolean): void;
	/**
	 * On Pre World Initialization Friendly
	*/
	OnPreWorldInitialization_Friendly(World: World): void;
	/**
	 * On Pre World Finish Destroy
	*/
	OnPreWorldFinishDestroy(World: World): void;
	/**
	 * On Pre Object Property Changed Friendly
	*/
	OnPreObjectPropertyChanged_Friendly(InObject: UObject,Property: Property,MemberProperty: Property): void;
	/**
	 * On Post World Initialization Friendly
	*/
	OnPostWorldInitialization_Friendly(World: World): void;
	/**
	 * WorldDelegates
	 * @todo : ELevelTick -> BT Type
	 *       UFUNCTION(BlueprintImplementableEvent, Category = "Scripting | Javascript")
	 *       void OnWorldTickStart(ELevelTick LevelTickType, float Delta);
	*/
	OnPostWorldCreation(World: World): void;
	/**
	 * On Post Duplicate Friendly
	*/
	OnPostDuplicate_Friendly(World: World,bDuplicateForPIE: boolean): void;
	/**
	 * On Object Saved
	*/
	OnObjectSaved(UObject: UObject): void;
	/**
	 * On Object Property Changed Friendly
	*/
	OnObjectPropertyChanged_Friendly(InObject: UObject,Property: Property,MemberProperty: Property,ChangeType: number): void;
	/**
	 * On Object Modified
	*/
	OnObjectModified(UObject: UObject): void;
	/**
	 * On Asset Loaded
	*/
	OnAssetLoaded(UObject: UObject): void;
	/**
	 * Level Removed from World
	*/
	LevelRemovedFromWorld(Level: Level,World: World): void;
	/**
	 * Level Added to World
	*/
	LevelAddedToWorld(Level: Level,World: World): void;
	/**
	 * end of WorldDelegates
	*/
	Bind(Key: string): void;
	static C(Other: UObject): JavascriptGlobalDelegates;
}

declare class JavascriptHeapStatistics { 
	/**
	 * Total Heap Size
	*/
	TotalHeapSize: number;
	/**
	 * Total Heap Size Executable
	*/
	TotalHeapSizeExecutable: number;
	/**
	 * Total Physical Size
	*/
	TotalPhysicalSize: number;
	/**
	 * Total Available Size
	*/
	TotalAvailableSize: number;
	/**
	 * Used Heap Size
	*/
	UsedHeapSize: number;
	/**
	 * Heap Size Limit
	*/
	HeapSizeLimit: number;
	/**
	 * Malloced Memory
	*/
	MallocedMemory: number;
	/**
	 * Does Zap Garbage
	*/
	bDoesZapGarbage: boolean;
	clone() : JavascriptHeapStatistics;
	static C(Other: UObject): JavascriptHeapStatistics;
}

declare class JavascriptIsolate extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptIsolate;
	static Find(Outer: UObject, ResourceName: string): JavascriptIsolate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptIsolate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptIsolate;
	/**
	 * Get Heap Statistics
	*/
	GetHeapStatistics(Statistics?: JavascriptHeapStatistics): {Statistics: JavascriptHeapStatistics};
	/**
	 * Create Context
	*/
	CreateContext(): JavascriptContext;
	static C(Other: UObject): JavascriptIsolate;
}

declare class JavascriptProfileNode { 
	clone() : JavascriptProfileNode;
	static C(Other: UObject): JavascriptProfileNode;
	/**
	 * static bool GetLineTicks(LineTick* entries, unsigned int length) const;
	*/
	GetBailoutReason(): string;
	/**
	 * Get Call Uid
	*/
	GetCallUid(): number;
	/**
	 * Get Child
	*/
	GetChild(index: number): JavascriptProfileNode;
	/**
	 * Get Children Count
	*/
	GetChildrenCount(): number;
	/**
	 * Get Column Number
	*/
	GetColumnNumber(): number;
	/**
	 * Get Deopt Info Reason
	*/
	GetDeoptInfo_Reason(index: number): string;
	/**
	 * Get Deopt Info Stack
	*/
	GetDeoptInfo_Stack(index: number): string;
	/**
	 * Get Deopt Infos Count
	*/
	GetDeoptInfosCount(index: number): number;
	/**
	 * Get Function Name
	*/
	GetFunctionName(): string;
	/**
	 * Get Hit Count
	*/
	GetHitCount(): number;
	/**
	 * Get Hit Line Count
	*/
	GetHitLineCount(): number;
	/**
	 * Get Line Number
	*/
	GetLineNumber(): number;
	/**
	 * Get Node Id
	*/
	GetNodeId(): number;
	/**
	 * Get Script Id
	*/
	GetScriptId(): number;
	/**
	 * Get Script Resource Name
	*/
	GetScriptResourceName(): string;
	/**
	 * static bool GetLineTicks(LineTick* entries, unsigned int length) const;
	*/
	static GetBailoutReason(UNode: JavascriptProfileNode): string;
	/**
	 * Get Call Uid
	*/
	static GetCallUid(UNode: JavascriptProfileNode): number;
	/**
	 * Get Child
	*/
	static GetChild(UNode: JavascriptProfileNode,index: number): JavascriptProfileNode;
	/**
	 * Get Children Count
	*/
	static GetChildrenCount(UNode: JavascriptProfileNode): number;
	/**
	 * Get Column Number
	*/
	static GetColumnNumber(UNode: JavascriptProfileNode): number;
	/**
	 * Get Deopt Info Reason
	*/
	static GetDeoptInfo_Reason(UNode: JavascriptProfileNode,index: number): string;
	/**
	 * Get Deopt Info Stack
	*/
	static GetDeoptInfo_Stack(UNode: JavascriptProfileNode,index: number): string;
	/**
	 * Get Deopt Infos Count
	*/
	static GetDeoptInfosCount(UNode: JavascriptProfileNode,index: number): number;
	/**
	 * Get Function Name
	*/
	static GetFunctionName(UNode: JavascriptProfileNode): string;
	/**
	 * Get Hit Count
	*/
	static GetHitCount(UNode: JavascriptProfileNode): number;
	/**
	 * Get Hit Line Count
	*/
	static GetHitLineCount(UNode: JavascriptProfileNode): number;
	/**
	 * Get Line Number
	*/
	static GetLineNumber(UNode: JavascriptProfileNode): number;
	/**
	 * Get Node Id
	*/
	static GetNodeId(UNode: JavascriptProfileNode): number;
	/**
	 * Get Script Id
	*/
	static GetScriptId(UNode: JavascriptProfileNode): number;
	/**
	 * Get Script Resource Name
	*/
	static GetScriptResourceName(UNode: JavascriptProfileNode): string;
}

declare class JavascriptProfile extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptProfile;
	static Find(Outer: UObject, ResourceName: string): JavascriptProfile;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptProfile;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptProfile;
	/**
	 * Stop
	*/
	static Stop(Title: string): JavascriptProfile;
	/**
	 * Start
	*/
	static Start(Title: string,bRecordSamples: boolean): void;
	/**
	 * Set Sampling Interval
	*/
	static SetSamplingInterval(us: number): void;
	/**
	 * Set Idle
	*/
	static SetIdle(is_idle: boolean): void;
	/**
	 * Get Top Down Root
	*/
	GetTopDownRoot(): JavascriptProfileNode;
	/**
	 * Get Sample Timestamp
	*/
	GetSampleTimestamp(index: number): number;
	/**
	 * Get Samples Count
	*/
	GetSamplesCount(): number;
	/**
	 * Get Sample
	*/
	GetSample(index: number): JavascriptProfileNode;
	static C(Other: UObject): JavascriptProfile;
}

declare class JavascriptFunction { 
	clone() : JavascriptFunction;
	static C(Other: UObject): JavascriptFunction;
}

declare class JavascriptStreamableManager { 
	clone() : JavascriptStreamableManager;
	static C(Other: UObject): JavascriptStreamableManager;
	/**
	 * Is Async Load Complete
	*/
	IsAsyncLoadComplete(Target: StringAssetReference): boolean;
	/**
	 * Request Async Load
	*/
	RequestAsyncLoad(TargetsToStream: StringAssetReference[],DelegateToCall: JavascriptFunction,Priority: number): void;
	/**
	 * Simple Async Load
	*/
	SimpleAsyncLoad(Target: StringAssetReference,Priority: number): void;
	/**
	 * Unload
	*/
	Unload(Target: StringAssetReference): void;
	/**
	 * Is Async Load Complete
	*/
	static IsAsyncLoadComplete(Manager: JavascriptStreamableManager,Target: StringAssetReference): boolean;
	/**
	 * Request Async Load
	*/
	static RequestAsyncLoad(Manager: JavascriptStreamableManager,TargetsToStream: StringAssetReference[],DelegateToCall: JavascriptFunction,Priority: number): void;
	/**
	 * Simple Async Load
	*/
	static SimpleAsyncLoad(Manager: JavascriptStreamableManager,Target: StringAssetReference,Priority: number): void;
	/**
	 * Unload
	*/
	static Unload(Manager: JavascriptStreamableManager,Target: StringAssetReference): void;
	/**
	 * Create Streamable Manager
	*/
	static CreateStreamableManager(): JavascriptStreamableManager;
}

declare type ELogVerbosity_JS = string | symbol;
declare var ELogVerbosity_JS = { NoLogging:'NoLogging',Fatal:'Fatal',Error:'Error',Warning:'Warning',Display:'Display',Log:'Log',Verbose:'Verbose',VeryVerbose:'VeryVerbose', };
declare class JavascriptLogCategory { 
	clone() : JavascriptLogCategory;
	static C(Other: UObject): JavascriptLogCategory;
	/**
	 * Log
	*/
	Log(Verbosity: ELogVerbosity_JS,Message: string,FileName: string,LineNumber: number): void;
	/**
	 * Log
	*/
	static Log(Category: JavascriptLogCategory,Verbosity: ELogVerbosity_JS,Message: string,FileName: string,LineNumber: number): void;
	/**
	 * Create Log Category
	*/
	static CreateLogCategory(CategoryName: string,InDefaultVerbosity: ELogVerbosity_JS): JavascriptLogCategory;
}

declare class JavascriptLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptLibrary;
	/**
	 * Write String to File
	*/
	static WriteStringToFile(UObject: UObject,Filename: string,Data: string): boolean;
	/**
	 * Write File
	*/
	static WriteFile(UObject: UObject,Filename: string): boolean;
	/**
	 * V8 Set Idle Task Budget
	*/
	static V8_SetIdleTaskBudget(BudgetInSeconds: number): void;
	/**
	 * V8 Set Flags from String
	*/
	static V8_SetFlagsFromString(V8Flags: string): void;
	/**
	 * Unregister Component
	*/
	static UnregisterComponent(ActorComponent: ActorComponent): void;
	/**
	 * Unload
	*/
	static Unload(Manager: JavascriptStreamableManager,Target: StringAssetReference): void;
	/**
	 * Try Load by Path
	*/
	static TryLoadByPath(Path: string): UObject;
	/**
	 * Simple Async Load
	*/
	static SimpleAsyncLoad(Manager: JavascriptStreamableManager,Target: StringAssetReference,Priority: number): void;
	/**
	 * Set Root Component
	*/
	static SetRootComponent(Actor: Actor,Component: SceneComponent): void;
	/**
	 * Set Object Flags
	*/
	static SetObjectFlags(Obj: UObject,Flags: number): void;
	/**
	 * Set Mobility
	*/
	static SetMobility(SceneComponent: SceneComponent,Type: EComponentMobility): void;
	/**
	 * Set Mobile
	*/
	static SetMobile(SceneComponent: SceneComponent): void;
	/**
	 * Set Client Travel
	*/
	static SetClientTravel(Engine: Engine,InWorld: World,NextURL: string,InTravelType: ETravelType): void;
	/**
	 * Segment Intersection 2D
	*/
	static SegmentIntersection2D(SegmentStartA: Vector,SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	/**
	 * Reregister Component
	*/
	static ReregisterComponent(ActorComponent: ActorComponent): void;
	/**
	 * Reregister All Components
	*/
	static ReregisterAllComponents(Actor: Actor): void;
	/**
	 * Request Async Load
	*/
	static RequestAsyncLoad(Manager: JavascriptStreamableManager,TargetsToStream: StringAssetReference[],DelegateToCall: JavascriptFunction,Priority: number): void;
	/**
	 * Register Component
	*/
	static RegisterComponent(ActorComponent: ActorComponent): void;
	/**
	 * Read String from File
	*/
	static ReadStringFromFile(UObject: UObject,Filename: string): string;
	/**
	 * Read File
	*/
	static ReadFile(UObject: UObject,Filename: string): boolean;
	/**
	 * Read Directory
	*/
	static ReadDirectory(UObject: UObject,Directory: string,OutItems?: DirectoryItem[]): {OutItems: DirectoryItem[], $: boolean};
	/**
	 * Mark Render State Dirty
	*/
	static MarkRenderStateDirty(Component: ActorComponent): void;
	/**
	 * Make Directory
	*/
	static MakeDirectory(Path: string,Tree: boolean): boolean;
	/**
	 * Log
	*/
	static Log(Category: JavascriptLogCategory,Verbosity: ELogVerbosity_JS,Message: string,FileName: string,LineNumber: number): void;
	/**
	 * Load Package
	*/
	static LoadPackage(InOuter: Package,PackageName: string): Package;
	/**
	 * Is Suppressed
	*/
	IsSuppressed(Category: JavascriptLogCategory,Verbosity: ELogVerbosity_JS): boolean;
	/**
	 * Is Registered
	*/
	static IsRegistered(ActorComponent: ActorComponent): boolean;
	/**
	 * Is Play in Preview
	*/
	static IsPlayInPreview(World: World): boolean;
	/**
	 * Is Play in Editor
	*/
	static IsPlayInEditor(World: World): boolean;
	/**
	 * Is Game World
	*/
	static IsGameWorld(World: World): boolean;
	/**
	 * Is Async Load Complete
	*/
	static IsAsyncLoadComplete(Manager: JavascriptStreamableManager,Target: StringAssetReference): boolean;
	/**
	 * Has Undo
	*/
	static HasUndo(Engine: Engine): boolean;
	/**
	 * Has Any Package Flags
	*/
	static HasAnyPackageFlags(Package: Package,Flags: number): boolean;
	/**
	 * Has Any Flags
	*/
	static HasAnyFlags(UObject: UObject,Flags: number): boolean;
	/**
	 * Handle Seamless Travel Player
	*/
	static HandleSeamlessTravelPlayer(GameMode: GameMode,C?: Controller): {C: Controller};
	/**
	 * Get Script Resource Name
	*/
	static GetScriptResourceName(UNode: JavascriptProfileNode): string;
	/**
	 * Get Script Id
	*/
	static GetScriptId(UNode: JavascriptProfileNode): number;
	/**
	 * Get Platform Name
	*/
	static GetPlatformName(): string;
	/**
	 * Get Outermost
	*/
	static GetOutermost(UObject: UObject): UObject;
	/**
	 * Get Outer
	*/
	static GetOuter(UObject: UObject): UObject;
	/**
	 * Get Objects with Outer
	*/
	static GetObjectsWithOuter(Outer: UObject,Results?: UObject[],bIncludeNestedObjects?: boolean,ExclusionFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	/**
	 * Get Objects Of Class
	*/
	static GetObjectsOfClass(ClassToLookFor: UnrealEngineClass,Results?: UObject[],bIncludeDerivedClasses?: boolean,ExcludeFlags?: number,ExclusionInternalFlags?: number): {Results: UObject[]};
	/**
	 * Get Node Id
	*/
	static GetNodeId(UNode: JavascriptProfileNode): number;
	/**
	 * Get Name
	*/
	static GetName(UObject: UObject): string;
	/**
	 * Get Model
	*/
	static GetModel(World: World): Model;
	/**
	 * Get Meta Data
	*/
	static GetMetaData(Field: Field,Key: string): string;
	/**
	 * Get Line Number
	*/
	static GetLineNumber(UNode: JavascriptProfileNode): number;
	/**
	 * Get Levels
	*/
	static GetLevels(World: World): Level[];
	/**
	 * Get Level
	*/
	static GetLevel(Actor: Actor): Level;
	/**
	 * Get Last Render Time
	*/
	static GetLastRenderTime(Actor: Actor): number;
	/**
	 * Get Hit Line Count
	*/
	static GetHitLineCount(UNode: JavascriptProfileNode): number;
	/**
	 * Get Hit Count
	*/
	static GetHitCount(UNode: JavascriptProfileNode): number;
	/**
	 * Get Function Parms Size
	*/
	static GetFunctionParmsSize(UFunction: UFunction): number;
	/**
	 * Get Function Name
	*/
	static GetFunctionName(UNode: JavascriptProfileNode): string;
	/**
	 * Get File Size
	*/
	static GetFileSize(UObject: UObject,Filename: string): number;
	/**
	 * Get Fields
	*/
	static GetFields(UObject: UObject,bIncludeSuper: boolean): Field[];
	/**
	 * Get Dynamic Binding
	*/
	static GetDynamicBinding(Outer: UnrealEngineClass,BindingObjectClass: UnrealEngineClass): DynamicBlueprintBinding;
	/**
	 * Get Dir
	*/
	static GetDir(UObject: UObject,WhichDir: string): string;
	/**
	 * Get Derived Classes
	*/
	static GetDerivedClasses(ClassToLookFor: UnrealEngineClass,Results?: UnrealEngineClass[],bRecursive?: boolean): {Results: UnrealEngineClass[]};
	/**
	 * Get Deopt Infos Count
	*/
	static GetDeoptInfosCount(UNode: JavascriptProfileNode,index: number): number;
	/**
	 * Get Deopt Info Stack
	*/
	static GetDeoptInfo_Stack(UNode: JavascriptProfileNode,index: number): string;
	/**
	 * Get Deopt Info Reason
	*/
	static GetDeoptInfo_Reason(UNode: JavascriptProfileNode,index: number): string;
	/**
	 * Get Current Process Id
	*/
	static GetCurrentProcessId(): number;
	/**
	 * Get Column Number
	*/
	static GetColumnNumber(UNode: JavascriptProfileNode): number;
	/**
	 * Get Class Path Name
	*/
	static GetClassPathName(Class: UnrealEngineClass): string;
	/**
	 * Get Children Count
	*/
	static GetChildrenCount(UNode: JavascriptProfileNode): number;
	/**
	 * Get Child
	*/
	static GetChild(UNode: JavascriptProfileNode,index: number): JavascriptProfileNode;
	/**
	 * Get Category Name
	*/
	GetCategoryName(Category: JavascriptLogCategory): string;
	/**
	 * Get Call Uid
	*/
	static GetCallUid(UNode: JavascriptProfileNode): number;
	/**
	 * Get Blueprint Generated Class from Path
	*/
	static GetBlueprintGeneratedClassFromPath(Path: string): UnrealEngineClass;
	/**
	 * Get Blueprint Generated Class
	*/
	static GetBlueprintGeneratedClass(Blueprint: Blueprint): UnrealEngineClass;
	/**
	 * static bool GetLineTicks(LineTick* entries, unsigned int length) const;
	*/
	static GetBailoutReason(UNode: JavascriptProfileNode): string;
	/**
	 * Get Archetype Path Name
	*/
	static GetArchetypePathName(UObject: UObject): string;
	/**
	 * Get All Actors Of Class and Tags
	*/
	static GetAllActorsOfClassAndTags(WorldContextObject: UObject,ActorClass: UnrealEngineClass,Tags_Accept: string[],Tags_Deny: string[],OutActors?: Actor[]): {OutActors: Actor[]};
	/**
	 * Generate Navigation
	*/
	static GenerateNavigation(world: World,NavData: RecastNavMesh): void;
	/**
	 * Find Package
	*/
	static FindPackage(InOuter: UObject,PackageName: string): Package;
	/**
	 * Find Object with Outer
	*/
	static FindObjectWithOuter(Outer: UObject,ClassToLookFor: UnrealEngineClass,NameToLookFor: string): UObject;
	/**
	 * File Exists
	*/
	static FileExists(Filename: string): boolean;
	/**
	 * Duplicate
	*/
	static Duplicate(UObject: UObject,Outer: UObject,Name: string): UObject;
	/**
	 * Directory Exists
	*/
	static DirectoryExists(InDirectory: string): boolean;
	/**
	 * Delete Directory
	*/
	static DeleteDirectory(Path: string,RequireExists: boolean,Tree: boolean): boolean;
	/**
	 * Create Streamable Manager
	*/
	static CreateStreamableManager(): JavascriptStreamableManager;
	/**
	 * Create Package
	*/
	static CreatePackage(Outer: UObject,PackageName: string): Package;
	/**
	 * Create Log Category
	*/
	static CreateLogCategory(CategoryName: string,InDefaultVerbosity: ELogVerbosity_JS): JavascriptLogCategory;
	/**
	 * Create Enum
	*/
	static CreateEnum(Outer: UObject,Name: string,DisplayNames: string[]): Enum;
	/**
	 * Add Dynamic Binding
	*/
	static AddDynamicBinding(Outer: UnrealEngineClass,BindingObject: DynamicBlueprintBinding): void;
	/**
	 * Actor Get World
	*/
	static Actor_GetWorld(Actor: Actor): World;
	static C(Other: UObject): JavascriptLibrary;
}

declare class JavascriptMemoryObject extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptMemoryObject;
	static Find(Outer: UObject, ResourceName: string): JavascriptMemoryObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptMemoryObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptMemoryObject;
	static C(Other: UObject): JavascriptMemoryObject;
}

declare class JavascriptSharedMemoryRegion extends JavascriptMemoryObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptSharedMemoryRegion;
	static Find(Outer: UObject, ResourceName: string): JavascriptSharedMemoryRegion;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptSharedMemoryRegion;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptSharedMemoryRegion;
	/**
	 * Dispose
	*/
	Dispose(): void;
	/**
	 * Create
	*/
	static Create(Name: string,bCreate: boolean,bRead: boolean,bWrite: boolean,Size: number): JavascriptSharedMemoryRegion;
	static C(Other: UObject): JavascriptSharedMemoryRegion;
}

declare class JavascriptObject extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptObject;
	static Find(Outer: UObject, ResourceName: string): JavascriptObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptObject;
	static C(Other: UObject): JavascriptObject;
}

declare class JavascriptOutputDevice extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptOutputDevice;
	static Find(Outer: UObject, ResourceName: string): JavascriptOutputDevice;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptOutputDevice;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptOutputDevice;
	/**
	 * On Message
	*/
	OnMessage(Message: string,Verbosity: ELogVerbosity_JS,Category: string): void;
	/**
	 * Log
	*/
	static Log(Category: string,Verbosity: ELogVerbosity_JS,Filename: string,LineNumber: number,Message: string): void;
	/**
	 * Kill
	*/
	Kill(): void;
	static C(Other: UObject): JavascriptOutputDevice;
}

declare class JavascriptProcess extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptProcess;
	static Find(Outer: UObject, ResourceName: string): JavascriptProcess;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptProcess;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptProcess;
	/**
	 * Write to Pipe
	*/
	WriteToPipe(Message: string,OutWritten?: string): {OutWritten: string, $: boolean};
	/**
	 * Wait
	*/
	Wait(): void;
	/**
	 * Terminate
	*/
	Terminate(KillTree: boolean): void;
	/**
	 * Set Environment Var
	*/
	static SetEnvironmentVar(VarName: string,VarValue: string): void;
	/**
	 * Read from Pipe
	*/
	ReadFromPipe(): string;
	/**
	 * Read Array from Pipe
	*/
	ReadArrayFromPipe(Array?: number[]): {Array: number[], $: boolean};
	/**
	 * Open PID
	*/
	static Open_PID(ProcessId: number): JavascriptProcess;
	/**
	 * Open
	*/
	static Open(ProcName: string): JavascriptProcess;
	/**
	 * Launch URL
	*/
	static LaunchURL(URL: string,Parms: string,Error?: string): {Error: string};
	/**
	 * Is Running
	*/
	IsRunning(): boolean;
	/**
	 * Is Application Running PID
	*/
	static IsApplicationRunning_PID(ProcessId: number): boolean;
	/**
	 * Is Application Running
	*/
	static IsApplicationRunning(ProcName: string): boolean;
	/**
	 * Get String
	*/
	static GetString(Key: string,bFlag: boolean): string;
	/**
	 * Get Return Code
	*/
	GetReturnCode(ReturnCode?: number): {ReturnCode: number, $: boolean};
	/**
	 * Get Environment Var
	*/
	static GetEnvironmentVar(VarName: string): string;
	/**
	 * Get Application Name
	*/
	static GetApplicationName(ProcessId: number): string;
	/**
	 * Create
	*/
	static Create(URL: string,Parms: string,bLaunchDetached: boolean,bLaunchHidden: boolean,bLaunchReallyHidden: boolean,PriorityModifier: number,OptionalWorkingDirectory: string,bUsePipe: boolean): JavascriptProcess;
	/**
	 * Close
	*/
	Close(): void;
	/**
	 * Can Launch URL
	*/
	static CanLaunchURL(URL: string): boolean;
	static C(Other: UObject): JavascriptProcess;
}

declare class JavascriptSemaphore extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptSemaphore;
	static Find(Outer: UObject, ResourceName: string): JavascriptSemaphore;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptSemaphore;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptSemaphore;
	/**
	 * Unlock
	*/
	Unlock(): void;
	/**
	 * Try Lock
	*/
	TryLock(NanosecondsToWait: number): boolean;
	/**
	 * Lock
	*/
	Lock(): void;
	/**
	 * Dispose
	*/
	Dispose(): void;
	/**
	 * Create
	*/
	static Create(Name: string,bCreate: boolean,MaxLocks: number): JavascriptSemaphore;
	static C(Other: UObject): JavascriptSemaphore;
}

declare class JavascriptSettings extends UObject { 
	/**
	 * V8 Flags. Please refer to V8 documentation
	*/
	V8Flags: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptSettings;
	static Find(Outer: UObject, ResourceName: string): JavascriptSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptSettings;
	static C(Other: UObject): JavascriptSettings;
}

declare class JavascriptAutomatedTestInstance { 
	clone() : JavascriptAutomatedTestInstance;
	static C(Other: UObject): JavascriptAutomatedTestInstance;
	/**
	 * Add Analytics Item
	*/
	AddAnalyticsItem(InAnalyticsItem: string): void;
	/**
	 * Add Error
	*/
	AddError(InError: string): void;
	/**
	 * Add Log Item
	*/
	AddLogItem(InLogItem: string): void;
	/**
	 * Add Warning
	*/
	AddWarning(InWarning: string): void;
	/**
	 * Clear any execution info/results from a prior running of this test
	*/
	ClearExecutionInfo(): void;
	/**
	 * Destroy
	*/
	Destroy(): {Test: JavascriptAutomatedTestInstance};
	/**
	 * Set Continue
	*/
	SetContinue(bInContinue: boolean): void;
	/**
	 * Add Analytics Item
	*/
	static AddAnalyticsItem(Test: JavascriptAutomatedTestInstance,InAnalyticsItem: string): void;
	/**
	 * Add Error
	*/
	static AddError(Test: JavascriptAutomatedTestInstance,InError: string): void;
	/**
	 * Add Log Item
	*/
	static AddLogItem(Test: JavascriptAutomatedTestInstance,InLogItem: string): void;
	/**
	 * Add Warning
	*/
	static AddWarning(Test: JavascriptAutomatedTestInstance,InWarning: string): void;
	/**
	 * Clear any execution info/results from a prior running of this test
	*/
	static ClearExecutionInfo(Test: JavascriptAutomatedTestInstance): void;
	/**
	 * Destroy
	*/
	static Destroy(Test?: JavascriptAutomatedTestInstance): {Test: JavascriptAutomatedTestInstance};
	/**
	 * Set Continue
	*/
	static SetContinue(Test: JavascriptAutomatedTestInstance,bInContinue: boolean): void;
}

declare class JavascriptAutomatedTest { 
	/**
	 * Name
	*/
	Name: string;
	/**
	 * Complex Task
	*/
	bComplexTask: boolean;
	/**
	 * Test Flags
	*/
	TestFlags: number;
	/**
	 * Required Device Num
	*/
	RequiredDeviceNum: number;
	/**
	 * Test Function Names
	*/
	TestFunctionNames: string[];
	/**
	 * Function
	*/
	UFunction: JavascriptFunction;
	clone() : JavascriptAutomatedTest;
	static C(Other: UObject): JavascriptAutomatedTest;
	/**
	 * Create
	*/
	Create(): JavascriptAutomatedTestInstance;
	/**
	 * Create
	*/
	static Create(Test: JavascriptAutomatedTest): JavascriptAutomatedTestInstance;
}

declare class JavascriptTestLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptTestLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptTestLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptTestLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptTestLibrary;
	/**
	 * Set Continue
	*/
	static SetContinue(Test: JavascriptAutomatedTestInstance,bInContinue: boolean): void;
	/**
	 * Push Frame Counter
	*/
	static PushFrameCounter(): void;
	/**
	 * Pop Frame Counter
	*/
	static PopFrameCounter(): void;
	/**
	 * New World
	*/
	static NewWorld(): World;
	/**
	 * Initialize Actors for Play
	*/
	static InitializeActorsForPlay(World: World,URL: URL): void;
	/**
	 * Destroy World
	*/
	static DestroyWorld(World: World): void;
	/**
	 * Destroy
	*/
	static Destroy(Test?: JavascriptAutomatedTestInstance): {Test: JavascriptAutomatedTestInstance};
	/**
	 * Create
	*/
	static Create(Test: JavascriptAutomatedTest): JavascriptAutomatedTestInstance;
	/**
	 * Clear any execution info/results from a prior running of this test
	*/
	static ClearExecutionInfo(Test: JavascriptAutomatedTestInstance): void;
	/**
	 * Begin Play
	*/
	static BeginPlay(World: World): void;
	/**
	 * Add Warning
	*/
	static AddWarning(Test: JavascriptAutomatedTestInstance,InWarning: string): void;
	/**
	 * Add Log Item
	*/
	static AddLogItem(Test: JavascriptAutomatedTestInstance,InLogItem: string): void;
	/**
	 * Add Error
	*/
	static AddError(Test: JavascriptAutomatedTestInstance,InError: string): void;
	/**
	 * Add Analytics Item
	*/
	static AddAnalyticsItem(Test: JavascriptAutomatedTestInstance,InAnalyticsItem: string): void;
	static C(Other: UObject): JavascriptTestLibrary;
}

declare class InGameSceneAccessor extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InGameSceneAccessor;
	static Find(Outer: UObject, ResourceName: string): InGameSceneAccessor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InGameSceneAccessor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InGameSceneAccessor;
	/**
	 * Tick
	*/
	Tick(DeltaTime: number): void;
	/**
	 * Is Begun Play
	*/
	isBegunPlay(): boolean;
	/**
	 * Initialize
	*/
	Initialize(): InGameSceneAccessor;
	/**
	 * Get Scene World
	*/
	GetSceneWorld(): World;
	/**
	 * Destroy
	*/
	Destroy(): void;
	static C(Other: UObject): InGameSceneAccessor;
}

declare class JavascriptSlateStyle { 
	clone() : JavascriptSlateStyle;
	static C(Other: UObject): JavascriptSlateStyle;
	/**
	 * Add Border Brush
	*/
	AddBorderBrush(PropertyName: string,InImageName: string,InMargin: Margin,InColorAndOpacity: LinearColor,InImageType: ESlateBrushImageType): void;
	/**
	 * Add Box Brush
	*/
	AddBoxBrush(PropertyName: string,InImageName: string,InMargin: Margin,InColorAndOpacity: LinearColor,InImageType: ESlateBrushImageType): void;
	/**
	 * Add Font Info
	*/
	AddFontInfo(PropertyName: string,FontInfo: SlateFontInfo): void;
	/**
	 * Add Image Brush
	*/
	AddImageBrush(PropertyName: string,InImageName: string,InImageSize: Vector2D,InTint: LinearColor,InTiling: ESlateBrushTileType,InImageType: ESlateBrushImageType): void;
	/**
	 * Add Sound
	*/
	AddSound(PropertyName: string,Sound: SlateSound): void;
	/**
	 * Register
	*/
	Register(): void;
	/**
	 * Root to Content Dir
	*/
	RootToContentDir(RelativePath: string): string;
	/**
	 * Root to Core Content Dir
	*/
	RootToCoreContentDir(RelativePath: string): string;
	/**
	 * Set Content Root
	*/
	SetContentRoot(InContentRootDir: string): void;
	/**
	 * Set Core Content Root
	*/
	SetCoreContentRoot(InCoreContentRootDir: string): void;
	/**
	 * Unregister
	*/
	Unregister(): void;
	/**
	 * Add Border Brush
	*/
	static AddBorderBrush(StyleSet: JavascriptSlateStyle,PropertyName: string,InImageName: string,InMargin: Margin,InColorAndOpacity: LinearColor,InImageType: ESlateBrushImageType): void;
	/**
	 * Add Box Brush
	*/
	static AddBoxBrush(StyleSet: JavascriptSlateStyle,PropertyName: string,InImageName: string,InMargin: Margin,InColorAndOpacity: LinearColor,InImageType: ESlateBrushImageType): void;
	/**
	 * Add Font Info
	*/
	static AddFontInfo(StyleSet: JavascriptSlateStyle,PropertyName: string,FontInfo: SlateFontInfo): void;
	/**
	 * Add Image Brush
	*/
	static AddImageBrush(StyleSet: JavascriptSlateStyle,PropertyName: string,InImageName: string,InImageSize: Vector2D,InTint: LinearColor,InTiling: ESlateBrushTileType,InImageType: ESlateBrushImageType): void;
	/**
	 * Add Sound
	*/
	static AddSound(StyleSet: JavascriptSlateStyle,PropertyName: string,Sound: SlateSound): void;
	/**
	 * Register
	*/
	static Register(StyleSet: JavascriptSlateStyle): void;
	/**
	 * Root to Content Dir
	*/
	static RootToContentDir(StyleSet: JavascriptSlateStyle,RelativePath: string): string;
	/**
	 * Root to Core Content Dir
	*/
	static RootToCoreContentDir(StyleSet: JavascriptSlateStyle,RelativePath: string): string;
	/**
	 * Set Content Root
	*/
	static SetContentRoot(StyleSet: JavascriptSlateStyle,InContentRootDir: string): void;
	/**
	 * Set Core Content Root
	*/
	static SetCoreContentRoot(StyleSet: JavascriptSlateStyle,InCoreContentRootDir: string): void;
	/**
	 * Unregister
	*/
	static Unregister(StyleSet: JavascriptSlateStyle): void;
	/**
	 * Create Slate Style
	*/
	static CreateSlateStyle(InStyleSetName: string): JavascriptSlateStyle;
}

declare class JavascriptUMGLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptUMGLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptUMGLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptUMGLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptUMGLibrary;
	/**
	 * Unregister
	*/
	static Unregister(StyleSet: JavascriptSlateStyle): void;
	/**
	 * Take Widget
	*/
	static TakeWidget(Widget: Widget): JavascriptSlateWidget;
	/**
	 * Set Core Content Root
	*/
	static SetCoreContentRoot(StyleSet: JavascriptSlateStyle,InCoreContentRootDir: string): void;
	/**
	 * Set Content Root
	*/
	static SetContentRoot(StyleSet: JavascriptSlateStyle,InContentRootDir: string): void;
	/**
	 * Root to Core Content Dir
	*/
	static RootToCoreContentDir(StyleSet: JavascriptSlateStyle,RelativePath: string): string;
	/**
	 * Root to Content Dir
	*/
	static RootToContentDir(StyleSet: JavascriptSlateStyle,RelativePath: string): string;
	/**
	 * Register
	*/
	static Register(StyleSet: JavascriptSlateStyle): void;
	/**
	 * Generate Dynamic Image Resource
	*/
	static GenerateDynamicImageResource(InDynamicBrushName: string): Vector2D;
	/**
	 * Create Slate Style
	*/
	static CreateSlateStyle(InStyleSetName: string): JavascriptSlateStyle;
	/**
	 * Compute Desired Size
	*/
	static ComputeDesiredSize(Widget: Widget,LayoutScaleMultiplier: number): Vector2D;
	/**
	 * Add Window as Native Child
	*/
	static AddWindowAsNativeChild(NewWindow: JavascriptSlateWidget,RootWindow: JavascriptSlateWidget): void;
	/**
	 * Add Window
	*/
	static AddWindow(NewWindow: JavascriptSlateWidget): void;
	/**
	 * Add Sound
	*/
	static AddSound(StyleSet: JavascriptSlateStyle,PropertyName: string,Sound: SlateSound): void;
	/**
	 * Add Image Brush
	*/
	static AddImageBrush(StyleSet: JavascriptSlateStyle,PropertyName: string,InImageName: string,InImageSize: Vector2D,InTint: LinearColor,InTiling: ESlateBrushTileType,InImageType: ESlateBrushImageType): void;
	/**
	 * Add Font Info
	*/
	static AddFontInfo(StyleSet: JavascriptSlateStyle,PropertyName: string,FontInfo: SlateFontInfo): void;
	/**
	 * Add Box Brush
	*/
	static AddBoxBrush(StyleSet: JavascriptSlateStyle,PropertyName: string,InImageName: string,InMargin: Margin,InColorAndOpacity: LinearColor,InImageType: ESlateBrushImageType): void;
	/**
	 * Add Border Brush
	*/
	static AddBorderBrush(StyleSet: JavascriptSlateStyle,PropertyName: string,InImageName: string,InMargin: Margin,InColorAndOpacity: LinearColor,InImageType: ESlateBrushImageType): void;
	static C(Other: UObject): JavascriptUMGLibrary;
}

declare class JavascriptComboButton extends ContentWidget { 
	/**
	 * Combo Button Style
	*/
	ComboButtonStyle: ComboButtonStyle;
	/**
	 * Button Style
	*/
	ButtonStyle: ButtonStyle;
	/**
	 * On Get Menu Content
	*/
	OnGetMenuContent: UnrealEngineDelegate<() => JavascriptSlateWidget>;
	/**
	 * On Menu Open Changed
	*/
	OnMenuOpenChanged: UnrealEngineDelegate<(Value: boolean) => void>;
	/**
	 * On Combo Box Opened
	*/
	OnComboBoxOpened: UnrealEngineDelegate<() => void>;
	/**
	 * Is Focusable
	*/
	bIsFocusable: boolean;
	/**
	 * Has Down Arrow
	*/
	bHasDownArrow: boolean;
	/**
	 * Foreground Color
	*/
	ForegroundColor: SlateColor;
	/**
	 * Button Color and Opacity
	*/
	ButtonColorAndOpacity: SlateColor;
	/**
	 * Content Padding
	*/
	ContentPadding: Margin;
	/**
	 * Menu Placement
	*/
	MenuPlacement: EMenuPlacement;
	/**
	 * HAlign
	*/
	HAlign: EHorizontalAlignment;
	/**
	 * VAlign
	*/
	VAlign: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptComboButton;
	static Find(Outer: UObject, ResourceName: string): JavascriptComboButton;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptComboButton;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptComboButton;
	/**
	 * Closes the menu if it is currently open.
	*/
	SetIsOpen(InIsOpen: boolean,bFocusMenu: boolean): void;
	static C(Other: UObject): JavascriptComboButton;
}

declare class JavascriptGameViewport extends ContentWidget { 
	/**
	 * Background Color
	*/
	BackgroundColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptGameViewport;
	static Find(Outer: UObject, ResourceName: string): JavascriptGameViewport;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptGameViewport;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptGameViewport;
	/**
	 * Spawn
	*/
	Spawn(ActorClass: UnrealEngineClass): Actor;
	/**
	 * Set View Rotation
	*/
	SetViewRotation(Rotation: Rotator): void;
	/**
	 * Set View Location
	*/
	SetViewLocation(Location: Vector): void;
	/**
	 * Get View Rotation
	*/
	GetViewRotation(): Rotator;
	/**
	 * Get Viewport World
	*/
	GetViewportWorld(): World;
	/**
	 * Get View Location
	*/
	GetViewLocation(): Vector;
	static C(Other: UObject): JavascriptGameViewport;
}

declare type EJavasrciptUserInterfaceActionType = string | symbol;
declare var EJavasrciptUserInterfaceActionType = { Button:'Button',ToggleButton:'ToggleButton',RadioButton:'RadioButton',Check:'Check', };
declare class JavascriptUICommand { 
	/**
	 * Id
	*/
	Id: string;
	/**
	 * Friendly Name
	*/
	FriendlyName: string;
	/**
	 * Description
	*/
	Description: string;
	/**
	 * Default Chord
	*/
	DefaultChord: InputChord;
	/**
	 * Action Type
	*/
	ActionType: EJavasrciptUserInterfaceActionType;
	clone() : JavascriptUICommand;
	static C(Other: UObject): JavascriptUICommand;
}

declare class JavascriptUICommandInfo { 
	clone() : JavascriptUICommandInfo;
	static C(Other: UObject): JavascriptUICommandInfo;
}

declare class JavascriptBindingContext { 
	clone() : JavascriptBindingContext;
	static C(Other: UObject): JavascriptBindingContext;
	/**
	 * Destroy
	*/
	Destroy(): void;
	/**
	 * UI COMMAND Function
	*/
	UI_COMMAND_Function(Command: JavascriptUICommand): JavascriptUICommandInfo;
	/**
	 * Destroy
	*/
	static Destroy(Context: JavascriptBindingContext): void;
	/**
	 * UI COMMAND Function
	*/
	static UI_COMMAND_Function(This: JavascriptBindingContext,Command: JavascriptUICommand): JavascriptUICommandInfo;
	/**
	 * New Binding Context
	*/
	static NewBindingContext(InContextName: string,InContextDesc: string,InContextParent: string,InStyleSetName: string): JavascriptBindingContext;
}

declare type EJavascriptExtensionHook = string | symbol;
declare var EJavascriptExtensionHook = { Before:'Before',After:'After',First:'First', };
declare class JavascriptUICommandList { 
	clone() : JavascriptUICommandList;
	static C(Other: UObject): JavascriptUICommandList;
	/**
	 * Create Menu Bar Builder
	*/
	CreateMenuBarBuilder(UFunction: JavascriptFunction): void;
	/**
	 * Create Menu Builder
	*/
	CreateMenuBuilder(bInShouldCloseWindowAfterMenuSelection: boolean,UFunction: JavascriptFunction): void;
	/**
	 * Create Toolbar Builder
	*/
	CreateToolbarBuilder(Orientation: EOrientation,UFunction: JavascriptFunction): void;
	/**
	 * Process Command Bindings Key Event
	*/
	ProcessCommandBindings_KeyEvent(InKeyEvent: KeyEvent): boolean;
	/**
	 * Process Command Bindings Pointer Event
	*/
	ProcessCommandBindings_PointerEvent(InMouseEvent: UPointerEvent): boolean;
	/**
	 * Create Menu Bar Builder
	*/
	static CreateMenuBarBuilder(CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): void;
	/**
	 * Create Menu Builder
	*/
	static CreateMenuBuilder(CommandList: JavascriptUICommandList,bInShouldCloseWindowAfterMenuSelection: boolean,UFunction: JavascriptFunction): void;
	/**
	 * Create Toolbar Builder
	*/
	static CreateToolbarBuilder(CommandList: JavascriptUICommandList,Orientation: EOrientation,UFunction: JavascriptFunction): void;
	/**
	 * Process Command Bindings Key Event
	*/
	static ProcessCommandBindings_KeyEvent(CommandList: JavascriptUICommandList,InKeyEvent: KeyEvent): boolean;
	/**
	 * Process Command Bindings Pointer Event
	*/
	static ProcessCommandBindings_PointerEvent(CommandList: JavascriptUICommandList,InMouseEvent: UPointerEvent): boolean;
	/**
	 * Create UICommand List
	*/
	static CreateUICommandList(): JavascriptUICommandList;
}

declare class JavascriptExtensionBase { 
	clone() : JavascriptExtensionBase;
	static C(Other: UObject): JavascriptExtensionBase;
}

declare class JavascriptMenuBuilder { 
	clone() : JavascriptMenuBuilder;
	static C(Other: UObject): JavascriptMenuBuilder;
	/**
	 * Add Pull Down Menu
	*/
	AddPullDownMenu(InMenuLabel?: string,InToolTip?: string,InPullDownMenu?: JavascriptFunction,InExtensionHook?: string,InTutorialHighlightName?: string): {MenuBuilder: JavascriptMenuBuilder};
	/**
	 * Add Separator
	*/
	AddSeparator(): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Tool Bar Button
	*/
	AddToolBarButton(CommandInfo?: JavascriptUICommandInfo): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Widget
	*/
	AddWidget(Widget?: Widget,Label?: string,bNoIndent?: boolean,InTutorialHighlightName?: string,bSearchable?: boolean): {Builder: JavascriptMenuBuilder};
	/**
	 * Begin Section
	*/
	BeginSection(InExtensionHook?: string): {Builder: JavascriptMenuBuilder};
	/**
	 * End Section
	*/
	EndSection(): {Builder: JavascriptMenuBuilder};
	/**
	 * Pop Command List
	*/
	PopCommandList(): {Builder: JavascriptMenuBuilder};
	/**
	 * Push Command List
	*/
	PushCommandList(List?: JavascriptUICommandList): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Pull Down Menu
	*/
	static AddPullDownMenu(MenuBuilder?: JavascriptMenuBuilder,InMenuLabel?: string,InToolTip?: string,InPullDownMenu?: JavascriptFunction,InExtensionHook?: string,InTutorialHighlightName?: string): {MenuBuilder: JavascriptMenuBuilder};
	/**
	 * Add Separator
	*/
	static AddSeparator(Builder?: JavascriptMenuBuilder): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Tool Bar Button
	*/
	static AddToolBarButton(Builder?: JavascriptMenuBuilder,CommandInfo?: JavascriptUICommandInfo): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Widget
	*/
	static AddWidget(Builder?: JavascriptMenuBuilder,Widget?: Widget,Label?: string,bNoIndent?: boolean,InTutorialHighlightName?: string,bSearchable?: boolean): {Builder: JavascriptMenuBuilder};
	/**
	 * Begin Section
	*/
	static BeginSection(Builder?: JavascriptMenuBuilder,InExtensionHook?: string): {Builder: JavascriptMenuBuilder};
	/**
	 * End Section
	*/
	static EndSection(Builder?: JavascriptMenuBuilder): {Builder: JavascriptMenuBuilder};
	/**
	 * Pop Command List
	*/
	static PopCommandList(Builder?: JavascriptMenuBuilder): {Builder: JavascriptMenuBuilder};
	/**
	 * Push Command List
	*/
	static PushCommandList(Builder?: JavascriptMenuBuilder,List?: JavascriptUICommandList): {Builder: JavascriptMenuBuilder};
}

declare class JavascriptExtender { 
	clone() : JavascriptExtender;
	static C(Other: UObject): JavascriptExtender;
	/**
	 * Add Menubar Extension
	*/
	AddMenubarExtension(ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	/**
	 * Add Menu Extension
	*/
	AddMenuExtension(ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	/**
	 * Add Tool Bar Extension
	*/
	AddToolBarExtension(ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	/**
	 * Apply
	*/
	Apply(ExtensionHook: string,HookPosition: EJavascriptExtensionHook,MenuBuilder?: JavascriptMenuBuilder): {MenuBuilder: JavascriptMenuBuilder};
	/**
	 * Remove Extension
	*/
	RemoveExtension(Extension: JavascriptExtensionBase): void;
	/**
	 * Add Menubar Extension
	*/
	static AddMenubarExtension(Extender: JavascriptExtender,ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	/**
	 * Add Menu Extension
	*/
	static AddMenuExtension(Extender: JavascriptExtender,ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	/**
	 * Add Tool Bar Extension
	*/
	static AddToolBarExtension(Extender: JavascriptExtender,ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	/**
	 * Apply
	*/
	static Apply(Extender: JavascriptExtender,ExtensionHook: string,HookPosition: EJavascriptExtensionHook,MenuBuilder?: JavascriptMenuBuilder): {MenuBuilder: JavascriptMenuBuilder};
	/**
	 * Remove Extension
	*/
	static RemoveExtension(Extender: JavascriptExtender,Extension: JavascriptExtensionBase): void;
	/**
	 * Combine
	*/
	static Combine(Extenders: JavascriptExtender[]): JavascriptExtender;
}

declare class JavascriptMenuLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptMenuLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptMenuLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptMenuLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptMenuLibrary;
	/**
	 * UI COMMAND Function
	*/
	static UI_COMMAND_Function(This: JavascriptBindingContext,Command: JavascriptUICommand): JavascriptUICommandInfo;
	/**
	 * Remove Extension
	*/
	static RemoveExtension(Extender: JavascriptExtender,Extension: JavascriptExtensionBase): void;
	/**
	 * Push Command List
	*/
	static PushCommandList(Builder?: JavascriptMenuBuilder,List?: JavascriptUICommandList): {Builder: JavascriptMenuBuilder};
	/**
	 * Process Command Bindings Pointer Event
	*/
	static ProcessCommandBindings_PointerEvent(CommandList: JavascriptUICommandList,InMouseEvent: UPointerEvent): boolean;
	/**
	 * Process Command Bindings Key Event
	*/
	static ProcessCommandBindings_KeyEvent(CommandList: JavascriptUICommandList,InKeyEvent: KeyEvent): boolean;
	/**
	 * Pop Command List
	*/
	static PopCommandList(Builder?: JavascriptMenuBuilder): {Builder: JavascriptMenuBuilder};
	/**
	 * New Binding Context
	*/
	static NewBindingContext(InContextName: string,InContextDesc: string,InContextParent: string,InStyleSetName: string): JavascriptBindingContext;
	/**
	 * End Section
	*/
	static EndSection(Builder?: JavascriptMenuBuilder): {Builder: JavascriptMenuBuilder};
	/**
	 * Destroy
	*/
	static Destroy(Context: JavascriptBindingContext): void;
	/**
	 * Create UICommand List
	*/
	static CreateUICommandList(): JavascriptUICommandList;
	/**
	 * Create Toolbar Builder
	*/
	static CreateToolbarBuilder(CommandList: JavascriptUICommandList,Orientation: EOrientation,UFunction: JavascriptFunction): void;
	/**
	 * Create Menu Builder
	*/
	static CreateMenuBuilder(CommandList: JavascriptUICommandList,bInShouldCloseWindowAfterMenuSelection: boolean,UFunction: JavascriptFunction): void;
	/**
	 * Create Menu Bar Builder
	*/
	static CreateMenuBarBuilder(CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): void;
	/**
	 * Combine
	*/
	static Combine(Extenders: JavascriptExtender[]): JavascriptExtender;
	/**
	 * Begin Section
	*/
	static BeginSection(Builder?: JavascriptMenuBuilder,InExtensionHook?: string): {Builder: JavascriptMenuBuilder};
	/**
	 * Apply
	*/
	static Apply(Extender: JavascriptExtender,ExtensionHook: string,HookPosition: EJavascriptExtensionHook,MenuBuilder?: JavascriptMenuBuilder): {MenuBuilder: JavascriptMenuBuilder};
	/**
	 * Add Widget
	*/
	static AddWidget(Builder?: JavascriptMenuBuilder,Widget?: Widget,Label?: string,bNoIndent?: boolean,InTutorialHighlightName?: string,bSearchable?: boolean): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Tool Bar Extension
	*/
	static AddToolBarExtension(Extender: JavascriptExtender,ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	/**
	 * Add Tool Bar Button
	*/
	static AddToolBarButton(Builder?: JavascriptMenuBuilder,CommandInfo?: JavascriptUICommandInfo): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Separator
	*/
	static AddSeparator(Builder?: JavascriptMenuBuilder): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Pull Down Menu
	*/
	static AddPullDownMenu(MenuBuilder?: JavascriptMenuBuilder,InMenuLabel?: string,InToolTip?: string,InPullDownMenu?: JavascriptFunction,InExtensionHook?: string,InTutorialHighlightName?: string): {MenuBuilder: JavascriptMenuBuilder};
	/**
	 * Add Menu Extension
	*/
	static AddMenuExtension(Extender: JavascriptExtender,ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	/**
	 * Add Menubar Extension
	*/
	static AddMenubarExtension(Extender: JavascriptExtender,ExtensionHook: string,HookPosition: EJavascriptExtensionHook,CommandList: JavascriptUICommandList,UFunction: JavascriptFunction): JavascriptExtensionBase;
	static C(Other: UObject): JavascriptMenuLibrary;
}

declare class JavascriptMultiBox extends Widget { 
	/**
	 * On Hook
	*/
	OnHook: UnrealEngineDelegate<(Id: string, Self: JavascriptMultiBox, CurrentBuilder: JavascriptMenuBuilder) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptMultiBox;
	static Find(Outer: UObject, ResourceName: string): JavascriptMultiBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptMultiBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptMultiBox;
	/**
	 * Bind
	*/
	static Bind(Builder: JavascriptMenuBuilder): void;
	/**
	 * Add Sub Menu
	*/
	AddSubMenu(Builder?: JavascriptMenuBuilder,Id?: string,Label?: string,ToolTip?: string,bInOpenSubMenuOnClick?: boolean): {Builder: JavascriptMenuBuilder};
	/**
	 * Add Pull Down Menu
	*/
	AddPullDownMenu(Builder?: JavascriptMenuBuilder,Id?: string,Label?: string,ToolTip?: string): {Builder: JavascriptMenuBuilder};
	static C(Other: UObject): JavascriptMultiBox;
}

declare class JavascriptSlateTextRun { 
	clone() : JavascriptSlateTextRun;
	static C(Other: UObject): JavascriptSlateTextRun;
}

declare class JavascriptTextModel extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptTextModel;
	static Find(Outer: UObject, ResourceName: string): JavascriptTextModel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptTextModel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptTextModel;
	/**
	 * Set String
	*/
	SetString(String: string): void;
	/**
	 * Get String
	*/
	GetString(): string;
	/**
	 * Create Run
	*/
	CreateRun(MessageTextStyle: TextBlockStyle,BeginIndex: number,EndIndex: number): JavascriptSlateTextRun;
	static C(Other: UObject): JavascriptTextModel;
}

declare class JavascriptTextLayout { 
	clone() : JavascriptTextLayout;
	static C(Other: UObject): JavascriptTextLayout;
	/**
	 * Add Line
	*/
	AddLine(Model?: JavascriptTextModel,Runs?: JavascriptSlateTextRun[]): {TextLayout: JavascriptTextLayout};
	/**
	 * Clear Lines
	*/
	ClearLines(): {TextLayout: JavascriptTextLayout};
	/**
	 * Get as Text
	*/
	GetAsText(): string;
	/**
	 * Get Line Length
	*/
	GetLineLength(): number;
	/**
	 * Add Line
	*/
	static AddLine(TextLayout?: JavascriptTextLayout,Model?: JavascriptTextModel,Runs?: JavascriptSlateTextRun[]): {TextLayout: JavascriptTextLayout};
	/**
	 * Clear Lines
	*/
	static ClearLines(TextLayout?: JavascriptTextLayout): {TextLayout: JavascriptTextLayout};
	/**
	 * Get as Text
	*/
	static GetAsText(TextLayout: JavascriptTextLayout): string;
	/**
	 * Get Line Length
	*/
	static GetLineLength(TargetTextLayout: JavascriptTextLayout): number;
}

declare class JavascriptMultiLineEditableTextBox extends MultiLineEditableTextBox { 
	/**
	 * Called whenever the text is committed.  This happens when the user presses enter or the text box loses focus.
	*/
	OnVScrollBarUserScrolled: UnrealEngineMulticastDelegate<(Offset: number) => void>;
	/**
	 * Get Text Delegate
	*/
	GetTextDelegate: UnrealEngineDelegate<(TextLayout: JavascriptTextLayout) => string>;
	/**
	 * Set Text Delegate
	*/
	SetTextDelegate: UnrealEngineDelegate<(InText: string, TextLayout: JavascriptTextLayout) => void>;
	/**
	 * Is Read Only
	*/
	bIsReadOnly: boolean;
	/**
	 * Always Show Scrollbars
	*/
	bAlwaysShowScrollbars: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptMultiLineEditableTextBox;
	static Find(Outer: UObject, ResourceName: string): JavascriptMultiLineEditableTextBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptMultiLineEditableTextBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptMultiLineEditableTextBox;
	/**
	 * Scroll To
	*/
	ScrollTo(Line: number,Offset: number): void;
	/**
	 * Refresh
	*/
	Refresh(): void;
	/**
	 * Go To
	*/
	GoTo(Line: number,Offset: number): void;
	static C(Other: UObject): JavascriptMultiLineEditableTextBox;
}

declare class JavascriptRichTextBlockHyperlinkDecorator extends RichTextBlockDecorator { 
	/**
	 * Hyperlink Id
	*/
	HyperlinkId: string;
	/**
	 * On Click
	*/
	OnClick: UnrealEngineMulticastDelegate<(Self: JavascriptRichTextBlockHyperlinkDecorator) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptRichTextBlockHyperlinkDecorator;
	static Find(Outer: UObject, ResourceName: string): JavascriptRichTextBlockHyperlinkDecorator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptRichTextBlockHyperlinkDecorator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptRichTextBlockHyperlinkDecorator;
	/**
	 * Get Metadata
	*/
	GetMetadata(Key: string): string;
	static C(Other: UObject): JavascriptRichTextBlockHyperlinkDecorator;
}

declare class JavascriptSearchBox extends Widget { 
	/**
	 * Called whenever the text is changed interactively by the user
	*/
	OnTextChanged: UnrealEngineMulticastDelegate<(Text: string) => void>;
	/**
	 * Called whenever the text is committed.  This happens when the user presses enter or the text box loses focus.
	*/
	OnTextCommitted: UnrealEngineMulticastDelegate<(Text: string, CommitMethod: ETextCommit) => void>;
	/**
	 * The text content for this editable text box widget
	*/
	Text: string;
	/**
	 * A bindable delegate to allow logic to drive the text of the widget
	*/
	TextDelegate: UnrealEngineDelegate<() => string>;
	/**
	 * Hint text that appears when there is no text in the text box
	*/
	HintText: string;
	/**
	 * A bindable delegate to allow logic to drive the hint text of the widget
	*/
	HintTextDelegate: UnrealEngineDelegate<() => string>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptSearchBox;
	static Find(Outer: UObject, ResourceName: string): JavascriptSearchBox;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptSearchBox;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptSearchBox;
	/**
	 * End of UWidget interface
	*/
	SetText(InText: string): void;
	/**
	 * Set Hint Text
	*/
	SetHintText(InHintText: string): void;
	static C(Other: UObject): JavascriptSearchBox;
}

declare class JavascriptStyleSet { 
	/**
	 * Style Set Name
	*/
	StyleSetName: string;
	clone() : JavascriptStyleSet;
	static C(Other: UObject): JavascriptStyleSet;
	/**
	 * Get Brush
	*/
	GetBrush(StyleName: string): SlateBrush;
	/**
	 * Get Button Style
	*/
	GetButtonStyle(StyleName: string): ButtonStyle;
	/**
	 * Get Check Box Style
	*/
	GetCheckBoxStyle(StyleName: string): CheckBoxStyle;
	/**
	 * Get Color
	*/
	GetColor(StyleName: string): LinearColor;
	/**
	 * Get Combo Box Style
	*/
	GetComboBoxStyle(StyleName: string): ComboBoxStyle;
	/**
	 * Get Combo Button Style
	*/
	GetComboButtonStyle(StyleName: string): ComboButtonStyle;
	/**
	 * Get Editable Text Box Style
	*/
	GetEditableTextBoxStyle(StyleName: string): EditableTextBoxStyle;
	/**
	 * Get Editable Text Style
	*/
	GetEditableTextStyle(StyleName: string): EditableTextStyle;
	/**
	 * Get Float
	*/
	GetFloat(StyleName: string): number;
	/**
	 * Get Font Style
	*/
	GetFontStyle(StyleName: string): SlateFontInfo;
	/**
	 * Get Margin
	*/
	GetMargin(StyleName: string): Margin;
	/**
	 * Get Slate Color
	*/
	GetSlateColor(StyleName: string): SlateColor;
	/**
	 * Get Sound
	*/
	GetSound(StyleName: string): SlateSound;
	/**
	 * Get Text Block Style
	*/
	GetTextBlockStyle(StyleName: string): TextBlockStyle;
	/**
	 * Get Vector
	*/
	GetVector(StyleName: string): Vector2D;
	/**
	 * Get Brush
	*/
	static GetBrush(Handle: JavascriptStyleSet,StyleName: string): SlateBrush;
	/**
	 * Get Button Style
	*/
	static GetButtonStyle(Handle: JavascriptStyleSet,StyleName: string): ButtonStyle;
	/**
	 * Get Check Box Style
	*/
	static GetCheckBoxStyle(Handle: JavascriptStyleSet,StyleName: string): CheckBoxStyle;
	/**
	 * Get Color
	*/
	static GetColor(Handle: JavascriptStyleSet,StyleName: string): LinearColor;
	/**
	 * Get Combo Box Style
	*/
	static GetComboBoxStyle(Handle: JavascriptStyleSet,StyleName: string): ComboBoxStyle;
	/**
	 * Get Combo Button Style
	*/
	static GetComboButtonStyle(Handle: JavascriptStyleSet,StyleName: string): ComboButtonStyle;
	/**
	 * Get Editable Text Box Style
	*/
	static GetEditableTextBoxStyle(Handle: JavascriptStyleSet,StyleName: string): EditableTextBoxStyle;
	/**
	 * Get Editable Text Style
	*/
	static GetEditableTextStyle(Handle: JavascriptStyleSet,StyleName: string): EditableTextStyle;
	/**
	 * Get Float
	*/
	static GetFloat(Handle: JavascriptStyleSet,StyleName: string): number;
	/**
	 * Get Font Style
	*/
	static GetFontStyle(Handle: JavascriptStyleSet,StyleName: string): SlateFontInfo;
	/**
	 * Get Margin
	*/
	static GetMargin(Handle: JavascriptStyleSet,StyleName: string): Margin;
	/**
	 * Get Slate Color
	*/
	static GetSlateColor(Handle: JavascriptStyleSet,StyleName: string): SlateColor;
	/**
	 * Get Sound
	*/
	static GetSound(Handle: JavascriptStyleSet,StyleName: string): SlateSound;
	/**
	 * Get Text Block Style
	*/
	static GetTextBlockStyle(Handle: JavascriptStyleSet,StyleName: string): TextBlockStyle;
	/**
	 * Get Vector
	*/
	static GetVector(Handle: JavascriptStyleSet,StyleName: string): Vector2D;
}

declare class JavascriptStyleSetLibrary extends BlueprintFunctionLibrary { 
	/**
	 * Slate Color
	*/
	SlateColor: SlateColor;
	/**
	 * Slate Brush
	*/
	SlateBrush: SlateBrush;
	/**
	 * Button Style
	*/
	ButtonStyle: ButtonStyle;
	/**
	 * Text Block Style
	*/
	TextBlockStyle: TextBlockStyle;
	/**
	 * Editable Text Style
	*/
	EditableTextStyle: EditableTextStyle;
	/**
	 * Editable Text Box Style
	*/
	EditableTextBoxStyle: EditableTextBoxStyle;
	/**
	 * Check Box Style
	*/
	CheckBoxStyle: CheckBoxStyle;
	/**
	 * Combo Box Style
	*/
	ComboBoxStyle: ComboBoxStyle;
	/**
	 * Combo Button Style
	*/
	ComboButtonStyle: ComboButtonStyle;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptStyleSetLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptStyleSetLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptStyleSetLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptStyleSetLibrary;
	/**
	 * Get Vector
	*/
	static GetVector(Handle: JavascriptStyleSet,StyleName: string): Vector2D;
	/**
	 * Get Text Block Style
	*/
	static GetTextBlockStyle(Handle: JavascriptStyleSet,StyleName: string): TextBlockStyle;
	/**
	 * Get Sound
	*/
	static GetSound(Handle: JavascriptStyleSet,StyleName: string): SlateSound;
	/**
	 * Get Slate Color
	*/
	static GetSlateColor(Handle: JavascriptStyleSet,StyleName: string): SlateColor;
	/**
	 * Get Margin
	*/
	static GetMargin(Handle: JavascriptStyleSet,StyleName: string): Margin;
	/**
	 * Get Font Style
	*/
	static GetFontStyle(Handle: JavascriptStyleSet,StyleName: string): SlateFontInfo;
	/**
	 * Get Float
	*/
	static GetFloat(Handle: JavascriptStyleSet,StyleName: string): number;
	/**
	 * Get Editable Text Style
	*/
	static GetEditableTextStyle(Handle: JavascriptStyleSet,StyleName: string): EditableTextStyle;
	/**
	 * Get Editable Text Box Style
	*/
	static GetEditableTextBoxStyle(Handle: JavascriptStyleSet,StyleName: string): EditableTextBoxStyle;
	/**
	 * Get Combo Button Style
	*/
	static GetComboButtonStyle(Handle: JavascriptStyleSet,StyleName: string): ComboButtonStyle;
	/**
	 * Get Combo Box Style
	*/
	static GetComboBoxStyle(Handle: JavascriptStyleSet,StyleName: string): ComboBoxStyle;
	/**
	 * Get Color
	*/
	static GetColor(Handle: JavascriptStyleSet,StyleName: string): LinearColor;
	/**
	 * Get Check Box Style
	*/
	static GetCheckBoxStyle(Handle: JavascriptStyleSet,StyleName: string): CheckBoxStyle;
	/**
	 * Get Button Style
	*/
	static GetButtonStyle(Handle: JavascriptStyleSet,StyleName: string): ButtonStyle;
	/**
	 * Get Brush
	*/
	static GetBrush(Handle: JavascriptStyleSet,StyleName: string): SlateBrush;
	static C(Other: UObject): JavascriptStyleSetLibrary;
}

declare class JavascriptTextBlock extends TextBlock { 
	/**
	 * Highlight text that appears when there is no text in the text box
	*/
	HighlightText: string;
	/**
	 * A bindable delegate to allow logic to drive the Highlight text of the widget
	*/
	HighlightTextDelegate: UnrealEngineDelegate<() => string>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptTextBlock;
	static Find(Outer: UObject, ResourceName: string): JavascriptTextBlock;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptTextBlock;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptTextBlock;
	/**
	 * End of UWidget interface
	*/
	SetHighlightText(InHighlightText: string): void;
	static C(Other: UObject): JavascriptTextBlock;
}

declare class JavascriptTileView extends TileView { 
	/**
	 * Javascript Context
	*/
	JavascriptContext: JavascriptContext;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptTileView;
	static Find(Outer: UObject, ResourceName: string): JavascriptTileView;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptTileView;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptTileView;
	/**
	 * Event fired when a tutorial stage ends
	*/
	OnSelectionChanged(UObject: UObject,Type: ESelectInfo): void;
	/**
	 * Event fired when a tutorial stage ends
	*/
	OnDoubleClick(UObject: UObject): void;
	/**
	 * Event fired when a tutorial stage ends
	*/
	OnClick(UObject: UObject): void;
	static C(Other: UObject): JavascriptTileView;
}

declare class TableColumnHeaderStyle extends SlateWidgetStyle { 
	/**
	 * Image used when a column is primarily sorted in ascending order
	*/
	SortPrimaryAscendingImage: SlateBrush;
	/**
	 * Image used when a column is primarily sorted in descending order
	*/
	SortPrimaryDescendingImage: SlateBrush;
	/**
	 * Image used when a column is secondarily sorted in ascending order
	*/
	SortSecondaryAscendingImage: SlateBrush;
	/**
	 * Image used when a column is secondarily sorted in descending order
	*/
	SortSecondaryDescendingImage: SlateBrush;
	/**
	 * Brush used to draw the header in its normal state
	*/
	NormalBrush: SlateBrush;
	/**
	 * Brush used to draw the header in its hovered state
	*/
	HoveredBrush: SlateBrush;
	/**
	 * Image used for the menu drop-down button
	*/
	MenuDropdownImage: SlateBrush;
	/**
	 * Brush used to draw the menu drop-down border in its normal state
	*/
	MenuDropdownNormalBorderBrush: SlateBrush;
	/**
	 * Brush used to draw the menu drop-down border in its hovered state
	*/
	MenuDropdownHoveredBorderBrush: SlateBrush;
	clone() : TableColumnHeaderStyle;
	static C(Other: UObject): TableColumnHeaderStyle;
}

declare class SplitterStyle extends SlateWidgetStyle { 
	/**
	 * Brush used to draw the handle in its normal state
	*/
	HandleNormalBrush: SlateBrush;
	/**
	 * Brush used to draw the handle in its highlight state
	*/
	HandleHighlightBrush: SlateBrush;
	clone() : SplitterStyle;
	static C(Other: UObject): SplitterStyle;
}

declare class HeaderRowStyle extends SlateWidgetStyle { 
	/**
	 * Style of the normal header row columns
	*/
	ColumnStyle: TableColumnHeaderStyle;
	/**
	 * Style of the last header row column
	*/
	LastColumnStyle: TableColumnHeaderStyle;
	/**
	 * Style of the splitter used between the columns
	*/
	ColumnSplitterStyle: SplitterStyle;
	/**
	 * Brush used to draw the header row background
	*/
	BackgroundBrush: SlateBrush;
	/**
	 * Color used to draw the header row foreground
	*/
	ForegroundColor: SlateColor;
	clone() : HeaderRowStyle;
	static C(Other: UObject): HeaderRowStyle;
}

declare class JavascriptColumn { 
	/**
	 * Id
	*/
	Id: string;
	/**
	 * Width
	*/
	Width: number;
	/**
	 * Widget
	*/
	Widget: Widget;
	clone() : JavascriptColumn;
	static C(Other: UObject): JavascriptColumn;
}

declare class JavascriptTreeView extends TableViewBase { 
	/**
	 * Called when a widget needs to be generated
	*/
	OnGenerateRowEvent: UnrealEngineDelegate<(UObject: UObject, Id: string, Instance: JavascriptTreeView) => Widget>;
	/**
	 * On Expansion Changed
	*/
	OnExpansionChanged: UnrealEngineDelegate<(Item: UObject, bExpanded: boolean, Instance: JavascriptTreeView) => void>;
	/**
	 * On Context Menu Opening
	*/
	OnContextMenuOpening: UnrealEngineDelegate<(Instance: JavascriptTreeView) => Widget>;
	/**
	 * Called when a widget needs to be generated
	*/
	OnGetChildren: UnrealEngineDelegate<(Item: UObject, Instance: JavascriptTreeView) => void>;
	/**
	 * Javascript Context
	*/
	JavascriptContext: JavascriptContext;
	/**
	 * The list of items to generate widgets for
	*/
	Items: UObject[];
	/**
	 * Header Row Style
	*/
	HeaderRowStyle: HeaderRowStyle;
	/**
	 * Table Row Style
	*/
	TableRowStyle: TableRowStyle;
	/**
	 * Scroll Bar Style
	*/
	ScrollBarStyle: ScrollBarStyle;
	/**
	 * The selection method for the list
	*/
	SelectionMode: ESelectionMode;
	/**
	 * Children
	*/
	Children: UObject[];
	/**
	 * Columns
	*/
	Columns: JavascriptColumn[];
	/**
	 * Column Widgets
	*/
	ColumnWidgets: Widget[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptTreeView;
	static Find(Outer: UObject, ResourceName: string): JavascriptTreeView;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptTreeView;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptTreeView;
	/**
	 * Set Single Expanded Item
	*/
	SetSingleExpandedItem(InItem: UObject): void;
	/**
	 * Set Selection
	*/
	SetSelection(SoleSelectedItem: UObject): void;
	/**
	 * Set Item Expansion
	*/
	SetItemExpansion(InItem: UObject,InShouldExpandItem: boolean): void;
	/**
	 * Refreshes the list
	*/
	RequestTreeRefresh(): void;
	/**
	 * Event fired when a tutorial stage ends
	*/
	OnSelectionChanged(UObject: UObject,Type: ESelectInfo): void;
	/**
	 * Event fired when a tutorial stage ends
	*/
	OnDoubleClick(UObject: UObject): void;
	/**
	 * Is Item Expanded
	*/
	IsItemExpanded(InItem: UObject): boolean;
	/**
	 * Get Selected Items
	*/
	GetSelectedItems(OutItems?: UObject[]): {OutItems: UObject[]};
	static C(Other: UObject): JavascriptTreeView;
}

declare class JavascriptListView extends JavascriptTreeView { 
	/**
	 * The height of each widget
	*/
	ItemHeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptListView;
	static Find(Outer: UObject, ResourceName: string): JavascriptListView;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptListView;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptListView;
	/**
	 * Set Selection
	*/
	SetSelection(SoleSelectedItem: UObject): void;
	/**
	 * Refreshes the list
	*/
	RequestListRefresh(): void;
	/**
	 * Event fired when a tutorial stage ends
	*/
	OnClick(UObject: UObject): void;
	/**
	 * Get Selected Items
	*/
	GetSelectedItems(OutItems?: UObject[]): {OutItems: UObject[]};
	static C(Other: UObject): JavascriptListView;
}

declare class JavascriptUICommands extends UObject { 
	/**
	 * On Execute Action
	*/
	OnExecuteAction: UnrealEngineDelegate<(Id: string) => void>;
	/**
	 * On Can Execute Action
	*/
	OnCanExecuteAction: UnrealEngineDelegate<(Id: string) => boolean>;
	/**
	 * On Is Action Checked
	*/
	OnIsActionChecked: UnrealEngineDelegate<(Id: string) => boolean>;
	/**
	 * On Is Action Button Visible
	*/
	OnIsActionButtonVisible: UnrealEngineDelegate<(Id: string) => boolean>;
	/**
	 * Commands
	*/
	Commands: JavascriptUICommand[];
	/**
	 * Context Name
	*/
	ContextName: string;
	/**
	 * Context Desc
	*/
	ContextDesc: string;
	/**
	 * Context Name Parent
	*/
	ContextNameParent: string;
	/**
	 * Style Set Name
	*/
	StyleSetName: string;
	/**
	 * Command Infos
	*/
	CommandInfos: JavascriptUICommandInfo[];
	/**
	 * Binding Context
	*/
	BindingContext: JavascriptBindingContext;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptUICommands;
	static Find(Outer: UObject, ResourceName: string): JavascriptUICommands;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptUICommands;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptUICommands;
	/**
	 * Uninitialize
	*/
	Uninitialize(): void;
	/**
	 * Unbind
	*/
	Unbind(List: JavascriptUICommandList): void;
	/**
	 * Refresh
	*/
	Refresh(): void;
	/**
	 * Initialize
	*/
	Initialize(): void;
	/**
	 * Get Action
	*/
	GetAction(Id: string): JavascriptUICommandInfo;
	/**
	 * Discard
	*/
	Discard(): void;
	/**
	 * Commit
	*/
	Commit(): void;
	/**
	 * Broadcast Commands Changed
	*/
	static BroadcastCommandsChanged(): void;
	/**
	 * Bind
	*/
	Bind(List: JavascriptUICommandList): void;
	static C(Other: UObject): JavascriptUICommands;
}

declare class JavascriptUMGBlueprintLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptUMGBlueprintLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptUMGBlueprintLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptUMGBlueprintLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptUMGBlueprintLibrary;
	/**
	 * Slate Color Use Subdued Foreground
	*/
	static SlateColor_UseSubduedForeground(): SlateColor;
	/**
	 * Slate Color Use Foreground
	*/
	static SlateColor_UseForeground(): SlateColor;
	/**
	 * Get Line Length
	*/
	static GetLineLength(TargetTextLayout: JavascriptTextLayout): number;
	/**
	 * Get as Text
	*/
	static GetAsText(TextLayout: JavascriptTextLayout): string;
	/**
	 * Draw Space Spline
	*/
	static DrawSpaceSpline(Context?: PaintContext,InStart?: Vector2D,InStartDir?: Vector2D,InEnd?: Vector2D,InEndDir?: Vector2D,InThickness?: number,InTint?: LinearColor): {Context: PaintContext};
	/**
	 * Clear Lines
	*/
	static ClearLines(TextLayout?: JavascriptTextLayout): {TextLayout: JavascriptTextLayout};
	/**
	 * Add Line
	*/
	static AddLine(TextLayout?: JavascriptTextLayout,Model?: JavascriptTextModel,Runs?: JavascriptSlateTextRun[]): {TextLayout: JavascriptTextLayout};
	static C(Other: UObject): JavascriptUMGBlueprintLibrary;
}

declare class JavascriptWidget extends UserWidget { 
	/**
	 * Javascript Context
	*/
	JavascriptContext: JavascriptContext;
	/**
	 * On Input Action Event
	*/
	OnInputActionEvent: UnrealEngineMulticastDelegate<(ActionName: string) => void>;
	/**
	 * Content Slot
	*/
	ContentSlot: PanelSlot;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptWidget;
	static Find(Outer: UObject, ResourceName: string): JavascriptWidget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptWidget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptWidget;
	/**
	 * Set Root Widget
	*/
	SetRootWidget(Widget: Widget): void;
	/**
	 * Remove Child
	*/
	RemoveChild(): boolean;
	/**
	 * On Listen for Input Action
	*/
	OnListenForInputAction(ActionName: string,EventType: EInputEvent,bConsume: boolean): void;
	/**
	 * On Input Action by Name
	*/
	OnInputActionByName(ActionName: string): void;
	/**
	 * Has Valid Cached Widget
	*/
	static HasValidCachedWidget(Widget: Widget): boolean;
	/**
	 * Call Synchronize Properties
	*/
	static CallSynchronizeProperties(WidgetOrSlot: Visual): void;
	/**
	 * Add Child
	*/
	AddChild(Content: Widget): PanelSlot;
	static C(Other: UObject): JavascriptWidget;
}

declare type EJavascriptWindowType = string | symbol;
declare var EJavascriptWindowType = { Normal:'Normal',Menu:'Menu',ToolTip:'ToolTip',Notification:'Notification',CursorDecorator:'CursorDecorator', };
declare class WindowStyle extends SlateWidgetStyle { 
	/**
	 * Style used to draw the window minimize button
	*/
	MinimizeButtonStyle: ButtonStyle;
	/**
	 * Style used to draw the window maximize button
	*/
	MaximizeButtonStyle: ButtonStyle;
	/**
	 * Style used to draw the window restore button
	*/
	RestoreButtonStyle: ButtonStyle;
	/**
	 * Style used to draw the window close button
	*/
	CloseButtonStyle: ButtonStyle;
	/**
	 * Style used to draw the window title text
	*/
	TitleTextStyle: TextBlockStyle;
	/**
	 * Brush used to draw the window title area when the window is active
	*/
	ActiveTitleBrush: SlateBrush;
	/**
	 * Brush used to draw the window title area when the window is inactive
	*/
	InactiveTitleBrush: SlateBrush;
	/**
	 * Brush used to draw the window title area when the window is flashing
	*/
	FlashTitleBrush: SlateBrush;
	/**
	 * Brush used to draw the window outline
	*/
	OutlineBrush: SlateBrush;
	/**
	 * Color used to draw the window outline
	*/
	OutlineColor: SlateColor;
	/**
	 * Brush used to draw the window border
	*/
	BorderBrush: SlateBrush;
	/**
	 * Brush used to draw the window background
	*/
	BackgroundBrush: SlateBrush;
	/**
	 * Brush used to draw the background of child windows
	*/
	ChildBackgroundBrush: SlateBrush;
	clone() : WindowStyle;
	static C(Other: UObject): WindowStyle;
}

declare type EJavascriptAutoCenter = string | symbol;
declare var EJavascriptAutoCenter = { None:'None',PrimaryWorkArea:'PrimaryWorkArea',PreferredWorkArea:'PreferredWorkArea', };
declare type EJavascriptWindowTransparency = string | symbol;
declare var EJavascriptWindowTransparency = { None:'None',PerWindow:'PerWindow', };
declare type EJavascriptSizingRule = string | symbol;
declare var EJavascriptSizingRule = { FixedSize:'FixedSize',Autosized:'Autosized',UserSized:'UserSized', };
declare class JavascriptWindow extends ContentWidget { 
	/**
	 * Type of this window
	*/
	Type: EJavascriptWindowType;
	/**
	 * Style
	*/
	Style: WindowStyle;
	/**
	 * Title
	*/
	Title: string;
	/**
	 * Drag Anywhere
	*/
	bDragAnywhere: boolean;
	/**
	 * Auto Center
	*/
	AutoCenter: EJavascriptAutoCenter;
	/**
	 * Screen-space position where the window should be initially located.
	*/
	ScreenPosition: Vector2D;
	/**
	 * What the initial size of the window should be.
	*/
	ClientSize: Vector2D;
	/**
	 * Should this window support transparency
	*/
	SupportsTransparency: EJavascriptWindowTransparency;
	/**
	 * Initial Opacity
	*/
	InitialOpacity: number;
	/**
	 * Is the window initially maximized
	*/
	IsInitiallyMaximized: boolean;
	/**
	 * Sizing Rule
	*/
	SizingRule: EJavascriptSizingRule;
	/**
	 * True if this should be a 'pop-up' window
	*/
	IsPopupWindow: boolean;
	/**
	 * Should this window be focused immediately after it is shown?
	*/
	FocusWhenFirstShown: boolean;
	/**
	 * Should this window be activated immediately after it is shown?
	*/
	ActivateWhenFirstShown: boolean;
	/**
	 * Use the default os look for the border of the window
	*/
	UseOSWindowBorder: boolean;
	/**
	 * Does this window have a close button?
	*/
	HasCloseButton: boolean;
	/**
	 * Can this window be maximized?
	*/
	SupportsMaximize: boolean;
	/**
	 * Can this window be minimized?
	*/
	SupportsMinimize: boolean;
	/**
	 * True if we should initially create a traditional title bar area.  If false, the user must embed the title
	 *       area content into the window manually, taking into account platform-specific considerations!  Has no
	 *       effect for certain types of windows (popups, tool-tips, etc.)
	*/
	CreateTitleBar: boolean;
	/**
	 * If the window appears off screen or is too large to safely fit this flag will force realistic
	 *       constraints on the window and bring it back into view.
	*/
	SaneWindowPlacement: boolean;
	/**
	 * The padding around the edges of the window applied to it's content.
	*/
	LayoutBorder: Margin;
	/**
	 * The margin around the edges of the window that will be detected as places the user can grab to resize the window.
	*/
	UserResizeBorder: Margin;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptWindow;
	static Find(Outer: UObject, ResourceName: string): JavascriptWindow;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptWindow;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptWindow;
	/**
	 * Show Window
	*/
	ShowWindow(): void;
	/**
	 * Set Opacity
	*/
	SetOpacity(InOpacity: number): void;
	/**
	 * Resize
	*/
	Resize(NewSize: Vector2D): void;
	/**
	 * Reshape Window
	*/
	ReshapeWindow(NewPosition: Vector2D,NewSize: Vector2D): void;
	/**
	 * Request Destroy Window
	*/
	RequestDestroyWindow(): void;
	/**
	 * End of UWidget interface
	*/
	MoveWindowTo(NewPosition: Vector2D): void;
	/**
	 * Hide Window
	*/
	HideWindow(): void;
	/**
	 * Flash Window
	*/
	FlashWindow(): void;
	/**
	 * Enable Window
	*/
	EnableWindow(bEnable: boolean): void;
	/**
	 * Destroy Window Immediately
	*/
	DestroyWindowImmediately(): void;
	/**
	 * Bring to Front
	*/
	BringToFront(): void;
	static C(Other: UObject): JavascriptWindow;
}

declare type EJavascriptHttpRequestStatus = string | symbol;
declare var EJavascriptHttpRequestStatus = { NotStarted:'NotStarted',Processing:'Processing',Failed:'Failed',Succeeded:'Succeeded', };
declare class JavascriptHttpRequest extends UObject { 
	/**
	 * On Complete
	*/
	OnComplete: UnrealEngineDelegate<(successful: boolean) => void>;
	/**
	 * On Progress
	*/
	OnProgress: UnrealEngineDelegate<(sent: number, recv: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptHttpRequest;
	static Find(Outer: UObject, ResourceName: string): JavascriptHttpRequest;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptHttpRequest;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptHttpRequest;
	/**
	 * Sets the verb used by the request.
	 * Eg. (GET, PUT, POST)
	 * Should be set before calling ProcessRequest.
	 * If not specified then a GET is assumed.
	 * @param Verb - verb to use.
	*/
	SetVerb(Verb: string): void;
	/**
	 * Sets the URL for the request
	 * Eg. (http://my.domain.com/something.ext?key=value&key2=value).
	 * Must be set before calling ProcessRequest.
	 * @param URL - URL to use.
	*/
	SetURL(URL: string): void;
	/**
	 * Sets optional header info.
	 * Content-Length is the only header set for you.
	 * Required headers depends on the request itself.
	 * Eg. "multipart/form-data" needed for a form post
	 * @param HeaderName - Name of the header (ie, Content-Type)
	 * @param HeaderValue - Value of the header
	*/
	SetHeader(HeaderName: string,HeaderValue: string): void;
	/**
	 * Sets the content of the request (optional data).
	 * Usually only set for POST requests.
	 * @param ContentPayload - payload to set.
	*/
	SetContentFromMemory(): void;
	/**
	 * Sets the content of the request as a string encoded as UTF8.
	 * @param ContentString - payload to set.
	*/
	SetContentAsString(ContentString: string): void;
	/**
	 * Called to begin processing the request.
	 * OnProcessRequestComplete delegate is always called when the request completes or on error if it is bound.
	 * A request can be re-used but not while still being processed.
	 * @return if the request was successfully started.
	*/
	ProcessRequest(): boolean;
	/**
	 * Gets the verb (GET, PUT, POST) used by the request.
	 * @return the verb string
	*/
	GetVerb(): string;
	/**
	 * Get the current status of the request being processed
	 * @return the current status
	*/
	GetStatus(): EJavascriptHttpRequestStatus;
	/**
	 * Gets the response code returned by the requested server.
	 * See EHttpResponseCodes for known response codes
	 * @return the response code.
	*/
	GetResponseCode(): number;
	/**
	 * Gets the time that it took for the server to fully respond to the request.
	 * @return elapsed time in seconds.
	*/
	GetElapsedTime(): number;
	/**
	 * Get Content to Memory
	*/
	GetContentToMemory(): void;
	/**
	 * Get Content Length
	*/
	GetContentLength(): number;
	/**
	 * Returns the payload as a string, assuming the payload is UTF8.
	 * @return the payload as a string.
	*/
	GetContentAsString(): string;
	/**
	 * Called to cancel a request that is still being processed
	*/
	CancelRequest(): void;
	static C(Other: UObject): JavascriptHttpRequest;
}

declare class JavascriptWebSocket extends UObject { 
	/**
	 * On Received
	*/
	OnReceived: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * On Connected
	*/
	OnConnected: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * On Error
	*/
	OnError: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptWebSocket;
	static Find(Outer: UObject, ResourceName: string): JavascriptWebSocket;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptWebSocket;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptWebSocket;
	/**
	 * Tick
	*/
	Tick(): void;
	/**
	 * Send Memory
	*/
	SendMemory(NumBytes: number): void;
	/**
	 * Remote End Point
	*/
	RemoteEndPoint(): string;
	/**
	 * Local End Point
	*/
	LocalEndPoint(): string;
	/**
	 * Get Received Bytes
	*/
	GetReceivedBytes(): number;
	/**
	 * Flush
	*/
	Flush(): void;
	/**
	 * Dispose
	*/
	Dispose(): void;
	/**
	 * Copy Buffer
	*/
	CopyBuffer(): void;
	/**
	 * Connect
	*/
	static Connect(Endpoint: string): JavascriptWebSocket;
	static C(Other: UObject): JavascriptWebSocket;
}

declare class JavascriptWebSocketServer extends UObject { 
	/**
	 * On Connected
	*/
	OnConnected: UnrealEngineMulticastDelegate<(WebSocket: JavascriptWebSocket) => void>;
	/**
	 * Connections
	*/
	Connections: JavascriptWebSocket[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptWebSocketServer;
	static Find(Outer: UObject, ResourceName: string): JavascriptWebSocketServer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptWebSocketServer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptWebSocketServer;
	/**
	 * Tick
	*/
	Tick(): void;
	/**
	 * Info
	*/
	Info(): string;
	/**
	 * Dispose
	*/
	Dispose(): void;
	/**
	 * Create
	*/
	static Create(Port: number): JavascriptWebSocketServer;
	static C(Other: UObject): JavascriptWebSocketServer;
}

declare class TcpMessagingSettings extends UObject { 
	/**
	 * Whether the TCP transport channel is enabled
	*/
	EnableTransport: boolean;
	/**
	 * The IP endpoint to listen for incoming connections.
	 * The format is IP_ADDRESS:PORT_NUMBER or blank to disable listening.
	*/
	ListenEndpoint: string;
	/**
	 * The IP endpoints to try to establish outgoing connection to.
	 * Use this setting to connect to a remote peer.
	 * The format is IP_ADDRESS:PORT_NUMBER.
	*/
	ConnectToEndpoints: string[];
	/**
	 * Delay time between attempts to re-establish outgoing connections that become disconnected or fail to connect
	 * 0 disables reconnection
	*/
	ConnectionRetryDelay: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TcpMessagingSettings;
	static Find(Outer: UObject, ResourceName: string): TcpMessagingSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TcpMessagingSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TcpMessagingSettings;
	static C(Other: UObject): TcpMessagingSettings;
}

declare class UdpMessagingSettings extends UObject { 
	/**
	 * Whether the UDP transport channel is enabled.
	*/
	EnableTransport: boolean;
	/**
	 * The IP endpoint to listen to and send packets from.
	 * The format is IP_ADDRESS:PORT_NUMBER.
	 * 0.0.0.0:0 will bind to the default network adapter on Windows,
	 * and all available network adapters on other operating systems.
	*/
	UnicastEndpoint: string;
	/**
	 * The IP endpoint to send multicast packets to.
	 * The format is IP_ADDRESS:PORT_NUMBER.
	 * The multicast IP address must be in the range 224.0.0.0 to 239.255.255.255.
	*/
	MulticastEndpoint: string;
	/**
	 * The time-to-live (TTL) for sent multicast packets.
	*/
	MulticastTimeToLive: number;
	/**
	 * The IP endpoints of static devices.
	 * Use this setting to list devices on other subnets, such as mobile phones on a WiFi network.
	 * The format is IP_ADDRESS:PORT_NUMBER.
	*/
	StaticEndpoints: string[];
	/**
	 * Whether the UDP tunnel is enabled.
	*/
	EnableTunnel: boolean;
	/**
	 * The local IP endpoint to listen to and send packets from.
	 * The format is IP_ADDRESS:PORT_NUMBER.
	*/
	TunnelUnicastEndpoint: string;
	/**
	 * The IP endpoint to send multicast packets to.
	 * The format is IP_ADDRESS:PORT_NUMBER.
	 * The multicast IP address must be in the range 224.0.0.0 to 239.255.255.255.
	*/
	TunnelMulticastEndpoint: string;
	/**
	 * The IP endpoints of remote tunnel nodes.
	 * Use this setting to connect to remote tunnel services.
	 * The format is IP_ADDRESS:PORT_NUMBER.
	*/
	RemoteTunnelEndpoints: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UdpMessagingSettings;
	static Find(Outer: UObject, ResourceName: string): UdpMessagingSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UdpMessagingSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UdpMessagingSettings;
	static C(Other: UObject): UdpMessagingSettings;
}

declare class FlipbookEditorSettings extends UObject { 
	/**
	 * Background color in the flipbook editor
	*/
	BackgroundColor: Color;
	/**
	 * Should the grid be shown by default when the editor is opened?
	*/
	bShowGridByDefault: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FlipbookEditorSettings;
	static Find(Outer: UObject, ResourceName: string): FlipbookEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FlipbookEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FlipbookEditorSettings;
	static C(Other: UObject): FlipbookEditorSettings;
}

declare type ESpriteExtractMode = string | symbol;
declare var ESpriteExtractMode = { Auto:'Auto',Grid:'Grid', };
declare class PaperExtractSpritesSettings extends UObject { 
	/**
	 * Sprite extract mode
	*/
	SpriteExtractMode: ESpriteExtractMode;
	/**
	 * The color of the sprite boundary outlines
	*/
	OutlineColor: LinearColor;
	/**
	 * Apply a tint to the texture in the viewport to improve outline visibility in this editor
	*/
	ViewportTextureTint: LinearColor;
	/**
	 * The viewport background color
	*/
	BackgroundColor: LinearColor;
	/**
	 * The name of the sprite that will be created. {0} will get replaced by the sprite number.
	*/
	NamingTemplate: string;
	/**
	 * The number to start naming with
	*/
	NamingStartIndex: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperExtractSpritesSettings;
	static Find(Outer: UObject, ResourceName: string): PaperExtractSpritesSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperExtractSpritesSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperExtractSpritesSettings;
	static C(Other: UObject): PaperExtractSpritesSettings;
}

declare class PaperExtractSpriteGridSettings extends UObject { 
	/**
	 * The width of each sprite in grid mode
	*/
	CellWidth: number;
	/**
	 * The height of each sprite in grid mode
	*/
	CellHeight: number;
	/**
	 * Number of cells extracted horizontally. Can be used to limit the number of sprites extracted. Set to 0 to extract all sprites
	*/
	NumCellsX: number;
	/**
	 * Number of cells extracted vertically. Can be used to limit the number of sprites extracted. Set to 0 to extract all sprites
	*/
	NumCellsY: number;
	/**
	 * Margin from the left of the texture to the first sprite
	*/
	MarginX: number;
	/**
	 * Margin from the top of the texture to the first sprite
	*/
	MarginY: number;
	/**
	 * Horizontal spacing between sprites
	*/
	SpacingX: number;
	/**
	 * Vertical spacing between sprites
	*/
	SpacingY: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperExtractSpriteGridSettings;
	static Find(Outer: UObject, ResourceName: string): PaperExtractSpriteGridSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperExtractSpriteGridSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperExtractSpriteGridSettings;
	static C(Other: UObject): PaperExtractSpriteGridSettings;
}

declare class PaperFlipbookActorFactory extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperFlipbookActorFactory;
	static Find(Outer: UObject, ResourceName: string): PaperFlipbookActorFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperFlipbookActorFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbookActorFactory;
	static C(Other: UObject): PaperFlipbookActorFactory;
}

declare class PaperFlipbookFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperFlipbookFactory;
	static Find(Outer: UObject, ResourceName: string): PaperFlipbookFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperFlipbookFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbookFactory;
	static C(Other: UObject): PaperFlipbookFactory;
}

declare class PaperImporterSettings extends UObject { 
	/**
	 * Should the source texture be scanned when creating new sprites to determine the appropriate material? (if false, the Default Masked Material is always used)
	*/
	bPickBestMaterialWhenCreatingSprites: boolean;
	/**
	 * Should the source texture be scanned when creating new tile maps (from a tile set or via importing) to determine the appropriate material? (if false, the Default Masked Material is always used)
	*/
	bPickBestMaterialWhenCreatingTileMaps: boolean;
	/**
	 * Can opaque materials be applied as part of the 'best material' analysis?
	*/
	bAnalysisCanUseOpaque: boolean;
	/**
	 * The default scaling factor between pixels and Unreal units (cm) to use for newly created sprite assets (e.g., 0.64 would make a 64 pixel wide sprite take up 100 cm)
	*/
	DefaultPixelsPerUnrealUnit: number;
	/**
	 * A list of default suffixes to use when looking for associated normal maps while importing sprites or creating sprites from textures
	*/
	NormalMapTextureSuffixes: string[];
	/**
	 * The default suffix to remove (if present) from a texture name before looking for an associated normal map using NormalMapTextureSuffixes
	*/
	BaseMapTextureSuffixes: string[];
	/**
	 * The default texture group for imported sprite textures, tile sheets, etc... (typically set to UI for 'modern 2D' or 2D pixels for 'retro 2D')
	*/
	DefaultSpriteTextureGroup: TextureGroup;
	/**
	 * Should texture compression settings be overridden on imported sprite textures, tile sheets, etc...?
	*/
	bOverrideTextureCompression: boolean;
	/**
	 * Compression settings to use when building the texture.
	 * The default texture group for imported sprite textures, tile sheets, etc... (typically set to UI for 'modern 2D' or 2D pixels for 'retro 2D')
	*/
	DefaultSpriteTextureCompression: TextureCompressionSettings;
	/**
	 * The unlit default masked material for newly created sprites (masked means binary opacity: things are either opaque or see-thru, with nothing in between)
	*/
	UnlitDefaultMaskedMaterialName: StringAssetReference;
	/**
	 * The unlit default translucent material for newly created sprites (translucent means smooth opacity which can vary continuously from 0..1, but translucent rendering is more expensive that opaque or masked rendering and has different sorting rules)
	*/
	UnlitDefaultTranslucentMaterialName: StringAssetReference;
	/**
	 * The unlit default opaque material for newly created sprites
	*/
	UnlitDefaultOpaqueMaterialName: StringAssetReference;
	/**
	 * The lit default masked material for newly created sprites (masked means binary opacity: things are either opaque or see-thru, with nothing in between)
	*/
	LitDefaultMaskedMaterialName: StringAssetReference;
	/**
	 * The lit default translucent material for newly created sprites (translucent means smooth opacity which can vary continuously from 0..1, but translucent rendering is more expensive that opaque or masked rendering and has different sorting rules)
	*/
	LitDefaultTranslucentMaterialName: StringAssetReference;
	/**
	 * The lit default opaque material for newly created sprites
	*/
	LitDefaultOpaqueMaterialName: StringAssetReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperImporterSettings;
	static Find(Outer: UObject, ResourceName: string): PaperImporterSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperImporterSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperImporterSettings;
	static C(Other: UObject): PaperImporterSettings;
}

declare class PaperSpriteActorFactory extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteActorFactory;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteActorFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteActorFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteActorFactory;
	static C(Other: UObject): PaperSpriteActorFactory;
}

declare class PaperSpriteAtlasFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteAtlasFactory;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteAtlasFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteAtlasFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteAtlasFactory;
	static C(Other: UObject): PaperSpriteAtlasFactory;
}

declare class PaperSpriteFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteFactory;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteFactory;
	static C(Other: UObject): PaperSpriteFactory;
}

declare class PaperSpriteThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteThumbnailRenderer;
	static C(Other: UObject): PaperSpriteThumbnailRenderer;
}

declare class PaperFlipbookThumbnailRenderer extends PaperSpriteThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperFlipbookThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): PaperFlipbookThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperFlipbookThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperFlipbookThumbnailRenderer;
	static C(Other: UObject): PaperFlipbookThumbnailRenderer;
}

declare class PaperTileMapFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTileMapFactory;
	static Find(Outer: UObject, ResourceName: string): PaperTileMapFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileMapFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileMapFactory;
	static C(Other: UObject): PaperTileMapFactory;
}

declare class PaperTileMapPromotionFactory extends Factory { 
	/**
	 * Object being promoted to an asset
	*/
	AssetToRename: PaperTileMap;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTileMapPromotionFactory;
	static Find(Outer: UObject, ResourceName: string): PaperTileMapPromotionFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileMapPromotionFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileMapPromotionFactory;
	static C(Other: UObject): PaperTileMapPromotionFactory;
}

declare class PaperTileSetFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTileSetFactory;
	static Find(Outer: UObject, ResourceName: string): PaperTileSetFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileSetFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileSetFactory;
	static C(Other: UObject): PaperTileSetFactory;
}

declare class PaperTileSetThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTileSetThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): PaperTileSetThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTileSetThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTileSetThumbnailRenderer;
	static C(Other: UObject): PaperTileSetThumbnailRenderer;
}

declare class SpriteEditorSettings extends UObject { 
	/**
	 * Background color in the sprite editor
	*/
	BackgroundColor: Color;
	/**
	 * Should the grid be shown by default when the editor is opened?
	*/
	bShowGridByDefault: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SpriteEditorSettings;
	static Find(Outer: UObject, ResourceName: string): SpriteEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpriteEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpriteEditorSettings;
	static C(Other: UObject): SpriteEditorSettings;
}

declare class TerrainSplineActorFactory extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TerrainSplineActorFactory;
	static Find(Outer: UObject, ResourceName: string): TerrainSplineActorFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TerrainSplineActorFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TerrainSplineActorFactory;
	static C(Other: UObject): TerrainSplineActorFactory;
}

declare class TileMapActorFactory extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TileMapActorFactory;
	static Find(Outer: UObject, ResourceName: string): TileMapActorFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TileMapActorFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileMapActorFactory;
	static C(Other: UObject): TileMapActorFactory;
}

declare class TileSetImportMapping { 
	/**
	 * Source Name
	*/
	SourceName: string;
	/**
	 * Imported Tile Set
	*/
	ImportedTileSet: any;
	/**
	 * Imported Texture
	*/
	ImportedTexture: any;
	clone() : TileSetImportMapping;
	static C(Other: UObject): TileSetImportMapping;
}

declare class TileMapAssetImportData extends AssetImportData { 
	/**
	 * Tile Set Map
	*/
	TileSetMap: TileSetImportMapping[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TileMapAssetImportData;
	static Find(Outer: UObject, ResourceName: string): TileMapAssetImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TileMapAssetImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileMapAssetImportData;
	static C(Other: UObject): TileMapAssetImportData;
}

declare class TileMapEditorSettings extends UObject { 
	/**
	 * Default background color for new tile map assets
	*/
	DefaultBackgroundColor: Color;
	/**
	 * Should the grid be shown by default when the editor is opened?
	*/
	bShowGridByDefault: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TileMapEditorSettings;
	static Find(Outer: UObject, ResourceName: string): TileMapEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TileMapEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileMapEditorSettings;
	static C(Other: UObject): TileMapEditorSettings;
}

declare class TileSetEditorSettings extends UObject { 
	/**
	 * Default background color for new tile set assets
	*/
	DefaultBackgroundColor: Color;
	/**
	 * Should the grid be shown by default when the editor is opened?
	*/
	bShowGridByDefault: boolean;
	/**
	 * The amount to extrude out from the edge of each tile (in pixels)
	*/
	ExtrusionAmount: number;
	/**
	 * Should we pad the conditioned texture to the next power of 2?
	*/
	bPadToPowerOf2: boolean;
	/**
	 * Should we use transparent black or white when filling the texture areas that aren't covered by tiles?
	*/
	bFillWithTransparentBlack: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TileSetEditorSettings;
	static Find(Outer: UObject, ResourceName: string): TileSetEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TileSetEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileSetEditorSettings;
	static C(Other: UObject): TileSetEditorSettings;
}

declare class TileSheetPaddingFactory extends Factory { 
	/**
	 * Source tile sheet texture
	*/
	SourceTileSet: PaperTileSet;
	/**
	 * The amount to extrude out from each tile (in pixels)
	*/
	ExtrusionAmount: number;
	/**
	 * Should we pad the texture to the next power of 2?
	*/
	bPadToPowerOf2: boolean;
	/**
	 * Should we use transparent black or white when filling the texture areas that aren't covered by tiles?
	*/
	bFillWithTransparentBlack: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TileSheetPaddingFactory;
	static Find(Outer: UObject, ResourceName: string): TileSheetPaddingFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TileSheetPaddingFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TileSheetPaddingFactory;
	static C(Other: UObject): TileSheetPaddingFactory;
}

declare class InternationalizationExportSettings extends UObject { 
	/**
	 * Which cultures should be exported
	*/
	CulturesToGenerate: string[];
	/**
	 * The commandlet to run
	*/
	CommandletClass: string;
	/**
	 * Source for the localization data
	*/
	SourcePath: string;
	/**
	 * Destination for the localization data
	*/
	DestinationPath: string;
	/**
	 * Filename for the Portable Object format file
	*/
	PortableObjectName: string;
	/**
	 * Name of the manifest file
	*/
	ManifestName: string;
	/**
	 * Name of the archive file
	*/
	ArchiveName: string;
	/**
	 * Whether or not to export localization data
	*/
	bExportLoc: boolean;
	/**
	 * Whether or not to import localization data
	*/
	bImportLoc: boolean;
	/**
	 * Whether or not to use culture path
	*/
	bUseCultureDirectory: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InternationalizationExportSettings;
	static Find(Outer: UObject, ResourceName: string): InternationalizationExportSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InternationalizationExportSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InternationalizationExportSettings;
	static C(Other: UObject): InternationalizationExportSettings;
}

declare class TranslationPickerSettings extends UObject { 
	/**
	 * Bool submit translation picker changes to Localization Service
	*/
	bSubmitTranslationPickerChangesToLocalizationService: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TranslationPickerSettings;
	static Find(Outer: UObject, ResourceName: string): TranslationPickerSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TranslationPickerSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationPickerSettings;
	static C(Other: UObject): TranslationPickerSettings;
}

declare class TranslationChange { 
	/**
	 * The changelist of this change
	*/
	Version: string;
	/**
	 * Date of this change //, meta=(DisplayName = "Date & Time"))
	*/
	DateAndTime: DateTime;
	/**
	 * Source at time of this change
	*/
	Source: string;
	/**
	 * Translation at time of this change
	*/
	Translation: string;
	clone() : TranslationChange;
	static C(Other: UObject): TranslationChange;
}

declare class TranslationContextInfo { 
	/**
	 * The key specified in LOCTEXT
	*/
	Key: string;
	/**
	 * What file and line this translation is from
	*/
	Context: string;
	/**
	 * List of previous versions of the source text for this context
	*/
	Changes: TranslationChange[];
	clone() : TranslationContextInfo;
	static C(Other: UObject): TranslationContextInfo;
}

declare class TranslationUnit extends UObject { 
	/**
	 * The localization namespace for this translation
	*/
	Namespace: string;
	/**
	 * Original text from the source language
	*/
	Source: string;
	/**
	 * Translations
	*/
	Translation: string;
	/**
	 * Contexts the source was found in
	*/
	Contexts: TranslationContextInfo[];
	/**
	 * Whether the changes have been reviewed
	*/
	HasBeenReviewed: boolean;
	/**
	 * If this Translation Unit had a different translation before import, it will be stored here
	*/
	TranslationBeforeImport: string;
	/**
	 * Optional: Which Locres File this translation is in
	*/
	LocresPath: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TranslationUnit;
	static Find(Outer: UObject, ResourceName: string): TranslationUnit;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TranslationUnit;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TranslationUnit;
	static C(Other: UObject): TranslationUnit;
}

declare class PixelInspectorView extends UObject { 
	/**
	 * Final RGBA 8bits Color after tone mapping, default value is black.
	*/
	FinalColor: LinearColor;
	/**
	 * HDR RGB Color.
	*/
	SceneColor: LinearColor;
	/**
	 * HDR Luminance.
	*/
	Luminance: number;
	/**
	 * HDR RGB Color.
	*/
	HdrColor: LinearColor;
	/**
	 * From the GBufferA RGB Channels.
	*/
	Normal: Vector;
	/**
	 * From the GBufferA A Channel.
	*/
	PerObjectGBufferData: number;
	/**
	 * From the GBufferB R Channel.
	*/
	Metallic: number;
	/**
	 * From the GBufferB G Channel.
	*/
	Specular: number;
	/**
	 * From the GBufferB B Channel.
	*/
	Roughness: number;
	/**
	 * From the GBufferB A Channel encoded with SelectiveOutputMask.
	*/
	MaterialShadingModel: EMaterialShadingModel;
	/**
	 * From the GBufferB A Channel encoded with ShadingModel.
	*/
	SelectiveOutputMask: number;
	/**
	 * From the GBufferC RGB Channels.
	*/
	BaseColor: LinearColor;
	/**
	 * From the GBufferC A Channel encoded with AmbientOcclusion.
	*/
	IndirectIrradiance: number;
	/**
	 * From the GBufferC A Channel encoded with IndirectIrradiance.
	*/
	AmbientOcclusion: number;
	/**
	 * From the GBufferD RGB Channels.
	*/
	SubSurfaceColor: LinearColor;
	/**
	 * From the GBufferD RGB Channels.
	*/
	SubsurfaceProfile: Vector;
	/**
	 * From the GBufferD A Channel.
	*/
	Opacity: number;
	/**
	 * From the GBufferD R Channel.
	*/
	ClearCoat: number;
	/**
	 * From the GBufferD G Channel.
	*/
	ClearCoatRoughness: number;
	/**
	 * From the GBufferD RG Channels.
	*/
	WorldNormal: Vector;
	/**
	 * From the GBufferD B Channel.
	*/
	BackLit: number;
	/**
	 * From the GBufferD A Channel.
	*/
	Cloth: number;
	/**
	 * From the GBufferD RG Channels.
	*/
	EyeTangent: Vector;
	/**
	 * From the GBufferD B Channel.
	*/
	IrisMask: number;
	/**
	 * From the GBufferD A Channel.
	*/
	IrisDistance: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PixelInspectorView;
	static Find(Outer: UObject, ResourceName: string): PixelInspectorView;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PixelInspectorView;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PixelInspectorView;
	static C(Other: UObject): PixelInspectorView;
}

declare class PaperSpriteSheet extends UObject { 
	/**
	 * The names of sprites during import
	*/
	SpriteNames: string[];
	/**
	 * Sprites
	*/
	Sprites: any[];
	/**
	 * The name of the default or diffuse texture during import
	*/
	TextureName: string;
	/**
	 * The asset that was created for TextureName
	*/
	Texture: Texture2D;
	/**
	 * The name of the normal map texture during import (if any)
	*/
	NormalMapTextureName: string;
	/**
	 * The asset that was created for NormalMapTextureName (if any)
	*/
	NormalMapTexture: Texture2D;
	/**
	 * Import data for this
	*/
	AssetImportData: AssetImportData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteSheet;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteSheet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteSheet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteSheet;
	static C(Other: UObject): PaperSpriteSheet;
}

declare class PaperSpriteSheetImportFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteSheetImportFactory;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteSheetImportFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteSheetImportFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteSheetImportFactory;
	static C(Other: UObject): PaperSpriteSheetImportFactory;
}

declare class PaperSpriteSheetReimportFactory extends PaperSpriteSheetImportFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperSpriteSheetReimportFactory;
	static Find(Outer: UObject, ResourceName: string): PaperSpriteSheetReimportFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperSpriteSheetReimportFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperSpriteSheetReimportFactory;
	static C(Other: UObject): PaperSpriteSheetReimportFactory;
}

declare class PaperTiledImporterFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PaperTiledImporterFactory;
	static Find(Outer: UObject, ResourceName: string): PaperTiledImporterFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PaperTiledImporterFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PaperTiledImporterFactory;
	static C(Other: UObject): PaperTiledImporterFactory;
}

declare class LightPropagationVolumeBlendableFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LightPropagationVolumeBlendableFactory;
	static Find(Outer: UObject, ResourceName: string): LightPropagationVolumeBlendableFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LightPropagationVolumeBlendableFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LightPropagationVolumeBlendableFactory;
	static C(Other: UObject): LightPropagationVolumeBlendableFactory;
}

declare class MyPluginStruct { 
	/**
	 * Test String
	*/
	TestString: string;
	clone() : MyPluginStruct;
	static C(Other: UObject): MyPluginStruct;
}

declare class MyPluginObject extends UObject { 
	/**
	 * My Struct
	*/
	MyStruct: MyPluginStruct;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MyPluginObject;
	static Find(Outer: UObject, ResourceName: string): MyPluginObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MyPluginObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MyPluginObject;
	static C(Other: UObject): MyPluginObject;
}

declare class PluginMetadataObject extends UObject { 
	/**
	 * Version number for the plugin.  The version number must increase with every version of the plugin, so that the system
	 *       can determine whether one version of a plugin is newer than another, or to enforce other requirements.  This version
	 *       number is not displayed in front-facing UI.  Use the VersionName for that.
	*/
	Version: number;
	/**
	 * Name of the version for this plugin.  This is the front-facing part of the version number.  It doesn't need to match
	 *       the version number numerically, but should be updated when the version number is increased accordingly.
	*/
	VersionName: string;
	/**
	 * Friendly name of the plugin
	*/
	FriendlyName: string;
	/**
	 * Description of the plugin
	*/
	Description: string;
	/**
	 * The category that this plugin belongs to
	*/
	Category: string;
	/**
	 * The company or individual who created this plugin.  This is an optional field that may be displayed in the user interface.
	*/
	CreatedBy: string;
	/**
	 * Hyperlink URL string for the company or individual who created this plugin.  This is optional.
	*/
	CreatedByURL: string;
	/**
	 * Documentation URL string.
	*/
	DocsURL: string;
	/**
	 * Marketplace URL string.
	*/
	MarketplaceURL: string;
	/**
	 * Support URL/email for this plugin. Email addresses must be prefixed with 'mailto:'
	*/
	SupportURL: string;
	/**
	 * Can this plugin contain content?
	*/
	bCanContainContent: boolean;
	/**
	 * Marks the plugin as beta in the UI
	*/
	bIsBetaVersion: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PluginMetadataObject;
	static Find(Outer: UObject, ResourceName: string): PluginMetadataObject;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PluginMetadataObject;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PluginMetadataObject;
	static C(Other: UObject): PluginMetadataObject;
}

declare class SpeedTreeImportFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SpeedTreeImportFactory;
	static Find(Outer: UObject, ResourceName: string): SpeedTreeImportFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpeedTreeImportFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpeedTreeImportFactory;
	static C(Other: UObject): SpeedTreeImportFactory;
}

declare class ReimportSpeedTreeFactory extends SpeedTreeImportFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReimportSpeedTreeFactory;
	static Find(Outer: UObject, ResourceName: string): ReimportSpeedTreeFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReimportSpeedTreeFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReimportSpeedTreeFactory;
	static C(Other: UObject): ReimportSpeedTreeFactory;
}

declare type ETutorialContent = string | symbol;
declare var ETutorialContent = { None:'None',Text:'Text',UDNExcerpt:'UDNExcerpt',RichText:'RichText', };
declare class TutorialContent { 
	/**
	 * The type of this content
	*/
	Type: ETutorialContent;
	/**
	 * Content reference string, path etc.
	*/
	Content: string;
	/**
	 * Excerpt name for UDN excerpt
	*/
	ExcerptName: string;
	/**
	 * Localized text to use with this content
	*/
	Text: string;
	clone() : TutorialContent;
	static C(Other: UObject): TutorialContent;
}

declare type ETutorialAnchorIdentifier = string | symbol;
declare var ETutorialAnchorIdentifier = { None:'None',NamedWidget:'NamedWidget',Asset:'Asset', };
declare class TutorialContentAnchor { 
	/**
	 * Type
	*/
	Type: ETutorialAnchorIdentifier;
	/**
	 * If widget is in a wrapper widget, this is the wrapper widget name
	*/
	WrapperIdentifier: string;
	/**
	 * If reference is an asset, we use this to resolve it
	*/
	Asset: StringAssetReference;
	/**
	 * Whether to draw an animated highlight around the widget
	*/
	bDrawHighlight: boolean;
	/**
	 * Tab on which to focus (EG 'My Blueprint' tab).
	*/
	TabToFocusOrOpen: string;
	/**
	 * User friendly name to display in the dialog
	*/
	FriendlyName: string;
	/**
	 * The GUID string
	*/
	GUIDString: string;
	/**
	 * Name of the outer object - should be the blueprint that 'owns' the node
	*/
	OuterName: string;
	clone() : TutorialContentAnchor;
	static C(Other: UObject): TutorialContentAnchor;
}

declare class TutorialWidgetContent { 
	/**
	 * Content to associate with widget
	*/
	Content: TutorialContent;
	/**
	 * Anchor for content widget to highlight
	*/
	WidgetAnchor: TutorialContentAnchor;
	/**
	 * Horizontal Alignment
	*/
	HorizontalAlignment: EHorizontalAlignment;
	/**
	 * Vertical Alignment
	*/
	VerticalAlignment: EVerticalAlignment;
	/**
	 * Custom offset from widget
	*/
	Offset: Vector2D;
	/**
	 * Content width - text will be wrapped at this point
	*/
	ContentWidth: number;
	/**
	 * If this a node that can be focused (EG a blueprint node) should we auto focus on it
	*/
	bAutoFocus: boolean;
	clone() : TutorialWidgetContent;
	static C(Other: UObject): TutorialWidgetContent;
}

declare class TutorialStage { 
	/**
	 * Identifier for this stage
	*/
	Name: string;
	/**
	 * Non-widget-bound content to display in this stage
	*/
	Content: TutorialContent;
	/**
	 * Widget-bound content to display for this stage
	*/
	WidgetContent: TutorialWidgetContent[];
	/**
	 * Text to display on the next button
	*/
	NextButtonText: string;
	/**
	 * Text to display on the back button
	*/
	BackButtonText: string;
	/**
	 * List of platforms to test against. Meaning of test is determined by InvertPlatformTest.
	*/
	PlatformsToTest: string[];
	/**
	 * If false, stage will be skipped if running on any platform in PlatformsToTest. If true, the stage will be if not running on any platform in PlatformsToTest.
	*/
	bInvertPlatformTest: boolean;
	clone() : TutorialStage;
	static C(Other: UObject): TutorialStage;
}

declare class EditorTutorial extends UObject { 
	/**
	 * Title of this tutorial, used when presented to the user
	*/
	Title: string;
	/**
	 * Sorting priority, used by the tutorial browser
	*/
	SortOrder: number;
	/**
	 * Icon name for this tutorial, used when presented to the user in the tutorial browser. This is a name for the icon in the Slate editor style. Only used if there isn't a valid texture to use.
	*/
	Icon: string;
	/**
	 * Texture for this tutorial, used when presented to the user in the tutorial browser.
	*/
	Texture: Texture2D;
	/**
	 * Category of this tutorial, used to organize tutorials when presented to the user
	*/
	Category: string;
	/**
	 * Content to be displayed for this tutorial when presented to the user in summary
	*/
	SummaryContent: TutorialContent;
	/**
	 * The various stages of this tutorial
	*/
	Stages: TutorialStage[];
	/**
	 * Tutorial to optionally chain back to if the "back" button is clicked on the first stage
	*/
	PreviousTutorial: StringClassReference;
	/**
	 * Tutorial to optionally chain onto after this tutorial completes
	*/
	NextTutorial: StringClassReference;
	/**
	 * A standalone tutorial displays no navigation buttons and each content widget has a close button
	*/
	bIsStandalone: boolean;
	/**
	 * Asset to open & attach the tutorial to. Non-widget-bound content will appear in the asset's window
	*/
	AssetToUse: StringAssetReference;
	/**
	 * The path this tutorial was imported from, if any.
	*/
	ImportPath: string;
	/**
	 * Hide this tutorial in the tutorials browser
	*/
	bHideInBrowser: boolean;
	/**
	 * Comma seperated list of tags the search will use to help find this tutorial
	*/
	SearchTags: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorTutorial;
	static Find(Outer: UObject, ResourceName: string): EditorTutorial;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorTutorial;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTutorial;
	/**
	 * Sets the visibility of the engine folder in the content browser
	*/
	static SetEngineFolderVisibilty(bNewVisibility: boolean): void;
	/**
	 * Open an asset for use by a tutorial
	 * @param       Asset   The asset to open
	*/
	static OpenAsset(Asset: UObject): void;
	/**
	 * Event fired when a tutorial stage begins
	*/
	OnTutorialStageStarted(StageName: string): void;
	/**
	 * Event fired when a tutorial stage ends
	*/
	OnTutorialStageEnded(StageName: string): void;
	/**
	 * Event fired when a tutorial is launched
	*/
	OnTutorialLaunched(): void;
	/**
	 * Event fired when a tutorial is closed
	*/
	OnTutorialClosed(): void;
	/**
	 * Advance to the previous stage of a tutorial
	*/
	static GoToPreviousTutorialStage(): void;
	/**
	 * Advance to the next stage of a tutorial
	*/
	static GoToNextTutorialStage(): void;
	/**
	 * Returns the visibility of the engine folder in the content browser
	*/
	static GetEngineFolderVisibilty(): boolean;
	/**
	 * Attempts to find the actor specified by PathToActor in the current editor world
	 * @param        PathToActor     The path to the actor (e.g. PersistentLevel.PlayerStart)
	 * @return       A reference to the actor, or none if it wasn't found
	*/
	GetActorReference(PathToActor: string): Actor;
	/**
	 * Begin a tutorial. Note that this will end the current tutorial that is in progress, if any
	*/
	static BeginTutorial(TutorialToStart: EditorTutorial,bRestart: boolean): void;
	static C(Other: UObject): EditorTutorial;
}

declare class EditorTutorialFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorTutorialFactory;
	static Find(Outer: UObject, ResourceName: string): EditorTutorialFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorTutorialFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTutorialFactory;
	static C(Other: UObject): EditorTutorialFactory;
}

declare class EditorTutorialImportFactory extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorTutorialImportFactory;
	static Find(Outer: UObject, ResourceName: string): EditorTutorialImportFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorTutorialImportFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTutorialImportFactory;
	static C(Other: UObject): EditorTutorialImportFactory;
}

declare class TutorialCategory { 
	/**
	 * Period-separated category name, e.g. "Editor Quickstart.Level Editor"
	*/
	Identifier: string;
	/**
	 * Title of the category
	*/
	Title: string;
	/**
	 * Sort order, used by the tutorial browser - set in editor game-agnostic INI file
	*/
	SortOrder: number;
	/**
	 * Localized text to use to describe this category
	*/
	Description: string;
	/**
	 * Icon for this tutorial, used when presented to the user in the tutorial browser. Only used if there isn't a valid texture to use.
	*/
	Icon: string;
	/**
	 * Texture for this tutorial, used when presented to the user in the tutorial browser.
	*/
	Texture: StringAssetReference;
	clone() : TutorialCategory;
	static C(Other: UObject): TutorialCategory;
}

declare class TutorialContext { 
	/**
	 * The context that this tutorial is used in
	*/
	Context: string;
	/**
	 * The filter string to apply to the tutorials browser when launched from this context
	*/
	BrowserFilter: string;
	/**
	 * The tutorial to use in this context to let the user know there is a tutorial available
	*/
	AttractTutorial: StringClassReference;
	/**
	 * The tutorial to use in this context when the user chooses to launch
	*/
	LaunchTutorial: StringClassReference;
	clone() : TutorialContext;
	static C(Other: UObject): TutorialContext;
}

declare class EditorTutorialSettings extends UObject { 
	/**
	 * Disable the pulsing alert that indicates a new tutorial is available.
	*/
	bDisableAllTutorialAlerts: boolean;
	/**
	 * Categories for tutorials
	*/
	Categories: TutorialCategory[];
	/**
	 * Tutorial to start on Editor startup
	*/
	StartupTutorial: StringClassReference;
	/**
	 * Tutorials used in various contexts - e.g. the various asset editors
	*/
	TutorialContexts: TutorialContext[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EditorTutorialSettings;
	static Find(Outer: UObject, ResourceName: string): EditorTutorialSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EditorTutorialSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EditorTutorialSettings;
	static C(Other: UObject): EditorTutorialSettings;
}

declare class TutorialSettings extends UObject { 
	/**
	 * Categories for tutorials
	*/
	Categories: TutorialCategory[];
	/**
	 * Tutorial to start on project startup
	*/
	StartupTutorial: StringClassReference;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TutorialSettings;
	static Find(Outer: UObject, ResourceName: string): TutorialSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TutorialSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TutorialSettings;
	static C(Other: UObject): TutorialSettings;
}

declare class TutorialProgress { 
	/**
	 * Tutorial
	*/
	Tutorial: StringClassReference;
	/**
	 * Current Stage
	*/
	CurrentStage: number;
	/**
	 * User Dismissed
	*/
	bUserDismissed: boolean;
	clone() : TutorialProgress;
	static C(Other: UObject): TutorialProgress;
}

declare class TutorialStateSettings extends UObject { 
	/**
	 * Tutorials Progress
	*/
	TutorialsProgress: TutorialProgress[];
	/**
	 * Record if user has chosen to cancel all tutorials
	*/
	bDismissedAllTutorials: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TutorialStateSettings;
	static Find(Outer: UObject, ResourceName: string): TutorialStateSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TutorialStateSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TutorialStateSettings;
	static C(Other: UObject): TutorialStateSettings;
}

declare type ESearchEngine = string | symbol;
declare var ESearchEngine = { Google:'Google',Bing:'Bing', };
declare class SuperSearchSettings extends DeveloperSettings { 
	/**
	 * Set the search engine to use in the editor for looking up questions in the community.
	*/
	SearchEngine: ESearchEngine;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SuperSearchSettings;
	static Find(Outer: UObject, ResourceName: string): SuperSearchSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SuperSearchSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SuperSearchSettings;
	static C(Other: UObject): SuperSearchSettings;
}

declare class GeometryCacheTrack extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeometryCacheTrack;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeometryCacheTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrack;
	static C(Other: UObject): GeometryCacheTrack;
}

declare class GeometryCache extends UObject { 
	/**
	 * Importing data and options used for this Geometry cache object
	*/
	AssetImportData: AssetImportData;
	/**
	 * Information for thumbnail rendering
	*/
	ThumbnailInfo: ThumbnailInfo;
	/**
	 * Materials
	*/
	Materials: MaterialInterface[];
	/**
	 * GeometryCache track defining the samples/geometry data for this GeomCache instance
	*/
	Tracks: GeometryCacheTrack[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeometryCache;
	static Find(Outer: UObject, ResourceName: string): GeometryCache;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeometryCache;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCache;
	static C(Other: UObject): GeometryCache;
}

declare class GeometryCacheComponent extends MeshComponent { 
	/**
	 * Geometry Cache instance referenced by the component
	*/
	GeometryCache: GeometryCache;
	/**
	 * Running
	*/
	bRunning: boolean;
	/**
	 * Looping
	*/
	bLooping: boolean;
	/**
	 * Start Time Offset
	*/
	StartTimeOffset: number;
	/**
	 * Playback Speed
	*/
	PlaybackSpeed: number;
	/**
	 * Num Tracks
	*/
	NumTracks: number;
	/**
	 * Elapsed Time
	*/
	ElapsedTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeometryCacheComponent;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeometryCacheComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheComponent;
	/**
	 * Stop playback of GeometryCache
	*/
	Stop(): void;
	/**
	 * Get whether this GeometryCache is playing or not.
	*/
	SetPlaybackSpeed(NewPlaybackSpeed: number): void;
	/**
	 * Set whether this GeometryCache is looping or not.
	*/
	SetLooping(bNewLooping: boolean): void;
	/**
	 * Change the Geometry Cache used by this instance.
	*/
	SetGeometryCache(NewGeomCache: GeometryCache): boolean;
	/**
	 * Start playback of GeometryCache from the end and play in reverse
	*/
	PlayReversedFromEnd(): void;
	/**
	 * Start playback of GeometryCache in reverse
	*/
	PlayReversed(): void;
	/**
	 * Start playback of GeometryCache from the start
	*/
	PlayFromStart(): void;
	/**
	 * Start playback of GeometryCache
	*/
	Play(): void;
	/**
	 * Pause playback of GeometryCache
	*/
	Pause(): void;
	/**
	 * Get whether this GeometryCache is playing in reverse or not.
	*/
	IsPlayingReversed(): boolean;
	/**
	 * Get whether this GeometryCache is playing or not.
	*/
	IsPlaying(): boolean;
	/**
	 * Get whether this GeometryCache is looping or not.
	*/
	IsLooping(): boolean;
	/**
	 * Get whether this GeometryCache is playing or not.
	*/
	GetPlaybackSpeed(): number;
	static C(Other: UObject): GeometryCacheComponent;
}

declare class GeometryCacheActor extends Actor { 
	/**
	 * End AActor overrides.
	*/
	GeometryCacheComponent: GeometryCacheComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeometryCacheActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheActor;
	/**
	 * Returns GeometryCacheComponent subobject *
	*/
	GetGeometryCacheComponent(): GeometryCacheComponent;
	static C(Other: UObject): GeometryCacheActor;
}

declare class GeometryCacheMeshData { 
	clone() : GeometryCacheMeshData;
	static C(Other: UObject): GeometryCacheMeshData;
}

declare class GeometryCacheTrack_FlipbookAnimation extends GeometryCacheTrack { 
	/**
	 * Number of Mesh Sample within this track
	*/
	NumMeshSamples: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeometryCacheTrack_FlipbookAnimation;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrack_FlipbookAnimation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeometryCacheTrack_FlipbookAnimation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrack_FlipbookAnimation;
	/**
	 * Add a GeometryCacheMeshData sample to the Track
	 * @param MeshData - Holds the mesh data for the specific sample
	 * @param SampleTime - SampleTime for the specific sample being added
	 * @return void
	*/
	AddMeshSample(MeshData: GeometryCacheMeshData,SampleTime: number): void;
	static C(Other: UObject): GeometryCacheTrack_FlipbookAnimation;
}

declare class GeometryCacheTrack_TransformAnimation extends GeometryCacheTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeometryCacheTrack_TransformAnimation;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrack_TransformAnimation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeometryCacheTrack_TransformAnimation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrack_TransformAnimation;
	/**
	 * Sets/updates the MeshData for this track
	 * @param NewMeshData - GeometryCacheMeshData instance later used as the rendered mesh
	*/
	SetMesh(NewMeshData: GeometryCacheMeshData): void;
	static C(Other: UObject): GeometryCacheTrack_TransformAnimation;
}

declare class GeometryCacheTrack_TransformGroupAnimation extends GeometryCacheTrack { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeometryCacheTrack_TransformGroupAnimation;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheTrack_TransformGroupAnimation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeometryCacheTrack_TransformGroupAnimation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheTrack_TransformGroupAnimation;
	/**
	 * Sets/updates the MeshData for this track
	 * @param NewMeshData - GeometryCacheMeshData instance later used as the rendered mesh
	*/
	SetMesh(NewMeshData: GeometryCacheMeshData): void;
	static C(Other: UObject): GeometryCacheTrack_TransformGroupAnimation;
}

declare class AbcAssetImportData extends AssetImportData { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AbcAssetImportData;
	static Find(Outer: UObject, ResourceName: string): AbcAssetImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AbcAssetImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbcAssetImportData;
	static C(Other: UObject): AbcAssetImportData;
}

declare type EAlembicImportType = string | symbol;
declare var EAlembicImportType = { StaticMesh:'StaticMesh',GeometryCache:'GeometryCache',Skeletal:'Skeletal', };
declare type EAlembicSamplingType = string | symbol;
declare var EAlembicSamplingType = { PerFrame:'PerFrame',PerXFrames:'PerXFrames',PerTimeStep:'PerTimeStep', };
declare class AbcSamplingSettings { 
	/**
	 * Type of sampling performed while importing the animation
	*/
	SamplingType: EAlembicSamplingType;
	/**
	 * Steps to take when sampling the animation
	*/
	FrameSteps: any;
	/**
	 * Time steps to take when sampling the animation
	*/
	TimeSteps: number;
	/**
	 * Starting index to start sampling the animation from
	*/
	FrameStart: any;
	/**
	 * Ending index to stop sampling the animation at
	*/
	FrameEnd: any;
	clone() : AbcSamplingSettings;
	static C(Other: UObject): AbcSamplingSettings;
}

declare class AbcNormalGenerationSettings { 
	/**
	 * Whether or not to force smooth normals for each individual object rather than calculating smoothing groups
	*/
	bForceOneSmoothingGroupPerObject: boolean;
	/**
	 * Threshold used to determine whether an angle between two normals should be considered hard, closer to 0 means more smooth vs 1
	*/
	HardEdgeAngleThreshold: number;
	/**
	 * Determines whether or not the normals should be forced to be recomputed
	*/
	bRecomputeNormals: boolean;
	/**
	 * Determines whether or not the degenerate triangles should be ignored when calculating tangents/normals
	*/
	bIgnoreDegenerateTriangles: boolean;
	clone() : AbcNormalGenerationSettings;
	static C(Other: UObject): AbcNormalGenerationSettings;
}

declare type EBaseCalculationType = string | symbol;
declare var EBaseCalculationType = { PercentageBased:'PercentageBased',FixedNumber:'FixedNumber',EBaseCalculationType_MAX:'EBaseCalculationType_MAX', };
declare class AbcCompressionSettings { 
	/**
	 * Whether or not the individual meshes should be merged for compression purposes
	*/
	bMergeMeshes: boolean;
	/**
	 * Whether or not Matrix-only animation should be baked out as vertex animation (or skipped?)
	*/
	bBakeMatrixAnimation: boolean;
	/**
	 * Determines how the final number of bases that are stored as morph targets are calculated
	*/
	BaseCalculationType: EBaseCalculationType;
	/**
	 * Will generate given percentage of the given bases as morph targets
	*/
	PercentageOfTotalBases: number;
	/**
	 * Will generate given fixed number of bases as morph targets
	*/
	MaxNumberOfBases: number;
	/**
	 * Minimum percentage of influenced vertices required for a morph target to be valid
	*/
	MinimumNumberOfVertexInfluencePercentage: number;
	clone() : AbcCompressionSettings;
	static C(Other: UObject): AbcCompressionSettings;
}

declare class AbcMaterialSettings { 
	/**
	 * Whether or not to create materials according to found Face Set names (will not work without face sets)
	*/
	bCreateMaterials: boolean;
	clone() : AbcMaterialSettings;
	static C(Other: UObject): AbcMaterialSettings;
}

declare class AbcStaticMeshSettings { 
	/**
	 * Whether or not to merge the static meshes on import (remember this can cause problems with overlapping UV-sets)
	*/
	bMergeMeshes: boolean;
	/**
	 * This will, if applicable, apply matrix transformations to the meshes before merging
	*/
	bPropagateMatrixTransformations: boolean;
	clone() : AbcStaticMeshSettings;
	static C(Other: UObject): AbcStaticMeshSettings;
}

declare class AbcImportSettings extends UObject { 
	/**
	 * Type of asset to import from Alembic file
	*/
	ImportType: EAlembicImportType;
	/**
	 * Sampling Settings
	*/
	SamplingSettings: AbcSamplingSettings;
	/**
	 * Normal Generation Settings
	*/
	NormalGenerationSettings: AbcNormalGenerationSettings;
	/**
	 * Compression Settings
	*/
	CompressionSettings: AbcCompressionSettings;
	/**
	 * Material Settings
	*/
	MaterialSettings: AbcMaterialSettings;
	/**
	 * Static Mesh Settings
	*/
	StaticMeshSettings: AbcStaticMeshSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AbcImportSettings;
	static Find(Outer: UObject, ResourceName: string): AbcImportSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AbcImportSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AbcImportSettings;
	static C(Other: UObject): AbcImportSettings;
}

declare class AlembicTestCommandlet extends Commandlet { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AlembicTestCommandlet;
	static Find(Outer: UObject, ResourceName: string): AlembicTestCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AlembicTestCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AlembicTestCommandlet;
	static C(Other: UObject): AlembicTestCommandlet;
}

declare class AlembicImportFactory extends Factory { 
	/**
	 * Object used to show import options for Alembic
	*/
	ImportSettings: AbcImportSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AlembicImportFactory;
	static Find(Outer: UObject, ResourceName: string): AlembicImportFactory;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AlembicImportFactory;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AlembicImportFactory;
	static C(Other: UObject): AlembicImportFactory;
}

declare class ActorFactoryGeometryCache extends ActorFactory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorFactoryGeometryCache;
	static Find(Outer: UObject, ResourceName: string): ActorFactoryGeometryCache;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorFactoryGeometryCache;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorFactoryGeometryCache;
	static C(Other: UObject): ActorFactoryGeometryCache;
}

declare class GeometryCacheThumbnailRenderer extends DefaultSizedThumbnailRenderer { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GeometryCacheThumbnailRenderer;
	static Find(Outer: UObject, ResourceName: string): GeometryCacheThumbnailRenderer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GeometryCacheThumbnailRenderer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GeometryCacheThumbnailRenderer;
	static C(Other: UObject): GeometryCacheThumbnailRenderer;
}

declare class WebSocketConnection extends NetConnection { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WebSocketConnection;
	static Find(Outer: UObject, ResourceName: string): WebSocketConnection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WebSocketConnection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WebSocketConnection;
	static C(Other: UObject): WebSocketConnection;
}

declare class WebSocketNetDriver extends NetDriver { 
	/**
	 * Websocket server port
	*/
	WebSocketPort: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WebSocketNetDriver;
	static Find(Outer: UObject, ResourceName: string): WebSocketNetDriver;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WebSocketNetDriver;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WebSocketNetDriver;
	static C(Other: UObject): WebSocketNetDriver;
}

declare class JavascriptAssetData { 
	/**
	 * Object Path
	*/
	ObjectPath: string;
	/**
	 * Package Name
	*/
	PackageName: string;
	/**
	 * Package Path
	*/
	PackagePath: string;
	/**
	 * Group Names
	*/
	GroupNames: string;
	/**
	 * Asset Name
	*/
	AssetName: string;
	/**
	 * Asset Class
	*/
	AssetClass: string;
	/**
	 * Chunk IDs
	*/
	ChunkIDs: number[];
	/**
	 * Package Flags
	*/
	PackageFlags: number;
	clone() : JavascriptAssetData;
	static C(Other: UObject): JavascriptAssetData;
	/**
	 * Get All Tags
	*/
	GetAllTags(OutArray?: string[]): {OutArray: string[]};
	/**
	 * Get Asset
	*/
	GetAsset(): UObject;
	/**
	 * Get Class
	*/
	GetClass(): UnrealEngineClass;
	/**
	 * Get Package
	*/
	GetPackage(): Package;
	/**
	 * Get Tag Value
	*/
	GetTagValue(Name: string,OutValue?: string): {OutValue: string, $: boolean};
	/**
	 * Is Asset Loaded
	*/
	IsAssetLoaded(): boolean;
	/**
	 * Get All Tags
	*/
	static GetAllTags(AssetData: JavascriptAssetData,OutArray?: string[]): {OutArray: string[]};
	/**
	 * Get Asset
	*/
	static GetAsset(AssetData: JavascriptAssetData): UObject;
	/**
	 * Get Class
	*/
	static GetClass(AssetData: JavascriptAssetData): UnrealEngineClass;
	/**
	 * Get Package
	*/
	static GetPackage(AssetData: JavascriptAssetData): Package;
	/**
	 * Get Tag Value
	*/
	static GetTagValue(AssetData: JavascriptAssetData,Name: string,OutValue?: string): {OutValue: string, $: boolean};
	/**
	 * Is Asset Loaded
	*/
	static IsAssetLoaded(AssetData: JavascriptAssetData): boolean;
}

declare class JavascriptEditorGlobalDelegates extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorGlobalDelegates;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorGlobalDelegates;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorGlobalDelegates;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorGlobalDelegates;
	/**
	 * World Change
	*/
	WorldChange(): void;
	/**
	 * Unbind All
	*/
	UnbindAll(): void;
	/**
	 * Unbind
	*/
	Unbind(Key: string): void;
	/**
	 * Surf Props
	*/
	SurfProps(): void;
	/**
	 * Single Step PIE
	*/
	SingleStepPIE(bIsSimulating: boolean): void;
	/**
	 * Selected Props
	*/
	SelectedProps(): void;
	/**
	 * Resume PIE
	*/
	ResumePIE(bIsSimulating: boolean): void;
	/**
	 * Refresh Primitive Stats Browser
	*/
	RefreshPrimitiveStatsBrowser(): void;
	/**
	 * Refresh Layer Browser
	*/
	RefreshLayerBrowser(): void;
	/**
	 * Refresh Editor
	*/
	RefreshEditor(): void;
	/**
	 * Refresh All Browsers
	*/
	RefreshAllBrowsers(): void;
	/**
	 * FEditorSupportDelegates
	*/
	RedrawAllViewports(): void;
	/**
	 * FEditorDelegates::FOnEditorModeTransitioned                             FEditorDelegates::EditorModeEnter;
	 *        FEditorDelegates::FOnEditorModeTransitioned                             FEditorDelegates::EditorModeExit;// PIE
	*/
	PropertySelectionChange(): void;
	/**
	 * Pre Save World Friendly
	*/
	PreSaveWorld_Friendly(SaveFlags: number,World: World): void;
	/**
	 * Pre Begin PIE
	*/
	PreBeginPIE(bIsSimulating: boolean): void;
	/**
	 * Post Save World Friendly
	*/
	PostSaveWorld_Friendly(SaveFlags: number,World: World,bSuccess: boolean): void;
	/**
	 * Post Landscape Layer Updated
	*/
	PostLandscapeLayerUpdated(): void;
	/**
	 * On Shutdown Post Packages Saved
	*/
	OnShutdownPostPackagesSaved(): void;
	/**
	 * On Path Removed
	*/
	OnPathRemoved(Path: string): void;
	/**
	 * On Path Added
	*/
	OnPathAdded(Path: string): void;
	/**
	 * On Object Reimported
	*/
	OnObjectReimported(UObject: UObject): void;
	/**
	 * On New Asset Created
	*/
	OnNewAssetCreated(InFactory: Factory): void;
	/**
	 * On New Actors Dropped
	*/
	OnNewActorsDropped(DroppedObjects: UObject[],OutNewActors: Actor[]): void;
	/**
	 * On Map Opened
	*/
	OnMapOpened(Filename: string,bAsTemplate: boolean): void;
	/**
	 * On Lighting Build Started
	*/
	OnLightingBuildStarted(): void;
	/**
	 * On Lighting Build Kept
	*/
	OnLightingBuildKept(): void;
	/**
	 * On in Memory Asset Deleted
	*/
	OnInMemoryAssetDeleted(InObject: UObject): void;
	/**
	 * On in Memory Asset Created
	*/
	OnInMemoryAssetCreated(InObject: UObject): void;
	/**
	 * On Grid Snapping Changed
	*/
	OnGridSnappingChanged(bGridEnabled: boolean,GridSize: number): void;
	/**
	 * On Focus Viewport on Actors
	*/
	OnFocusViewportOnActors(Actors: Actor[]): void;
	/**
	 * On Finish Picking Blueprint Class
	*/
	OnFinishPickingBlueprintClass(InClass: UnrealEngineClass): void;
	/**
	 * On Files Loaded
	*/
	OnFilesLoaded(): void;
	/**
	 * On File Load Progress Updated Friendly
	*/
	OnFileLoadProgressUpdated_Friendly(NumTotalAssets: number,NumAssetsProcessedByAssetRegistry: number,NumAssetsPendingDataLoad: number,bIsDiscoveringAssetFiles: boolean): void;
	/**
	 * On Editor Camera Moved
	*/
	OnEditorCameraMoved(ViewLocation: Vector,ViewRotation: Rotator,ViewportType: ELevelViewportType,ViewIndex: number): void;
	/**
	 * On Dolly Perspective Camera
	*/
	OnDollyPerspectiveCamera(Drag: Vector,ViewIndex: number): void;
	/**
	 * On Configure New Asset Properties
	*/
	OnConfigureNewAssetProperties(InFactory: Factory): void;
	/**
	 * OnObjectsReplaced
	*/
	OnClassPackageLoadedOrUnloaded(): void;
	/**
	 * On Blueprint Reinstanced
	*/
	OnBlueprintReinstanced(): void;
	/**
	 * On Blueprint Pre Compile
	*/
	OnBlueprintPreCompile(Blueprint: Blueprint): void;
	/**
	 * On Blueprint Compiled
	*/
	OnBlueprintCompiled(): void;
	/**
	 * On Assets Pre Delete
	*/
	OnAssetsPreDelete(Assets: UObject[]): void;
	/**
	 * On Assets Deleted
	*/
	OnAssetsDeleted(Classes: UnrealEngineClass[]): void;
	/**
	 * On Asset Renamed Friendly
	*/
	OnAssetRenamed_Friendly(AssetData: JavascriptAssetData,Name: string): void;
	/**
	 * On Asset Removed Friendly
	*/
	OnAssetRemoved_Friendly(AssetData: JavascriptAssetData): void;
	/**
	 * On Asset Reimport
	*/
	OnAssetReimport(InCreatedObject: UObject): void;
	/**
	 * On Asset Pre Import Friendly
	*/
	OnAssetPreImport_Friendly(InFactory: Factory,InClass: UnrealEngineClass,InParent: UObject,Name: string,Type: string): void;
	/**
	 * On Asset Post Import
	*/
	OnAssetPostImport(InFactory: Factory,InCreatedObject: UObject): void;
	/**
	 * On Asset Added Friendly
	*/
	OnAssetAdded_Friendly(AssetData: JavascriptAssetData): void;
	/**
	 * On Apply Object to Actor
	*/
	OnApplyObjectToActor(ObjectToApply: UObject,Actor: Actor): void;
	/**
	 * On Add Level to World
	*/
	OnAddLevelToWorld(Level: Level): void;
	/**
	 * On Action Axis Mappings Changed
	*/
	OnActionAxisMappingsChanged(): void;
	/**
	 * New Current Level
	*/
	NewCurrentLevel(): void;
	/**
	 * Map Change Friendly
	*/
	MapChange_Friendly(MapChangeFlags: number): void;
	/**
	 * Load Selected Assets if Needed
	*/
	LoadSelectedAssetsIfNeeded(): void;
	/**
	 * Layer Change
	*/
	LayerChange(): void;
	/**
	 * Fit Texture to Surface
	*/
	FitTextureToSurface(World: World): void;
	/**
	 * End PIE
	*/
	EndPIE(bIsSimulating: boolean): void;
	/**
	 * Display Load Errors
	*/
	DisplayLoadErrors(): void;
	/**
	 * Cleanse Editor
	*/
	CleanseEditor(): void;
	/**
	 * Change Editor Mode
	*/
	ChangeEditorMode(NewMode: string): void;
	/**
	 * Bind
	*/
	Bind(Key: string): void;
	/**
	 * Begin PIE
	*/
	BeginPIE(bIsSimulating: boolean): void;
	/**
	 * Actor Properties Change
	*/
	ActorPropertiesChange(): void;
	static C(Other: UObject): JavascriptEditorGlobalDelegates;
}

declare class JavascriptInputEventState { 
	clone() : JavascriptInputEventState;
	static C(Other: UObject): JavascriptInputEventState;
	/**
	 * Get Input Event
	*/
	GetInputEvent(): EInputEvent;
	/**
	 * Get Key
	*/
	GetKey(): Key;
	/**
	 * Is Alt Button Event
	*/
	IsAltButtonEvent(): boolean;
	/**
	 * return true if alt is pressed right now.  This will be true even if the event was for a different key but an alt key is currently pressed
	*/
	IsAltButtonPressed(): boolean;
	/**
	 * Is Any Mouse Button Down
	*/
	IsAnyMouseButtonDown(): boolean;
	/**
	 * Is Button Pressed
	*/
	IsButtonPressed(InKey: Key): boolean;
	/**
	 * return true if the event causing button is a control key
	*/
	IsCtrlButtonEvent(): boolean;
	/**
	 * Is Ctrl Button Pressed
	*/
	IsCtrlButtonPressed(): boolean;
	/**
	 * Is Left Mouse Button Pressed
	*/
	IsLeftMouseButtonPressed(): boolean;
	/**
	 * Is Middle Mouse Button Pressed
	*/
	IsMiddleMouseButtonPressed(): boolean;
	/**
	 * Is Mouse Button Event
	*/
	IsMouseButtonEvent(): boolean;
	/**
	 * Is Right Mouse Button Pressed
	*/
	IsRightMouseButtonPressed(): boolean;
	/**
	 * Is Shift Button Event
	*/
	IsShiftButtonEvent(): boolean;
	/**
	 * Is Shift Button Pressed
	*/
	IsShiftButtonPressed(): boolean;
	/**
	 * Is Space Bar Pressed
	*/
	IsSpaceBarPressed(): boolean;
	/**
	 * Get Input Event
	*/
	static GetInputEvent(InputEvent: JavascriptInputEventState): EInputEvent;
	/**
	 * Get Key
	*/
	static GetKey(InputEvent: JavascriptInputEventState): Key;
	/**
	 * Is Alt Button Event
	*/
	static IsAltButtonEvent(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * return true if alt is pressed right now.  This will be true even if the event was for a different key but an alt key is currently pressed
	*/
	static IsAltButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Any Mouse Button Down
	*/
	static IsAnyMouseButtonDown(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Button Pressed
	*/
	static IsButtonPressed(InputEvent: JavascriptInputEventState,InKey: Key): boolean;
	/**
	 * return true if the event causing button is a control key
	*/
	static IsCtrlButtonEvent(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Ctrl Button Pressed
	*/
	static IsCtrlButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Left Mouse Button Pressed
	*/
	static IsLeftMouseButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Middle Mouse Button Pressed
	*/
	static IsMiddleMouseButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Mouse Button Event
	*/
	static IsMouseButtonEvent(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Right Mouse Button Pressed
	*/
	static IsRightMouseButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Shift Button Event
	*/
	static IsShiftButtonEvent(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Shift Button Pressed
	*/
	static IsShiftButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Space Bar Pressed
	*/
	static IsSpaceBarPressed(InputEvent: JavascriptInputEventState): boolean;
}

declare class JavascriptInputEventStateLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptInputEventStateLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptInputEventStateLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptInputEventStateLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptInputEventStateLibrary;
	/**
	 * Is Space Bar Pressed
	*/
	static IsSpaceBarPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Shift Button Pressed
	*/
	static IsShiftButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Shift Button Event
	*/
	static IsShiftButtonEvent(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Right Mouse Button Pressed
	*/
	static IsRightMouseButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Mouse Button Event
	*/
	static IsMouseButtonEvent(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Middle Mouse Button Pressed
	*/
	static IsMiddleMouseButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Left Mouse Button Pressed
	*/
	static IsLeftMouseButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Ctrl Button Pressed
	*/
	static IsCtrlButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * return true if the event causing button is a control key
	*/
	static IsCtrlButtonEvent(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Button Pressed
	*/
	static IsButtonPressed(InputEvent: JavascriptInputEventState,InKey: Key): boolean;
	/**
	 * Is Any Mouse Button Down
	*/
	static IsAnyMouseButtonDown(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * return true if alt is pressed right now.  This will be true even if the event was for a different key but an alt key is currently pressed
	*/
	static IsAltButtonPressed(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Is Alt Button Event
	*/
	static IsAltButtonEvent(InputEvent: JavascriptInputEventState): boolean;
	/**
	 * Get Key
	*/
	static GetKey(InputEvent: JavascriptInputEventState): Key;
	/**
	 * Get Input Event
	*/
	static GetInputEvent(InputEvent: JavascriptInputEventState): EInputEvent;
	static C(Other: UObject): JavascriptInputEventStateLibrary;
}

declare class JavascriptPDI { 
	clone() : JavascriptPDI;
	static C(Other: UObject): JavascriptPDI;
	/**
	 * Draw Arc
	*/
	DrawArc(Base: Vector,X: Vector,Y: Vector,MinAngle: number,MaxAngle: number,Radius: number,Sections: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Circle
	*/
	DrawCircle(Base: Vector,X: Vector,Y: Vector,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Connected Arrow
	*/
	DrawConnectedArrow(ArrowToWorld: Transform,Color: LinearColor,ArrowHeight: number,ArrowWidth: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,NumSpokes: number): void;
	/**
	 * Draw Dashed Line
	*/
	DrawDashedLine(Start: Vector,End: Vector,Color: LinearColor,DashSize: number,DepthPriority: ESceneDepthPriorityGroup,DepthBias: number): void;
	/**
	 * Draw Directional Arrow
	*/
	DrawDirectionalArrow(ArrowToWorld: Transform,InColor: LinearColor,Length: number,ArrowSize: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number): void;
	/**
	 * Draw Oriented Wire Box
	*/
	DrawOrientedWireBox(Base: Vector,X: Vector,Y: Vector,Z: Vector,Extent: Vector,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Polygon
	*/
	DrawPolygon(Verts: Vector[],InColor: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Box
	*/
	DrawWireBox(Box: Box,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Box 2
	*/
	DrawWireBox2(Matrix: Transform,Box: Box,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Capsule
	*/
	DrawWireCapsule(Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Chopped Cone
	*/
	DrawWireChoppedCone(Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,TopRadius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Cone
	*/
	DrawWireCone(Verts?: Vector[],Transform?: Transform,ConeRadius?: number,ConeAngle?: number,ConeSides?: number,Color?: LinearColor,DepthPriority?: ESceneDepthPriorityGroup,Thickness?: number,DepthBias?: number,bScreenSpace?: boolean): {Verts: Vector[]};
	/**
	 * Draw Wire Cylinder
	*/
	DrawWireCylinder(Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Diamond
	*/
	DrawWireDiamond(Transform: Transform,Size: number,InColor: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Sphere
	*/
	DrawWireSphere(Base: Vector,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere 2
	*/
	DrawWireSphere2(Transform: Transform,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere Auto Sides
	*/
	DrawWireSphereAutoSides(Base: Vector,Color: LinearColor,Radius: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere Auto Sides 2
	*/
	DrawWireSphereAutoSides2(Transform: Transform,Color: LinearColor,Radius: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere Capped Cone
	*/
	DrawWireSphereCappedCone(Transform: Transform,ConeRadius: number,ConeAngle: number,ConeSides: number,ArcFrequency: number,CapSegments: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Star
	*/
	DrawWireStar(Position: Vector,Size: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Set Hit Proxy
	*/
	SetHitProxy(Name: string): void;
	/**
	 * Draw Arc
	*/
	static DrawArc(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,MinAngle: number,MaxAngle: number,Radius: number,Sections: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Circle
	*/
	static DrawCircle(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Connected Arrow
	*/
	static DrawConnectedArrow(PDI: JavascriptPDI,ArrowToWorld: Transform,Color: LinearColor,ArrowHeight: number,ArrowWidth: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,NumSpokes: number): void;
	/**
	 * Draw Dashed Line
	*/
	static DrawDashedLine(PDI: JavascriptPDI,Start: Vector,End: Vector,Color: LinearColor,DashSize: number,DepthPriority: ESceneDepthPriorityGroup,DepthBias: number): void;
	/**
	 * Draw Directional Arrow
	*/
	static DrawDirectionalArrow(PDI: JavascriptPDI,ArrowToWorld: Transform,InColor: LinearColor,Length: number,ArrowSize: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number): void;
	/**
	 * Draw Oriented Wire Box
	*/
	static DrawOrientedWireBox(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Z: Vector,Extent: Vector,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Polygon
	*/
	static DrawPolygon(PDI: JavascriptPDI,Verts: Vector[],InColor: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Box
	*/
	static DrawWireBox(PDI: JavascriptPDI,Box: Box,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Box 2
	*/
	static DrawWireBox2(PDI: JavascriptPDI,Matrix: Transform,Box: Box,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Capsule
	*/
	static DrawWireCapsule(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Chopped Cone
	*/
	static DrawWireChoppedCone(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,TopRadius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Cone
	*/
	static DrawWireCone(PDI: JavascriptPDI,Verts?: Vector[],Transform?: Transform,ConeRadius?: number,ConeAngle?: number,ConeSides?: number,Color?: LinearColor,DepthPriority?: ESceneDepthPriorityGroup,Thickness?: number,DepthBias?: number,bScreenSpace?: boolean): {Verts: Vector[]};
	/**
	 * Draw Wire Cylinder
	*/
	static DrawWireCylinder(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Diamond
	*/
	static DrawWireDiamond(PDI: JavascriptPDI,Transform: Transform,Size: number,InColor: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Sphere
	*/
	static DrawWireSphere(PDI: JavascriptPDI,Base: Vector,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere 2
	*/
	static DrawWireSphere2(PDI: JavascriptPDI,Transform: Transform,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere Auto Sides
	*/
	static DrawWireSphereAutoSides(PDI: JavascriptPDI,Base: Vector,Color: LinearColor,Radius: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere Auto Sides 2
	*/
	static DrawWireSphereAutoSides2(PDI: JavascriptPDI,Transform: Transform,Color: LinearColor,Radius: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere Capped Cone
	*/
	static DrawWireSphereCappedCone(PDI: JavascriptPDI,Transform: Transform,ConeRadius: number,ConeAngle: number,ConeSides: number,ArcFrequency: number,CapSegments: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Star
	*/
	static DrawWireStar(PDI: JavascriptPDI,Position: Vector,Size: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Set Hit Proxy
	*/
	static SetHitProxy(PDI: JavascriptPDI,Name: string): void;
}

declare class JavascriptExtensibilityManager { 
	clone() : JavascriptExtensibilityManager;
	static C(Other: UObject): JavascriptExtensibilityManager;
	/**
	 * Add Extender
	*/
	AddExtender(Extender: JavascriptExtender): void;
	/**
	 * Remove Extender
	*/
	RemoveExtender(Extender: JavascriptExtender): void;
	/**
	 * Add Extender
	*/
	static AddExtender(Manager: JavascriptExtensibilityManager,Extender: JavascriptExtender): void;
	/**
	 * Remove Extender
	*/
	static RemoveExtender(Manager: JavascriptExtensibilityManager,Extender: JavascriptExtender): void;
	/**
	 * Get Menu Extensibility Manager
	*/
	static GetMenuExtensibilityManager(What: string): JavascriptExtensibilityManager;
	/**
	 * Get Tool Bar Extensibility Manager
	*/
	static GetToolBarExtensibilityManager(What: string): JavascriptExtensibilityManager;
}

declare class JavascriptViewportClick { 
	clone() : JavascriptViewportClick;
	static C(Other: UObject): JavascriptViewportClick;
	/**
	 * Get Click Pos
	*/
	GetClickPos(): IntPoint;
	/**
	 * Get Direction
	*/
	GetDirection(): Vector;
	/**
	 * Get Event
	*/
	GetEvent(): EInputEvent;
	/**
	 * Get Key
	*/
	GetKey(): Key;
	/**
	 * Get Origin
	*/
	GetOrigin(): Vector;
	/**
	 * Is Alt Down
	*/
	IsAltDown(): boolean;
	/**
	 * Is Control Down
	*/
	IsControlDown(): boolean;
	/**
	 * Is Shift Down
	*/
	IsShiftDown(): boolean;
	/**
	 * Get Click Pos
	*/
	static GetClickPos(Click: JavascriptViewportClick): IntPoint;
	/**
	 * Get Direction
	*/
	static GetDirection(Click: JavascriptViewportClick): Vector;
	/**
	 * Get Event
	*/
	static GetEvent(Click: JavascriptViewportClick): EInputEvent;
	/**
	 * Get Key
	*/
	static GetKey(Click: JavascriptViewportClick): Key;
	/**
	 * Get Origin
	*/
	static GetOrigin(Click: JavascriptViewportClick): Vector;
	/**
	 * Is Alt Down
	*/
	static IsAltDown(Click: JavascriptViewportClick): boolean;
	/**
	 * Is Control Down
	*/
	static IsControlDown(Click: JavascriptViewportClick): boolean;
	/**
	 * Is Shift Down
	*/
	static IsShiftDown(Click: JavascriptViewportClick): boolean;
}

declare class JavascriptHitProxy { 
	clone() : JavascriptHitProxy;
	static C(Other: UObject): JavascriptHitProxy;
	/**
	 * Get Actor
	*/
	GetActor(): Actor;
	/**
	 * Get Name
	*/
	GetName(): string;
	/**
	 * Get Actor
	*/
	static GetActor(Proxy: JavascriptHitProxy): Actor;
	/**
	 * Get Name
	*/
	static GetName(Proxy: JavascriptHitProxy): string;
}

declare class JavascriptWorkspaceItem { 
	clone() : JavascriptWorkspaceItem;
	static C(Other: UObject): JavascriptWorkspaceItem;
	/**
	 * Add Group
	*/
	AddGroup(DisplayName: string): JavascriptWorkspaceItem;
	/**
	 * Add Group
	*/
	static AddGroup(Parent: JavascriptWorkspaceItem,DisplayName: string): JavascriptWorkspaceItem;
	/**
	 * Get Group
	*/
	static GetGroup(Name: string): JavascriptWorkspaceItem;
}

declare class JavascriptEditorLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorLibrary;
	/**
	 * Update Model Components
	*/
	static UpdateModelComponents(Level: Level): void;
	/**
	 * Toggle Select
	*/
	static ToggleSelect(USelection: USelection,InObject: UObject): void;
	/**
	 * Set Is Temporarily Hidden in Editor
	*/
	static SetIsTemporarilyHiddenInEditor(Actor: Actor,bIsHidden: boolean): void;
	/**
	 * Set Hit Proxy
	*/
	static SetHitProxy(PDI: JavascriptPDI,Name: string): void;
	/**
	 * Set Heightmap Data from Memory
	*/
	static SetHeightmapDataFromMemory(LandscapeInfo: LandscapeInfo,MinX: number,MinY: number,MaxX: number,MaxY: number): void;
	/**
	 * Set Folder Path Recursively
	*/
	static SetFolderPath_Recursively(Actor: Actor,NewFolderPath: string): void;
	/**
	 * Set Folder Path
	*/
	static SetFolderPath(Actor: Actor,NewFolderPath: string): void;
	/**
	 * Set Alphamap Data from Memory
	*/
	static SetAlphamapDataFromMemory(LandscapeInfo: LandscapeInfo,LayerInfo: LandscapeLayerInfoObject,MinX: number,MinY: number,MaxX: number,MaxY: number,PaintingRestriction: ELandscapeLayerPaintingRestriction): void;
	/**
	 * Set Actor Label
	*/
	static SetActorLabel(Actor: Actor,NewActorLabel: string,bMarkDirty: boolean): void;
	/**
	 * Select
	*/
	static Select(USelection: USelection,InObject: UObject): void;
	/**
	 * Save Package
	*/
	static SavePackage(Package: Package,FileName: string): boolean;
	/**
	 * Request End Play Map in PIE
	*/
	static RequestEndPlayMapInPIE(): void;
	/**
	 * Remove Level Instance
	*/
	static RemoveLevelInstance(World: World): void;
	/**
	 * Remove Extender
	*/
	static RemoveExtender(Manager: JavascriptExtensibilityManager,Extender: JavascriptExtender): void;
	/**
	 * Open Popup Window
	*/
	static OpenPopupWindow(Widget: Widget,PopupDesiredSize: Vector2D,HeadingText: string): void;
	/**
	 * Modify Object
	*/
	static ModifyObject(UObject: UObject,bAlwaysMarkDirty: boolean): void;
	/**
	 * Is Shift Down
	*/
	static IsShiftDown(Click: JavascriptViewportClick): boolean;
	/**
	 * Is Control Down
	*/
	static IsControlDown(Click: JavascriptViewportClick): boolean;
	/**
	 * Is Asset Loaded
	*/
	static IsAssetLoaded(AssetData: JavascriptAssetData): boolean;
	/**
	 * Is Alt Down
	*/
	static IsAltDown(Click: JavascriptViewportClick): boolean;
	/**
	 * Is Actor Label Editable
	*/
	static IsActorLabelEditable(Actor: Actor): boolean;
	/**
	 * Is Active
	*/
	static IsActive(Transactor: Transactor): boolean;
	/**
	 * Invalidate Model Geometry
	*/
	static InvalidateModelGeometry(World: World,InLevel: Level): void;
	/**
	 * Get Transaction
	*/
	static GetTransaction(Transactor: Transactor,QueueIndex: number): JavascriptTransaction;
	/**
	 * Get Tool Bar Extensibility Manager
	*/
	static GetToolBarExtensibilityManager(What: string): JavascriptExtensibilityManager;
	/**
	 * Get Title
	*/
	static GetTitle(Transaction: JavascriptTransaction): string;
	/**
	 * Get Tag Value
	*/
	static GetTagValue(AssetData: JavascriptAssetData,Name: string,OutValue?: string): {OutValue: string, $: boolean};
	/**
	 * Get Selected Objects
	*/
	static GetSelectedObjects(USelection: USelection,Out?: UObject[]): {Out: UObject[], $: number};
	/**
	 * Get Root Window
	*/
	static GetRootWindow(): JavascriptSlateWidget;
	/**
	 * Get Queue Length
	*/
	static GetQueueLength(Transactor: Transactor): number;
	/**
	 * Get Primary Object
	*/
	static GetPrimaryObject(Transaction: JavascriptTransaction): UObject;
	/**
	 * Get Package
	*/
	static GetPackage(AssetData: JavascriptAssetData): Package;
	/**
	 * Get Origin
	*/
	static GetOrigin(Click: JavascriptViewportClick): Vector;
	/**
	 * Get Name
	*/
	static GetName(Proxy: JavascriptHitProxy): string;
	/**
	 * Get Menu Extensibility Manager
	*/
	static GetMenuExtensibilityManager(What: string): JavascriptExtensibilityManager;
	/**
	 * Get Layer Info by Name
	*/
	static GetLayerInfoByName(LandscapeInfo: LandscapeInfo,LayerName: string,Owner: LandscapeProxy): LandscapeLayerInfoObject;
	/**
	 * Get Landscape Info
	*/
	static GetLandscapeInfo(Landscape: Landscape,bSpawnNewActor: boolean): LandscapeInfo;
	/**
	 * Get Landscape Extent
	*/
	static GetLandscapeExtent(LandscapeInfo: LandscapeInfo,MinX?: number,MinY?: number,MaxX?: number,MaxY?: number): {MinX: number, MinY: number, MaxX: number, MaxY: number, $: boolean};
	/**
	 * Get Key
	*/
	static GetKey(Click: JavascriptViewportClick): Key;
	/**
	 * Get Heightmap Data to Memory
	*/
	static GetHeightmapDataToMemory(LandscapeInfo: LandscapeInfo,MinX: number,MinY: number,MaxX: number,MaxY: number): void;
	/**
	 * Get Group
	*/
	static GetGroup(Name: string): JavascriptWorkspaceItem;
	/**
	 * Get Folder Path
	*/
	static GetFolderPath(Actor: Actor): string;
	/**
	 * Get Event
	*/
	static GetEvent(Click: JavascriptViewportClick): EInputEvent;
	/**
	 * Get Direction
	*/
	static GetDirection(Click: JavascriptViewportClick): Vector;
	/**
	 * Get Default Brush
	*/
	static GetDefaultBrush(World: World): Brush;
	/**
	 * Get Context
	*/
	static GetContext(Transaction: JavascriptTransaction): string;
	/**
	 * Get Click Pos
	*/
	static GetClickPos(Click: JavascriptViewportClick): IntPoint;
	/**
	 * Get Class
	*/
	static GetClass(AssetData: JavascriptAssetData): UnrealEngineClass;
	/**
	 * Get Asset
	*/
	static GetAsset(AssetData: JavascriptAssetData): UObject;
	/**
	 * Get Alphamap Data to Memory
	*/
	static GetAlphamapDataToMemory(LandscapeInfo: LandscapeInfo,LayerInfo: LandscapeLayerInfoObject,MinX: number,MinY: number,MaxX: number,MaxY: number): void;
	/**
	 * Get All Tags
	*/
	static GetAllTags(AssetData: JavascriptAssetData,OutArray?: string[]): {OutArray: string[]};
	/**
	 * Returns this actor's current label.  Actor labels are only available in development builds.
	 * @return       The label text
	*/
	static GetActorLabel(Actor: Actor): string;
	/**
	 * Get Actor
	*/
	static GetActor(Proxy: JavascriptHitProxy): Actor;
	/**
	 * Find World in Package
	*/
	static FindWorldInPackage(Package: Package): World;
	/**
	 * Export Navigation
	*/
	static ExportNavigation(InWorld: World,Path: string): string;
	/**
	 * Editor Destroy Actor
	*/
	static EditorDestroyActor(World: World,Actor: Actor,bShouldModifyLevel: boolean): boolean;
	/**
	 * Editor Add Modal Window
	*/
	static EditorAddModalWindow(Widget: JavascriptSlateWidget): void;
	/**
	 * Draw Wire Star
	*/
	static DrawWireStar(PDI: JavascriptPDI,Position: Vector,Size: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Sphere Capped Cone
	*/
	static DrawWireSphereCappedCone(PDI: JavascriptPDI,Transform: Transform,ConeRadius: number,ConeAngle: number,ConeSides: number,ArcFrequency: number,CapSegments: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Sphere Auto Sides 2
	*/
	static DrawWireSphereAutoSides2(PDI: JavascriptPDI,Transform: Transform,Color: LinearColor,Radius: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere Auto Sides
	*/
	static DrawWireSphereAutoSides(PDI: JavascriptPDI,Base: Vector,Color: LinearColor,Radius: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere 2
	*/
	static DrawWireSphere2(PDI: JavascriptPDI,Transform: Transform,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Sphere
	*/
	static DrawWireSphere(PDI: JavascriptPDI,Base: Vector,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Diamond
	*/
	static DrawWireDiamond(PDI: JavascriptPDI,Transform: Transform,Size: number,InColor: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Cylinder
	*/
	static DrawWireCylinder(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Cone
	*/
	static DrawWireCone(PDI: JavascriptPDI,Verts?: Vector[],Transform?: Transform,ConeRadius?: number,ConeAngle?: number,ConeSides?: number,Color?: LinearColor,DepthPriority?: ESceneDepthPriorityGroup,Thickness?: number,DepthBias?: number,bScreenSpace?: boolean): {Verts: Vector[]};
	/**
	 * Draw Wire Chopped Cone
	*/
	static DrawWireChoppedCone(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,TopRadius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Wire Capsule
	*/
	static DrawWireCapsule(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Z: Vector,Color: LinearColor,Radius: number,HalfHeight: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Box 2
	*/
	static DrawWireBox2(PDI: JavascriptPDI,Matrix: Transform,Box: Box,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Wire Box
	*/
	static DrawWireBox(PDI: JavascriptPDI,Box: Box,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Polygon
	*/
	static DrawPolygon(PDI: JavascriptPDI,Verts: Vector[],InColor: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Draw Oriented Wire Box
	*/
	static DrawOrientedWireBox(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Z: Vector,Extent: Vector,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Directional Arrow
	*/
	static DrawDirectionalArrow(PDI: JavascriptPDI,ArrowToWorld: Transform,InColor: LinearColor,Length: number,ArrowSize: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number): void;
	/**
	 * Draw Dashed Line
	*/
	static DrawDashedLine(PDI: JavascriptPDI,Start: Vector,End: Vector,Color: LinearColor,DashSize: number,DepthPriority: ESceneDepthPriorityGroup,DepthBias: number): void;
	/**
	 * Draw Connected Arrow
	*/
	static DrawConnectedArrow(PDI: JavascriptPDI,ArrowToWorld: Transform,Color: LinearColor,ArrowHeight: number,ArrowWidth: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,NumSpokes: number): void;
	/**
	 * Draw Circle
	*/
	static DrawCircle(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,Color: LinearColor,Radius: number,NumSides: number,DepthPriority: ESceneDepthPriorityGroup,Thickness: number,DepthBias: number,bScreenSpace: boolean): void;
	/**
	 * Draw Arc
	*/
	static DrawArc(PDI: JavascriptPDI,Base: Vector,X: Vector,Y: Vector,MinAngle: number,MaxAngle: number,Radius: number,Sections: number,Color: LinearColor,DepthPriority: ESceneDepthPriorityGroup): void;
	/**
	 * Deselect All
	*/
	static DeselectAll(USelection: USelection,InClass: UnrealEngineClass): void;
	/**
	 * Deselect
	*/
	static Deselect(USelection: USelection,InObject: UObject): void;
	/**
	 * Delete Package
	*/
	static DeletePackage(Package: Package): boolean;
	/**
	 * Csg Add
	*/
	static csgAdd(DefaultBrush: Brush,PolyFlags: number,BrushType: EBrushType): Brush;
	/**
	 * Create Property Editor Toolkit
	*/
	static CreatePropertyEditorToolkit(ObjectsForPropertiesMenu: UObject[]): void;
	/**
	 * Create Brush for Volume Actor
	*/
	static CreateBrushForVolumeActor(NewActor: Volume,BrushBuilder: BrushBuilder): void;
	/**
	 * Clear Actor Label
	*/
	static ClearActorLabel(Actor: Actor): void;
	/**
	 * Build
	*/
	static Build(Builder: BrushBuilder,InWorld: World,InBrush: Brush): boolean;
	/**
	 * Broadcast Hot Reload
	*/
	static BroadcastHotReload(): void;
	/**
	 * Broadcast Asset Created
	*/
	static BroadcastAssetCreated(NewAsset: UObject): void;
	/**
	 * Add Group
	*/
	static AddGroup(Parent: JavascriptWorkspaceItem,DisplayName: string): JavascriptWorkspaceItem;
	/**
	 * Add Extender
	*/
	static AddExtender(Manager: JavascriptExtensibilityManager,Extender: JavascriptExtender): void;
	static C(Other: UObject): JavascriptEditorLibrary;
}

declare type EJavascriptTabRole = string | symbol;
declare var EJavascriptTabRole = { MajorTab:'MajorTab',PanelTab:'PanelTab',NomadTab:'NomadTab',DocumentTab:'DocumentTab', };
declare class JavascriptEditorTab extends UObject { 
	/**
	 * On Spawn Tab
	*/
	OnSpawnTab: UnrealEngineDelegate<(Context: UObject) => Widget>;
	/**
	 * On Close Tab
	*/
	OnCloseTab: UnrealEngineDelegate<(Widget: Widget) => void>;
	/**
	 * Group
	*/
	Group: JavascriptWorkspaceItem;
	/**
	 * Tab Id
	*/
	TabId: string;
	/**
	 * Display Name
	*/
	DisplayName: string;
	/**
	 * Is Nomad
	*/
	bIsNomad: boolean;
	/**
	 * Role
	*/
	Role: EJavascriptTabRole;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorTab;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorTab;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorTab;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorTab;
	/**
	 * Discard
	*/
	Discard(): void;
	/**
	 * Commit
	*/
	Commit(): void;
	/**
	 * Close Tab
	*/
	CloseTab(Widget: Widget): void;
	static C(Other: UObject): JavascriptEditorTab;
}

declare class JavascriptMenuExtension { 
	/**
	 * Extension Hook
	*/
	ExtensionHook: string;
	/**
	 * Hook Position
	*/
	HookPosition: EJavascriptExtensionHook;
	clone() : JavascriptMenuExtension;
	static C(Other: UObject): JavascriptMenuExtension;
}

declare class JavascriptUIExtender extends UObject { 
	/**
	 * Menu Extensions
	*/
	MenuExtensions: JavascriptMenuExtension[];
	/**
	 * Toolbar Extensions
	*/
	ToolbarExtensions: JavascriptMenuExtension[];
	/**
	 * On Hook
	*/
	OnHook: UnrealEngineDelegate<(Hook: string) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptUIExtender;
	static Find(Outer: UObject, ResourceName: string): JavascriptUIExtender;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptUIExtender;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptUIExtender;
	/**
	 * Get Top Command List
	*/
	static GetTopCommandList(): JavascriptUICommandList;
	/**
	 * End Section
	*/
	static EndSection(): void;
	/**
	 * Bind
	*/
	static Bind(Commands: JavascriptUICommands): void;
	/**
	 * Begin Section
	*/
	static BeginSection(Name: string,Text: string): void;
	/**
	 * Toolbar
	*/
	static AddToolBarButton(Commands: JavascriptUICommands,Id: string): void;
	/**
	 * Add Menu Separator
	*/
	static AddMenuSeparator(): void;
	/**
	 * Menu
	*/
	static AddMenuEntry(Commands: JavascriptUICommands,Id: string): void;
	static C(Other: UObject): JavascriptUIExtender;
}

declare class JavascriptAssetEditorToolkit extends UObject { 
	/**
	 * Toolkit FName
	*/
	ToolkitFName: string;
	/**
	 * Layout
	*/
	Layout: string;
	/**
	 * Base Toolkit Name
	*/
	BaseToolkitName: string;
	/**
	 * Toolkit Name
	*/
	ToolkitName: string;
	/**
	 * World Centric Tab Color Scale
	*/
	WorldCentricTabColorScale: LinearColor;
	/**
	 * World Centric Tab Prefix
	*/
	WorldCentricTabPrefix: string;
	/**
	 * Tabs
	*/
	Tabs: JavascriptEditorTab[];
	/**
	 * Commands
	*/
	Commands: JavascriptUICommands;
	/**
	 * Menu Extender
	*/
	MenuExtender: JavascriptUIExtender;
	/**
	 * Toolbar Extender
	*/
	ToolbarExtender: JavascriptUIExtender;
	/**
	 * Test Array
	*/
	TestArray: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptAssetEditorToolkit;
	static Find(Outer: UObject, ResourceName: string): JavascriptAssetEditorToolkit;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptAssetEditorToolkit;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptAssetEditorToolkit;
	/**
	 * Refresh
	*/
	Refresh(): void;
	/**
	 * Discard
	*/
	Discard(): void;
	/**
	 * Commit
	*/
	Commit(): void;
	static C(Other: UObject): JavascriptAssetEditorToolkit;
}

declare class JavascriptAssetTypeActions extends UObject { 
	/**
	 * Actions Name
	*/
	ActionsName: string;
	/**
	 * Color
	*/
	Color: Color;
	/**
	 * Supported Class
	*/
	SupportedClass: UnrealEngineClass;
	/**
	 * Editor
	*/
	Editor: JavascriptAssetEditorToolkit;
	/**
	 * Actions
	*/
	Actions: JavascriptUIExtender;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptAssetTypeActions;
	static Find(Outer: UObject, ResourceName: string): JavascriptAssetTypeActions;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptAssetTypeActions;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptAssetTypeActions;
	/**
	 * Refresh
	*/
	Refresh(): void;
	/**
	 * Discard
	*/
	Discard(): void;
	/**
	 * Commit
	*/
	Commit(): void;
	static C(Other: UObject): JavascriptAssetTypeActions;
}

declare class JavascriptCommandlet extends Commandlet { 
	/**
	 * Parsed commandline tokens
	*/
	CmdLineTokens: string[];
	/**
	 * Parsed commandline switches
	*/
	CmdLineSwitches: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptCommandlet;
	static Find(Outer: UObject, ResourceName: string): JavascriptCommandlet;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptCommandlet;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptCommandlet;
	static C(Other: UObject): JavascriptCommandlet;
}

declare class JavascriptEdGraphNode extends EdGraphNode { 
	/**
	 * instance class
	*/
	ClassData: GraphNodeClassData;
	/**
	 * Node Instance
	*/
	NodeInstance: UObject;
	/**
	 * Sub Nodes
	*/
	SubNodes: JavascriptEdGraphNode[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEdGraphNode;
	static Find(Outer: UObject, ResourceName: string): JavascriptEdGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEdGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEdGraphNode;
	static C(Other: UObject): JavascriptEdGraphNode;
}

declare class JavascriptEditorEngineLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorEngineLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorEngineLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorEngineLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorEngineLibrary;
	/**
	 * Set Material
	*/
	static SetMaterial(Engine: EditorEngine,InModel: Model,Material: MaterialInterface,Surfaces: number[]): void;
	/**
	 * Select None
	*/
	static SelectNone(Engine: EditorEngine,bNoteSelectionChange: boolean,bDeselectBSPSurfs: boolean,WarnAboutManyActors: boolean): void;
	/**
	 * Select Group
	*/
	static SelectGroup(Engine: EditorEngine,InGroupActor: GroupActor,bForceSelection: boolean,bInSelected: boolean,bNotify: boolean): void;
	/**
	 * Select Component
	*/
	static SelectComponent(Engine: EditorEngine,Component: ActorComponent,bInSelected: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean): void;
	/**
	 * Selection.
	*/
	static SelectActor(Engine: EditorEngine,Actor: Actor,bInSelected: boolean,bNotify: boolean,bSelectEvenIfHidden: boolean,bForceRefresh: boolean): void;
	/**
	 * Redraw All Viewports
	*/
	static RedrawAllViewports(Engine: EditorEngine,bInvalidateHitProxies: boolean): void;
	/**
	 * Rebuild Static Navigable Geometry
	*/
	static RebuildStaticNavigableGeometry(Engine: EditorEngine,Level: Level): void;
	/**
	 * Rebuild Level
	*/
	static RebuildLevel(Engine: EditorEngine,Level: Level): void;
	/**
	 * Get Surfaces
	*/
	static GetSurfaces(Brush: Brush,Surfaces?: number[]): {Surfaces: number[]};
	/**
	 * Get Selected Set
	*/
	static GetSelectedSet(Engine: EditorEngine,Class: UnrealEngineClass): USelection;
	/**
	 * Get Selected Objects
	*/
	static GetSelectedObjects(Engine: EditorEngine): USelection;
	/**
	 * Get Selected Components
	*/
	static GetSelectedComponents(Engine: EditorEngine): USelection;
	/**
	 * Get PIEWorld
	*/
	static GetPIEWorld(Engine: Engine): World;
	/**
	 * Get Editor World
	*/
	static GetEditorWorld(Engine: Engine): World;
	/**
	 * Find Brush Builder
	*/
	static FindBrushBuilder(Engine: EditorEngine,BrushBuilderClass: UnrealEngineClass): BrushBuilder;
	/**
	 * Exec
	*/
	static Exec(Engine: EditorEngine,InWorld: World,Command: string,Out?: string): {Out: string, $: boolean};
	/**
	 * Delete Objects Unchecked
	*/
	static DeleteObjectsUnchecked(ObjectsToDelete: UObject[]): number;
	/**
	 * Can Select Actor
	*/
	static CanSelectActor(Engine: EditorEngine,Actor: Actor,bInSelected: boolean,bSelectEvenIfHidden: boolean,bWarnIfLevelLocked: boolean): boolean;
	/**
	 * Bsp Brush CSG
	*/
	static bspBrushCSG(Engine: EditorEngine,Actor: Brush,Model: Model,PolyFlags: number,BrushType: EBrushType,CSGOper: ECsgOper,bBuildBounds: boolean,bMergePolys: boolean,bReplaceNULLMaterialRefs: boolean,bShowProgressBar: boolean): number;
	static C(Other: UObject): JavascriptEditorEngineLibrary;
}

declare class JavascriptEditorInputProcessor extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorInputProcessor;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorInputProcessor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorInputProcessor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorInputProcessor;
	/**
	 * Handle Mouse Move Event
	*/
	HandleMouseMoveEvent(InPointerEvent: UPointerEvent): boolean;
	/**
	 * Handle Key Up Event
	*/
	HandleKeyUpEvent(InKeyEvent: KeyEvent): boolean;
	/**
	 * Handle Key Down Event
	*/
	HandleKeyDownEvent(InKeyEvent: KeyEvent): boolean;
	/**
	 * Handle Analog Input Event
	*/
	HandleAnalogInputEvent(InKeyEvent: AnalogInputEvent): boolean;
	/**
	 * Activate
	*/
	Activate(bEnable: boolean): void;
	static C(Other: UObject): JavascriptEditorInputProcessor;
}

declare class JavascriptEditorPopupWindow extends UObject { 
	/**
	 * Widget
	*/
	Widget: Widget;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorPopupWindow;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorPopupWindow;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorPopupWindow;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorPopupWindow;
	/**
	 * Open
	*/
	Open(Heading: string,DesiredSize: Vector2D): boolean;
	/**
	 * On Dismissed
	*/
	OnDismissed(): void;
	static C(Other: UObject): JavascriptEditorPopupWindow;
}

declare class JavascriptEditorTabManager extends Widget { 
	/**
	 * Layout
	*/
	Layout: string;
	/**
	 * Tabs
	*/
	Tabs: JavascriptEditorTab[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorTabManager;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorTabManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorTabManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorTabManager;
	static C(Other: UObject): JavascriptEditorTabManager;
}

declare class JavascriptEditorTick extends UObject { 
	/**
	 * On Tick
	*/
	OnTick: UnrealEngineDelegate<(DeltaSeconds: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorTick;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorTick;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorTick;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorTick;
	/**
	 * Get Engine
	*/
	GetEngine(): EditorEngine;
	static C(Other: UObject): JavascriptEditorTick;
}

declare class JavascriptEditorToolbar extends Widget { 
	/**
	 * On Hook
	*/
	OnHook: UnrealEngineDelegate<() => JavascriptMenuBuilder>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorToolbar;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorToolbar;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorToolbar;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorToolbar;
	static C(Other: UObject): JavascriptEditorToolbar;
}

declare type EJavascriptWidgetMode = string | symbol;
declare var EJavascriptWidgetMode = { WM_Translate:'WM_Translate',WM_TranslateRotateZ:'WM_TranslateRotateZ',WM_2D:'WM_2D',WM_Rotate:'WM_Rotate',WM_Scale:'WM_Scale',WM_Max:'WM_Max',WM_None:'WM_None',None:'None', };
declare class JavascriptEditorViewport extends PanelWidget { 
	/**
	 * On Click
	*/
	OnClick: UnrealEngineDelegate<(ViewportClick: JavascriptViewportClick, HitProxy: JavascriptHitProxy, Instance: JavascriptEditorViewport) => void>;
	/**
	 * On Tracking Started
	*/
	OnTrackingStarted: UnrealEngineDelegate<(InputState: JavascriptInputEventState, bIsDraggingWidget: boolean, bNudge: boolean, Instance: JavascriptEditorViewport) => void>;
	/**
	 * On Tracking Stopped
	*/
	OnTrackingStopped: UnrealEngineDelegate<(Instance: JavascriptEditorViewport) => void>;
	/**
	 * On Input Widget Delta
	*/
	OnInputWidgetDelta: UnrealEngineDelegate<(Drag: Vector, Rot: Rotator, Scale: Vector, Instance: JavascriptEditorViewport) => boolean>;
	/**
	 * On Input Key
	*/
	OnInputKey: UnrealEngineDelegate<(ControllerId: number, Key: Key, Event: EInputEvent, Instance: JavascriptEditorViewport) => boolean>;
	/**
	 * On Input Axis
	*/
	OnInputAxis: UnrealEngineDelegate<(ControllerId: number, Key: Key, Delta: number, DeltaTime: number, Instance: JavascriptEditorViewport) => boolean>;
	/**
	 * On Mouse Enter
	*/
	OnMouseEnter: UnrealEngineDelegate<(x: number, y: number, Instance: JavascriptEditorViewport) => boolean>;
	/**
	 * On Mouse Move
	*/
	OnMouseMove: UnrealEngineDelegate<(x: number, y: number, Instance: JavascriptEditorViewport) => boolean>;
	/**
	 * On Mouse Leave
	*/
	OnMouseLeave: UnrealEngineDelegate<(Instance: JavascriptEditorViewport) => boolean>;
	/**
	 * On Draw
	*/
	OnDraw: UnrealEngineDelegate<(PDI: JavascriptPDI, Instance: JavascriptEditorViewport) => void>;
	/**
	 * On Draw Canvas
	*/
	OnDrawCanvas: UnrealEngineDelegate<(Canvas: Canvas, Instance: JavascriptEditorViewport) => void>;
	/**
	 * On Get Widget Location
	*/
	OnGetWidgetLocation: UnrealEngineDelegate<(Instance: JavascriptEditorViewport) => Vector>;
	/**
	 * On Get Widget Rotation
	*/
	OnGetWidgetRotation: UnrealEngineDelegate<(Instance: JavascriptEditorViewport) => Rotator>;
	/**
	 * On Get Widget Mode
	*/
	OnGetWidgetMode: UnrealEngineDelegate<(Instance: JavascriptEditorViewport) => EJavascriptWidgetMode>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEditorViewport;
	static Find(Outer: UObject, ResourceName: string): JavascriptEditorViewport;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEditorViewport;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEditorViewport;
	/**
	 * Set Widget Mode
	*/
	SetWidgetMode(WidgetMode: EJavascriptWidgetMode): void;
	/**
	 * Set View Rotation
	*/
	SetViewRotation(ViewRotation: Rotator): void;
	/**
	 * Set Viewport Type
	*/
	SetViewportType(InViewportType: ELevelViewportType): void;
	/**
	 * Set View Mode
	*/
	SetViewMode(InViewModeIndex: EViewModeIndex): void;
	/**
	 * Set View Location
	*/
	SetViewLocation(ViewLocation: Vector): void;
	/**
	 * Set View FOV
	*/
	SetViewFOV(InViewFOV: number): void;
	/**
	 * Set Sky Brightness
	*/
	SetSkyBrightness(SkyBrightness: number): void;
	/**
	 * Set Simulate Physics
	*/
	SetSimulatePhysics(bShouldSimulatePhysics: boolean): void;
	/**
	 * Set Realtime
	*/
	SetRealtime(bInRealtime: boolean,bStoreCurrentValue: boolean): void;
	/**
	 * Set Profile Index
	*/
	SetProfileIndex(InProfileIndex: number): void;
	/**
	 * Set Light Direction
	*/
	SetLightDirection(InLightDir: Rotator): void;
	/**
	 * Set Light Color
	*/
	SetLightColor(LightColor: Color): void;
	/**
	 * Set Light Brightness
	*/
	SetLightBrightness(LightBrightness: number): void;
	/**
	 * Set Floor Offset
	*/
	SetFloorOffset(InFloorOffset: number): void;
	/**
	 * Set Engine Show Flags
	*/
	SetEngineShowFlags(In: string): boolean;
	/**
	 * Set Camera Speed Setting
	*/
	SetCameraSpeedSetting(SpeedSetting: number): void;
	/**
	 * Set Background Color
	*/
	SetBackgroundColor(BackgroundColor: LinearColor): void;
	/**
	 * Restore Realtime
	*/
	RestoreRealtime(bAllowDisable: boolean): void;
	/**
	 * Redraw
	*/
	Redraw(): void;
	/**
	 * Project World to Screen
	*/
	ProjectWorldToScreen(WorldPosition: Vector,OutScreenPosition?: Vector2D): {OutScreenPosition: Vector2D};
	/**
	 * Override Post Process Settings
	*/
	OverridePostProcessSettings(PostProcessSettings: PostProcessSettings,Weight: number): void;
	/**
	 * Get Widget Mode
	*/
	GetWidgetMode(): EJavascriptWidgetMode;
	/**
	 * Get Viewport World
	*/
	GetViewportWorld(): World;
	/**
	 * Get View FOV
	*/
	GetViewFOV(): number;
	/**
	 * Get Sky Component
	*/
	GetSkyComponent(): StaticMeshComponent;
	/**
	 * Get Floor Mesh Component
	*/
	GetFloorMeshComponent(): StaticMeshComponent;
	/**
	 * Get Engine Show Flags
	*/
	GetEngineShowFlags(): string;
	/**
	 * Get Default Asset Viewer Settings
	*/
	GetDefaultAssetViewerSettings(): AssetViewerSettings;
	/**
	 * Get Current Profile Index
	*/
	GetCurrentProfileIndex(): number;
	/**
	 * Get Camera Speed Setting
	*/
	GetCameraSpeedSetting(): number;
	/**
	 * Deproject Screen to World
	*/
	DeprojectScreenToWorld(ScreenPosition: Vector2D,OutRayOrigin?: Vector,OutRayDirection?: Vector): {OutRayOrigin: Vector, OutRayDirection: Vector};
	static C(Other: UObject): JavascriptEditorViewport;
}

declare class JavascriptEdViewport { 
	clone() : JavascriptEdViewport;
	static C(Other: UObject): JavascriptEdViewport;
	/**
	 * Get Hit Proxy
	*/
	GetHitProxy(): JavascriptHitProxy;
	/**
	 * Get Hit Proxy
	*/
	static GetHitProxy(Viewport: JavascriptEdViewport): JavascriptHitProxy;
}

declare class JavascriptEditorModeTools { 
	clone() : JavascriptEditorModeTools;
	static C(Other: UObject): JavascriptEditorModeTools;
	/**
	 * Activate Default Mode
	*/
	ActivateDefaultMode(): {Tools: JavascriptEditorModeTools};
	/**
	 * Activate Mode
	*/
	ActivateMode(InID?: string,bToggle?: boolean): {Tools: JavascriptEditorModeTools};
	/**
	 * Deactivate All Modes
	*/
	DeactivateAllModes(): {Tools: JavascriptEditorModeTools};
	/**
	 * Deactivate Mode
	*/
	DeactivateMode(InID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * Destroy Mode
	*/
	DestroyMode(InID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * End Tracking
	*/
	EndTracking(Viewport: JavascriptEdViewport): boolean;
	/**
	 * Ensure Not in Mode
	*/
	EnsureNotInMode(ModeID?: string,ErrorMsg?: string,bNotifyUser?: boolean): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * Is Default Mode Active
	*/
	IsDefaultModeActive(): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * Is Mode Active
	*/
	IsModeActive(InID?: string): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * Is Tracking
	*/
	IsTracking(): boolean;
	/**
	 * Set Default Mode
	*/
	SetDefaultMode(DefaultID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * Start Tracking
	*/
	StartTracking(Viewport: JavascriptEdViewport): boolean;
	/**
	 * Activate Default Mode
	*/
	static ActivateDefaultMode(Tools?: JavascriptEditorModeTools): {Tools: JavascriptEditorModeTools};
	/**
	 * Activate Mode
	*/
	static ActivateMode(Tools?: JavascriptEditorModeTools,InID?: string,bToggle?: boolean): {Tools: JavascriptEditorModeTools};
	/**
	 * Deactivate All Modes
	*/
	static DeactivateAllModes(Tools?: JavascriptEditorModeTools): {Tools: JavascriptEditorModeTools};
	/**
	 * Deactivate Mode
	*/
	static DeactivateMode(Tools?: JavascriptEditorModeTools,InID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * Destroy Mode
	*/
	static DestroyMode(Tools?: JavascriptEditorModeTools,InID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * End Tracking
	*/
	static EndTracking(Tools: JavascriptEditorModeTools,Viewport: JavascriptEdViewport): boolean;
	/**
	 * Ensure Not in Mode
	*/
	static EnsureNotInMode(Tools?: JavascriptEditorModeTools,ModeID?: string,ErrorMsg?: string,bNotifyUser?: boolean): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * Is Default Mode Active
	*/
	static IsDefaultModeActive(Tools?: JavascriptEditorModeTools): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * Is Mode Active
	*/
	static IsModeActive(Tools?: JavascriptEditorModeTools,InID?: string): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * Is Tracking
	*/
	static IsTracking(Tools: JavascriptEditorModeTools): boolean;
	/**
	 * Set Default Mode
	*/
	static SetDefaultMode(Tools?: JavascriptEditorModeTools,DefaultID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * Start Tracking
	*/
	static StartTracking(Tools: JavascriptEditorModeTools,Viewport: JavascriptEdViewport): boolean;
}

declare class JavascriptEditorMode { 
	clone() : JavascriptEditorMode;
	static C(Other: UObject): JavascriptEditorMode;
	/**
	 * Get Current Widget Axis
	*/
	GetCurrentWidgetAxis(): number;
	/**
	 * Get Mode Manager
	*/
	GetModeManager(): JavascriptEditorModeTools;
	/**
	 * Select None
	*/
	SelectNone(): void;
	/**
	 * Set Current Widget Axis
	*/
	SetCurrentWidgetAxis(InAxis: number): void;
	/**
	 * Get Current Widget Axis
	*/
	static GetCurrentWidgetAxis(Mode: JavascriptEditorMode): number;
	/**
	 * Get Mode Manager
	*/
	static GetModeManager(Mode: JavascriptEditorMode): JavascriptEditorModeTools;
	/**
	 * Select None
	*/
	static SelectNone(Mode: JavascriptEditorMode): void;
	/**
	 * Set Current Widget Axis
	*/
	static SetCurrentWidgetAxis(Mode: JavascriptEditorMode,InAxis: number): void;
}

declare class JavascriptEdModeLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEdModeLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptEdModeLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEdModeLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEdModeLibrary;
	/**
	 * Start Tracking
	*/
	static StartTracking(Tools: JavascriptEditorModeTools,Viewport: JavascriptEdViewport): boolean;
	/**
	 * Set Default Mode
	*/
	static SetDefaultMode(Tools?: JavascriptEditorModeTools,DefaultID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * Set Current Widget Axis
	*/
	static SetCurrentWidgetAxis(Mode: JavascriptEditorMode,InAxis: number): void;
	/**
	 * Select None
	*/
	static SelectNone(Mode: JavascriptEditorMode): void;
	/**
	 * Is Tracking
	*/
	static IsTracking(Tools: JavascriptEditorModeTools): boolean;
	/**
	 * Is Mode Active
	*/
	static IsModeActive(Tools?: JavascriptEditorModeTools,InID?: string): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * Is Default Mode Active
	*/
	static IsDefaultModeActive(Tools?: JavascriptEditorModeTools): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * Get Mode Manager
	*/
	static GetModeManager(Mode: JavascriptEditorMode): JavascriptEditorModeTools;
	/**
	 * Get Hit Proxy
	*/
	static GetHitProxy(Viewport: JavascriptEdViewport): JavascriptHitProxy;
	/**
	 * Get Current Widget Axis
	*/
	static GetCurrentWidgetAxis(Mode: JavascriptEditorMode): number;
	/**
	 * Ensure Not in Mode
	*/
	static EnsureNotInMode(Tools?: JavascriptEditorModeTools,ModeID?: string,ErrorMsg?: string,bNotifyUser?: boolean): {Tools: JavascriptEditorModeTools, $: boolean};
	/**
	 * End Tracking
	*/
	static EndTracking(Tools: JavascriptEditorModeTools,Viewport: JavascriptEdViewport): boolean;
	/**
	 * Destroy Mode
	*/
	static DestroyMode(Tools?: JavascriptEditorModeTools,InID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * Deactivate Mode
	*/
	static DeactivateMode(Tools?: JavascriptEditorModeTools,InID?: string): {Tools: JavascriptEditorModeTools};
	/**
	 * Deactivate All Modes
	*/
	static DeactivateAllModes(Tools?: JavascriptEditorModeTools): {Tools: JavascriptEditorModeTools};
	/**
	 * Activate Mode
	*/
	static ActivateMode(Tools?: JavascriptEditorModeTools,InID?: string,bToggle?: boolean): {Tools: JavascriptEditorModeTools};
	/**
	 * Activate Default Mode
	*/
	static ActivateDefaultMode(Tools?: JavascriptEditorModeTools): {Tools: JavascriptEditorModeTools};
	static C(Other: UObject): JavascriptEdModeLibrary;
}

declare type EJavascriptEditAction = string | symbol;
declare var EJavascriptEditAction = { Skip:'Skip',Process:'Process',Halt:'Halt', };
declare class JavascriptSlateIcon { 
	/**
	 * Style Set Name
	*/
	StyleSetName: string;
	/**
	 * Style Name
	*/
	StyleName: string;
	/**
	 * Small Style Name
	*/
	SmallStyleName: string;
	clone() : JavascriptSlateIcon;
	static C(Other: UObject): JavascriptSlateIcon;
}

declare class JavascriptEdMode extends UObject { 
	/**
	 * On Get Widget Location
	*/
	OnGetWidgetLocation: UnrealEngineDelegate<(Instance: JavascriptEditorMode) => Vector>;
	/**
	 * On Select
	*/
	OnSelect: UnrealEngineDelegate<(Actor: Actor, bSelected: boolean, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Draw
	*/
	OnDraw: UnrealEngineDelegate<(PDI: JavascriptPDI, Instance: JavascriptEditorMode) => void>;
	/**
	 * On Draw HUD
	*/
	OnDrawHUD: UnrealEngineDelegate<(Canvas: Canvas, Instance: JavascriptEditorMode) => void>;
	/**
	 * Is Selection Allowed
	*/
	IsSelectionAllowed: UnrealEngineDelegate<(Actor: Actor, bSelected: boolean, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Click
	*/
	OnClick: UnrealEngineDelegate<(ViewportClick: JavascriptViewportClick, HitProxy: JavascriptHitProxy, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Query
	*/
	OnQuery: UnrealEngineDelegate<(Request: string, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Start Tracking
	*/
	OnStartTracking: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On End Tracking
	*/
	OnEndTracking: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Input Axis
	*/
	OnInputAxis: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, ControllerId: number, Key: Key, Delta: number, DeltaTime: number, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Input Key
	*/
	OnInputKey: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, Key: Key, Event: EInputEvent, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Input Delta
	*/
	OnInputDelta: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, Drag: Vector, Rot: Rotator, Scale: Vector, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Captured Mouse Move
	*/
	OnCapturedMouseMove: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, X: number, Y: number, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Mouse Enter
	*/
	OnMouseEnter: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, X: number, Y: number, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Mouse Leave
	*/
	OnMouseLeave: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Mouse Move
	*/
	OnMouseMove: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, X: number, Y: number, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Lost Focus
	*/
	OnLostFocus: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Received Focus
	*/
	OnReceivedFocus: UnrealEngineDelegate<(Viewport: JavascriptEdViewport, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Selection Changed
	*/
	OnSelectionChanged: UnrealEngineDelegate<(Tools: JavascriptEditorModeTools, Item: UObject) => void>;
	/**
	 * On Get Content
	*/
	OnGetContent: UnrealEngineDelegate<() => Widget>;
	/**
	 * On Process
	*/
	OnProcess: UnrealEngineDelegate<(Request: string, Instance: JavascriptEditorMode) => boolean>;
	/**
	 * On Get Action
	*/
	OnGetAction: UnrealEngineDelegate<(Request: string, Instance: JavascriptEditorMode) => EJavascriptEditAction>;
	/**
	 * On Actor Moved
	*/
	OnActorMoved: UnrealEngineDelegate<(Instance: JavascriptEditorMode) => void>;
	/**
	 * On Actors Duplicated
	*/
	OnActorsDuplicated: UnrealEngineDelegate<(PreDuplicateSelection: Actor[], PostDuplicateSelection: Actor[], bOffsetLocations: boolean, Instance: JavascriptEditorMode) => void>;
	/**
	 * On Actor Selection Changed
	*/
	OnActorSelectionChanged: UnrealEngineDelegate<(Instance: JavascriptEditorMode) => void>;
	/**
	 * On Actor Prop Changed
	*/
	OnActorPropChanged: UnrealEngineDelegate<(Instance: JavascriptEditorMode) => void>;
	/**
	 * On Map Changed
	*/
	OnMapChanged: UnrealEngineDelegate<(Instance: JavascriptEditorMode) => void>;
	/**
	 * Mode Id
	*/
	ModeId: string;
	/**
	 * Slate Icon
	*/
	SlateIcon: JavascriptSlateIcon;
	/**
	 * Mode Name
	*/
	ModeName: string;
	/**
	 * Visible
	*/
	bVisible: boolean;
	/**
	 * Priority Order
	*/
	PriorityOrder: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptEdMode;
	static Find(Outer: UObject, ResourceName: string): JavascriptEdMode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptEdMode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptEdMode;
	/**
	 * Unregister
	*/
	Unregister(): void;
	/**
	 * Register
	*/
	Register(): void;
	static C(Other: UObject): JavascriptEdMode;
}

declare class JavascriptGraphAction { 
	/**
	 * Name
	*/
	Name: string;
	/**
	 * Category
	*/
	Category: string;
	/**
	 * Resource
	*/
	Resource: UObject;
	clone() : JavascriptGraphAction;
	static C(Other: UObject): JavascriptGraphAction;
}

declare class JavascriptGraphEditor extends Widget { 
	/**
	 * Title Name
	*/
	TitleName: string;
	/**
	 * Graph
	*/
	Graph: EdGraph;
	/**
	 * Graph Editor Commands
	*/
	GraphEditorCommands: JavascriptUICommandList;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptGraphEditor;
	static Find(Outer: UObject, ResourceName: string): JavascriptGraphEditor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptGraphEditor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptGraphEditor;
	/**
	 * Add Action Context
	*/
	AddActionContext(Action: JavascriptGraphAction): void;
	static C(Other: UObject): JavascriptGraphEditor;
}

declare class JavascriptGraphSchema extends EdGraphSchema { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptGraphSchema;
	static Find(Outer: UObject, ResourceName: string): JavascriptGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptGraphSchema;
	static C(Other: UObject): JavascriptGraphSchema;
}

declare class JavascriptNotification extends UObject { 
	/**
	 * The text displayed in this text block
	*/
	Text: string;
	/**
	 * The icon image to display next to the text
	*/
	bUseImage: boolean;
	/**
	 * Image
	*/
	UImage: SlateBrush;
	/**
	 * The fade in duration for this element
	*/
	FadeInDuration: number;
	/**
	 * The fade out duration for this element
	*/
	FadeOutDuration: number;
	/**
	 * The duration before a fadeout for this element
	*/
	ExpireDuration: number;
	/**
	 * Controls whether or not to add the animated throbber
	*/
	bUseThrobber: boolean;
	/**
	 * Controls whether or not to display the success and fail icons
	*/
	bUseSuccessFailIcons: boolean;
	/**
	 * When true the larger bolder font will be used to display the message
	*/
	bUseLargeFont: boolean;
	/**
	 * When true the notification will automatically time out after the expire duration.
	*/
	bFireAndForget: boolean;
	/**
	 * When set this will display a check box on the notification; handles getting the current check box state
	*/
	CheckBoxState: ECheckBoxState;
	/**
	 * When set this will display a check box on the notification; handles setting the new check box state
	*/
	CheckBoxStateChanged: UnrealEngineDelegate<(State: ECheckBoxState) => void>;
	/**
	 * Text to display for the check box message
	*/
	CheckBoxText: string;
	/**
	 * When set this will display as a hyperlink on the right side of the notification.
	*/
	Hyperlink: UnrealEngineDelegate<() => void>;
	/**
	 * Text to display for the hyperlink message
	*/
	HyperlinkText: string;
	/**
	 * True if we should throttle the editor while the notification is transitioning and performance is poor, to make sure the user can see the animation
	*/
	bAllowThrottleWhenFrameRateIsLow: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptNotification;
	static Find(Outer: UObject, ResourceName: string): JavascriptNotification;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptNotification;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptNotification;
	/**
	 * Success
	*/
	Success(): void;
	/**
	 * Reset
	*/
	Reset(): void;
	/**
	 * Pending
	*/
	Pending(): void;
	/**
	 * Fire
	*/
	Fire(): void;
	/**
	 * Fail
	*/
	Fail(): void;
	/**
	 * Fadeout
	*/
	Fadeout(): void;
	static C(Other: UObject): JavascriptNotification;
}

declare class JavascriptDetailWidgetDecl { 
	clone() : JavascriptDetailWidgetDecl;
	static C(Other: UObject): JavascriptDetailWidgetDecl;
	/**
	 * Set Content
	*/
	SetContent(Widget: JavascriptSlateWidget): void;
	/**
	 * Set HAlign
	*/
	SetHAlign(InAlignment: EHorizontalAlignment): void;
	/**
	 * Set Max Desired Width
	*/
	SetMaxDesiredWidth(MaxWidth: number): void;
	/**
	 * Set Min Desired Width
	*/
	SetMinDesiredWidth(MinWidth: number): void;
	/**
	 * Set VAlign
	*/
	SetVAlign(InAlignment: EVerticalAlignment): void;
	/**
	 * Set Content
	*/
	static SetContent(Decl: JavascriptDetailWidgetDecl,Widget: JavascriptSlateWidget): void;
	/**
	 * Set HAlign
	*/
	static SetHAlign(Decl: JavascriptDetailWidgetDecl,InAlignment: EHorizontalAlignment): void;
	/**
	 * Set Max Desired Width
	*/
	static SetMaxDesiredWidth(Decl: JavascriptDetailWidgetDecl,MaxWidth: number): void;
	/**
	 * Set Min Desired Width
	*/
	static SetMinDesiredWidth(Decl: JavascriptDetailWidgetDecl,MinWidth: number): void;
	/**
	 * Set VAlign
	*/
	static SetVAlign(Decl: JavascriptDetailWidgetDecl,InAlignment: EVerticalAlignment): void;
}

declare class JavascriptDetailWidgetRow { 
	clone() : JavascriptDetailWidgetRow;
	static C(Other: UObject): JavascriptDetailWidgetRow;
	/**
	 * Name Content
	*/
	NameContent(): JavascriptDetailWidgetDecl;
	/**
	 * Set Filter String
	*/
	SetFilterString(InFilterString: string): void;
	/**
	 * Value Content
	*/
	ValueContent(): JavascriptDetailWidgetDecl;
	/**
	 * Whole Row Content
	*/
	WholeRowContent(): JavascriptDetailWidgetDecl;
	/**
	 * Name Content
	*/
	static NameContent(Row: JavascriptDetailWidgetRow): JavascriptDetailWidgetDecl;
	/**
	 * Set Filter String
	*/
	static SetFilterString(Row: JavascriptDetailWidgetRow,InFilterString: string): void;
	/**
	 * Value Content
	*/
	static ValueContent(Row: JavascriptDetailWidgetRow): JavascriptDetailWidgetDecl;
	/**
	 * Whole Row Content
	*/
	static WholeRowContent(Row: JavascriptDetailWidgetRow): JavascriptDetailWidgetDecl;
}

declare type EPropertyAccessResult = string | symbol;
declare var EPropertyAccessResult = { MultipleValues:'MultipleValues',Fail:'Fail',Success:'Success', };
declare class JavascriptPropertyHandle { 
	clone() : JavascriptPropertyHandle;
	static C(Other: UObject): JavascriptPropertyHandle;
	/**
	 * Create Property Name Widget
	*/
	CreatePropertyNameWidget(NameOverride: string,ToolTipOverride: string,bDisplayResetToDefault: boolean,bHideText: boolean,bHideThumbnail: boolean): JavascriptSlateWidget;
	/**
	 * Create Property Value Widget
	*/
	CreatePropertyValueWidget(bHideDefaultPropertyButtons: boolean): JavascriptSlateWidget;
	/**
	 * Get Child Handle
	*/
	GetChildHandle(Name: string): JavascriptPropertyHandle;
	/**
	 * Get Meta Data
	*/
	GetMetaData(Key: string): string;
	/**
	 * Get Property
	*/
	GetProperty(): Property;
	/**
	 * Get Value as Formatted String
	*/
	GetValueAsFormattedString(OutValue?: string): {OutValue: string, $: EPropertyAccessResult};
	/**
	 * Set on Property Value Changed
	*/
	SetOnPropertyValueChanged(UFunction: JavascriptFunction): void;
	/**
	 * Set Value from Formatted String
	*/
	SetValueFromFormattedString(InValue: string): EPropertyAccessResult;
	/**
	 * Create Property Name Widget
	*/
	static CreatePropertyNameWidget(Handle: JavascriptPropertyHandle,NameOverride: string,ToolTipOverride: string,bDisplayResetToDefault: boolean,bHideText: boolean,bHideThumbnail: boolean): JavascriptSlateWidget;
	/**
	 * Create Property Value Widget
	*/
	static CreatePropertyValueWidget(Handle: JavascriptPropertyHandle,bHideDefaultPropertyButtons: boolean): JavascriptSlateWidget;
	/**
	 * Get Child Handle
	*/
	static GetChildHandle(Parent: JavascriptPropertyHandle,Name: string): JavascriptPropertyHandle;
	/**
	 * Get Meta Data
	*/
	static GetMetaData(Handle: JavascriptPropertyHandle,Key: string): string;
	/**
	 * Get Property
	*/
	static GetProperty(Handle: JavascriptPropertyHandle): Property;
	/**
	 * Get Value as Formatted String
	*/
	static GetValueAsFormattedString(Handle: JavascriptPropertyHandle,OutValue?: string): {OutValue: string, $: EPropertyAccessResult};
	/**
	 * Set on Property Value Changed
	*/
	static SetOnPropertyValueChanged(Handle: JavascriptPropertyHandle,UFunction: JavascriptFunction): void;
	/**
	 * Set Value from Formatted String
	*/
	static SetValueFromFormattedString(Handle: JavascriptPropertyHandle,InValue: string): EPropertyAccessResult;
}

declare class JavascriptDetailPropertyRow { 
	clone() : JavascriptDetailPropertyRow;
	static C(Other: UObject): JavascriptDetailPropertyRow;
	/**
	 * void ShouldAutoExpand(FJavascriptDetailPropertyRow Row, bool bForceExpansion);
	 * void Visibility(TAttribute<EVisibility> Visibility);
	 * void OverrideResetToDefault(const FResetToDefaultOverride& ResetToDefault);
	 * void GetDefaultWidgets(TSharedPtr<SWidget>& OutNameWidget, TSharedPtr<SWidget>& OutValueWidget);
	 * void GetDefaultWidgets(TSharedPtr<SWidget>& OutNameWidget, TSharedPtr<SWidget>& OutValueWidget, FDetailWidgetRow& Row);
	*/
	CustomWidget(bShowChildren: boolean): JavascriptDetailWidgetRow;
	/**
	 * void ShouldAutoExpand(FJavascriptDetailPropertyRow Row, bool bForceExpansion);
	 * void Visibility(TAttribute<EVisibility> Visibility);
	 * void OverrideResetToDefault(const FResetToDefaultOverride& ResetToDefault);
	 * void GetDefaultWidgets(TSharedPtr<SWidget>& OutNameWidget, TSharedPtr<SWidget>& OutValueWidget);
	 * void GetDefaultWidgets(TSharedPtr<SWidget>& OutNameWidget, TSharedPtr<SWidget>& OutValueWidget, FDetailWidgetRow& Row);
	*/
	static CustomWidget(Row: JavascriptDetailPropertyRow,bShowChildren: boolean): JavascriptDetailWidgetRow;
}

declare class JavascriptDetailChildrenBuilder { 
	clone() : JavascriptDetailChildrenBuilder;
	static C(Other: UObject): JavascriptDetailChildrenBuilder;
	/**
	 * Add Child Content
	*/
	AddChildContent(SearchString: string): JavascriptDetailWidgetRow;
	/**
	 * Add Child Property
	*/
	AddChildProperty(PropertyHandle: JavascriptPropertyHandle): JavascriptDetailPropertyRow;
	/**
	 * Generate Struct Value Widget
	*/
	GenerateStructValueWidget(StructPropertyHandle: JavascriptPropertyHandle): JavascriptSlateWidget;
	/**
	 * Add Child Content
	*/
	static AddChildContent(ChildBuilder: JavascriptDetailChildrenBuilder,SearchString: string): JavascriptDetailWidgetRow;
	/**
	 * Add Child Property
	*/
	static AddChildProperty(ChildBuilder: JavascriptDetailChildrenBuilder,PropertyHandle: JavascriptPropertyHandle): JavascriptDetailPropertyRow;
	/**
	 * Generate Struct Value Widget
	*/
	static GenerateStructValueWidget(ChildBuilder: JavascriptDetailChildrenBuilder,StructPropertyHandle: JavascriptPropertyHandle): JavascriptSlateWidget;
}

declare class JavascriptPropertyCustomizationLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptPropertyCustomizationLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptPropertyCustomizationLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptPropertyCustomizationLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptPropertyCustomizationLibrary;
	/**
	 * Whole Row Content
	*/
	static WholeRowContent(Row: JavascriptDetailWidgetRow): JavascriptDetailWidgetDecl;
	/**
	 * Value Content
	*/
	static ValueContent(Row: JavascriptDetailWidgetRow): JavascriptDetailWidgetDecl;
	/**
	 * Set Value from Formatted String
	*/
	static SetValueFromFormattedString(Handle: JavascriptPropertyHandle,InValue: string): EPropertyAccessResult;
	/**
	 * Set VAlign
	*/
	static SetVAlign(Decl: JavascriptDetailWidgetDecl,InAlignment: EVerticalAlignment): void;
	/**
	 * Set on Property Value Changed
	*/
	static SetOnPropertyValueChanged(Handle: JavascriptPropertyHandle,UFunction: JavascriptFunction): void;
	/**
	 * Set Min Desired Width
	*/
	static SetMinDesiredWidth(Decl: JavascriptDetailWidgetDecl,MinWidth: number): void;
	/**
	 * Set Max Desired Width
	*/
	static SetMaxDesiredWidth(Decl: JavascriptDetailWidgetDecl,MaxWidth: number): void;
	/**
	 * Set HAlign
	*/
	static SetHAlign(Decl: JavascriptDetailWidgetDecl,InAlignment: EHorizontalAlignment): void;
	/**
	 * Set Filter String
	*/
	static SetFilterString(Row: JavascriptDetailWidgetRow,InFilterString: string): void;
	/**
	 * Set Content
	*/
	static SetContent(Decl: JavascriptDetailWidgetDecl,Widget: JavascriptSlateWidget): void;
	/**
	 * Name Content
	*/
	static NameContent(Row: JavascriptDetailWidgetRow): JavascriptDetailWidgetDecl;
	/**
	 * Get Value as Formatted String
	*/
	static GetValueAsFormattedString(Handle: JavascriptPropertyHandle,OutValue?: string): {OutValue: string, $: EPropertyAccessResult};
	/**
	 * Get Property
	*/
	static GetProperty(Handle: JavascriptPropertyHandle): Property;
	/**
	 * Get Meta Data
	*/
	static GetMetaData(Handle: JavascriptPropertyHandle,Key: string): string;
	/**
	 * Get Child Handle
	*/
	static GetChildHandle(Parent: JavascriptPropertyHandle,Name: string): JavascriptPropertyHandle;
	/**
	 * Generate Struct Value Widget
	*/
	static GenerateStructValueWidget(ChildBuilder: JavascriptDetailChildrenBuilder,StructPropertyHandle: JavascriptPropertyHandle): JavascriptSlateWidget;
	/**
	 * void ShouldAutoExpand(FJavascriptDetailPropertyRow Row, bool bForceExpansion);
	 * void Visibility(TAttribute<EVisibility> Visibility);
	 * void OverrideResetToDefault(const FResetToDefaultOverride& ResetToDefault);
	 * void GetDefaultWidgets(TSharedPtr<SWidget>& OutNameWidget, TSharedPtr<SWidget>& OutValueWidget);
	 * void GetDefaultWidgets(TSharedPtr<SWidget>& OutNameWidget, TSharedPtr<SWidget>& OutValueWidget, FDetailWidgetRow& Row);
	*/
	static CustomWidget(Row: JavascriptDetailPropertyRow,bShowChildren: boolean): JavascriptDetailWidgetRow;
	/**
	 * Create Property Value Widget
	*/
	static CreatePropertyValueWidget(Handle: JavascriptPropertyHandle,bHideDefaultPropertyButtons: boolean): JavascriptSlateWidget;
	/**
	 * Create Property Name Widget
	*/
	static CreatePropertyNameWidget(Handle: JavascriptPropertyHandle,NameOverride: string,ToolTipOverride: string,bDisplayResetToDefault: boolean,bHideText: boolean,bHideThumbnail: boolean): JavascriptSlateWidget;
	/**
	 * Add Child Property
	*/
	static AddChildProperty(ChildBuilder: JavascriptDetailChildrenBuilder,PropertyHandle: JavascriptPropertyHandle): JavascriptDetailPropertyRow;
	/**
	 * Add Child Content
	*/
	static AddChildContent(ChildBuilder: JavascriptDetailChildrenBuilder,SearchString: string): JavascriptDetailWidgetRow;
	static C(Other: UObject): JavascriptPropertyCustomizationLibrary;
}

declare class JavascriptPropertyTypeCustomizationUtils { 
	clone() : JavascriptPropertyTypeCustomizationUtils;
	static C(Other: UObject): JavascriptPropertyTypeCustomizationUtils;
}

declare class JavascriptPropertyCustomization extends UObject { 
	/**
	 * Property Type Name
	*/
	PropertyTypeName: string;
	/**
	 * On Destroy
	*/
	OnDestroy: UnrealEngineDelegate<(Id: number) => void>;
	/**
	 * On Customize Header
	*/
	OnCustomizeHeader: UnrealEngineDelegate<(Handle: JavascriptPropertyHandle, HeaderRow: JavascriptDetailWidgetRow, Utils: JavascriptPropertyTypeCustomizationUtils, Id: number) => void>;
	/**
	 * On Customize Children
	*/
	OnCustomizeChildren: UnrealEngineDelegate<(Handle: JavascriptPropertyHandle, ChildBuilder: JavascriptDetailChildrenBuilder, Utils: JavascriptPropertyTypeCustomizationUtils, Id: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptPropertyCustomization;
	static Find(Outer: UObject, ResourceName: string): JavascriptPropertyCustomization;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptPropertyCustomization;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptPropertyCustomization;
	/**
	 * Unregister
	*/
	Unregister(): void;
	/**
	 * Register
	*/
	Register(): void;
	static C(Other: UObject): JavascriptPropertyCustomization;
}

declare class JavascriptRawMeshLibrary extends BlueprintFunctionLibrary { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): JavascriptRawMeshLibrary;
	static Find(Outer: UObject, ResourceName: string): JavascriptRawMeshLibrary;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): JavascriptRawMeshLibrary;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): JavascriptRawMeshLibrary;
	/**
	 * Set Section Info
	*/
	static SetSectionInfo(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number,Info: MeshSectionInfo): void;
	/**
	 * Store a new raw mesh in the bulk data.
	*/
	static SaveRawMesh(StaticMesh: StaticMesh,SourceModelIndex: number,InMesh?: JavascriptRawMesh): {InMesh: JavascriptRawMesh};
	/**
	 * Mark Package Dirty
	*/
	static MarkPackageDirty(InObject: UObject): boolean;
	/**
	 * Load the raw mesh from bulk data.
	*/
	static LoadRawMesh(StaticMesh: StaticMesh,SourceModelIndex: number,OutMesh?: JavascriptRawMesh): {OutMesh: JavascriptRawMesh};
	/**
	 * Returns true if the mesh contains valid information or slightly invalid information that we can fix.
	 *  - Validates that stream sizes match.
	 *  - Validates that there is at least one texture coordinate.
	 *  - Validates that indices are valid positions in the vertex stream.
	*/
	static IsValidOrFixable(RawMesh: JavascriptRawMesh): boolean;
	/**
	 * Is Valid
	*/
	static IsValid(RawMesh: JavascriptRawMesh): boolean;
	/**
	 * Helper for getting the position of a wedge.
	*/
	static GetWedgePosition(RawMesh: JavascriptRawMesh,WedgeIndex: number): Vector;
	/**
	 * Get Section Info
	*/
	static GetSectionInfo(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number): MeshSectionInfo;
	/**
	 * Empty
	*/
	static Empty(RawMesh?: JavascriptRawMesh): {RawMesh: JavascriptRawMesh};
	/**
	 * Compact Material Indices
	*/
	static CompactMaterialIndices(RawMesh?: JavascriptRawMesh): {RawMesh: JavascriptRawMesh};
	/**
	 * Build
	*/
	static Build(StaticMesh: StaticMesh): void;
	static C(Other: UObject): JavascriptRawMeshLibrary;
}

declare type EPropertyEditorNameAreaSettings = string | symbol;
declare var EPropertyEditorNameAreaSettings = { HideNameArea:'HideNameArea',ObjectsUseNameArea:'ObjectsUseNameArea',ActorsUseNameArea:'ActorsUseNameArea',ComponentsAndActorsUseNameArea:'ComponentsAndActorsUseNameArea', };
declare class PropertyEditor extends Widget { 
	/**
	 * On Change
	*/
	OnChange: UnrealEngineMulticastDelegate<(ParameterName: string) => void>;
	/**
	 * Update from Selection
	*/
	bUpdateFromSelection: boolean;
	/**
	 * Lockable
	*/
	bLockable: boolean;
	/**
	 * Allow Search
	*/
	bAllowSearch: boolean;
	/**
	 * Hide Selection Tip
	*/
	bHideSelectionTip: boolean;
	/**
	 * Name Area Settings
	*/
	NameAreaSettings: EPropertyEditorNameAreaSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PropertyEditor;
	static Find(Outer: UObject, ResourceName: string): PropertyEditor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PropertyEditor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyEditor;
	/**
	 * Set Objects
	*/
	SetObjects(Objects: UObject[],bForceRefresh: boolean,bOverrideLock: boolean): void;
	/**
	 * Set Object
	*/
	SetObject(UObject: UObject,bForceRefresh: boolean): void;
	static C(Other: UObject): PropertyEditor;
}

declare class FileMediaSourceFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FileMediaSourceFactoryNew;
	static Find(Outer: UObject, ResourceName: string): FileMediaSourceFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FileMediaSourceFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FileMediaSourceFactoryNew;
	static C(Other: UObject): FileMediaSourceFactoryNew;
}

declare class MediaPlayerEditorSettings extends UObject { 
	/**
	 * The name of the desired native media player to use for playback.
	*/
	DesiredPlayerName: string;
	/**
	 * Whether the media texture should be scaled to maintain the video's aspect ratio.
	*/
	ScaleVideoToFit: boolean;
	/**
	 * Whether to display caption/subtitle text.
	*/
	ShowCaptions: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaPlayerEditorSettings;
	static Find(Outer: UObject, ResourceName: string): MediaPlayerEditorSettings;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaPlayerEditorSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlayerEditorSettings;
	static C(Other: UObject): MediaPlayerEditorSettings;
}

declare class MediaPlayerFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaPlayerFactoryNew;
	static Find(Outer: UObject, ResourceName: string): MediaPlayerFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaPlayerFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlayerFactoryNew;
	static C(Other: UObject): MediaPlayerFactoryNew;
}

declare class MediaPlaylistFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaPlaylistFactoryNew;
	static Find(Outer: UObject, ResourceName: string): MediaPlaylistFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaPlaylistFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaPlaylistFactoryNew;
	static C(Other: UObject): MediaPlaylistFactoryNew;
}

declare class MediaSoundWaveFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaSoundWaveFactoryNew;
	static Find(Outer: UObject, ResourceName: string): MediaSoundWaveFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaSoundWaveFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaSoundWaveFactoryNew;
	static C(Other: UObject): MediaSoundWaveFactoryNew;
}

declare class MediaTextureFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MediaTextureFactoryNew;
	static Find(Outer: UObject, ResourceName: string): MediaTextureFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MediaTextureFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MediaTextureFactoryNew;
	static C(Other: UObject): MediaTextureFactoryNew;
}

declare class PlatformMediaSourceFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PlatformMediaSourceFactoryNew;
	static Find(Outer: UObject, ResourceName: string): PlatformMediaSourceFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlatformMediaSourceFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlatformMediaSourceFactoryNew;
	static C(Other: UObject): PlatformMediaSourceFactoryNew;
}

declare class StreamMediaSourceFactoryNew extends Factory { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StreamMediaSourceFactoryNew;
	static Find(Outer: UObject, ResourceName: string): StreamMediaSourceFactoryNew;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StreamMediaSourceFactoryNew;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StreamMediaSourceFactoryNew;
	static C(Other: UObject): StreamMediaSourceFactoryNew;
}

declare class ArchVisCharacter extends Character { 
	/**
	 * Axis name for direct look up/down inputs (e.g. mouse). This should match an Axis Binding in your input settings
	*/
	LookUpAxisName: string;
	/**
	 * Axis name for rate-based look up/down inputs (e.g. joystick). This should match an Axis Binding in your input settings
	*/
	LookUpAtRateAxisName: string;
	/**
	 * Axis name for direct turn left/right inputs (e.g. mouse). This should match an Axis Binding in your input settings
	*/
	TurnAxisName: string;
	/**
	 * Axis name for rate-based turn left/right inputs (e.g. joystick). This should match an Axis Binding in your input settings
	*/
	TurnAtRateAxisName: string;
	/**
	 * Axis name for "move forward/back" control. This should match an Axis Binding in your input settings
	*/
	MoveForwardAxisName: string;
	/**
	 * Axis name for "move left/right" control. This should match an Axis Binding in your input settings
	*/
	MoveRightAxisName: string;
	/**
	 * Controls how aggressively mouse motion translates to character rotation in the pitch axis.
	*/
	MouseSensitivityScale_Pitch: number;
	/**
	 * Controls how aggressively mouse motion translates to character rotation in the yaw axis.
	*/
	MouseSensitivityScale_Yaw: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ArchVisCharacter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArchVisCharacter;
	static C(Other: UObject): ArchVisCharacter;
}

declare class ArchVisCharMovementComponent extends CharacterMovementComponent { 
	/**
	 * Controls how fast the character's turn rate accelerates when rotating and looking up/down
	*/
	RotationalAcceleration: Rotator;
	/**
	 * Controls how fast the character's turn rate decelerates to 0 when user stops turning
	*/
	RotationalDeceleration: Rotator;
	/**
	 * Fastest possible turn rate
	*/
	MaxRotationalVelocity: Rotator;
	/**
	 * Controls how far down you can look
	*/
	MinPitch: number;
	/**
	 * Controls how far up you can look
	*/
	MaxPitch: number;
	/**
	 * Controls walking deceleration.
	*/
	WalkingFriction: number;
	/**
	 * How fast the character can walk.
	*/
	WalkingSpeed: number;
	/**
	 * How fast the character accelerates.
	*/
	WalkingAcceleration: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ArchVisCharMovementComponent;
	static Find(Outer: UObject, ResourceName: string): ArchVisCharMovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ArchVisCharMovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArchVisCharMovementComponent;
	static C(Other: UObject): ArchVisCharMovementComponent;
}

declare class ComponentReference { 
	/**
	 * Pointer to a different Actor that owns the Component.
	*/
	OtherActor: Actor;
	/**
	 * Name of component property to use
	*/
	ComponentProperty: string;
	clone() : ComponentReference;
	static C(Other: UObject): ComponentReference;
}

declare class CableComponent extends MeshComponent { 
	/**
	 * Actor or Component that the end of the cable should be attached to
	*/
	AttachEndTo: ComponentReference;
	/**
	 * End location of cable, relative to AttachEndTo if specified, otherwise relative to cable component.
	*/
	EndLocation: Vector;
	/**
	 * Rest length of the cable
	*/
	CableLength: number;
	/**
	 * How many segments the cable has
	*/
	NumSegments: number;
	/**
	 * Controls the simulation substep time for the cable
	*/
	SubstepTime: number;
	/**
	 * The number of solver iterations controls how 'stiff' the cable is
	*/
	SolverIterations: number;
	/**
	 * How wide the cable geometry is
	*/
	CableWidth: number;
	/**
	 * Number of sides of the cable geometry
	*/
	NumSides: number;
	/**
	 * How many times to repeat the material along the length of the cable
	*/
	TileMaterial: number;
	/**
	 * Axis (in component space) that is used when building cable mesh geometry. Should be orthogonal to cable direction.
	*/
	CableUpDir: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CableComponent;
	static Find(Outer: UObject, ResourceName: string): CableComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CableComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CableComponent;
	/**
	 * Attaches the end of the cable to a specific Component within an Actor *
	*/
	SetAttachEndTo(Actor: Actor,ComponentProperty: string): void;
	/**
	 * Gets the specific USceneComponent that the cable is attached to *
	*/
	GetAttachedComponent(): SceneComponent;
	/**
	 * Gets the Actor that the cable is attached to *
	*/
	GetAttachedActor(): Actor;
	static C(Other: UObject): CableComponent;
}

declare class CableActor extends Actor { 
	/**
	 * Cable component that performs simulation and rendering
	*/
	CableComponent: CableComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CableActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CableActor;
	static C(Other: UObject): CableActor;
}

