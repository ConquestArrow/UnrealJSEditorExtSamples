declare function gc() : void;
declare type UnrealEngineClass = any;
declare type timeout_handle = any;
declare function setTimeout(fn : (milliseconds: number) => void, timeout : number) : timeout_handle;
declare function clearTimeout(handle : timeout_handle) : void;
declare class UnrealEngineMulticastDelegate<T> {
	Add(fn : T): void;
	Remove(fn : T): void;
}

declare class UnrealEngineDelegate<T> {
	Add(fn : T): void;
	Remove(fn : T): void;
}

declare class Process {
	nextTick(fn : (number) => void): void;
}

declare var process : Process;

declare class Memory {
	exec(ab : ArrayBuffer, fn : (ab : ArrayBuffer) => void): void;
	access(obj : JavascriptMemoryObject): ArrayBuffer;
}

declare var memory : Memory;

declare class Field extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Field;
	static Find(Outer: UObject, ResourceName: string): Field;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Field;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Field;
	static C(Other: UObject): Field;
	/**
	 * Get Meta Data
	*/
	GetMetaData(Key: string): string;
	/**
	 * Get Meta Data
	*/
	static GetMetaData(Field: Field,Key: string): string;
}

declare class Enum extends Field { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Enum;
	static Find(Outer: UObject, ResourceName: string): Enum;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Enum;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Enum;
	static C(Other: UObject): Enum;
	/**
	 * Gets enumerator name.
	 * @param Enum - Enumeration
	 * @param EnumeratorValue - Value of searched enumeration
	 * @return - name of the searched enumerator, or NAME_None
	*/
	GetEnumeratorName(EnumeratorValue: number): string;
	/**
	 * Gets enumerator name as FString. Use DeisplayName when possible.
	 * @param Enum - Enumeration
	 * @param EnumeratorValue - Value of searched enumeration
	 * @return - name of the searched enumerator, or NAME_None
	*/
	GetEnumeratorUserFriendlyName(EnumeratorValue: number): string;
	/**
	 * @param Enum - Enumeration
	 * @param EnumeratorIndex - Input index
	 * @return - The value of the enumerator, or INDEX_NONE
	*/
	GetEnumeratorValueFromIndex(EnumeratorIndex: number): number;
	/**
	 * @param Enum - Enumeration
	 * @param EnumeratorIndex - Input value
	 * @return - if EnumeratorIndex is valid return EnumeratorIndex, otherwise return MAX value of Enum
	*/
	GetValidValue(EnumeratorValue: number): number;
	/**
	 * Gets enumerator name.
	 * @param Enum - Enumeration
	 * @param EnumeratorValue - Value of searched enumeration
	 * @return - name of the searched enumerator, or NAME_None
	*/
	static GetEnumeratorName(Enum: Enum,EnumeratorValue: number): string;
	/**
	 * Gets enumerator name as FString. Use DeisplayName when possible.
	 * @param Enum - Enumeration
	 * @param EnumeratorValue - Value of searched enumeration
	 * @return - name of the searched enumerator, or NAME_None
	*/
	static GetEnumeratorUserFriendlyName(Enum: Enum,EnumeratorValue: number): string;
	/**
	 * @param Enum - Enumeration
	 * @param EnumeratorIndex - Input index
	 * @return - The value of the enumerator, or INDEX_NONE
	*/
	static GetEnumeratorValueFromIndex(Enum: Enum,EnumeratorIndex: number): number;
	/**
	 * @param Enum - Enumeration
	 * @param EnumeratorIndex - Input value
	 * @return - if EnumeratorIndex is valid return EnumeratorIndex, otherwise return MAX value of Enum
	*/
	static GetValidValue(Enum: Enum,EnumeratorValue: number): number;
}

declare class LayerActorStats { 
	/**
	 * A Type of Actor currently associated with the Layer
	*/
	Type: UnrealEngineClass;
	/**
	 * The total number of Actors of Type assigned to the Layer
	*/
	Total: number;
	clone() : LayerActorStats;
	static C(Other: UObject): LayerActorStats;
}

declare class Layer extends UObject { 
	/**
	 * The display name of the layer
	*/
	LayerName: string;
	/**
	 * Whether actors associated with the layer are visible in the viewport
	*/
	bIsVisible: boolean;
	/**
	 * Basic stats regarding the number of Actors and their types currently assigned to the Layer
	*/
	ActorStats: LayerActorStats[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Layer;
	static Find(Outer: UObject, ResourceName: string): Layer;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Layer;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Layer;
	static C(Other: UObject): Layer;
}

declare type ETickingGroup = string | symbol;
declare var ETickingGroup = { TG_PrePhysics:'TG_PrePhysics',TG_StartPhysics:'TG_StartPhysics',TG_DuringPhysics:'TG_DuringPhysics',TG_EndPhysics:'TG_EndPhysics',TG_PostPhysics:'TG_PostPhysics',TG_PostUpdateWork:'TG_PostUpdateWork',TG_LastDemotable:'TG_LastDemotable',TG_NewlySpawned:'TG_NewlySpawned', };
declare class TickFunction { 
	/**
	 * Defines the minimum tick group for this tick function. These groups determine the relative order of when objects tick during a frame update.
	 * Given prerequisites, the tick may be delayed.
	 * @see ETickingGroup
	 * @see FTickFunction::AddPrerequisite()
	*/
	TickGroup: ETickingGroup;
	/**
	 * Defines the tick group that this tick function must finish in. These groups determine the relative order of when objects tick during a frame update.
	 * @see ETickingGroup
	*/
	EndTickGroup: ETickingGroup;
	/**
	 * Bool indicating that this function should execute even if the game is paused. Pause ticks are very limited in capabilities. *
	*/
	bTickEvenWhenPaused: boolean;
	/**
	 * If false, this tick function will never be registered and will never tick. Only settable in defaults.
	*/
	bCanEverTick: boolean;
	/**
	 * If true, this tick function will start enabled, but can be disabled later on.
	*/
	bStartWithTickEnabled: boolean;
	/**
	 * If we allow this tick to run on a dedicated server
	*/
	bAllowTickOnDedicatedServer: boolean;
	/**
	 * The frequency in seconds at which this tick function will be executed.  If less than or equal to 0 then it will tick every frame
	*/
	TickInterval: number;
	clone() : TickFunction;
	static C(Other: UObject): TickFunction;
}

declare class ActorTickFunction extends TickFunction { 
	clone() : ActorTickFunction;
	static C(Other: UObject): ActorTickFunction;
}

declare type ENetRole = string | symbol;
declare var ENetRole = { ROLE_None:'ROLE_None',ROLE_SimulatedProxy:'ROLE_SimulatedProxy',ROLE_AutonomousProxy:'ROLE_AutonomousProxy',ROLE_Authority:'ROLE_Authority', };
declare class Vector2D { 
	/**
	 * X
	*/
	X: number;
	/**
	 * Y
	*/
	Y: number;
	clone() : Vector2D;
	static C(Other: UObject): Vector2D;
	/**
	 * Set Canvas Material Scale And Position
	*/
	SetCanvasMaterialScaleandPosition(Position: Vector2D,Scale: number,__WorldContext: UObject,ScreenPosition?: Vector2D,ScreenSize?: Vector2D): {Screen Position: Vector2D, Screen Size: Vector2D};
	/**
	 * Set Canvas Material Scale And Position
	*/
	SetCanvasMaterialScaleandPosition(Position: Vector2D,Scale: number,__WorldContext: UObject,ScreenPosition?: Vector2D,ScreenSize?: Vector2D): {Screen Position: Vector2D, Screen Size: Vector2D};
	/**
	 * Converts a vector2d value to a localizable text, in the form 'X= Y='
	*/
	ToText(): string;
	/**
	 * Converts a vector2d value to a string, in the form 'X= Y='
	*/
	ToString(): string;
	/**
	 * Returns Vector A added by B
	*/
	Add_Vector2DFloat(B: number): Vector2D;
	/**
	 * Returns addition of Vector A and Vector B (A + B)
	*/
	Add_Vector2DVector2D(B: Vector2D): Vector2D;
	/**
	 * Breaks a 2D vector apart into X, Y.
	*/
	BreakVector2D(X?: number,Y?: number): {X: number, Y: number};
	/**
	 * Convert a Vector2D to a Vector
	*/
	ToVector(Z: number): Vector;
	/**
	 * Returns the cross product of two 2d vectors
	*/
	CrossProduct(B: Vector2D): number;
	/**
	 * Returns Vector A divided by B
	*/
	Divide_Vector2DFloat(B: number): Vector2D;
	/**
	 * Returns the dot product of two 2d vectors
	*/
	DotProduct(B: Vector2D): number;
	/**
	 * Returns true if vector2D A is equal to vector2D B (A == B) within a specified error tolerance
	*/
	Equal(B: Vector2D,ErrorTolerance: number): boolean;
	/**
	 * Returns Vector A scaled by B
	*/
	Multiply_Vector2DFloat(B: number): Vector2D;
	/**
	 * Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y})
	*/
	Multiply_Vector2DVector2D(B: Vector2D): Vector2D;
	/**
	 * Returns a unit normal version of the vector2d A
	*/
	Normalize2D(): Vector2D;
	/**
	 * Returns true if vector2D A is not equal to vector2D B (A != B) within a specified error tolerance
	*/
	NotEqual(B: Vector2D,ErrorTolerance: number): boolean;
	/**
	 * Returns Vector A subtracted by B
	*/
	Subtract_Vector2DFloat(B: number): Vector2D;
	/**
	 * Returns subtraction of Vector B from Vector A (A - B)
	*/
	Subtract_Vector2DVector2D(B: Vector2D): Vector2D;
	/**
	 * Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
	 * @param               Current                 Actual position
	 * @param               Target                  Target position
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	Vector2DInterpTo(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	/**
	 * Tries to reach Target at a constant rate.
	 * @param               Current                 Actual position
	 * @param               Target                  Target position
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	Vector2DInterpTo_Constant(Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	/**
	 * Returns the length of a 2d FVector.
	*/
	Vector2dLength(): number;
	/**
	 * Returns the squared length of a 2d FVector.
	*/
	Vector2dLengthSquared(): number;
	/**
	 * Set Canvas Material Scale And Position
	*/
	static SetCanvasMaterialScaleandPosition(Size: Vector2D,Position: Vector2D,Scale: number,__WorldContext: UObject,ScreenPosition?: Vector2D,ScreenSize?: Vector2D): {Screen Position: Vector2D, Screen Size: Vector2D};
	/**
	 * Set Canvas Material Scale And Position
	*/
	static SetCanvasMaterialScaleandPosition(Size: Vector2D,Position: Vector2D,Scale: number,__WorldContext: UObject,ScreenPosition?: Vector2D,ScreenSize?: Vector2D): {Screen Position: Vector2D, Screen Size: Vector2D};
	/**
	 * Converts a vector2d value to a localizable text, in the form 'X= Y='
	*/
	static ToText(InVec: Vector2D): string;
	/**
	 * Converts a vector2d value to a string, in the form 'X= Y='
	*/
	static ToString(InVec: Vector2D): string;
	/**
	 * Returns Vector A added by B
	*/
	static Add_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	/**
	 * Returns addition of Vector A and Vector B (A + B)
	*/
	static Add_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	/**
	 * Breaks a 2D vector apart into X, Y.
	*/
	static BreakVector2D(InVec: Vector2D,X?: number,Y?: number): {X: number, Y: number};
	/**
	 * Convert a Vector2D to a Vector
	*/
	static ToVector(InVector2D: Vector2D,Z: number): Vector;
	/**
	 * Returns the cross product of two 2d vectors
	*/
	static CrossProduct(A: Vector2D,B: Vector2D): number;
	/**
	 * Returns Vector A divided by B
	*/
	static Divide_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	/**
	 * Returns the dot product of two 2d vectors
	*/
	static DotProduct(A: Vector2D,B: Vector2D): number;
	/**
	 * Returns true if vector2D A is equal to vector2D B (A == B) within a specified error tolerance
	*/
	static Equal(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	/**
	 * Returns Vector A scaled by B
	*/
	static Multiply_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	/**
	 * Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y})
	*/
	static Multiply_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	/**
	 * Returns a unit normal version of the vector2d A
	*/
	static Normalize2D(A: Vector2D): Vector2D;
	/**
	 * Returns true if vector2D A is not equal to vector2D B (A != B) within a specified error tolerance
	*/
	static NotEqual(A: Vector2D,B: Vector2D,ErrorTolerance: number): boolean;
	/**
	 * Returns Vector A subtracted by B
	*/
	static Subtract_Vector2DFloat(A: Vector2D,B: number): Vector2D;
	/**
	 * Returns subtraction of Vector B from Vector A (A - B)
	*/
	static Subtract_Vector2DVector2D(A: Vector2D,B: Vector2D): Vector2D;
	/**
	 * Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
	 * @param               Current                 Actual position
	 * @param               Target                  Target position
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	static Vector2DInterpTo(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	/**
	 * Tries to reach Target at a constant rate.
	 * @param               Current                 Actual position
	 * @param               Target                  Target position
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	static Vector2DInterpTo_Constant(Current: Vector2D,Target: Vector2D,DeltaTime: number,InterpSpeed: number): Vector2D;
	/**
	 * Returns the length of a 2d FVector.
	*/
	static Vector2dLength(A: Vector2D): number;
	/**
	 * Returns the squared length of a 2d FVector.
	*/
	static Vector2dLengthSquared(A: Vector2D): number;
	/**
	 * Generate Dynamic Image Resource
	*/
	static GenerateDynamicImageResource(InDynamicBrushName: string): Vector2D;
	/**
	 * Makes a 2d vector {X, Y}
	*/
	static MakeVector2D(X: number,Y: number): Vector2D;
}

declare class ProcMeshTangent { 
	/**
	 * Direction of X tangent for this vertex
	*/
	TangentX: Vector;
	/**
	 * Bool that indicates whether we should flip the Y tangent when we compute it using cross product
	*/
	bFlipTangentY: boolean;
	clone() : ProcMeshTangent;
	static C(Other: UObject): ProcMeshTangent;
}

declare class Color { 
	/**
	 * B
	*/
	B: number;
	/**
	 * G
	*/
	G: number;
	/**
	 * R
	*/
	R: number;
	/**
	 * A
	*/
	A: number;
	clone() : Color;
	static C(Other: UObject): Color;
	/**
	 * Converts a color to LinearColor
	*/
	ToLinearColor(): LinearColor;
	/**
	 * Converts a color to LinearColor
	*/
	static ToLinearColor(InColor: Color): LinearColor;
}

declare class LinearColor { 
	/**
	 * R
	*/
	R: number;
	/**
	 * G
	*/
	G: number;
	/**
	 * B
	*/
	B: number;
	/**
	 * A
	*/
	A: number;
	clone() : LinearColor;
	static C(Other: UObject): LinearColor;
	/**
	 * Converts a linear color value to a localizable text, in the form '(R=,G=,B=,A=)'
	*/
	ToText(): string;
	/**
	 * Converts a linear color value to a string, in the form '(R=,G=,B=,A=)'
	*/
	ToString(): string;
	/**
	 * Breaks apart a color into individual RGB components (as well as alpha)
	*/
	BreakColor(R?: number,G?: number,B?: number,A?: number): {R: number, G: number, B: number, A: number};
	/**
	 * Interpolates towards a varying target color smoothly.
	 * @param               Current                 Current Color
	 * @param               Target                  Target Color
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated Color
	*/
	CInterpTo(Target: LinearColor,DeltaTime: number,InterpSpeed: number): LinearColor;
	/**
	 * Converts a LinearColor to a color
	*/
	ToColor(): Color;
	/**
	 * Converts a LinearColor to a vector
	*/
	ToVector(): Vector;
	/**
	 * Converts a HSV linear color (where H is in R, S is in G, and V is in B) to RGB
	*/
	HSVtoRGB(RGB?: LinearColor): {RGB: LinearColor};
	/**
	 * Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
	*/
	Lerp(B: LinearColor,Alpha: number): LinearColor;
	/**
	 * Linearly interpolates between two colors by the specified Alpha amount (100% of A when Alpha=0 and 100% of B when Alpha=1).  The interpolation is performed in HSV color space taking the shortest path to the new color's hue.  This can give better results than a normal lerp, but is much more expensive.  The incoming colors are in RGB space, and the output color will be RGB.  The alpha value will also be interpolated.
	 * @param       A               The color and alpha to interpolate from as linear RGBA
	 * @param       B               The color and alpha to interpolate to as linear RGBA
	 * @param       Alpha   Scalar interpolation amount (usually between 0.0 and 1.0 inclusive)
	 * @return      The interpolated color in linear RGB space along with the interpolated alpha value
	*/
	LerpUsingHSV(B: LinearColor,Alpha: number): LinearColor;
	/**
	 * Element-wise multiplication of a linear color by a float (F*R, F*G, F*B, F*A)
	*/
	Multiply_LinearColorFloat(B: number): LinearColor;
	/**
	 * Element-wise multiplication of two linear colors (R*R, G*G, B*B, A*A)
	*/
	Multiply_LinearColorLinearColor(B: LinearColor): LinearColor;
	/**
	 * Breaks apart a color into individual HSV components (as well as alpha)
	*/
	RGBToHSV(H?: number,S?: number,V?: number,A?: number): {H: number, S: number, V: number, A: number};
	/**
	 * Converts a RGB linear color to HSV (where H is in R, S is in G, and V is in B)
	*/
	RGBtoHSV(HSV?: LinearColor): {HSV: LinearColor};
	/**
	 * If bPickA is true, A is returned, otherwise B is
	*/
	SelectColor(B: LinearColor,bPickA: boolean): LinearColor;
	/**
	 * Converts a linear color value to a localizable text, in the form '(R=,G=,B=,A=)'
	*/
	static ToText(InColor: LinearColor): string;
	/**
	 * Converts a linear color value to a string, in the form '(R=,G=,B=,A=)'
	*/
	static ToString(InColor: LinearColor): string;
	/**
	 * Breaks apart a color into individual RGB components (as well as alpha)
	*/
	static BreakColor(InColor: LinearColor,R?: number,G?: number,B?: number,A?: number): {R: number, G: number, B: number, A: number};
	/**
	 * Interpolates towards a varying target color smoothly.
	 * @param               Current                 Current Color
	 * @param               Target                  Target Color
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated Color
	*/
	static CInterpTo(Current: LinearColor,Target: LinearColor,DeltaTime: number,InterpSpeed: number): LinearColor;
	/**
	 * Converts a LinearColor to a color
	*/
	static ToColor(InLinearColor: LinearColor): Color;
	/**
	 * Converts a LinearColor to a vector
	*/
	static ToVector(InLinearColor: LinearColor): Vector;
	/**
	 * Converts a HSV linear color (where H is in R, S is in G, and V is in B) to RGB
	*/
	static HSVtoRGB(HSV: LinearColor,RGB?: LinearColor): {RGB: LinearColor};
	/**
	 * Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
	*/
	static Lerp(A: LinearColor,B: LinearColor,Alpha: number): LinearColor;
	/**
	 * Linearly interpolates between two colors by the specified Alpha amount (100% of A when Alpha=0 and 100% of B when Alpha=1).  The interpolation is performed in HSV color space taking the shortest path to the new color's hue.  This can give better results than a normal lerp, but is much more expensive.  The incoming colors are in RGB space, and the output color will be RGB.  The alpha value will also be interpolated.
	 * @param       A               The color and alpha to interpolate from as linear RGBA
	 * @param       B               The color and alpha to interpolate to as linear RGBA
	 * @param       Alpha   Scalar interpolation amount (usually between 0.0 and 1.0 inclusive)
	 * @return      The interpolated color in linear RGB space along with the interpolated alpha value
	*/
	static LerpUsingHSV(A: LinearColor,B: LinearColor,Alpha: number): LinearColor;
	/**
	 * Element-wise multiplication of a linear color by a float (F*R, F*G, F*B, F*A)
	*/
	static Multiply_LinearColorFloat(A: LinearColor,B: number): LinearColor;
	/**
	 * Element-wise multiplication of two linear colors (R*R, G*G, B*B, A*A)
	*/
	static Multiply_LinearColorLinearColor(A: LinearColor,B: LinearColor): LinearColor;
	/**
	 * Breaks apart a color into individual HSV components (as well as alpha)
	*/
	static RGBToHSV(InColor: LinearColor,H?: number,S?: number,V?: number,A?: number): {H: number, S: number, V: number, A: number};
	/**
	 * Converts a RGB linear color to HSV (where H is in R, S is in G, and V is in B)
	*/
	static RGBtoHSV(RGB: LinearColor,HSV?: LinearColor): {HSV: LinearColor};
	/**
	 * If bPickA is true, A is returned, otherwise B is
	*/
	static SelectColor(A: LinearColor,B: LinearColor,bPickA: boolean): LinearColor;
	/**
	 * Convert a float into a LinearColor, where each element is that float
	*/
	static ToLinearColor(InFloat: number): LinearColor;
	/**
	 * Make a color from individual color components (HSV space)
	*/
	static HSVToRGB(H: number,S: number,V: number,A: number): LinearColor;
	/**
	 * Make a color from individual color components (RGB space)
	*/
	static MakeColor(R: number,G: number,B: number,A: number): LinearColor;
}

declare type EOrientPositionSelector = string | symbol;
declare var EOrientPositionSelector = { Orientation:'Orientation',Position:'Position',OrientationAndPosition:'OrientationAndPosition', };
declare type EEasingFunc = string | symbol;
declare var EEasingFunc = { Linear:'Linear',Step:'Step',SinusoidalIn:'SinusoidalIn',SinusoidalOut:'SinusoidalOut',SinusoidalInOut:'SinusoidalInOut',EaseIn:'EaseIn',EaseOut:'EaseOut',EaseInOut:'EaseInOut',ExpoIn:'ExpoIn',ExpoOut:'ExpoOut',ExpoInOut:'ExpoInOut',CircularIn:'CircularIn',CircularOut:'CircularOut',CircularInOut:'CircularInOut', };
declare class RandomStream { 
	/**
	 * Initial Seed
	*/
	InitialSeed: number;
	/**
	 * Seed
	*/
	Seed: number;
	clone() : RandomStream;
	static C(Other: UObject): RandomStream;
	/**
	 * Breaks apart a random number generator
	*/
	BreakRandomStream(InitialSeed?: number): {InitialSeed: number};
	/**
	 * Returns a random bool
	*/
	RandomBoolFromStream(): boolean;
	/**
	 * Returns a random float between 0 and 1
	*/
	RandomFloatFromStream(): number;
	/**
	 * Returns a random vector with length of 1.0
	*/
	RandomUnitVectorFromStream(): Vector;
	/**
	 * Reset a random stream
	*/
	ResetRandomStream(): void;
	/**
	 * Create a new random seed for a random stream
	*/
	SeedRandomStream(): {Stream: RandomStream};
	/**
	 * Set the seed of a random stream to a specific number
	*/
	SetRandomStreamSeed(NewSeed?: number): {Stream: RandomStream};
	/**
	 * Breaks apart a random number generator
	*/
	static BreakRandomStream(InRandomStream: RandomStream,InitialSeed?: number): {InitialSeed: number};
	/**
	 * Returns a random bool
	*/
	static RandomBoolFromStream(Stream: RandomStream): boolean;
	/**
	 * Returns a random float between 0 and 1
	*/
	static RandomFloatFromStream(Stream: RandomStream): number;
	/**
	 * Returns a random vector with length of 1.0
	*/
	static RandomUnitVectorFromStream(Stream: RandomStream): Vector;
	/**
	 * Reset a random stream
	*/
	static ResetRandomStream(Stream: RandomStream): void;
	/**
	 * Create a new random seed for a random stream
	*/
	static SeedRandomStream(Stream?: RandomStream): {Stream: RandomStream};
	/**
	 * Set the seed of a random stream to a specific number
	*/
	static SetRandomStreamSeed(Stream?: RandomStream,NewSeed?: number): {Stream: RandomStream};
	/**
	 * Makes a SRand-based random number generator
	*/
	static MakeRandomStream(InitialSeed: number): RandomStream;
}

declare class Rotator { 
	/**
	 * Pitch (degrees) around Y axis
	*/
	Pitch: number;
	/**
	 * Yaw (degrees) around Z axis
	*/
	Yaw: number;
	/**
	 * Roll (degrees) around X axis
	*/
	Roll: number;
	clone() : Rotator;
	static C(Other: UObject): Rotator;
	/**
	 * Returns current base rotation and base offset.
	 * The base offset is currently used base position offset, previously set by the
	 * ResetPosition or SetBasePositionOffset calls. It represents a vector that translates the HMD's position
	 * into (0,0,0) point, in meters.
	 * The axis of the vector are the same as in Unreal: X - forward, Y - right, Z - up.
	 * @param OutRotation                    (out) Rotator object with base rotation
	 * @param OutBaseOffsetInMeters  (out) base position offset, vector, in meters.
	*/
	GetBaseRotationAndBaseOffsetInMeters(OutBaseOffsetInMeters?: Vector): {OutRotation: Rotator, OutBaseOffsetInMeters: Vector};
	/**
	 * Returns current base rotation and position offset.
	 * @param OutRot                        (out) Rotator object with base rotation
	 * @param OutPosOffset          (out) the vector with previously set position offset.
	*/
	GetBaseRotationAndPositionOffset(OutPosOffset?: Vector): {OutRot: Rotator, OutPosOffset: Vector};
	/**
	 * Grabs the current orientation and position for the HMD.  If positional tracking is not available, DevicePosition will be a zero vector
	 * @param DeviceRotation        (out) The device's current rotation
	 * @param DevicePosition        (out) The device's current position, in its own tracking space
	 * @param NeckPosition          (out) The estimated neck position, calculated using NeckToEye vector from User Profile. Same coordinate space as DevicePosition.
	 * @param bUseOrienationForPlayerCamera (in) Should be set to 'true' if the orientation is going to be used to update orientation of the camera manually.
	 * @param bUsePositionForPlayerCamera   (in) Should be set to 'true' if the position is going to be used to update position of the camera manually.
	 * @param PositionScale         (in) The 3D scale that will be applied to position.
	*/
	GetPose(DevicePosition?: Vector,NeckPosition?: Vector,bUseOrienationForPlayerCamera?: boolean,bUsePositionForPlayerCamera?: boolean,PositionScale?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector, NeckPosition: Vector};
	/**
	 * Sets 'base rotation' - the rotation that will be subtracted from
	 * the actual HMD orientation.
	 * Sets base position offset (in meters). The base position offset is the distance from the physical (0, 0, 0) position
	 * to current HMD position (bringing the (0, 0, 0) point to the current HMD position)
	 * Note, this vector is set by ResetPosition call; use this method with care.
	 * The axis of the vector are the same as in Unreal: X - forward, Y - right, Z - up.
	 * @param Rotation                       (in) Rotator object with base rotation
	 * @param BaseOffsetInMeters (in) the vector to be set as base offset, in meters.
	 * @param Options                        (in) specifies either position, orientation or both should be set.
	*/
	SetBaseRotationAndBaseOffsetInMeters(BaseOffsetInMeters: Vector,Options: EOrientPositionSelector): void;
	/**
	 * Sets 'base rotation' - the rotation that will be subtracted from
	 * the actual HMD orientation.
	 * The position offset might be added to current HMD position,
	 * effectively moving the virtual camera by the specified offset. The addition
	 * occurs after the HMD orientation and position are applied.
	 * @param BaseRot                       (in) Rotator object with base rotation
	 * @param PosOffset                     (in) the vector to be added to HMD position.
	 * @param Options                       (in) specifies either position, orientation or both should be set.
	*/
	SetBaseRotationAndPositionOffset(PosOffset: Vector,Options: EOrientPositionSelector): void;
	/**
	 * Converts a rotator value to a localizable text, in the form 'P= Y= R='
	*/
	ToText(): string;
	/**
	 * Converts a rotator value to a string, in the form 'P= Y= R='
	*/
	ToString(): string;
	/**
	 * Breaks apart a rotator into {Roll, Pitch, Yaw} angles in degrees
	*/
	BreakRotator(Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	/**
	 * Breaks apart a rotator into its component axes
	*/
	BreakRotIntoAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	/**
	 * Combine 2 rotations to give you the resulting rotation
	*/
	CombineRotators(B: Rotator): Rotator;
	/**
	 * Get the X direction vector after this rotation
	*/
	GetRotationXVector(): Vector;
	/**
	 * Returns true if rotator A is equal to rotator B (A == B) within a specified error tolerance
	*/
	Equal(B: Rotator,ErrorTolerance: number): boolean;
	/**
	 * Get the reference frame direction vectors (axes) described by this rotation
	*/
	GetAxes(X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	/**
	 * Rotate the world forward vector by the given rotation
	*/
	GetForwardVector(): Vector;
	/**
	 * Rotate the world right vector by the given rotation
	*/
	GetRightVector(): Vector;
	/**
	 * Rotate the world up vector by the given rotation
	*/
	GetUpVector(): Vector;
	/**
	 * Returns rotator representing rotator A scaled by B
	*/
	ScaleRotator(B: number): Rotator;
	/**
	 * Returns rotator representing rotator A scaled by B
	*/
	ScaleRotator(B: number): Rotator;
	/**
	 * Negate a rotator
	*/
	InvertRotator(): Rotator;
	/**
	 * Normalized A-B
	*/
	Delta(B: Rotator): Rotator;
	/**
	 * Returns true if rotator A is not equal to rotator B (A != B) within a specified error tolerance
	*/
	NotEqual(B: Rotator,ErrorTolerance: number): boolean;
	/**
	 * Easeing  between A and B using a specified easing function
	*/
	Ease(B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	/**
	 * Tries to reach Target rotation based on Current rotation, giving a nice smooth feeling when rotating to Target rotation.
	 * @param               Current                 Actual rotation
	 * @param               Target                  Target rotation
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	RInterpTo(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	/**
	 * Tries to reach Target rotation at a constant rate.
	 * @param               Current                 Actual rotation
	 * @param               Target                  Target rotation
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	RInterpTo_Constant(Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	/**
	 * Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
	*/
	Lerp(B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	/**
	 * If bPickA is true, A is returned, otherwise B is
	*/
	SelectRotator(B: Rotator,bPickA: boolean): Rotator;
	/**
	 * Grabs the current orientation and position for the HMD.  If positional tracking is not available, DevicePosition will be a zero vector
	 * @param DeviceRotation        (out) The device's current rotation
	 * @param DevicePosition        (out) The device's current position, in its own tracking space
	*/
	GetOrientationAndPosition(DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	/**
	 * Is Valid AIRotation
	*/
	IsValidAIRotation(): boolean;
	/**
	 * Returns current base rotation and base offset.
	 * The base offset is currently used base position offset, previously set by the
	 * ResetPosition or SetBasePositionOffset calls. It represents a vector that translates the HMD's position
	 * into (0,0,0) point, in meters.
	 * The axis of the vector are the same as in Unreal: X - forward, Y - right, Z - up.
	 * @param OutRotation                    (out) Rotator object with base rotation
	 * @param OutBaseOffsetInMeters  (out) base position offset, vector, in meters.
	*/
	static GetBaseRotationAndBaseOffsetInMeters(OutRotation?: Rotator,OutBaseOffsetInMeters?: Vector): {OutRotation: Rotator, OutBaseOffsetInMeters: Vector};
	/**
	 * Returns current base rotation and position offset.
	 * @param OutRot                        (out) Rotator object with base rotation
	 * @param OutPosOffset          (out) the vector with previously set position offset.
	*/
	static GetBaseRotationAndPositionOffset(OutRot?: Rotator,OutPosOffset?: Vector): {OutRot: Rotator, OutPosOffset: Vector};
	/**
	 * Grabs the current orientation and position for the HMD.  If positional tracking is not available, DevicePosition will be a zero vector
	 * @param DeviceRotation        (out) The device's current rotation
	 * @param DevicePosition        (out) The device's current position, in its own tracking space
	 * @param NeckPosition          (out) The estimated neck position, calculated using NeckToEye vector from User Profile. Same coordinate space as DevicePosition.
	 * @param bUseOrienationForPlayerCamera (in) Should be set to 'true' if the orientation is going to be used to update orientation of the camera manually.
	 * @param bUsePositionForPlayerCamera   (in) Should be set to 'true' if the position is going to be used to update position of the camera manually.
	 * @param PositionScale         (in) The 3D scale that will be applied to position.
	*/
	static GetPose(DeviceRotation?: Rotator,DevicePosition?: Vector,NeckPosition?: Vector,bUseOrienationForPlayerCamera?: boolean,bUsePositionForPlayerCamera?: boolean,PositionScale?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector, NeckPosition: Vector};
	/**
	 * Sets 'base rotation' - the rotation that will be subtracted from
	 * the actual HMD orientation.
	 * Sets base position offset (in meters). The base position offset is the distance from the physical (0, 0, 0) position
	 * to current HMD position (bringing the (0, 0, 0) point to the current HMD position)
	 * Note, this vector is set by ResetPosition call; use this method with care.
	 * The axis of the vector are the same as in Unreal: X - forward, Y - right, Z - up.
	 * @param Rotation                       (in) Rotator object with base rotation
	 * @param BaseOffsetInMeters (in) the vector to be set as base offset, in meters.
	 * @param Options                        (in) specifies either position, orientation or both should be set.
	*/
	static SetBaseRotationAndBaseOffsetInMeters(Rotation: Rotator,BaseOffsetInMeters: Vector,Options: EOrientPositionSelector): void;
	/**
	 * Sets 'base rotation' - the rotation that will be subtracted from
	 * the actual HMD orientation.
	 * The position offset might be added to current HMD position,
	 * effectively moving the virtual camera by the specified offset. The addition
	 * occurs after the HMD orientation and position are applied.
	 * @param BaseRot                       (in) Rotator object with base rotation
	 * @param PosOffset                     (in) the vector to be added to HMD position.
	 * @param Options                       (in) specifies either position, orientation or both should be set.
	*/
	static SetBaseRotationAndPositionOffset(BaseRot: Rotator,PosOffset: Vector,Options: EOrientPositionSelector): void;
	/**
	 * Converts a rotator value to a localizable text, in the form 'P= Y= R='
	*/
	static ToText(InRot: Rotator): string;
	/**
	 * Converts a rotator value to a string, in the form 'P= Y= R='
	*/
	static ToString(InRot: Rotator): string;
	/**
	 * Breaks apart a rotator into {Roll, Pitch, Yaw} angles in degrees
	*/
	static BreakRotator(InRot: Rotator,Roll?: number,Pitch?: number,Yaw?: number): {Roll: number, Pitch: number, Yaw: number};
	/**
	 * Breaks apart a rotator into its component axes
	*/
	static BreakRotIntoAxes(InRot: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	/**
	 * Combine 2 rotations to give you the resulting rotation
	*/
	static CombineRotators(A: Rotator,B: Rotator): Rotator;
	/**
	 * Get the X direction vector after this rotation
	*/
	static GetRotationXVector(InRot: Rotator): Vector;
	/**
	 * Returns true if rotator A is equal to rotator B (A == B) within a specified error tolerance
	*/
	static Equal(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	/**
	 * Get the reference frame direction vectors (axes) described by this rotation
	*/
	static GetAxes(A: Rotator,X?: Vector,Y?: Vector,Z?: Vector): {X: Vector, Y: Vector, Z: Vector};
	/**
	 * Rotate the world forward vector by the given rotation
	*/
	static GetForwardVector(InRot: Rotator): Vector;
	/**
	 * Rotate the world right vector by the given rotation
	*/
	static GetRightVector(InRot: Rotator): Vector;
	/**
	 * Rotate the world up vector by the given rotation
	*/
	static GetUpVector(InRot: Rotator): Vector;
	/**
	 * Returns rotator representing rotator A scaled by B
	*/
	static ScaleRotator(A: Rotator,B: number): Rotator;
	/**
	 * Returns rotator representing rotator A scaled by B
	*/
	static ScaleRotator(A: Rotator,B: number): Rotator;
	/**
	 * Negate a rotator
	*/
	static InvertRotator(A: Rotator): Rotator;
	/**
	 * Normalized A-B
	*/
	static Delta(A: Rotator,B: Rotator): Rotator;
	/**
	 * Returns true if rotator A is not equal to rotator B (A != B) within a specified error tolerance
	*/
	static NotEqual(A: Rotator,B: Rotator,ErrorTolerance: number): boolean;
	/**
	 * Easeing  between A and B using a specified easing function
	*/
	static Ease(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Rotator;
	/**
	 * Tries to reach Target rotation based on Current rotation, giving a nice smooth feeling when rotating to Target rotation.
	 * @param               Current                 Actual rotation
	 * @param               Target                  Target rotation
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	static RInterpTo(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	/**
	 * Tries to reach Target rotation at a constant rate.
	 * @param               Current                 Actual rotation
	 * @param               Target                  Target rotation
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	static RInterpTo_Constant(Current: Rotator,Target: Rotator,DeltaTime: number,InterpSpeed: number): Rotator;
	/**
	 * Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
	*/
	static Lerp(A: Rotator,B: Rotator,Alpha: number,bShortestPath: boolean): Rotator;
	/**
	 * If bPickA is true, A is returned, otherwise B is
	*/
	static SelectRotator(A: Rotator,B: Rotator,bPickA: boolean): Rotator;
	/**
	 * Grabs the current orientation and position for the HMD.  If positional tracking is not available, DevicePosition will be a zero vector
	 * @param DeviceRotation        (out) The device's current rotation
	 * @param DevicePosition        (out) The device's current position, in its own tracking space
	*/
	static GetOrientationAndPosition(DeviceRotation?: Rotator,DevicePosition?: Vector): {DeviceRotation: Rotator, DevicePosition: Vector};
	/**
	 * Is Valid AIRotation
	*/
	static IsValidAIRotation(Rotation: Rotator): boolean;
	/**
	 * Makes a rotator {Roll, Pitch, Yaw} from rotation values supplied in degrees
	*/
	static MakeRotator(Roll: number,Pitch: number,Yaw: number): Rotator;
	/**
	 * Generates a random rotation, with optional random roll.
	*/
	static RandomRotator(bRoll: boolean): Rotator;
	/**
	 * Create a random rotation
	*/
	static RandomRotatorFromStream(bRoll: boolean,Stream: RandomStream): Rotator;
}

declare class Quat { 
	/**
	 * X
	*/
	X: number;
	/**
	 * Y
	*/
	Y: number;
	/**
	 * Z
	*/
	Z: number;
	/**
	 * W
	*/
	W: number;
	clone() : Quat;
	static C(Other: UObject): Quat;
}

declare type ELerpInterpolationMode = string | symbol;
declare var ELerpInterpolationMode = { QuatInterp:'QuatInterp',EulerInterp:'EulerInterp',DualQuatInterp:'DualQuatInterp', };
declare class Transform { 
	/**
	 * Rotation
	*/
	Rotation: Quat;
	/**
	 * Translation
	*/
	Translation: Vector;
	/**
	 * Scale 3D
	*/
	Scale3D: Vector;
	clone() : Transform;
	static C(Other: UObject): Transform;
	/**
	 * Converts a transform value to a localizable text, in the form 'Translation: X= Y= Z= Rotation: P= Y= R= Scale: X= Y= Z='
	*/
	ToText(): string;
	/**
	 * Converts a transform value to a string, in the form 'Translation: X= Y= Z= Rotation: P= Y= R= Scale: X= Y= Z='
	*/
	ToString(): string;
	/**
	 * Breaks apart a transform into location, rotation and scale
	*/
	BreakTransform(Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	/**
	 * Compose two transforms in order: A * B.
	 * Order matters when composing transforms:
	 * A * B will yield a transform that logically first applies A then B to any subsequent transformation.
	 * Example: LocalToWorld = ComposeTransforms(DeltaRotation, LocalToWorld) will change rotation in local space by DeltaRotation.
	 * Example: LocalToWorld = ComposeTransforms(LocalToWorld, DeltaRotation) will change rotation in world space by DeltaRotation.
	 * @return New transform: A * B
	*/
	ComposeTransforms(B: Transform): Transform;
	/**
	 * Returns the given transform, converted to be relative to the given ParentTransform.
	 * Example: AToB = ConvertTransformToRelative(AToWorld, BToWorld) to compute A relative to B.
	 * @param               Transform               The transform you wish to convert
	 * @param               ParentTransform The transform the conversion is relative to (in the same space as Transform)
	 * @return              The new relative transform
	*/
	ConvertTransformToRelative(ParentTransform: Transform): Transform;
	/**
	 * Returns true if transform A is equal to transform B
	*/
	EqualTransform(B: Transform): boolean;
	/**
	 * Transform a direction vector by the inverse of the supplied transform - will not change its length.
	 * For example, if T was an object's transform, would transform a direction from world space to local space.
	*/
	InverseTransformDirection(Direction: Vector): Vector;
	/**
	 * Transform a position by the inverse of the supplied transform.
	 * For example, if T was an object's transform, would transform a position from world space to local space.
	*/
	InverseTransformLocation(Location: Vector): Vector;
	/**
	 * Returns the inverse of the given transform T.
	 * Example: Given a LocalToWorld transform, WorldToLocal will be returned.
	 * @param       T       The transform you wish to invert
	 * @return      The inverse of T.
	*/
	InvertTransform(): Transform;
	/**
	 * Returns true if transform A is nearly equal to B
	 * @param LocationTolerance        How close position of transforms need to be to be considered equal
	 * @param RotationTolerance        How close rotations of transforms need to be to be considered equal
	 * @param Scale3DTolerance         How close scale of transforms need to be to be considered equal
	*/
	NearlyEqual(B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	/**
	 * If bPickA is true, A is returned, otherwise B is
	*/
	SelectTransform(B: Transform,bPickA: boolean): Transform;
	/**
	 * Ease between A and B using a specified easing function.
	*/
	Ease(B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	/**
	 * Tries to reach a target transform.
	*/
	TInterpTo(Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	/**
	 * Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1).
	*/
	Lerp(B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	/**
	 * Transform a direction vector by the supplied transform - will not change its length.
	 * For example, if T was an object's transform, would transform a direction from local space to world space.
	*/
	TransformDirection(Direction: Vector): Vector;
	/**
	 * Transform a position by the supplied transform.
	 * For example, if T was an object's transform, would transform a position from local space to world space.
	*/
	TransformLocation(Location: Vector): Vector;
	/**
	 * Converts a transform value to a localizable text, in the form 'Translation: X= Y= Z= Rotation: P= Y= R= Scale: X= Y= Z='
	*/
	static ToText(InTrans: Transform): string;
	/**
	 * Converts a transform value to a string, in the form 'Translation: X= Y= Z= Rotation: P= Y= R= Scale: X= Y= Z='
	*/
	static ToString(InTrans: Transform): string;
	/**
	 * Breaks apart a transform into location, rotation and scale
	*/
	static BreakTransform(InTransform: Transform,Location?: Vector,Rotation?: Rotator,Scale?: Vector): {Location: Vector, Rotation: Rotator, Scale: Vector};
	/**
	 * Compose two transforms in order: A * B.
	 * Order matters when composing transforms:
	 * A * B will yield a transform that logically first applies A then B to any subsequent transformation.
	 * Example: LocalToWorld = ComposeTransforms(DeltaRotation, LocalToWorld) will change rotation in local space by DeltaRotation.
	 * Example: LocalToWorld = ComposeTransforms(LocalToWorld, DeltaRotation) will change rotation in world space by DeltaRotation.
	 * @return New transform: A * B
	*/
	static ComposeTransforms(A: Transform,B: Transform): Transform;
	/**
	 * Returns the given transform, converted to be relative to the given ParentTransform.
	 * Example: AToB = ConvertTransformToRelative(AToWorld, BToWorld) to compute A relative to B.
	 * @param               Transform               The transform you wish to convert
	 * @param               ParentTransform The transform the conversion is relative to (in the same space as Transform)
	 * @return              The new relative transform
	*/
	static ConvertTransformToRelative(Transform: Transform,ParentTransform: Transform): Transform;
	/**
	 * Returns true if transform A is equal to transform B
	*/
	static EqualTransform(A: Transform,B: Transform): boolean;
	/**
	 * Transform a direction vector by the inverse of the supplied transform - will not change its length.
	 * For example, if T was an object's transform, would transform a direction from world space to local space.
	*/
	static InverseTransformDirection(T: Transform,Direction: Vector): Vector;
	/**
	 * Transform a position by the inverse of the supplied transform.
	 * For example, if T was an object's transform, would transform a position from world space to local space.
	*/
	static InverseTransformLocation(T: Transform,Location: Vector): Vector;
	/**
	 * Returns the inverse of the given transform T.
	 * Example: Given a LocalToWorld transform, WorldToLocal will be returned.
	 * @param       T       The transform you wish to invert
	 * @return      The inverse of T.
	*/
	static InvertTransform(T: Transform): Transform;
	/**
	 * Returns true if transform A is nearly equal to B
	 * @param LocationTolerance        How close position of transforms need to be to be considered equal
	 * @param RotationTolerance        How close rotations of transforms need to be to be considered equal
	 * @param Scale3DTolerance         How close scale of transforms need to be to be considered equal
	*/
	static NearlyEqual(A: Transform,B: Transform,LocationTolerance: number,RotationTolerance: number,Scale3DTolerance: number): boolean;
	/**
	 * If bPickA is true, A is returned, otherwise B is
	*/
	static SelectTransform(A: Transform,B: Transform,bPickA: boolean): Transform;
	/**
	 * Ease between A and B using a specified easing function.
	*/
	static Ease(A: Transform,B: Transform,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Transform;
	/**
	 * Tries to reach a target transform.
	*/
	static TInterpTo(Current: Transform,Target: Transform,DeltaTime: number,InterpSpeed: number): Transform;
	/**
	 * Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1).
	*/
	static Lerp(A: Transform,B: Transform,Alpha: number,InterpMode: ELerpInterpolationMode): Transform;
	/**
	 * Transform a direction vector by the supplied transform - will not change its length.
	 * For example, if T was an object's transform, would transform a direction from local space to world space.
	*/
	static TransformDirection(T: Transform,Direction: Vector): Vector;
	/**
	 * Transform a position by the supplied transform.
	 * For example, if T was an object's transform, would transform a position from local space to world space.
	*/
	static TransformLocation(T: Transform,Location: Vector): Vector;
}

declare class Plane extends Vector { 
	/**
	 * W
	*/
	W: number;
	clone() : Plane;
	static C(Other: UObject): Plane;
}

declare class Vector { 
	/**
	 * X
	*/
	X: number;
	/**
	 * Y
	*/
	Y: number;
	/**
	 * Z
	*/
	Z: number;
	clone() : Vector;
	static C(Other: UObject): Vector;
	/**
	 * Generate vertex and index buffer for a simple box, given the supplied dimensions. Normals, UVs and tangents are also generated for each vertex.
	*/
	GenerateBoxMesh(Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	/**
	 * Reports raw sensor data. If HMD doesn't support any of the parameters then it will be set to zero.
	 * @param AngularAcceleration    (out) Angular acceleration in radians per second per second.
	 * @param LinearAcceleration             (out) Acceleration in meters per second per second.
	 * @param AngularVelocity                (out) Angular velocity in radians per second.
	 * @param LinearVelocity                 (out) Velocity in meters per second.
	 * @param TimeInSeconds                  (out) Time when the reported IMU reading took place, in seconds.
	*/
	GetRawSensorData(LinearAcceleration?: Vector,AngularVelocity?: Vector,LinearVelocity?: Vector,TimeInSeconds?: number): {AngularAcceleration: Vector, LinearAcceleration: Vector, AngularVelocity: Vector, LinearVelocity: Vector, TimeInSeconds: number};
	/**
	 * Scales the HMD position that gets added to the virtual camera position.
	 * @param PosScale3D    (in) the scale to apply to the HMD position.
	*/
	SetPositionScale3D(): void;
	/**
	 * Segment Intersection 2D
	*/
	SegmentIntersection2D(SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	/**
	 * Converts a vector value to a localizable text, in the form 'X= Y= Z='
	*/
	ToText(): string;
	/**
	 * Converts a vector value to a string, in the form 'X= Y= Z='
	*/
	ToString(): string;
	/**
	 * Adds a float to each component of a vector
	*/
	Add_VectorFloat(B: number): Vector;
	/**
	 * Adds an integer to each component of a vector
	*/
	Add_VectorInt(B: number): Vector;
	/**
	 * Vector addition
	*/
	Add_VectorVector(B: Vector): Vector;
	/**
	 * Breaks a vector apart into X, Y, Z
	*/
	BreakVector(X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	/**
	 * Clamp the vector size between a min and max length
	*/
	ClampVectorSize(Min: number,Max: number): Vector;
	/**
	 * Converts a vector to LinearColor
	*/
	ToLinearColor(): LinearColor;
	/**
	 * Create a rotator which orients X along the supplied direction vector
	*/
	RotationFromXVector(): Rotator;
	/**
	 * Convert a vector to a transform. Uses vector as location
	*/
	ToTransform(): Transform;
	/**
	 * Convert a Vector to a Vector2D
	*/
	ToVector2D(): Vector2D;
	/**
	 * Returns the cross product of two 3d vectors
	*/
	CrossProduct(B: Vector): Vector;
	/**
	 * Vector divide by a float
	*/
	Divide_VectorFloat(B: number): Vector;
	/**
	 * Vector divide by an integer
	*/
	Divide_VectorInt(B: number): Vector;
	/**
	 * Vector divide by vector
	*/
	Divide_VectorVector(B: Vector): Vector;
	/**
	 * Returns the dot product of two 3d vectors
	*/
	DotProduct(B: Vector): number;
	/**
	 * Returns true if vector A is equal to vector B (A == B) within a specified error tolerance
	*/
	Equal(B: Vector,ErrorTolerance: number): boolean;
	/**
	 * Find the closest point on an infinite line to a given point.
	 * @param Point                 Point for which we find the closest point on the line.
	 * @param LineOrigin    Point of reference on the line.
	 * @param LineDirection Direction of the line. Not required to be normalized.
	 * @return The closest point on the line to the given point.
	*/
	FindClosestPointOnLine(LineOrigin: Vector,LineDirection: Vector): Vector;
	/**
	 * Find the closest point on a segment to a given point.
	 * @param Point                 Point for which we find the closest point on the segment.
	 * @param SegmentStart  Start of the segment.
	 * @param SegmentEnd    End of the segment.
	 * @return The closest point on the segment to the given point.
	*/
	FindClosestPointOnSegment(SegmentStart: Vector,SegmentEnd: Vector): Vector;
	/**
	 * Find a rotation for an object at Start location to point at Target location.
	*/
	FindLookAtRotation(Target: Vector): Rotator;
	/**
	 * Find closest points between 2 segments.
	 * @param       Segment1Start   Start of the 1st segment.
	 * @param       Segment1End             End of the 1st segment.
	 * @param       Segment2Start   Start of the 2nd segment.
	 * @param       Segment2End             End of the 2nd segment.
	 * @param       Segment1Point   Closest point on segment 1 to segment 2.
	 * @param       Segment2Point   Closest point on segment 2 to segment 1.
	*/
	FindNearestPointsOnLineSegments(Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	/**
	 * Find the unit direction vector from one position to another.
	*/
	GetDirectionVector(To: Vector): Vector;
	/**
	 * Find the maximum element (X, Y or Z) of a vector
	*/
	GetMaxElement(): number;
	/**
	 * Find the minimum element (X, Y or Z) of a vector
	*/
	GetMinElement(): number;
	/**
	 * Find the distance from a point to the closest point on an infinite line.
	 * @param Point                  Point for which we find the distance to the closest point on the line.
	 * @param LineOrigin             Point of reference on the line.
	 * @param LineDirection  Direction of the line. Not required to be normalized.
	 * @return The distance from the given point to the closest point on the line.
	*/
	GetPointDistanceToLine(LineOrigin: Vector,LineDirection: Vector): number;
	/**
	 * Find the distance from a point to the closest point on a segment.
	 * @param Point                  Point for which we find the distance to the closest point on the segment.
	 * @param SegmentStart   Start of the segment.
	 * @param SegmentEnd             End of the segment.
	 * @return The distance from the given point to the closest point on the segment.
	*/
	GetPointDistanceToSegment(SegmentStart: Vector,SegmentEnd: Vector): number;
	/**
	 * Breaks a vector apart into Yaw, Pitch rotation values given in degrees. (non-clamped)
	*/
	GetYawPitchFromVector(Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	/**
	 * Returns result of vector A rotated by Rotator B
	*/
	RotateVector(B: Rotator): Vector;
	/**
	 * Returns result of vector A rotated by the inverse of Rotator B
	*/
	UnrotateVector(B: Rotator): Vector;
	/**
	 * Computes the intersection point between a line and a plane.
	 * @param               T - The t of the intersection between the line and the plane
	 * @param               Intersection - The point of intersection between the line and the plane
	 * @return              True if the intersection test was successful.
	*/
	LinePlaneIntersection(LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	/**
	 * Computes the intersection point between a line and a plane.
	 * @param               T - The t of the intersection between the line and the plane
	 * @param               Intersection - The point of intersection between the line and the plane
	 * @return              True if the intersection test was successful.
	*/
	LinePlaneIntersection(LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	/**
	 * Creates a plane with a facing direction of Normal at the given Point
	 * @param Point  A point on the plane
	 * @param Normal  The Normal of the plane at Point
	 * @return Plane instance
	*/
	MakePlaneFromPointAndNormal(Normal: Vector): Plane;
	/**
	 * Build a reference frame from three axes
	*/
	MakeRotationFromAxes(Right: Vector,Up: Vector): Rotator;
	/**
	 * Builds a rotator given only a XAxis. Y and Z are unspecified but will be orthonormal. XAxis need not be normalized.
	*/
	MakeRotFromX(): Rotator;
	/**
	 * Builds a matrix with given X and Y axes. X will remain fixed, Y may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized.
	*/
	MakeRotFromXY(Y: Vector): Rotator;
	/**
	 * Builds a matrix with given X and Z axes. X will remain fixed, Z may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized.
	*/
	MakeRotFromXZ(Z: Vector): Rotator;
	/**
	 * Builds a rotation matrix given only a YAxis. X and Z are unspecified but will be orthonormal. YAxis need not be normalized.
	*/
	MakeRotFromY(): Rotator;
	/**
	 * Builds a matrix with given Y and X axes. Y will remain fixed, X may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized.
	*/
	MakeRotFromYX(X: Vector): Rotator;
	/**
	 * Builds a matrix with given Y and Z axes. Y will remain fixed, Z may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized.
	*/
	MakeRotFromYZ(Z: Vector): Rotator;
	/**
	 * Builds a rotation matrix given only a ZAxis. X and Y are unspecified but will be orthonormal. ZAxis need not be normalized.
	*/
	MakeRotFromZ(): Rotator;
	/**
	 * Builds a matrix with given Z and X axes. Z will remain fixed, X may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized.
	*/
	MakeRotFromZX(X: Vector): Rotator;
	/**
	 * Builds a matrix with given Z and Y axes. Z will remain fixed, Y may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized.
	*/
	MakeRotFromZY(Y: Vector): Rotator;
	/**
	 * Make a transform from location, rotation and scale
	*/
	MakeTransform(Rotation: Rotator,Scale: Vector): Transform;
	/**
	 * Mirrors a vector by a normal
	*/
	MirrorVectorByNormal(InNormal: Vector): Vector;
	/**
	 * Scales Vector A by B
	*/
	Multiply_VectorFloat(B: number): Vector;
	/**
	 * Scales Vector A by B
	*/
	Multiply_VectorInt(B: number): Vector;
	/**
	 * Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y, A.z*B.z})
	*/
	Multiply_VectorVector(B: Vector): Vector;
	/**
	 * Negate a vector.
	*/
	NegateVector(): Vector;
	/**
	 * Returns a unit normal version of the FVector A
	*/
	Normalize(): Vector;
	/**
	 * Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance
	*/
	NotEqual(B: Vector,ErrorTolerance: number): boolean;
	/**
	 * Projects a point onto a plane defined by a point on the plane and a plane normal.
	 * @param  Point Point to project onto the plane.
	 * @param  PlaneBase A point on the plane.
	 * @param  PlaneNormal Normal of the plane.
	 * @return Point projected onto the plane.
	*/
	ProjectPointOnToPlane(PlaneBase: Vector,PlaneNormal: Vector): Vector;
	/**
	 * Projects a vector onto a plane defined by a normalized vector (PlaneNormal).
	 * @param  V Vector to project onto the plane.
	 * @param  PlaneNormal Normal of the plane.
	 * @return Vector projected onto the plane.
	*/
	ProjectVectorOnToPlane(PlaneNormal: Vector): Vector;
	/**
	 * Projects one vector (V) onto another (Target) and returns the projected vector.
	 * If Target is nearly zero in length, returns the zero vector.
	 * @param  V Vector to project.
	 * @param  Target Vector on which we are projecting.
	 * @return V projected on to Target.
	*/
	ProjectVectorOnToVector(Target: Vector): Vector;
	/**
	 * Returns a random point within the specified bounding box
	*/
	RandomPointInBoundingBox(BoxExtent: Vector): Vector;
	/**
	 * Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
	 * @param ConeDir       The base "center" direction of the cone.
	 * @param ConeHalfAngle         The half-angle of the cone (from ConeDir to edge), in radians.
	*/
	RandomUnitVectorInCone(ConeHalfAngle: number): Vector;
	/**
	 * RandomUnitVectorWithYawAndPitch
	 * @param MaxYaw - The Yaw-angle of the cone (from ConeDir to horizontal-edge), in degrees.
	 * @param MaxPitch - The Pitch-angle of the cone (from ConeDir to vertical-edge), in degrees.
	*/
	RandomUnitVectorInConeWithYawAndPitch(MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	/**
	 * Returns result of vector A rotated by AngleDeg around Axis
	*/
	RotateVectorAroundAxis(AngleDeg: number,Axis: Vector): Vector;
	/**
	 * Create a rotation from an axis and and angle (in degrees)
	*/
	RotatorFromAxisAndAngle(Angle: number): Rotator;
	/**
	 * If bPickA is true, A is returned, otherwise B is
	*/
	SelectVector(B: Vector,bPickA: boolean): Vector;
	/**
	 * Subtracts a float from each component of a vector
	*/
	Subtract_VectorFloat(B: number): Vector;
	/**
	 * Subtracts an integer from each component of a vector
	*/
	Subtract_VectorInt(B: number): Vector;
	/**
	 * Vector subtraction
	*/
	Subtract_VectorVector(B: Vector): Vector;
	/**
	 * Easeing  between A and B using a specified easing function
	*/
	Ease(B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	/**
	 * Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
	 * @param               Current                 Actual position
	 * @param               Target                  Target position
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	VInterpTo(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	/**
	 * Tries to reach Target at a constant rate.
	 * @param               Current                 Actual position
	 * @param               Target                  Target position
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	VInterpTo_Constant(Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	/**
	 * Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
	*/
	Lerp(B: Vector,Alpha: number): Vector;
	/**
	 * Returns the length of the FVector
	*/
	VectorLength(): number;
	/**
	 * Returns the squared length of the FVector
	*/
	VectorLengthSquared(): number;
	/**
	 * If the HMD has a positional sensor, this will return the game-world location of it, as well as the parameters for the bounding region of tracking.
	 * This allows an in-game representation of the legal positional tracking range.  All values will be zeroed if the sensor is not available or the HMD does not support it.
	 * @param Origin                        (out) Origin, in world-space, of the sensor
	 * @param Rotation                      (out) Rotation, in world-space, of the sensor
	 * @param HFOV                          (out) Field-of-view, horizontal, in degrees, of the valid tracking zone of the sensor
	 * @param VFOV                          (out) Field-of-view, vertical, in degrees, of the valid tracking zone of the sensor
	 * @param CameraDistance        (out) Nominal distance to sensor, in world-space
	 * @param NearPlane                     (out) Near plane distance of the tracking volume, in world-space
	 * @param FarPlane                      (out) Far plane distance of the tracking volume, in world-space
	*/
	GetPositionalTrackingCameraParameters(CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	/**
	 * If the HMD has a positional sensor, this will return the game-world location of it, as well as the parameters for the bounding region of tracking.
	 * This allows an in-game representation of the legal positional tracking range.  All values will be zeroed if the sensor is not available or the HMD does not support it.
	 * @param Index                         (in) Index of the tracking sensor to query
	 * @param Origin                        (out) Origin, in world-space, of the sensor
	 * @param Rotation                      (out) Rotation, in world-space, of the sensor
	 * @param HFOV                          (out) Field-of-view, horizontal, in degrees, of the valid tracking zone of the sensor
	 * @param VFOV                          (out) Field-of-view, vertical, in degrees, of the valid tracking zone of the sensor
	 * @param Distance                      (out) Nominal distance to sensor, in world-space
	 * @param NearPlane                     (out) Near plane distance of the tracking volume, in world-space
	 * @param FarPlane                      (out) Far plane distance of the tracking volume, in world-space
	 * @param IsActive                      (out) True, if the query for the specified sensor succeeded.
	*/
	GetTrackingSensorParameters(Rotation?: Rotator,HFOV?: number,VFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, HFOV: number, VFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	/**
	 * Is Valid AIDirection
	*/
	IsValidAIDirection(): boolean;
	/**
	 * Is Valid AILocation
	*/
	IsValidAILocation(): boolean;
	/**
	 * Generate vertex and index buffer for a simple box, given the supplied dimensions. Normals, UVs and tangents are also generated for each vertex.
	*/
	static GenerateBoxMesh(BoxRadius: Vector,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	/**
	 * Reports raw sensor data. If HMD doesn't support any of the parameters then it will be set to zero.
	 * @param AngularAcceleration    (out) Angular acceleration in radians per second per second.
	 * @param LinearAcceleration             (out) Acceleration in meters per second per second.
	 * @param AngularVelocity                (out) Angular velocity in radians per second.
	 * @param LinearVelocity                 (out) Velocity in meters per second.
	 * @param TimeInSeconds                  (out) Time when the reported IMU reading took place, in seconds.
	*/
	static GetRawSensorData(AngularAcceleration?: Vector,LinearAcceleration?: Vector,AngularVelocity?: Vector,LinearVelocity?: Vector,TimeInSeconds?: number): {AngularAcceleration: Vector, LinearAcceleration: Vector, AngularVelocity: Vector, LinearVelocity: Vector, TimeInSeconds: number};
	/**
	 * Scales the HMD position that gets added to the virtual camera position.
	 * @param PosScale3D    (in) the scale to apply to the HMD position.
	*/
	static SetPositionScale3D(PosScale3D: Vector): void;
	/**
	 * Segment Intersection 2D
	*/
	static SegmentIntersection2D(SegmentStartA: Vector,SegmentEndA: Vector,SegmentStartB: Vector,SegmentEndB: Vector,IntersectionPoint?: Vector): {IntersectionPoint: Vector, $: boolean};
	/**
	 * Converts a vector value to a localizable text, in the form 'X= Y= Z='
	*/
	static ToText(InVec: Vector): string;
	/**
	 * Converts a vector value to a string, in the form 'X= Y= Z='
	*/
	static ToString(InVec: Vector): string;
	/**
	 * Adds a float to each component of a vector
	*/
	static Add_VectorFloat(A: Vector,B: number): Vector;
	/**
	 * Adds an integer to each component of a vector
	*/
	static Add_VectorInt(A: Vector,B: number): Vector;
	/**
	 * Vector addition
	*/
	static Add_VectorVector(A: Vector,B: Vector): Vector;
	/**
	 * Breaks a vector apart into X, Y, Z
	*/
	static BreakVector(InVec: Vector,X?: number,Y?: number,Z?: number): {X: number, Y: number, Z: number};
	/**
	 * Clamp the vector size between a min and max length
	*/
	static ClampVectorSize(A: Vector,Min: number,Max: number): Vector;
	/**
	 * Converts a vector to LinearColor
	*/
	static ToLinearColor(InVec: Vector): LinearColor;
	/**
	 * Create a rotator which orients X along the supplied direction vector
	*/
	static RotationFromXVector(InVec: Vector): Rotator;
	/**
	 * Convert a vector to a transform. Uses vector as location
	*/
	static ToTransform(InLocation: Vector): Transform;
	/**
	 * Convert a Vector to a Vector2D
	*/
	static ToVector2D(InVector: Vector): Vector2D;
	/**
	 * Returns the cross product of two 3d vectors
	*/
	static CrossProduct(A: Vector,B: Vector): Vector;
	/**
	 * Vector divide by a float
	*/
	static Divide_VectorFloat(A: Vector,B: number): Vector;
	/**
	 * Vector divide by an integer
	*/
	static Divide_VectorInt(A: Vector,B: number): Vector;
	/**
	 * Vector divide by vector
	*/
	static Divide_VectorVector(A: Vector,B: Vector): Vector;
	/**
	 * Returns the dot product of two 3d vectors
	*/
	static DotProduct(A: Vector,B: Vector): number;
	/**
	 * Returns true if vector A is equal to vector B (A == B) within a specified error tolerance
	*/
	static Equal(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	/**
	 * Find the closest point on an infinite line to a given point.
	 * @param Point                 Point for which we find the closest point on the line.
	 * @param LineOrigin    Point of reference on the line.
	 * @param LineDirection Direction of the line. Not required to be normalized.
	 * @return The closest point on the line to the given point.
	*/
	static FindClosestPointOnLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): Vector;
	/**
	 * Find the closest point on a segment to a given point.
	 * @param Point                 Point for which we find the closest point on the segment.
	 * @param SegmentStart  Start of the segment.
	 * @param SegmentEnd    End of the segment.
	 * @return The closest point on the segment to the given point.
	*/
	static FindClosestPointOnSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): Vector;
	/**
	 * Find a rotation for an object at Start location to point at Target location.
	*/
	static FindLookAtRotation(Start: Vector,Target: Vector): Rotator;
	/**
	 * Find closest points between 2 segments.
	 * @param       Segment1Start   Start of the 1st segment.
	 * @param       Segment1End             End of the 1st segment.
	 * @param       Segment2Start   Start of the 2nd segment.
	 * @param       Segment2End             End of the 2nd segment.
	 * @param       Segment1Point   Closest point on segment 1 to segment 2.
	 * @param       Segment2Point   Closest point on segment 2 to segment 1.
	*/
	static FindNearestPointsOnLineSegments(Segment1Start: Vector,Segment1End: Vector,Segment2Start: Vector,Segment2End: Vector,Segment1Point?: Vector,Segment2Point?: Vector): {Segment1Point: Vector, Segment2Point: Vector};
	/**
	 * Find the unit direction vector from one position to another.
	*/
	static GetDirectionVector(From: Vector,To: Vector): Vector;
	/**
	 * Find the maximum element (X, Y or Z) of a vector
	*/
	static GetMaxElement(A: Vector): number;
	/**
	 * Find the minimum element (X, Y or Z) of a vector
	*/
	static GetMinElement(A: Vector): number;
	/**
	 * Find the distance from a point to the closest point on an infinite line.
	 * @param Point                  Point for which we find the distance to the closest point on the line.
	 * @param LineOrigin             Point of reference on the line.
	 * @param LineDirection  Direction of the line. Not required to be normalized.
	 * @return The distance from the given point to the closest point on the line.
	*/
	static GetPointDistanceToLine(Point: Vector,LineOrigin: Vector,LineDirection: Vector): number;
	/**
	 * Find the distance from a point to the closest point on a segment.
	 * @param Point                  Point for which we find the distance to the closest point on the segment.
	 * @param SegmentStart   Start of the segment.
	 * @param SegmentEnd             End of the segment.
	 * @return The distance from the given point to the closest point on the segment.
	*/
	static GetPointDistanceToSegment(Point: Vector,SegmentStart: Vector,SegmentEnd: Vector): number;
	/**
	 * Breaks a vector apart into Yaw, Pitch rotation values given in degrees. (non-clamped)
	*/
	static GetYawPitchFromVector(InVec: Vector,Yaw?: number,Pitch?: number): {Yaw: number, Pitch: number};
	/**
	 * Returns result of vector A rotated by Rotator B
	*/
	static RotateVector(A: Vector,B: Rotator): Vector;
	/**
	 * Returns result of vector A rotated by the inverse of Rotator B
	*/
	static UnrotateVector(A: Vector,B: Rotator): Vector;
	/**
	 * Computes the intersection point between a line and a plane.
	 * @param               T - The t of the intersection between the line and the plane
	 * @param               Intersection - The point of intersection between the line and the plane
	 * @return              True if the intersection test was successful.
	*/
	static LinePlaneIntersection(LineStart: Vector,LineEnd: Vector,APlane: Plane,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	/**
	 * Computes the intersection point between a line and a plane.
	 * @param               T - The t of the intersection between the line and the plane
	 * @param               Intersection - The point of intersection between the line and the plane
	 * @return              True if the intersection test was successful.
	*/
	static LinePlaneIntersection(LineStart: Vector,LineEnd: Vector,PlaneOrigin: Vector,PlaneNormal: Vector,T?: number,Intersection?: Vector): {T: number, Intersection: Vector, $: boolean};
	/**
	 * Creates a plane with a facing direction of Normal at the given Point
	 * @param Point  A point on the plane
	 * @param Normal  The Normal of the plane at Point
	 * @return Plane instance
	*/
	static MakePlaneFromPointAndNormal(Point: Vector,Normal: Vector): Plane;
	/**
	 * Build a reference frame from three axes
	*/
	static MakeRotationFromAxes(Forward: Vector,Right: Vector,Up: Vector): Rotator;
	/**
	 * Builds a rotator given only a XAxis. Y and Z are unspecified but will be orthonormal. XAxis need not be normalized.
	*/
	static MakeRotFromX(X: Vector): Rotator;
	/**
	 * Builds a matrix with given X and Y axes. X will remain fixed, Y may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized.
	*/
	static MakeRotFromXY(X: Vector,Y: Vector): Rotator;
	/**
	 * Builds a matrix with given X and Z axes. X will remain fixed, Z may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized.
	*/
	static MakeRotFromXZ(X: Vector,Z: Vector): Rotator;
	/**
	 * Builds a rotation matrix given only a YAxis. X and Z are unspecified but will be orthonormal. YAxis need not be normalized.
	*/
	static MakeRotFromY(Y: Vector): Rotator;
	/**
	 * Builds a matrix with given Y and X axes. Y will remain fixed, X may be changed minimally to enforce orthogonality. Z will be computed. Inputs need not be normalized.
	*/
	static MakeRotFromYX(Y: Vector,X: Vector): Rotator;
	/**
	 * Builds a matrix with given Y and Z axes. Y will remain fixed, Z may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized.
	*/
	static MakeRotFromYZ(Y: Vector,Z: Vector): Rotator;
	/**
	 * Builds a rotation matrix given only a ZAxis. X and Y are unspecified but will be orthonormal. ZAxis need not be normalized.
	*/
	static MakeRotFromZ(Z: Vector): Rotator;
	/**
	 * Builds a matrix with given Z and X axes. Z will remain fixed, X may be changed minimally to enforce orthogonality. Y will be computed. Inputs need not be normalized.
	*/
	static MakeRotFromZX(Z: Vector,X: Vector): Rotator;
	/**
	 * Builds a matrix with given Z and Y axes. Z will remain fixed, Y may be changed minimally to enforce orthogonality. X will be computed. Inputs need not be normalized.
	*/
	static MakeRotFromZY(Z: Vector,Y: Vector): Rotator;
	/**
	 * Make a transform from location, rotation and scale
	*/
	static MakeTransform(Location: Vector,Rotation: Rotator,Scale: Vector): Transform;
	/**
	 * Mirrors a vector by a normal
	*/
	static MirrorVectorByNormal(InVect: Vector,InNormal: Vector): Vector;
	/**
	 * Scales Vector A by B
	*/
	static Multiply_VectorFloat(A: Vector,B: number): Vector;
	/**
	 * Scales Vector A by B
	*/
	static Multiply_VectorInt(A: Vector,B: number): Vector;
	/**
	 * Element-wise Vector multiplication (Result = {A.x*B.x, A.y*B.y, A.z*B.z})
	*/
	static Multiply_VectorVector(A: Vector,B: Vector): Vector;
	/**
	 * Negate a vector.
	*/
	static NegateVector(A: Vector): Vector;
	/**
	 * Returns a unit normal version of the FVector A
	*/
	static Normalize(A: Vector): Vector;
	/**
	 * Returns true if vector A is not equal to vector B (A != B) within a specified error tolerance
	*/
	static NotEqual(A: Vector,B: Vector,ErrorTolerance: number): boolean;
	/**
	 * Projects a point onto a plane defined by a point on the plane and a plane normal.
	 * @param  Point Point to project onto the plane.
	 * @param  PlaneBase A point on the plane.
	 * @param  PlaneNormal Normal of the plane.
	 * @return Point projected onto the plane.
	*/
	static ProjectPointOnToPlane(Point: Vector,PlaneBase: Vector,PlaneNormal: Vector): Vector;
	/**
	 * Projects a vector onto a plane defined by a normalized vector (PlaneNormal).
	 * @param  V Vector to project onto the plane.
	 * @param  PlaneNormal Normal of the plane.
	 * @return Vector projected onto the plane.
	*/
	static ProjectVectorOnToPlane(V: Vector,PlaneNormal: Vector): Vector;
	/**
	 * Projects one vector (V) onto another (Target) and returns the projected vector.
	 * If Target is nearly zero in length, returns the zero vector.
	 * @param  V Vector to project.
	 * @param  Target Vector on which we are projecting.
	 * @return V projected on to Target.
	*/
	static ProjectVectorOnToVector(V: Vector,Target: Vector): Vector;
	/**
	 * Returns a random point within the specified bounding box
	*/
	static RandomPointInBoundingBox(Origin: Vector,BoxExtent: Vector): Vector;
	/**
	 * Returns a random vector with length of 1, within the specified cone, with uniform random distribution.
	 * @param ConeDir       The base "center" direction of the cone.
	 * @param ConeHalfAngle         The half-angle of the cone (from ConeDir to edge), in radians.
	*/
	static RandomUnitVectorInCone(ConeDir: Vector,ConeHalfAngle: number): Vector;
	/**
	 * RandomUnitVectorWithYawAndPitch
	 * @param MaxYaw - The Yaw-angle of the cone (from ConeDir to horizontal-edge), in degrees.
	 * @param MaxPitch - The Pitch-angle of the cone (from ConeDir to vertical-edge), in degrees.
	*/
	static RandomUnitVectorInConeWithYawAndPitch(ConeDir: Vector,MaxYawInDegrees: number,MaxPitchInDegrees: number): Vector;
	/**
	 * Returns result of vector A rotated by AngleDeg around Axis
	*/
	static RotateVectorAroundAxis(InVect: Vector,AngleDeg: number,Axis: Vector): Vector;
	/**
	 * Create a rotation from an axis and and angle (in degrees)
	*/
	static RotatorFromAxisAndAngle(Axis: Vector,Angle: number): Rotator;
	/**
	 * If bPickA is true, A is returned, otherwise B is
	*/
	static SelectVector(A: Vector,B: Vector,bPickA: boolean): Vector;
	/**
	 * Subtracts a float from each component of a vector
	*/
	static Subtract_VectorFloat(A: Vector,B: number): Vector;
	/**
	 * Subtracts an integer from each component of a vector
	*/
	static Subtract_VectorInt(A: Vector,B: number): Vector;
	/**
	 * Vector subtraction
	*/
	static Subtract_VectorVector(A: Vector,B: Vector): Vector;
	/**
	 * Easeing  between A and B using a specified easing function
	*/
	static Ease(A: Vector,B: Vector,Alpha: number,EasingFunc: EEasingFunc,BlendExp: number,Steps: number): Vector;
	/**
	 * Tries to reach Target based on distance from Current position, giving a nice smooth feeling when tracking a position.
	 * @param               Current                 Actual position
	 * @param               Target                  Target position
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	static VInterpTo(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	/**
	 * Tries to reach Target at a constant rate.
	 * @param               Current                 Actual position
	 * @param               Target                  Target position
	 * @param               DeltaTime               Time since last tick
	 * @param               InterpSpeed             Interpolation speed
	 * @return              New interpolated position
	*/
	static VInterpTo_Constant(Current: Vector,Target: Vector,DeltaTime: number,InterpSpeed: number): Vector;
	/**
	 * Linearly interpolates between A and B based on Alpha (100% of A when Alpha=0 and 100% of B when Alpha=1)
	*/
	static Lerp(A: Vector,B: Vector,Alpha: number): Vector;
	/**
	 * Returns the length of the FVector
	*/
	static VectorLength(A: Vector): number;
	/**
	 * Returns the squared length of the FVector
	*/
	static VectorLengthSquared(A: Vector): number;
	/**
	 * If the HMD has a positional sensor, this will return the game-world location of it, as well as the parameters for the bounding region of tracking.
	 * This allows an in-game representation of the legal positional tracking range.  All values will be zeroed if the sensor is not available or the HMD does not support it.
	 * @param Origin                        (out) Origin, in world-space, of the sensor
	 * @param Rotation                      (out) Rotation, in world-space, of the sensor
	 * @param HFOV                          (out) Field-of-view, horizontal, in degrees, of the valid tracking zone of the sensor
	 * @param VFOV                          (out) Field-of-view, vertical, in degrees, of the valid tracking zone of the sensor
	 * @param CameraDistance        (out) Nominal distance to sensor, in world-space
	 * @param NearPlane                     (out) Near plane distance of the tracking volume, in world-space
	 * @param FarPlane                      (out) Far plane distance of the tracking volume, in world-space
	*/
	static GetPositionalTrackingCameraParameters(CameraOrigin?: Vector,CameraRotation?: Rotator,HFOV?: number,VFOV?: number,CameraDistance?: number,NearPlane?: number,FarPlane?: number): {CameraOrigin: Vector, CameraRotation: Rotator, HFOV: number, VFOV: number, CameraDistance: number, NearPlane: number, FarPlane: number};
	/**
	 * If the HMD has a positional sensor, this will return the game-world location of it, as well as the parameters for the bounding region of tracking.
	 * This allows an in-game representation of the legal positional tracking range.  All values will be zeroed if the sensor is not available or the HMD does not support it.
	 * @param Index                         (in) Index of the tracking sensor to query
	 * @param Origin                        (out) Origin, in world-space, of the sensor
	 * @param Rotation                      (out) Rotation, in world-space, of the sensor
	 * @param HFOV                          (out) Field-of-view, horizontal, in degrees, of the valid tracking zone of the sensor
	 * @param VFOV                          (out) Field-of-view, vertical, in degrees, of the valid tracking zone of the sensor
	 * @param Distance                      (out) Nominal distance to sensor, in world-space
	 * @param NearPlane                     (out) Near plane distance of the tracking volume, in world-space
	 * @param FarPlane                      (out) Far plane distance of the tracking volume, in world-space
	 * @param IsActive                      (out) True, if the query for the specified sensor succeeded.
	*/
	static GetTrackingSensorParameters(Origin?: Vector,Rotation?: Rotator,HFOV?: number,VFOV?: number,Distance?: number,NearPlane?: number,FarPlane?: number,IsActive?: boolean,Index?: number): {Origin: Vector, Rotation: Rotator, HFOV: number, VFOV: number, Distance: number, NearPlane: number, FarPlane: number, IsActive: boolean};
	/**
	 * Is Valid AIDirection
	*/
	static IsValidAIDirection(DirectionVector: Vector): boolean;
	/**
	 * Is Valid AILocation
	*/
	static IsValidAILocation(Location: Vector): boolean;
	/**
	 * Convert a float into a vector, where each element is that float
	*/
	static ToVector(InFloat: number): Vector;
	/**
	 * Creates a directional vector from rotation values {Pitch, Yaw} supplied in degrees with specified Length
	*/
	static CreateVectorFromYawPitch(Yaw: number,Pitch: number,Length: number): Vector;
	/**
	 * Find the average of an array of vectors
	*/
	static GetVectorArrayAverage(Vectors: Vector[]): Vector;
	/**
	 * Makes a vector {X, Y, Z}
	*/
	static MakeVector(X: number,Y: number,Z: number): Vector;
	/**
	 * Returns a random vector with length of 1
	*/
	static RandomUnitVector(): Vector;
	/**
	 * Find the average location (centroid) of an array of Actors
	*/
	static GetActorArrayAverageLocation(Actors: Actor[]): Vector;
}

declare type EVectorQuantization = string | symbol;
declare var EVectorQuantization = { RoundWholeNumber:'RoundWholeNumber',RoundOneDecimal:'RoundOneDecimal',RoundTwoDecimals:'RoundTwoDecimals', };
declare type ERotatorQuantization = string | symbol;
declare var ERotatorQuantization = { ByteComponents:'ByteComponents',ShortComponents:'ShortComponents', };
declare class RepMovement { 
	/**
	 * Linear Velocity
	*/
	LinearVelocity: Vector;
	/**
	 * Angular Velocity
	*/
	AngularVelocity: Vector;
	/**
	 * Location
	*/
	Location: Vector;
	/**
	 * Rotation
	*/
	Rotation: Rotator;
	/**
	 * If set, RootComponent should be sleeping.
	*/
	bSimulatedPhysicSleep: boolean;
	/**
	 * If set, additional physic data (angular velocity) will be replicated.
	*/
	bRepPhysics: boolean;
	/**
	 * Allows tuning the compression level for the replicated location vector. You should only need to change this from the default if you see visual artifacts.
	*/
	LocationQuantizationLevel: EVectorQuantization;
	/**
	 * Allows tuning the compression level for the replicated velocity vectors. You should only need to change this from the default if you see visual artifacts.
	*/
	VelocityQuantizationLevel: EVectorQuantization;
	/**
	 * Allows tuning the compression level for replicated rotation. You should only need to change this from the default if you see visual artifacts.
	*/
	RotationQuantizationLevel: ERotatorQuantization;
	clone() : RepMovement;
	static C(Other: UObject): RepMovement;
}

declare class Vector_NetQuantize100 extends Vector { 
	clone() : Vector_NetQuantize100;
	static C(Other: UObject): Vector_NetQuantize100;
}

declare class ActorComponentTickFunction extends TickFunction { 
	clone() : ActorComponentTickFunction;
	static C(Other: UObject): ActorComponentTickFunction;
}

declare class AssetUserData extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AssetUserData;
	static Find(Outer: UObject, ResourceName: string): AssetUserData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AssetUserData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetUserData;
	static C(Other: UObject): AssetUserData;
}

declare type EComponentCreationMethod = string | symbol;
declare var EComponentCreationMethod = { Native:'Native',SimpleConstructionScript:'SimpleConstructionScript',UserConstructionScript:'UserConstructionScript',Instance:'Instance', };
declare class Guid { 
	/**
	 * A
	*/
	A: number;
	/**
	 * B
	*/
	B: number;
	/**
	 * C
	*/
	C: number;
	/**
	 * D
	*/
	D: number;
	clone() : Guid;
	static C(Other: UObject): Guid;
	/**
	 * Converts a GUID value to a string, in the form 'A-B-C-D'
	*/
	ToString(): string;
	/**
	 * Returns true if the values are equal (A == B)
	*/
	Equal(B: Guid): boolean;
	/**
	 * Invalidates the given GUID
	*/
	Invalidate_Guid(): {InGuid: Guid};
	/**
	 * Checks whether the given GUID is valid
	*/
	IsValid(): boolean;
	/**
	 * Returns true if the values are not equal (A != B)
	*/
	NotEqual(B: Guid): boolean;
	/**
	 * Converts a GUID value to a string, in the form 'A-B-C-D'
	*/
	static ToString(InGuid: Guid): string;
	/**
	 * Returns true if the values are equal (A == B)
	*/
	static Equal(A: Guid,B: Guid): boolean;
	/**
	 * Invalidates the given GUID
	*/
	static Invalidate_Guid(InGuid?: Guid): {InGuid: Guid};
	/**
	 * Checks whether the given GUID is valid
	*/
	static IsValid(InGuid: Guid): boolean;
	/**
	 * Returns true if the values are not equal (A != B)
	*/
	static NotEqual(A: Guid,B: Guid): boolean;
	/**
	 * Returns a new unique GUID
	*/
	static NewGuid(): Guid;
}

declare class SimpleMemberReference { 
	/**
	 * Most often the Class that this member is defined in. Could be a UPackage
	 * if it is a native delegate signature function (declared globally).
	*/
	MemberParent: UObject;
	/**
	 * Name of the member
	*/
	MemberName: string;
	/**
	 * The Guid of the member
	*/
	MemberGuid: Guid;
	clone() : SimpleMemberReference;
	static C(Other: UObject): SimpleMemberReference;
}

declare type EEndPlayReason = string | symbol;
declare var EEndPlayReason = { Destroyed:'Destroyed',LevelTransition:'LevelTransition',EndPlayInEditor:'EndPlayInEditor',RemovedFromWorld:'RemovedFromWorld',Quit:'Quit', };
declare class ActorComponent extends UObject { 
	/**
	 * Main tick function for the Actor
	*/
	PrimaryComponentTick: ActorComponentTickFunction;
	/**
	 * Array of tags that can be used for grouping and categorizing. Can also be accessed from scripting.
	*/
	ComponentTags: string[];
	/**
	 * Array of user data stored with the component
	*/
	AssetUserData: AssetUserData[];
	/**
	 * Is this component currently replicating? Should the network code consider it for replication? Owning Actor must be replicating first!
	*/
	bReplicates: boolean;
	/**
	 * Is this component safe to ID over the network by name?
	*/
	bNetAddressable: boolean;
	/**
	 * True if this component was created by a construction script, and will be destroyed by DestroyConstructedComponents
	*/
	bCreatedByConstructionScript: boolean;
	/**
	 * True if this component was created as an instance component
	*/
	bInstanceComponent: boolean;
	/**
	 * Whether the component is activated at creation or must be explicitly activated.
	*/
	bAutoActivate: boolean;
	/**
	 * Whether the component is currently active.
	*/
	bIsActive: boolean;
	/**
	 * Editable when Inherited
	*/
	bEditableWhenInherited: boolean;
	/**
	 * Whether this component can potentially influence navigation
	*/
	bCanEverAffectNavigation: boolean;
	/**
	 * If true, we call the virtual BeginPlay
	*/
	bWantsBeginPlay: boolean;
	/**
	 * Creation Method
	*/
	CreationMethod: EComponentCreationMethod;
	/**
	 * UCSModified Properties
	*/
	UCSModifiedProperties: SimpleMemberReference[];
	/**
	 * On Component Activated
	*/
	OnComponentActivated: UnrealEngineMulticastDelegate<(bReset: boolean) => void>;
	/**
	 * On Component Deactivated
	*/
	OnComponentDeactivated: UnrealEngineMulticastDelegate<() => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ActorComponent;
	static Find(Outer: UObject, ResourceName: string): ActorComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ActorComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ActorComponent;
	/**
	 * Toggles the active state of the component
	*/
	ToggleActive(): void;
	/**
	 * Changes the ticking group for this component
	*/
	SetTickGroup(NewTickGroup: ETickingGroup): void;
	/**
	 * Sets whether this component can tick when paused.
	*/
	SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
	/**
	 * Enable or disable replication. This is the equivalent of RemoteRole for actors (only a bool is required for components)
	*/
	SetIsReplicated(ShouldReplicate: boolean): void;
	/**
	 * Sets the tick interval for this component's primary tick function. Does not enable the tick interval. Takes effect on next tick.
	 * @param TickInterval   The duration between ticks for this component's primary tick function
	*/
	SetComponentTickInterval(TickInterval: number): void;
	/**
	 * Set this component's tick functions to be enabled or disabled. Only has an effect if the function is registered
	 * @param       bEnabled - Whether it should be enabled or not
	*/
	SetComponentTickEnabled(bEnabled: boolean): void;
	/**
	 * Sets whether the component is active or not
	 * @param bNewActive - The new active state of the component
	*/
	SetActive(bNewActive: boolean,bReset: boolean): void;
	/**
	 * Remove tick dependency on PrerequisiteComponent.
	*/
	RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	/**
	 * Remove tick dependency on PrerequisiteActor.
	*/
	RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	/**
	 * Event called every frame
	*/
	Tick(DeltaSeconds: number): void;
	/**
	 * Blueprint implementable event for when the component ends play, generally via destruction or its Actor's EndPlay.
	*/
	EndPlay(EndPlayReason: EEndPlayReason): void;
	/**
	 * Blueprint implementable event for when the component is beginning play, called before its Owner's BeginPlay on Actor BeginPlay
	 * or when the component is dynamically created if the Actor has already BegunPlay.
	*/
	BeginPlay(): void;
	/**
	 * On Rep Is Active
	*/
	OnRep_IsActive(): void;
	/**
	 * Unregister and mark for pending kill a component.  This may not be used to destroy a component is owned by an actor other than the one calling the function.
	*/
	DestroyComponent(UObject: UObject): void;
	/**
	 * Returns whether this component has tick enabled or not
	*/
	IsComponentTickEnabled(): boolean;
	/**
	 * Returns whether the component is in the process of being destroyed.
	*/
	IsComponentBeingDestroyed(): boolean;
	/**
	 * Returns whether the component is active or not
	 * @return - The active state of the component.
	*/
	IsActive(): boolean;
	/**
	 * Follow the Outer chain to get the  AActor  that 'Owns' this component
	*/
	GetOwner(): Actor;
	/**
	 * Returns whether this component has tick enabled or not
	*/
	GetComponentTickInterval(): number;
	/**
	 * Deactivates the SceneComponent.
	*/
	Deactivate(): void;
	/**
	 * See if this component contains the supplied tag
	*/
	ComponentHasTag(Tag: string): boolean;
	/**
	 * Make this component tick after PrerequisiteComponent.
	*/
	AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
	/**
	 * Make this component tick after PrerequisiteActor
	*/
	AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
	/**
	 * Activates the SceneComponent
	 * @param bReset - The value to assign to HiddenGame.
	*/
	Activate(bReset: boolean): void;
	static C(Other: UObject): ActorComponent;
	/**
	 * Is Registered
	*/
	IsRegistered(): boolean;
	/**
	 * Mark Render State Dirty
	*/
	MarkRenderStateDirty(): void;
	/**
	 * Register Component
	*/
	RegisterComponent(): void;
	/**
	 * Reregister Component
	*/
	ReregisterComponent(): void;
	/**
	 * Unregister Component
	*/
	UnregisterComponent(): void;
	/**
	 * Is Registered
	*/
	static IsRegistered(ActorComponent: ActorComponent): boolean;
	/**
	 * Mark Render State Dirty
	*/
	static MarkRenderStateDirty(Component: ActorComponent): void;
	/**
	 * Register Component
	*/
	static RegisterComponent(ActorComponent: ActorComponent): void;
	/**
	 * Reregister Component
	*/
	static ReregisterComponent(ActorComponent: ActorComponent): void;
	/**
	 * Unregister Component
	*/
	static UnregisterComponent(ActorComponent: ActorComponent): void;
}

declare type EComponentMobility = string | symbol;
declare var EComponentMobility = { Static:'Static',Stationary:'Stationary',Movable:'Movable', };
declare type EDetailMode = string | symbol;
declare var EDetailMode = { DM_Low:'DM_Low',DM_Medium:'DM_Medium',DM_High:'DM_High', };
declare type EBrushType = string | symbol;
declare var EBrushType = { Brush_Default:'Brush_Default',Brush_Add:'Brush_Add',Brush_Subtract:'Brush_Subtract', };
declare class Model extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Model;
	static Find(Outer: UObject, ResourceName: string): Model;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Model;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Model;
	static C(Other: UObject): Model;
}

declare type ESceneDepthPriorityGroup = string | symbol;
declare var ESceneDepthPriorityGroup = { SDPG_World:'SDPG_World',SDPG_Foreground:'SDPG_Foreground', };
declare type EIndirectLightingCacheQuality = string | symbol;
declare var EIndirectLightingCacheQuality = { ILCQ_Off:'ILCQ_Off',ILCQ_Point:'ILCQ_Point',ILCQ_Volume:'ILCQ_Volume', };
declare class LightingChannels { 
	/**
	 * Default channel for all primitives and lights.
	*/
	bChannel0: boolean;
	/**
	 * Channel 1
	*/
	bChannel1: boolean;
	/**
	 * Channel 2
	*/
	bChannel2: boolean;
	clone() : LightingChannels;
	static C(Other: UObject): LightingChannels;
}

declare type ECollisionResponse = string | symbol;
declare var ECollisionResponse = { ECR_Ignore:'ECR_Ignore',ECR_Overlap:'ECR_Overlap',ECR_Block:'ECR_Block', };
declare class CollisionResponseContainer { 
	/**
	 * Reserved Engine Trace Channels
	 * Note -        If you change this (add/remove/modify)
	 *                       you should make sure it matches with ECollisionChannel (including DisplayName)
	 *                       They has to be mirrored if serialized
	*/
	WorldStatic: ECollisionResponse;
	/**
	 * 0
	*/
	WorldDynamic: ECollisionResponse;
	/**
	 * 1.
	*/
	Pawn: ECollisionResponse;
	/**
	 * 2
	*/
	Visibility: ECollisionResponse;
	/**
	 * 3
	*/
	Camera: ECollisionResponse;
	/**
	 * 4
	*/
	PhysicsBody: ECollisionResponse;
	/**
	 * 5
	*/
	Vehicle: ECollisionResponse;
	/**
	 * 6
	*/
	Destructible: ECollisionResponse;
	/**
	 * Unspecified Engine Trace Channels
	*/
	EngineTraceChannel1: ECollisionResponse;
	/**
	 * 8
	*/
	EngineTraceChannel2: ECollisionResponse;
	/**
	 * 9
	*/
	EngineTraceChannel3: ECollisionResponse;
	/**
	 * 10
	*/
	EngineTraceChannel4: ECollisionResponse;
	/**
	 * 11
	*/
	EngineTraceChannel5: ECollisionResponse;
	/**
	 * 12
	*/
	EngineTraceChannel6: ECollisionResponse;
	/**
	 * in order to use this custom channels
	 * we recommend to define in your local file
	 * - i.e. #define COLLISION_WEAPON               ECC_GameTraceChannel1
	 * and make sure you customize these it in INI file by
	 * in DefaultEngine.ini
	 * [/Script/Engine.CollisionProfile]
	 * GameTraceChannel1="Weapon"
	 * also in the INI file, you can override collision profiles that are defined by simply redefining
	 * note that Weapon isn't defined in the BaseEngine.ini file, but "Trigger" is defined in Engine
	 * +Profiles=(Name="Trigger",CollisionEnabled=QueryOnly,ObjectTypeName=WorldDynamic, DefaultResponse=ECR_Overlap, CustomResponses=((Channel=Visibility, Response=ECR_Ignore), (Channel=Weapon, Response=ECR_Ignore)))
	*/
	GameTraceChannel1: ECollisionResponse;
	/**
	 * 14
	*/
	GameTraceChannel2: ECollisionResponse;
	/**
	 * 15
	*/
	GameTraceChannel3: ECollisionResponse;
	/**
	 * 16
	*/
	GameTraceChannel4: ECollisionResponse;
	/**
	 * 17
	*/
	GameTraceChannel5: ECollisionResponse;
	/**
	 * 18
	*/
	GameTraceChannel6: ECollisionResponse;
	/**
	 * 19
	*/
	GameTraceChannel7: ECollisionResponse;
	/**
	 * 20
	*/
	GameTraceChannel8: ECollisionResponse;
	/**
	 * 21
	*/
	GameTraceChannel9: ECollisionResponse;
	/**
	 * 22
	*/
	GameTraceChannel10: ECollisionResponse;
	/**
	 * 23
	*/
	GameTraceChannel11: ECollisionResponse;
	/**
	 * 24
	*/
	GameTraceChannel12: ECollisionResponse;
	/**
	 * 25
	*/
	GameTraceChannel13: ECollisionResponse;
	/**
	 * 26
	*/
	GameTraceChannel14: ECollisionResponse;
	/**
	 * 27
	*/
	GameTraceChannel15: ECollisionResponse;
	/**
	 * 28
	*/
	GameTraceChannel16: ECollisionResponse;
	/**
	 * 28
	*/
	GameTraceChannel17: ECollisionResponse;
	/**
	 * 30
	*/
	GameTraceChannel18: ECollisionResponse;
	clone() : CollisionResponseContainer;
	static C(Other: UObject): CollisionResponseContainer;
}

declare class ResponseChannel { 
	/**
	 * This should match DisplayName of ECollisionChannel
	 *     Meta data of custom channels can be used as well
	*/
	Channel: string;
	/**
	 * Response
	*/
	Response: ECollisionResponse;
	clone() : ResponseChannel;
	static C(Other: UObject): ResponseChannel;
}

declare class CollisionResponse { 
	/**
	 * Types of objects that this physics objects will collide with. // @todo : make this to be transient, so that it doesn't have to save anymore
	 * // we have to still load them until resave
	*/
	ResponseToChannels: CollisionResponseContainer;
	/**
	 * Custom Channels for Responses
	*/
	ResponseArray: ResponseChannel[];
	clone() : CollisionResponse;
	static C(Other: UObject): CollisionResponse;
}

declare type EWalkableSlopeBehavior = string | symbol;
declare var EWalkableSlopeBehavior = { WalkableSlope_Default:'WalkableSlope_Default',WalkableSlope_Increase:'WalkableSlope_Increase',WalkableSlope_Decrease:'WalkableSlope_Decrease',WalkableSlope_Unwalkable:'WalkableSlope_Unwalkable', };
declare class WalkableSlopeOverride { 
	/**
	 * Behavior of this surface (whether we affect the walkable slope).
	*/
	WalkableSlopeBehavior: EWalkableSlopeBehavior;
	/**
	 * Override walkable slope, applying the rules of the Walkable Slope Behavior.
	*/
	WalkableSlopeAngle: number;
	clone() : WalkableSlopeOverride;
	static C(Other: UObject): WalkableSlopeOverride;
}

declare type EFrictionCombineMode = string | symbol;
declare var EFrictionCombineMode = { Average:'Average',Min:'Min',Multiply:'Multiply',Max:'Max', };
declare class PhysicalMaterialPropertyBase extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicalMaterialPropertyBase;
	static Find(Outer: UObject, ResourceName: string): PhysicalMaterialPropertyBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicalMaterialPropertyBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterialPropertyBase;
	static C(Other: UObject): PhysicalMaterialPropertyBase;
}

declare type EPhysicalSurface = string | symbol;
declare var EPhysicalSurface = { SurfaceType_Default:'SurfaceType_Default',SurfaceType1:'SurfaceType1',SurfaceType2:'SurfaceType2',SurfaceType3:'SurfaceType3',SurfaceType4:'SurfaceType4',SurfaceType5:'SurfaceType5',SurfaceType6:'SurfaceType6',SurfaceType7:'SurfaceType7',SurfaceType8:'SurfaceType8',SurfaceType9:'SurfaceType9',SurfaceType10:'SurfaceType10',SurfaceType11:'SurfaceType11',SurfaceType12:'SurfaceType12',SurfaceType13:'SurfaceType13',SurfaceType14:'SurfaceType14',SurfaceType15:'SurfaceType15',SurfaceType16:'SurfaceType16',SurfaceType17:'SurfaceType17',SurfaceType18:'SurfaceType18',SurfaceType19:'SurfaceType19',SurfaceType20:'SurfaceType20',SurfaceType21:'SurfaceType21',SurfaceType22:'SurfaceType22',SurfaceType23:'SurfaceType23',SurfaceType24:'SurfaceType24',SurfaceType25:'SurfaceType25',SurfaceType26:'SurfaceType26',SurfaceType27:'SurfaceType27',SurfaceType28:'SurfaceType28',SurfaceType29:'SurfaceType29',SurfaceType30:'SurfaceType30',SurfaceType31:'SurfaceType31',SurfaceType32:'SurfaceType32',SurfaceType33:'SurfaceType33',SurfaceType34:'SurfaceType34',SurfaceType35:'SurfaceType35',SurfaceType36:'SurfaceType36',SurfaceType37:'SurfaceType37',SurfaceType38:'SurfaceType38',SurfaceType39:'SurfaceType39',SurfaceType40:'SurfaceType40',SurfaceType41:'SurfaceType41',SurfaceType42:'SurfaceType42',SurfaceType43:'SurfaceType43',SurfaceType44:'SurfaceType44',SurfaceType45:'SurfaceType45',SurfaceType46:'SurfaceType46',SurfaceType47:'SurfaceType47',SurfaceType48:'SurfaceType48',SurfaceType49:'SurfaceType49',SurfaceType50:'SurfaceType50',SurfaceType51:'SurfaceType51',SurfaceType52:'SurfaceType52',SurfaceType53:'SurfaceType53',SurfaceType54:'SurfaceType54',SurfaceType55:'SurfaceType55',SurfaceType56:'SurfaceType56',SurfaceType57:'SurfaceType57',SurfaceType58:'SurfaceType58',SurfaceType59:'SurfaceType59',SurfaceType60:'SurfaceType60',SurfaceType61:'SurfaceType61',SurfaceType62:'SurfaceType62',SurfaceType_Max:'SurfaceType_Max', };
declare class DataAsset extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DataAsset;
	static Find(Outer: UObject, ResourceName: string): DataAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DataAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DataAsset;
	static C(Other: UObject): DataAsset;
}

declare class TireType extends DataAsset { 
	/**
	 * Scale the tire friction for this tire type
	*/
	FrictionScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TireType;
	static Find(Outer: UObject, ResourceName: string): TireType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TireType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TireType;
	static C(Other: UObject): TireType;
}

declare class TireFrictionScalePair { 
	/**
	 * Tire type
	*/
	TireType: TireType;
	/**
	 * Friction scale for this type of tire
	*/
	FrictionScale: number;
	clone() : TireFrictionScalePair;
	static C(Other: UObject): TireFrictionScalePair;
}

declare class PhysicalMaterial extends UObject { 
	/**
	 * Friction value of surface, controls how easily things can slide on this surface
	*/
	Friction: number;
	/**
	 * Friction combine mode, controls how friction is computed for multiple materials.
	*/
	FrictionCombineMode: EFrictionCombineMode;
	/**
	 * If set we will use the FrictionCombineMode of this material, instead of the FrictionCombineMode found in the project settings.
	*/
	bOverrideFrictionCombineMode: boolean;
	/**
	 * Restitution or 'bounciness' of this surface, between 0 (no bounce) and 1 (outgoing velocity is same as incoming).
	*/
	Restitution: number;
	/**
	 * Restitution combine mode, controls how restitution is computed for multiple materials.
	*/
	RestitutionCombineMode: EFrictionCombineMode;
	/**
	 * If set we will use the RestitutionCombineMode of this material, instead of the RestitutionCombineMode found in the project settings.
	*/
	bOverrideRestitutionCombineMode: boolean;
	/**
	 * Used with the shape of the object to calculate its mass properties. The higher the number, the heavier the object. g per cubic cm.
	*/
	Density: number;
	/**
	 * Used to adjust the way that mass increases as objects get larger. This is applied to the mass as calculated based on a 'solid' object.
	 * In actuality, larger objects do not tend to be solid, and become more like 'shells' (e.g. a car is not a solid piece of metal).
	 * Values are clamped to 1 or less.
	*/
	RaiseMassToPower: number;
	/**
	 * How much to scale the damage threshold by on any destructible we are applied to
	*/
	DestructibleDamageThresholdScale: number;
	/**
	 * deprecated
	*/
	PhysicalMaterialProperty: PhysicalMaterialPropertyBase;
	/**
	 * To edit surface type for your project, use ProjectSettings/Physics/PhysicalSurface section
	*/
	SurfaceType: EPhysicalSurface;
	/**
	 * Overall tire friction scalar for every type of tire. This value is multiplied against our parents' values.
	*/
	TireFrictionScale: number;
	/**
	 * Tire friction scales for specific types of tires. These values are multiplied against our parents' values.
	*/
	TireFrictionScales: TireFrictionScalePair[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicalMaterial;
	static Find(Outer: UObject, ResourceName: string): PhysicalMaterial;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicalMaterial;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicalMaterial;
	static C(Other: UObject): PhysicalMaterial;
}

declare type ESleepFamily = string | symbol;
declare var ESleepFamily = { Normal:'Normal',Sensitive:'Sensitive',Custom:'Custom', };
declare type EDOFMode = string | symbol;
declare var EDOFMode = { Default:'Default',SixDOF:'SixDOF',YZPlane:'YZPlane',XZPlane:'XZPlane',XYPlane:'XYPlane',CustomPlane:'CustomPlane',None:'None', };
declare type ECollisionEnabled = string | symbol;
declare var ECollisionEnabled = { NoCollision:'NoCollision',QueryOnly:'QueryOnly',PhysicsOnly:'PhysicsOnly',QueryAndPhysics:'QueryAndPhysics', };
declare type ECollisionChannel = string | symbol;
declare var ECollisionChannel = { ECC_WorldStatic:'ECC_WorldStatic',ECC_WorldDynamic:'ECC_WorldDynamic',ECC_Pawn:'ECC_Pawn',ECC_Visibility:'ECC_Visibility',ECC_Camera:'ECC_Camera',ECC_PhysicsBody:'ECC_PhysicsBody',ECC_Vehicle:'ECC_Vehicle',ECC_Destructible:'ECC_Destructible',ECC_EngineTraceChannel1:'ECC_EngineTraceChannel1',ECC_EngineTraceChannel2:'ECC_EngineTraceChannel2',ECC_EngineTraceChannel3:'ECC_EngineTraceChannel3',ECC_EngineTraceChannel4:'ECC_EngineTraceChannel4',ECC_EngineTraceChannel5:'ECC_EngineTraceChannel5',ECC_EngineTraceChannel6:'ECC_EngineTraceChannel6',ECC_GameTraceChannel1:'ECC_GameTraceChannel1',ECC_GameTraceChannel2:'ECC_GameTraceChannel2',ECC_GameTraceChannel3:'ECC_GameTraceChannel3',ECC_GameTraceChannel4:'ECC_GameTraceChannel4',ECC_GameTraceChannel5:'ECC_GameTraceChannel5',ECC_GameTraceChannel6:'ECC_GameTraceChannel6',ECC_GameTraceChannel7:'ECC_GameTraceChannel7',ECC_GameTraceChannel8:'ECC_GameTraceChannel8',ECC_GameTraceChannel9:'ECC_GameTraceChannel9',ECC_GameTraceChannel10:'ECC_GameTraceChannel10',ECC_GameTraceChannel11:'ECC_GameTraceChannel11',ECC_GameTraceChannel12:'ECC_GameTraceChannel12',ECC_GameTraceChannel13:'ECC_GameTraceChannel13',ECC_GameTraceChannel14:'ECC_GameTraceChannel14',ECC_GameTraceChannel15:'ECC_GameTraceChannel15',ECC_GameTraceChannel16:'ECC_GameTraceChannel16',ECC_GameTraceChannel17:'ECC_GameTraceChannel17',ECC_GameTraceChannel18:'ECC_GameTraceChannel18',ECC_OverlapAll_Deprecated:'ECC_OverlapAll_Deprecated', };
declare class BodyInstance { 
	/**
	 * @todo : make this to be transient, so that it doesn't have to save anymore
	 * we have to still load them until resave
	*/
	ResponseToChannels: CollisionResponseContainer;
	/**
	 * Collision Profile Name *
	*/
	CollisionProfileName: string;
	/**
	 * Custom Channels for Responses
	*/
	CollisionResponses: CollisionResponse;
	/**
	 * If true Continuous Collision Detection (CCD) will be used for this component
	*/
	bUseCCD: boolean;
	/**
	 * Should 'Hit' events fire when this object collides during physics simulation.
	*/
	bNotifyRigidBodyCollision: boolean;
	/**
	 * If true, this body will use simulation. If false, will be 'fixed' (ie kinematic) and move where it is told.
	*/
	bSimulatePhysics: boolean;
	/**
	 * If true, mass will not be automatically computed and you must set it directly
	*/
	bOverrideMass: boolean;
	/**
	 * If object should have the force of gravity applied
	*/
	bEnableGravity: boolean;
	/**
	 * If true and is attached to a parent, the two bodies will be joined into a single rigid body. Physical settings like collision profile and body settings are determined by the root
	*/
	bAutoWeld: boolean;
	/**
	 * If object should start awake, or if it should initially be sleeping
	*/
	bStartAwake: boolean;
	/**
	 * Should 'wake/sleep' events fire when this object is woken up or put to sleep by the physics simulation.
	*/
	bGenerateWakeEvents: boolean;
	/**
	 * If true, it will update mass when scale changes *
	*/
	bUpdateMassWhenScaleChanges: boolean;
	/**
	 * When a Locked Axis Mode is selected, will lock translation on the specified axis
	*/
	bLockTranslation: boolean;
	/**
	 * When a Locked Axis Mode is selected, will lock rotation to the specified axis
	*/
	bLockRotation: boolean;
	/**
	 * Lock translation along the X-axis
	*/
	bLockXTranslation: boolean;
	/**
	 * Lock translation along the Y-axis
	*/
	bLockYTranslation: boolean;
	/**
	 * Lock translation along the Z-axis
	*/
	bLockZTranslation: boolean;
	/**
	 * Lock rotation about the X-axis
	*/
	bLockXRotation: boolean;
	/**
	 * Lock rotation about the Y-axis
	*/
	bLockYRotation: boolean;
	/**
	 * Lock rotation about the Z-axis
	*/
	bLockZRotation: boolean;
	/**
	 * Override the default max angular velocity
	*/
	bOverrideMaxAngularVelocity: boolean;
	/**
	 * If true, this body will be put into the asynchronous physics scene. If false, it will be put into the synchronous physics scene.
	 * If the body is static, it will be placed into both scenes regardless of the value of bUseAsyncScene.
	*/
	bUseAsyncScene: boolean;
	/**
	 * Whether this body instance has its own custom MaxDepenetrationVelocity
	*/
	bOverrideMaxDepenetrationVelocity: boolean;
	/**
	 * Whether this instance of the object has its own custom walkable slope override setting.
	*/
	bOverrideWalkableSlopeOnInstance: boolean;
	/**
	 * The maximum velocity used to depenetrate this object
	*/
	MaxDepenetrationVelocity: number;
	/**
	 * Mass of the body in KG. By default we compute this based on physical material and mass scale.
	 * @see bOverrideMass to set this directly
	*/
	MassInKgOverride: number;
	/**
	 * 'Drag' force added to reduce linear movement
	*/
	LinearDamping: number;
	/**
	 * 'Drag' force added to reduce angular movement
	*/
	AngularDamping: number;
	/**
	 * Locks physical movement along a custom plane for a given normal.
	*/
	CustomDOFPlaneNormal: Vector;
	/**
	 * User specified offset for the center of mass of this object, from the calculated location
	*/
	COMNudge: Vector;
	/**
	 * Per-instance scaling of mass
	*/
	MassScale: number;
	/**
	 * Custom walkable slope override setting for this instance.
	 * @see GetWalkableSlopeOverride(), SetWalkableSlopeOverride()
	*/
	WalkableSlopeOverride: WalkableSlopeOverride;
	/**
	 * Allows you to override the PhysicalMaterial to use for simple collision on this body.
	*/
	PhysMaterialOverride: PhysicalMaterial;
	/**
	 * The maximum angular velocity for this instance
	*/
	MaxAngularVelocity: number;
	/**
	 * If the SleepFamily is set to custom, multiply the natural sleep threshold by this amount. A higher number will cause the body to sleep sooner.
	*/
	CustomSleepThresholdMultiplier: number;
	/**
	 * Provide appropriate interface for doing this instead of allowing BlueprintReadWrite *
	*/
	PhysicsBlendWeight: number;
	/**
	 * This physics body's solver iteration count for position. Increasing this will be more CPU intensive, but better stabilized.
	*/
	PositionSolverIterationCount: number;
	/**
	 * Internal use. Physics-engine id of the actor used during serialization. Needs to be outside the ifdef for serialization purposes
	*/
	RigidActorSyncId: any;
	/**
	 * Internal use. Physics-engine id of the actor used during serialization.  Needs to be outside the ifdef for serialization purposes
	*/
	RigidActorAsyncId: any;
	/**
	 * This physics body's solver iteration count for velocity. Increasing this will be more CPU intensive, but better stabilized.
	*/
	VelocitySolverIterationCount: number;
	/**
	 * The set of values used in considering when put this body to sleep.
	*/
	SleepFamily: ESleepFamily;
	/**
	 * Locks physical movement along specified axis.
	*/
	DOFMode: EDOFMode;
	/**
	 * Type of collision enabled.
	 *      No Collision      : Will not create any representation in the physics engine. Cannot be used for spatial queries (raycasts, sweeps, overlaps) or simulation (rigid body, constraints). Best performance possible (especially for moving objects)
	 *      Query Only        : Only used for spatial queries (raycasts, sweeps, and overlaps). Cannot be used for simulation (rigid body, constraints). Useful for character movement and things that do not need physical simulation. Performance gains by keeping data out of simulation tree.
	 *      Physics Only      : Only used only for physics simulation (rigid body, constraints). Cannot be used for spatial queries (raycasts, sweeps, overlaps). Useful for jiggly bits on characters that do not need per bone detection. Performance gains by keeping data out of query tree
	 *      Collision Enabled : Can be used for both spatial queries (raycasts, sweeps, overlaps) and simulation (rigid body, constraints).
	*/
	CollisionEnabled: ECollisionEnabled;
	/**
	 * Enum indicating what type of object this should be considered as when it moves
	*/
	ObjectType: ECollisionChannel;
	clone() : BodyInstance;
	static C(Other: UObject): BodyInstance;
}

declare type EHasCustomNavigableGeometry = string | symbol;
declare var EHasCustomNavigableGeometry = { No:'No',Yes:'Yes',EvenIfNotCollidable:'EvenIfNotCollidable',DontExport:'DontExport', };
declare type ECanBeCharacterBase = string | symbol;
declare var ECanBeCharacterBase = { ECB_No:'ECB_No',ECB_Yes:'ECB_Yes',ECB_Owner:'ECB_Owner', };
declare class Vector_NetQuantize extends Vector { 
	clone() : Vector_NetQuantize;
	static C(Other: UObject): Vector_NetQuantize;
}

declare class Vector_NetQuantizeNormal extends Vector { 
	clone() : Vector_NetQuantizeNormal;
	static C(Other: UObject): Vector_NetQuantizeNormal;
}

declare class HitResult { 
	/**
	 * Indicates if this hit was a result of blocking collision. If false, there was no hit or it was an overlap/touch instead.
	*/
	bBlockingHit: boolean;
	/**
	 * Whether the trace started in penetration, i.e. with an initial blocking overlap.
	 * In the case of penetration, if PenetrationDepth > 0.f, then it will represent the distance along the Normal vector that will result in
	 * minimal contact between the swept shape and the object that was hit. In this case, ImpactNormal will be the normal opposed to movement at that location
	 * (ie, Normal may not equal ImpactNormal). ImpactPoint will be the same as Location, since there is no single impact point to report.
	*/
	bStartPenetrating: boolean;
	/**
	 * 'Time' of impact along trace direction (ranging from 0.0 to 1.0) if there is a hit, indicating time between TraceStart and TraceEnd.
	 * For swept movement (but not queries) this may be pulled back slightly from the actual time of impact, to prevent precision problems with adjacent geometry.
	*/
	Time: number;
	/**
	 * The distance from the TraceStart to the ImpactPoint in world space. This value is 0 if there was an initial overlap (trace started inside another colliding object).
	*/
	Distance: number;
	/**
	 * The location in world space where the moving shape would end up against the impacted object, if there is a hit. Equal to the point of impact for line tests.
	 * Example: for a sphere trace test, this is the point where the center of the sphere would be located when it touched the other object.
	 * For swept movement (but not queries) this may not equal the final location of the shape since hits are pulled back slightly to prevent precision issues from overlapping another surface.
	*/
	Location: Vector_NetQuantize;
	/**
	 * Location in world space of the actual contact of the trace shape (box, sphere, ray, etc) with the impacted object.
	 * Example: for a sphere trace test, this is the point where the surface of the sphere touches the other object.
	 * @note: In the case of initial overlap (bStartPenetrating=true), ImpactPoint will be the same as Location because there is no meaningful single impact point to report.
	*/
	ImpactPoint: Vector_NetQuantize;
	/**
	 * Normal of the hit in world space, for the object that was swept. Equal to ImpactNormal for line tests.
	 * This is computed for capsules and spheres, otherwise it will be the same as ImpactNormal.
	 * Example: for a sphere trace test, this is a normalized vector pointing in towards the center of the sphere at the point of impact.
	*/
	Normal: Vector_NetQuantizeNormal;
	/**
	 * Normal of the hit in world space, for the object that was hit by the sweep, if any.
	 * For example if a box hits a flat plane, this is a normalized vector pointing out from the plane.
	 * In the case of impact with a corner or edge of a surface, usually the "most opposing" normal (opposed to the query direction) is chosen.
	*/
	ImpactNormal: Vector_NetQuantizeNormal;
	/**
	 * Start location of the trace.
	 * For example if a sphere is swept against the world, this is the starting location of the center of the sphere.
	*/
	TraceStart: Vector_NetQuantize;
	/**
	 * End location of the trace; this is NOT where the impact occurred (if any), but the furthest point in the attempted sweep.
	 * For example if a sphere is swept against the world, this would be the center of the sphere if there was no blocking hit.
	*/
	TraceEnd: Vector_NetQuantize;
	/**
	 * If this test started in penetration (bStartPenetrating is true) and a depenetration vector can be computed,
	 * this value is the distance along Normal that will result in moving out of penetration.
	 * If the distance cannot be computed, this distance will be zero.
	*/
	PenetrationDepth: number;
	/**
	 * Extra data about item that was hit (hit primitive specific).
	*/
	Item: number;
	/**
	 * Physical material that was hit.
	 * @note Must set bReturnPhysicalMaterial on the swept PrimitiveComponent or in the query params for this to be returned.
	*/
	PhysMaterial: any;
	/**
	 * Actor hit by the trace.
	*/
	Actor: any;
	/**
	 * PrimitiveComponent hit by the trace.
	*/
	Component: any;
	/**
	 * Name of bone we hit (for skeletal meshes).
	*/
	BoneName: string;
	/**
	 * Face index we hit (for complex hits with triangle meshes).
	*/
	FaceIndex: number;
	clone() : HitResult;
	static C(Other: UObject): HitResult;
	/**
	 * Extracts data from a HitResult.
	 * @param Hit                   The source HitResult.
	 * @param bBlockingHit  True if there was a blocking hit, false otherwise.
	 * @param bInitialOverlap True if the hit started in an initial overlap. In this case some other values should be interpreted differently. Time will be 0, ImpactPoint will equal Location, and normals will be equal and indicate a depenetration vector.
	 * @param Time                  'Time' of impact along trace direction ranging from [0.0 to 1.0) if there is a hit, indicating time between start and end. Equals 1.0 if there is no hit.
	 * @param Location              Location of the hit in world space. If this was a swept shape test, this is the location where we can place the shape in the world where it will not penetrate.
	 * @param Normal                Normal of the hit in world space, for the object that was swept (e.g. for a sphere trace this points towards the sphere's center). Equal to ImpactNormal for line tests.
	 * @param ImpactPoint   Location of the actual contact point of the trace shape with the surface of the hit object. Equal to Location in the case of an initial overlap.
	 * @param ImpactNormal  Normal of the hit in world space, for the object that was hit by the sweep.
	 * @param PhysMat               Physical material that was hit. Must set bReturnPhysicalMaterial to true in the query params for this to be returned.
	 * @param HitActor              Actor hit by the trace.
	 * @param HitComponent  PrimitiveComponent hit by the trace.
	 * @param HitBoneName   Name of the bone hit (valid only if we hit a skeletal mesh).
	 * @param HitItem               Primitive-specific data recording which item in the primitive was hit
	 * @param FaceIndex             If colliding with trimesh or landscape, index of face that was hit.
	*/
	BreakHitResult(bBlockingHit?: boolean,bInitialOverlap?: boolean,Time?: number,Location?: Vector,ImpactPoint?: Vector,Normal?: Vector,ImpactNormal?: Vector,PhysMat?: PhysicalMaterial,HitActor?: Actor,HitComponent?: PrimitiveComponent,HitBoneName?: string,HitItem?: number,FaceIndex?: number,TraceStart?: Vector,TraceEnd?: Vector): {bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: string, HitItem: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector};
	/**
	 * Try and find the UV for a collision impact. Note this ONLY works if 'Support UV From Hit Results' is enabled in Physics Settings.
	*/
	FindCollisionUV(UVChannel: number,UV?: Vector2D): {UV: Vector2D, $: boolean};
	/**
	 * Returns the EPhysicalSurface type of the given Hit.
	 * To edit surface type for your project, use ProjectSettings/Physics/PhysicalSurface section
	*/
	GetSurfaceType(): EPhysicalSurface;
	/**
	 * Extracts data from a HitResult.
	 * @param Hit                   The source HitResult.
	 * @param bBlockingHit  True if there was a blocking hit, false otherwise.
	 * @param bInitialOverlap True if the hit started in an initial overlap. In this case some other values should be interpreted differently. Time will be 0, ImpactPoint will equal Location, and normals will be equal and indicate a depenetration vector.
	 * @param Time                  'Time' of impact along trace direction ranging from [0.0 to 1.0) if there is a hit, indicating time between start and end. Equals 1.0 if there is no hit.
	 * @param Location              Location of the hit in world space. If this was a swept shape test, this is the location where we can place the shape in the world where it will not penetrate.
	 * @param Normal                Normal of the hit in world space, for the object that was swept (e.g. for a sphere trace this points towards the sphere's center). Equal to ImpactNormal for line tests.
	 * @param ImpactPoint   Location of the actual contact point of the trace shape with the surface of the hit object. Equal to Location in the case of an initial overlap.
	 * @param ImpactNormal  Normal of the hit in world space, for the object that was hit by the sweep.
	 * @param PhysMat               Physical material that was hit. Must set bReturnPhysicalMaterial to true in the query params for this to be returned.
	 * @param HitActor              Actor hit by the trace.
	 * @param HitComponent  PrimitiveComponent hit by the trace.
	 * @param HitBoneName   Name of the bone hit (valid only if we hit a skeletal mesh).
	 * @param HitItem               Primitive-specific data recording which item in the primitive was hit
	 * @param FaceIndex             If colliding with trimesh or landscape, index of face that was hit.
	*/
	static BreakHitResult(Hit: HitResult,bBlockingHit?: boolean,bInitialOverlap?: boolean,Time?: number,Location?: Vector,ImpactPoint?: Vector,Normal?: Vector,ImpactNormal?: Vector,PhysMat?: PhysicalMaterial,HitActor?: Actor,HitComponent?: PrimitiveComponent,HitBoneName?: string,HitItem?: number,FaceIndex?: number,TraceStart?: Vector,TraceEnd?: Vector): {bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: string, HitItem: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector};
	/**
	 * Try and find the UV for a collision impact. Note this ONLY works if 'Support UV From Hit Results' is enabled in Physics Settings.
	*/
	static FindCollisionUV(Hit: HitResult,UVChannel: number,UV?: Vector2D): {UV: Vector2D, $: boolean};
	/**
	 * Returns the EPhysicalSurface type of the given Hit.
	 * To edit surface type for your project, use ProjectSettings/Physics/PhysicalSurface section
	*/
	static GetSurfaceType(Hit: HitResult): EPhysicalSurface;
	/**
	 * Create a HitResult struct
	 * @param Hit                   The source HitResult.
	 * @param bBlockingHit  True if there was a blocking hit, false otherwise.
	 * @param bInitialOverlap True if the hit started in an initial overlap. In this case some other values should be interpreted differently. Time will be 0, ImpactPoint will equal Location, and normals will be equal and indicate a depenetration vector.
	 * @param Time                  'Time' of impact along trace direction ranging from [0.0 to 1.0) if there is a hit, indicating time between start and end. Equals 1.0 if there is no hit.
	 * @param Location              Location of the hit in world space. If this was a swept shape test, this is the location where we can place the shape in the world where it will not penetrate.
	 * @param Normal                Normal of the hit in world space, for the object that was swept (e.g. for a sphere trace this points towards the sphere's center). Equal to ImpactNormal for line tests.
	 * @param ImpactPoint   Location of the actual contact point of the trace shape with the surface of the hit object. Equal to Location in the case of an initial overlap.
	 * @param ImpactNormal  Normal of the hit in world space, for the object that was hit by the sweep.
	 * @param PhysMat               Physical material that was hit. Must set bReturnPhysicalMaterial to true in the query params for this to be returned.
	 * @param HitActor              Actor hit by the trace.
	 * @param HitComponent  PrimitiveComponent hit by the trace.
	 * @param HitBoneName   Name of the bone hit (valid only if we hit a skeletal mesh).
	 * @param HitItem               Primitive-specific data recording which item in the primitive was hit
	 * @param FaceIndex             If colliding with trimesh or landscape, index of face that was hit.
	*/
	static MakeHitResult(bBlockingHit: boolean,bInitialOverlap: boolean,Time: number,Location: Vector,ImpactPoint: Vector,Normal: Vector,ImpactNormal: Vector,PhysMat: PhysicalMaterial,HitActor: Actor,HitComponent: PrimitiveComponent,HitBoneName: string,HitItem: number,FaceIndex: number,TraceStart: Vector,TraceEnd: Vector): HitResult;
}

declare class Key { 
	/**
	 * Key Name
	*/
	KeyName: string;
	clone() : Key;
	static C(Other: UObject): Key;
	/**
	 * Test if the input key are equal (A == B)
	 * @param A - The key to compare against
	 * @param B - The key to compare
	 * @returns True if the key are equal, false otherwise
	*/
	Equal(B: Key): boolean;
	/**
	 * @returns The display name of the key.
	*/
	Key_GetDisplayName(): string;
	/**
	 * @returns True if the key is a float axis
	*/
	Key_IsFloatAxis(): boolean;
	/**
	 * @returns True if the key is a gamepad button
	*/
	Key_IsGamepadKey(): boolean;
	/**
	 * @returns True if the key is a keyboard button
	*/
	Key_IsKeyboardKey(): boolean;
	/**
	 * @returns True if the key is a modifier key: Ctrl, Command, Alt, Shift
	*/
	Key_IsModifierKey(): boolean;
	/**
	 * @returns True if the key is a mouse button
	*/
	Key_IsMouseButton(): boolean;
	/**
	 * @returns True if the key is a vector axis
	*/
	Key_IsVectorAxis(): boolean;
	/**
	 * Test if the input key are equal (A == B)
	 * @param A - The key to compare against
	 * @param B - The key to compare
	 * @returns True if the key are equal, false otherwise
	*/
	static Equal(A: Key,B: Key): boolean;
	/**
	 * @returns The display name of the key.
	*/
	static Key_GetDisplayName(Key: Key): string;
	/**
	 * @returns True if the key is a float axis
	*/
	static Key_IsFloatAxis(Key: Key): boolean;
	/**
	 * @returns True if the key is a gamepad button
	*/
	static Key_IsGamepadKey(Key: Key): boolean;
	/**
	 * @returns True if the key is a keyboard button
	*/
	static Key_IsKeyboardKey(Key: Key): boolean;
	/**
	 * @returns True if the key is a modifier key: Ctrl, Command, Alt, Shift
	*/
	static Key_IsModifierKey(Key: Key): boolean;
	/**
	 * @returns True if the key is a mouse button
	*/
	static Key_IsMouseButton(Key: Key): boolean;
	/**
	 * @returns True if the key is a vector axis
	*/
	static Key_IsVectorAxis(Key: Key): boolean;
}

declare type ETouchIndex = string | symbol;
declare var ETouchIndex = { Touch1:'Touch1',Touch2:'Touch2',Touch3:'Touch3',Touch4:'Touch4',Touch5:'Touch5',Touch6:'Touch6',Touch7:'Touch7',Touch8:'Touch8',Touch9:'Touch9',Touch10:'Touch10', };
declare class PrimitiveComponentPostPhysicsTickFunction extends TickFunction { 
	clone() : PrimitiveComponentPostPhysicsTickFunction;
	static C(Other: UObject): PrimitiveComponentPostPhysicsTickFunction;
}

declare class SubsurfaceProfileStruct { 
	/**
	 * in world/unreal units (cm)
	*/
	ScatterRadius: number;
	/**
	 * Specifies the how much of the diffuse light gets into the material,
	 * can be seen as a per-channel mix factor between the original image,
	 * and the SSS-filtered image (called "strength" in SeparableSSS, default there: 0.48, 0.41, 0.28)
	*/
	SubsurfaceColor: LinearColor;
	/**
	 * defines the per-channel falloff of the gradients
	 * produced by the subsurface scattering events, can be used to fine tune the color of the gradients
	 * (called "falloff" in SeparableSSS, default there: 1, 0.37, 0.3)
	*/
	FalloffColor: LinearColor;
	clone() : SubsurfaceProfileStruct;
	static C(Other: UObject): SubsurfaceProfileStruct;
}

declare class SubsurfaceProfile extends UObject { 
	/**
	 * Settings
	*/
	Settings: SubsurfaceProfileStruct;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SubsurfaceProfile;
	static Find(Outer: UObject, ResourceName: string): SubsurfaceProfile;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SubsurfaceProfile;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SubsurfaceProfile;
	static C(Other: UObject): SubsurfaceProfile;
}

declare class LightmassMaterialInterfaceSettings { 
	/**
	 * If true, forces translucency to cast static shadows as if the material were masked.
	*/
	bCastShadowAsMasked: boolean;
	/**
	 * Scales the emissive contribution of this material to static lighting.
	*/
	EmissiveBoost: number;
	/**
	 * Scales the diffuse contribution of this material to static lighting.
	*/
	DiffuseBoost: number;
	/**
	 * Scales the resolution that this material's attributes were exported at.
	 * This is useful for increasing material resolution when details are needed.
	*/
	ExportResolutionScale: number;
	/**
	 * If true, override the bCastShadowAsMasked setting of the parent material.
	*/
	bOverrideCastShadowAsMasked: boolean;
	/**
	 * If true, override the emissive boost setting of the parent material.
	*/
	bOverrideEmissiveBoost: boolean;
	/**
	 * If true, override the diffuse boost setting of the parent material.
	*/
	bOverrideDiffuseBoost: boolean;
	/**
	 * If true, override the export resolution scale setting of the parent material.
	*/
	bOverrideExportResolutionScale: boolean;
	clone() : LightmassMaterialInterfaceSettings;
	static C(Other: UObject): LightmassMaterialInterfaceSettings;
}

declare class StringAssetReference { 
	/**
	 * Asset Long Pathname
	*/
	AssetLongPathname: string;
	clone() : StringAssetReference;
	static C(Other: UObject): StringAssetReference;
	/**
	 * End of UObject interface
	*/
	static MakeStringAssetReference(AssetLongPathname: string): StringAssetReference;
}

declare class ThumbnailInfo extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ThumbnailInfo;
	static Find(Outer: UObject, ResourceName: string): ThumbnailInfo;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ThumbnailInfo;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ThumbnailInfo;
	static C(Other: UObject): ThumbnailInfo;
}

declare class MaterialExpressionComment extends MaterialExpression { 
	/**
	 * Size X
	*/
	SizeX: number;
	/**
	 * Size Y
	*/
	SizeY: number;
	/**
	 * Text
	*/
	Text: string;
	/**
	 * Color to style comment with
	*/
	CommentColor: LinearColor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpressionComment;
	static Find(Outer: UObject, ResourceName: string): MaterialExpressionComment;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpressionComment;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpressionComment;
	static C(Other: UObject): MaterialExpressionComment;
}

declare class MaterialFunction extends UObject { 
	/**
	 * Used by materials using this function to know when to recompile.
	*/
	StateId: Guid;
	/**
	 * Used in the material editor, points to the function asset being edited, which this function is just a preview for.
	*/
	ParentFunction: MaterialFunction;
	/**
	 * Description of the function which will be displayed as a tooltip wherever the function is used.
	*/
	Description: string;
	/**
	 * Whether to list this function in the material function library, which is a window in the material editor that lists categorized functions.
	*/
	bExposeToLibrary: boolean;
	/**
	 * Categories that this function belongs to in the material function library.
	 * Ideally categories should be chosen carefully so that there are not too many.
	*/
	LibraryCategories: string[];
	/**
	 * Categories that this function belongs to in the material function library.
	 * Ideally categories should be chosen carefully so that there are not too many.
	*/
	LibraryCategoriesText: string[];
	/**
	 * Array of material expressions, excluding Comments.  Used by the material editor.
	*/
	FunctionExpressions: MaterialExpression[];
	/**
	 * Array of comments associated with this material; viewed in the material editor.
	*/
	FunctionEditorComments: MaterialExpressionComment[];
	/**
	 * Preview Material
	*/
	PreviewMaterial: Material;
	/**
	 * Transient flag used to track re-entrance in recursive functions like IsDependent.
	*/
	bReentrantFlag: boolean;
	/**
	 * Combined Input Types
	*/
	CombinedInputTypes: any;
	/**
	 * Combined Output Types
	*/
	CombinedOutputTypes: any;
	/**
	 * Information for thumbnail rendering
	*/
	ThumbnailInfo: ThumbnailInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialFunction;
	static Find(Outer: UObject, ResourceName: string): MaterialFunction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialFunction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialFunction;
	static C(Other: UObject): MaterialFunction;
}

declare class ExpressionOutput { 
	/**
	 * Output Name
	*/
	OutputName: string;
	/**
	 * Mask
	*/
	Mask: number;
	/**
	 * Mask R
	*/
	MaskR: number;
	/**
	 * Mask G
	*/
	MaskG: number;
	/**
	 * Mask B
	*/
	MaskB: number;
	/**
	 * Mask A
	*/
	MaskA: number;
	clone() : ExpressionOutput;
	static C(Other: UObject): ExpressionOutput;
}

declare class MaterialExpression extends UObject { 
	/**
	 * Material Expression Editor X
	*/
	MaterialExpressionEditorX: number;
	/**
	 * Material Expression Editor Y
	*/
	MaterialExpressionEditorY: number;
	/**
	 * GUID to uniquely identify this node, to help the tutorials out
	*/
	MaterialExpressionGuid: Guid;
	/**
	 * The material that this expression is currently being compiled in.
	 * This is not necessarily the object which owns this expression, for example a preview material compiling a material function's expressions.
	*/
	Material: Material;
	/**
	 * The material function that this expression is being used with, if any.
	 * This will be NULL if the expression belongs to a function that is currently being edited,
	*/
	UFunction: MaterialFunction;
	/**
	 * A description that level designers can add (shows in the material editor UI).
	*/
	Desc: string;
	/**
	 * Color of the expression's border outline.
	*/
	BorderColor: Color;
	/**
	 * Set to true by RecursiveUpdateRealtimePreview() if the expression's preview needs to be updated in realtime in the material editor.
	*/
	bRealtimePreview: boolean;
	/**
	 * If true, we should update the preview next render. This is set when changing bRealtimePreview.
	*/
	bNeedToUpdatePreview: boolean;
	/**
	 * Indicates that this is a 'parameter' type of expression and should always be loaded (ie not cooked away) because we might want the default parameter.
	*/
	bIsParameterExpression: boolean;
	/**
	 * If true, the comment bubble will be visible in the graph editor
	*/
	bCommentBubbleVisible: boolean;
	/**
	 * If true, use the output name as the label for the pin
	*/
	bShowOutputNameOnPin: boolean;
	/**
	 * If true, do not render the preview window for the expression
	*/
	bHidePreviewWindow: boolean;
	/**
	 * If true, show a collapsed version of the node
	*/
	bCollapsed: boolean;
	/**
	 * Whether the node represents an input to the shader or not.  Used to color the node's background.
	*/
	bShaderInputData: boolean;
	/**
	 * Whether to draw the expression's inputs.
	*/
	bShowInputs: boolean;
	/**
	 * Whether to draw the expression's outputs.
	*/
	bShowOutputs: boolean;
	/**
	 * Localized categories to sort this expression into...
	*/
	MenuCategories: string[];
	/**
	 * The expression's outputs, which are set in default properties by derived classes.
	*/
	Outputs: ExpressionOutput[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialExpression;
	static Find(Outer: UObject, ResourceName: string): MaterialExpression;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialExpression;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialExpression;
	static C(Other: UObject): MaterialExpression;
}

declare class MaterialInput { 
	/**
	 * Material expression that this input is connected to, or NULL if not connected.
	*/
	Expression: MaterialExpression;
	/**
	 * Index into Expression's outputs array that this input is connected to.
	*/
	OutputIndex: number;
	/**
	 * Optional name of the input.
	 * Note that this is the only member which is not derived from the output currently connected.
	*/
	InputName: string;
	/**
	 * Mask
	*/
	Mask: number;
	/**
	 * Mask R
	*/
	MaskR: number;
	/**
	 * Mask G
	*/
	MaskG: number;
	/**
	 * Mask B
	*/
	MaskB: number;
	/**
	 * Mask A
	*/
	MaskA: number;
	/**
	 * Material expression name that this input is connected to, or None if not connected. Used only in cooked builds
	*/
	ExpressionName: string;
	clone() : MaterialInput;
	static C(Other: UObject): MaterialInput;
}

declare class ColorMaterialInput extends MaterialInput { 
	/**
	 * Use Constant
	*/
	UseConstant: boolean;
	/**
	 * Constant
	*/
	Constant: Color;
	clone() : ColorMaterialInput;
	static C(Other: UObject): ColorMaterialInput;
}

declare class ScalarMaterialInput extends MaterialInput { 
	/**
	 * Use Constant
	*/
	UseConstant: boolean;
	/**
	 * Constant
	*/
	Constant: number;
	clone() : ScalarMaterialInput;
	static C(Other: UObject): ScalarMaterialInput;
}

declare class VectorMaterialInput extends MaterialInput { 
	/**
	 * Use Constant
	*/
	UseConstant: boolean;
	/**
	 * Constant
	*/
	Constant: Vector;
	clone() : VectorMaterialInput;
	static C(Other: UObject): VectorMaterialInput;
}

declare type EMaterialDomain = string | symbol;
declare var EMaterialDomain = { MD_Surface:'MD_Surface',MD_DeferredDecal:'MD_DeferredDecal',MD_LightFunction:'MD_LightFunction',MD_PostProcess:'MD_PostProcess',MD_UI:'MD_UI', };
declare type EBlendMode = string | symbol;
declare var EBlendMode = { BLEND_Opaque:'BLEND_Opaque',BLEND_Masked:'BLEND_Masked',BLEND_Translucent:'BLEND_Translucent',BLEND_Additive:'BLEND_Additive',BLEND_Modulate:'BLEND_Modulate',BLEND_AlphaComposite:'BLEND_AlphaComposite', };
declare type EDecalBlendMode = string | symbol;
declare var EDecalBlendMode = { DBM_Translucent:'DBM_Translucent',DBM_Stain:'DBM_Stain',DBM_Normal:'DBM_Normal',DBM_Emissive:'DBM_Emissive',DBM_DBuffer_ColorNormalRoughness:'DBM_DBuffer_ColorNormalRoughness',DBM_DBuffer_Color:'DBM_DBuffer_Color',DBM_DBuffer_ColorNormal:'DBM_DBuffer_ColorNormal',DBM_DBuffer_ColorRoughness:'DBM_DBuffer_ColorRoughness',DBM_DBuffer_Normal:'DBM_DBuffer_Normal',DBM_DBuffer_NormalRoughness:'DBM_DBuffer_NormalRoughness',DBM_DBuffer_Roughness:'DBM_DBuffer_Roughness',DBM_Volumetric_DistanceFunction:'DBM_Volumetric_DistanceFunction', };
declare type EMaterialDecalResponse = string | symbol;
declare var EMaterialDecalResponse = { MDR_None:'MDR_None',MDR_ColorNormalRoughness:'MDR_ColorNormalRoughness',MDR_Color:'MDR_Color',MDR_ColorNormal:'MDR_ColorNormal',MDR_ColorRoughness:'MDR_ColorRoughness',MDR_Normal:'MDR_Normal',MDR_NormalRoughness:'MDR_NormalRoughness',MDR_Roughness:'MDR_Roughness', };
declare type EMaterialShadingModel = string | symbol;
declare var EMaterialShadingModel = { MSM_Unlit:'MSM_Unlit',MSM_DefaultLit:'MSM_DefaultLit',MSM_Subsurface:'MSM_Subsurface',MSM_PreintegratedSkin:'MSM_PreintegratedSkin',MSM_ClearCoat:'MSM_ClearCoat',MSM_SubsurfaceProfile:'MSM_SubsurfaceProfile',MSM_TwoSidedFoliage:'MSM_TwoSidedFoliage',MSM_Hair:'MSM_Hair',MSM_Cloth:'MSM_Cloth',MSM_Eye:'MSM_Eye', };
declare class Vector2MaterialInput extends MaterialInput { 
	/**
	 * Use Constant
	*/
	UseConstant: boolean;
	/**
	 * Constant X
	*/
	ConstantX: number;
	/**
	 * Constant Y
	*/
	ConstantY: number;
	clone() : Vector2MaterialInput;
	static C(Other: UObject): Vector2MaterialInput;
}

declare class ExpressionInput { 
	/**
	 * UMaterial expression that this input is connected to, or NULL if not connected.
	*/
	Expression: MaterialExpression;
	/**
	 * Index into Expression's outputs array that this input is connected to.
	*/
	OutputIndex: number;
	/**
	 * optional FName of the input.
	 * Note that this is the only member which is not derived from the output currently connected.
	*/
	InputName: string;
	/**
	 * Mask
	*/
	Mask: number;
	/**
	 * Mask R
	*/
	MaskR: number;
	/**
	 * Mask G
	*/
	MaskG: number;
	/**
	 * Mask B
	*/
	MaskB: number;
	/**
	 * Mask A
	*/
	MaskA: number;
	/**
	 * Material expression name that this input is connected to, or None if not connected. Used only in cooked builds
	*/
	ExpressionName: string;
	clone() : ExpressionInput;
	static C(Other: UObject): ExpressionInput;
}

declare class MaterialAttributesInput extends ExpressionInput { 
	/**
	 * Property Connected Bitmask
	*/
	PropertyConnectedBitmask: number;
	clone() : MaterialAttributesInput;
	static C(Other: UObject): MaterialAttributesInput;
}

declare type ETranslucencyLightingMode = string | symbol;
declare var ETranslucencyLightingMode = { TLM_VolumetricNonDirectional:'TLM_VolumetricNonDirectional',TLM_VolumetricDirectional:'TLM_VolumetricDirectional',TLM_VolumetricPerVertexNonDirectional:'TLM_VolumetricPerVertexNonDirectional',TLM_VolumetricPerVertexDirectional:'TLM_VolumetricPerVertexDirectional',TLM_Surface:'TLM_Surface',TLM_SurfacePerPixelLighting:'TLM_SurfacePerPixelLighting', };
declare type EMaterialTessellationMode = string | symbol;
declare var EMaterialTessellationMode = { MTM_NoTessellation:'MTM_NoTessellation',MTM_FlatTessellation:'MTM_FlatTessellation',MTM_PNTriangles:'MTM_PNTriangles', };
declare class MaterialFunctionInfo { 
	/**
	 * Id that the function had when this material was last compiled.
	*/
	StateId: Guid;
	/**
	 * The function which this material has a dependency on.
	*/
	UFunction: MaterialFunction;
	clone() : MaterialFunctionInfo;
	static C(Other: UObject): MaterialFunctionInfo;
}

declare class CollectionParameterBase { 
	/**
	 * The name of the parameter.  Changing this name will break any blueprints that reference the parameter.
	*/
	ParameterName: string;
	/**
	 * Uniquely identifies the parameter, used for fixing up materials that reference this parameter when renaming.
	*/
	Id: Guid;
	clone() : CollectionParameterBase;
	static C(Other: UObject): CollectionParameterBase;
}

declare class CollectionScalarParameter extends CollectionParameterBase { 
	/**
	 * Default Value
	*/
	DefaultValue: number;
	clone() : CollectionScalarParameter;
	static C(Other: UObject): CollectionScalarParameter;
}

declare class CollectionVectorParameter extends CollectionParameterBase { 
	/**
	 * Default Value
	*/
	DefaultValue: LinearColor;
	clone() : CollectionVectorParameter;
	static C(Other: UObject): CollectionVectorParameter;
}

declare class MaterialParameterCollection extends UObject { 
	/**
	 * Used by materials using this collection to know when to recompile.
	*/
	StateId: Guid;
	/**
	 * Scalar Parameters
	*/
	ScalarParameters: CollectionScalarParameter[];
	/**
	 * Vector Parameters
	*/
	VectorParameters: CollectionVectorParameter[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialParameterCollection;
	static Find(Outer: UObject, ResourceName: string): MaterialParameterCollection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialParameterCollection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialParameterCollection;
	static C(Other: UObject): MaterialParameterCollection;
}

declare class MaterialParameterCollectionInfo { 
	/**
	 * Id that the collection had when this material was last compiled.
	*/
	StateId: Guid;
	/**
	 * The collection which this material has a dependency on.
	*/
	ParameterCollection: MaterialParameterCollection;
	clone() : MaterialParameterCollectionInfo;
	static C(Other: UObject): MaterialParameterCollectionInfo;
}

declare type EBlendableLocation = string | symbol;
declare var EBlendableLocation = { BL_AfterTonemapping:'BL_AfterTonemapping',BL_BeforeTonemapping:'BL_BeforeTonemapping',BL_BeforeTranslucency:'BL_BeforeTranslucency',BL_ReplacingTonemapper:'BL_ReplacingTonemapper', };
declare type ERefractionMode = string | symbol;
declare var ERefractionMode = { RM_IndexOfRefraction:'RM_IndexOfRefraction',RM_PixelNormalOffset:'RM_PixelNormalOffset', };
declare type ETextureSourceFormat = string | symbol;
declare var ETextureSourceFormat = { TSF_Invalid:'TSF_Invalid',TSF_G8:'TSF_G8',TSF_BGRA8:'TSF_BGRA8',TSF_BGRE8:'TSF_BGRE8',TSF_RGBA16:'TSF_RGBA16',TSF_RGBA16F:'TSF_RGBA16F',TSF_RGBA8:'TSF_RGBA8',TSF_RGBE8:'TSF_RGBE8', };
declare class TextureSource { 
	/**
	 * GUID used to track changes to the source data.
	*/
	Id: Guid;
	/**
	 * Width of the texture.
	*/
	SizeX: number;
	/**
	 * Height of the texture.
	*/
	SizeY: number;
	/**
	 * Depth (volume textures) or faces (cube maps).
	*/
	NumSlices: number;
	/**
	 * Number of mips provided as source data for the texture.
	*/
	NumMips: number;
	/**
	 * RGBA8 source data is optionally compressed as PNG.
	*/
	bPNGCompressed: boolean;
	/**
	 * Legacy textures use a hash instead of a GUID.
	*/
	bGuidIsHash: boolean;
	/**
	 * Format in which the source data is stored.
	*/
	Format: ETextureSourceFormat;
	clone() : TextureSource;
	static C(Other: UObject): TextureSource;
}

declare class AssetImportInfo { 
	clone() : AssetImportInfo;
	static C(Other: UObject): AssetImportInfo;
}

declare class AssetImportData extends UObject { 
	/**
	 * Path to the resource used to construct this static mesh. Relative to the object's package, BaseDir() or absolute
	*/
	SourceFilePath: string;
	/**
	 * Date/Time-stamp of the file from the last import
	*/
	SourceFileTimestamp: string;
	/**
	 * Source file data describing the files that were used to import this asset.
	*/
	SourceData: AssetImportInfo;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AssetImportData;
	static Find(Outer: UObject, ResourceName: string): AssetImportData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AssetImportData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AssetImportData;
	static C(Other: UObject): AssetImportData;
}

declare class Vector4 { 
	/**
	 * X
	*/
	X: number;
	/**
	 * Y
	*/
	Y: number;
	/**
	 * Z
	*/
	Z: number;
	/**
	 * W
	*/
	W: number;
	clone() : Vector4;
	static C(Other: UObject): Vector4;
}

declare type ETexturePowerOfTwoSetting = string | symbol;
declare var ETexturePowerOfTwoSetting = { None:'None',PadToPowerOfTwo:'PadToPowerOfTwo',PadToSquarePowerOfTwo:'PadToSquarePowerOfTwo', };
declare type TextureMipGenSettings = string | symbol;
declare var TextureMipGenSettings = { TMGS_FromTextureGroup:'TMGS_FromTextureGroup',TMGS_SimpleAverage:'TMGS_SimpleAverage',TMGS_Sharpen0:'TMGS_Sharpen0',TMGS_Sharpen1:'TMGS_Sharpen1',TMGS_Sharpen2:'TMGS_Sharpen2',TMGS_Sharpen3:'TMGS_Sharpen3',TMGS_Sharpen4:'TMGS_Sharpen4',TMGS_Sharpen5:'TMGS_Sharpen5',TMGS_Sharpen6:'TMGS_Sharpen6',TMGS_Sharpen7:'TMGS_Sharpen7',TMGS_Sharpen8:'TMGS_Sharpen8',TMGS_Sharpen9:'TMGS_Sharpen9',TMGS_Sharpen10:'TMGS_Sharpen10',TMGS_NoMipmaps:'TMGS_NoMipmaps',TMGS_LeaveExistingMips:'TMGS_LeaveExistingMips',TMGS_Blur1:'TMGS_Blur1',TMGS_Blur2:'TMGS_Blur2',TMGS_Blur3:'TMGS_Blur3',TMGS_Blur4:'TMGS_Blur4',TMGS_Blur5:'TMGS_Blur5', };
declare type ECompositeTextureMode = string | symbol;
declare var ECompositeTextureMode = { CTM_Disabled:'CTM_Disabled',CTM_NormalRoughnessToRed:'CTM_NormalRoughnessToRed',CTM_NormalRoughnessToGreen:'CTM_NormalRoughnessToGreen',CTM_NormalRoughnessToBlue:'CTM_NormalRoughnessToBlue',CTM_NormalRoughnessToAlpha:'CTM_NormalRoughnessToAlpha', };
declare type TextureCompressionSettings = string | symbol;
declare var TextureCompressionSettings = { TC_Default:'TC_Default',TC_Normalmap:'TC_Normalmap',TC_Masks:'TC_Masks',TC_Grayscale:'TC_Grayscale',TC_Displacementmap:'TC_Displacementmap',TC_VectorDisplacementmap:'TC_VectorDisplacementmap',TC_HDR:'TC_HDR',TC_EditorIcon:'TC_EditorIcon',TC_Alpha:'TC_Alpha',TC_DistanceFieldFont:'TC_DistanceFieldFont',TC_HDR_Compressed:'TC_HDR_Compressed',TC_BC7:'TC_BC7', };
declare type TextureFilter = string | symbol;
declare var TextureFilter = { TF_Nearest:'TF_Nearest',TF_Bilinear:'TF_Bilinear',TF_Trilinear:'TF_Trilinear',TF_Default:'TF_Default', };
declare type TextureGroup = string | symbol;
declare var TextureGroup = { TEXTUREGROUP_World:'TEXTUREGROUP_World',TEXTUREGROUP_WorldNormalMap:'TEXTUREGROUP_WorldNormalMap',TEXTUREGROUP_WorldSpecular:'TEXTUREGROUP_WorldSpecular',TEXTUREGROUP_Character:'TEXTUREGROUP_Character',TEXTUREGROUP_CharacterNormalMap:'TEXTUREGROUP_CharacterNormalMap',TEXTUREGROUP_CharacterSpecular:'TEXTUREGROUP_CharacterSpecular',TEXTUREGROUP_Weapon:'TEXTUREGROUP_Weapon',TEXTUREGROUP_WeaponNormalMap:'TEXTUREGROUP_WeaponNormalMap',TEXTUREGROUP_WeaponSpecular:'TEXTUREGROUP_WeaponSpecular',TEXTUREGROUP_Vehicle:'TEXTUREGROUP_Vehicle',TEXTUREGROUP_VehicleNormalMap:'TEXTUREGROUP_VehicleNormalMap',TEXTUREGROUP_VehicleSpecular:'TEXTUREGROUP_VehicleSpecular',TEXTUREGROUP_Cinematic:'TEXTUREGROUP_Cinematic',TEXTUREGROUP_Effects:'TEXTUREGROUP_Effects',TEXTUREGROUP_EffectsNotFiltered:'TEXTUREGROUP_EffectsNotFiltered',TEXTUREGROUP_Skybox:'TEXTUREGROUP_Skybox',TEXTUREGROUP_UI:'TEXTUREGROUP_UI',TEXTUREGROUP_Lightmap:'TEXTUREGROUP_Lightmap',TEXTUREGROUP_RenderTarget:'TEXTUREGROUP_RenderTarget',TEXTUREGROUP_MobileFlattened:'TEXTUREGROUP_MobileFlattened',TEXTUREGROUP_ProcBuilding_Face:'TEXTUREGROUP_ProcBuilding_Face',TEXTUREGROUP_ProcBuilding_LightMap:'TEXTUREGROUP_ProcBuilding_LightMap',TEXTUREGROUP_Shadowmap:'TEXTUREGROUP_Shadowmap',TEXTUREGROUP_ColorLookupTable:'TEXTUREGROUP_ColorLookupTable',TEXTUREGROUP_Terrain_Heightmap:'TEXTUREGROUP_Terrain_Heightmap',TEXTUREGROUP_Terrain_Weightmap:'TEXTUREGROUP_Terrain_Weightmap',TEXTUREGROUP_Bokeh:'TEXTUREGROUP_Bokeh',TEXTUREGROUP_IESLightProfile:'TEXTUREGROUP_IESLightProfile',TEXTUREGROUP_Pixels2D:'TEXTUREGROUP_Pixels2D',TEXTUREGROUP_HierarchicalLOD:'TEXTUREGROUP_HierarchicalLOD', };
declare class Texture extends UObject { 
	/**
	 * Source
	*/
	Source: TextureSource;
	/**
	 * Unique ID for this material, used for caching during distributed lighting
	*/
	LightingGuid: Guid;
	/**
	 * Source File Path
	*/
	SourceFilePath: string;
	/**
	 * Asset Import Data
	*/
	AssetImportData: AssetImportData;
	/**
	 * Static texture brightness adjustment (scales HSV value.)  (Non-destructive; Requires texture source art to be available.)
	*/
	AdjustBrightness: number;
	/**
	 * Static texture curve adjustment (raises HSV value to the specified power.)  (Non-destructive; Requires texture source art to be available.)
	*/
	AdjustBrightnessCurve: number;
	/**
	 * Static texture "vibrance" adjustment (0 - 1) (HSV saturation algorithm adjustment.)  (Non-destructive; Requires texture source art to be available.)
	*/
	AdjustVibrance: number;
	/**
	 * Static texture saturation adjustment (scales HSV saturation.)  (Non-destructive; Requires texture source art to be available.)
	*/
	AdjustSaturation: number;
	/**
	 * Static texture RGB curve adjustment (raises linear-space RGB color to the specified power.)  (Non-destructive; Requires texture source art to be available.)
	*/
	AdjustRGBCurve: number;
	/**
	 * Static texture hue adjustment (0 - 360) (offsets HSV hue by value in degrees.)  (Non-destructive; Requires texture source art to be available.)
	*/
	AdjustHue: number;
	/**
	 * Remaps the alpha to the specified min/max range, defines the new value of 0 (Non-destructive; Requires texture source art to be available.)
	*/
	AdjustMinAlpha: number;
	/**
	 * Remaps the alpha to the specified min/max range, defines the new value of 1 (Non-destructive; Requires texture source art to be available.)
	*/
	AdjustMaxAlpha: number;
	/**
	 * If enabled, the texture's alpha channel will be discarded during compression
	*/
	CompressionNoAlpha: boolean;
	/**
	 * Compression None
	*/
	CompressionNone: boolean;
	/**
	 * If enabled, defer compression of the texture until save.
	*/
	DeferCompression: boolean;
	/**
	 * The maximum resolution for generated textures. A value of 0 means the maximum size for the format on each platform, except HDR long/lat cubemaps, which default to a resolution of 512.
	*/
	MaxTextureSize: number;
	/**
	 * When true, the alpha channel of mip-maps and the base image are dithered for smooth LOD transitions.
	*/
	bDitherMipMapAlpha: boolean;
	/**
	 * Alpha values per channel to compare to when preserving alpha coverage.
	*/
	AlphaCoverageThresholds: Vector4;
	/**
	 * When true the texture's border will be preserved during mipmap generation.
	*/
	bPreserveBorder: boolean;
	/**
	 * When true the texture's green channel will be inverted. This is useful for some normal maps.
	*/
	bFlipGreenChannel: boolean;
	/**
	 * For DXT1 textures, setting this will cause the texture to be twice the size, but better looking, on iPhone
	*/
	bForcePVRTC4: boolean;
	/**
	 * How to pad the texture to a power of 2 size (if necessary)
	*/
	PowerOfTwoMode: ETexturePowerOfTwoSetting;
	/**
	 * The color used to pad the texture out if it is resized due to PowerOfTwoMode
	*/
	PaddingColor: Color;
	/**
	 * Whether to chroma key the image, replacing any pixels that match ChromaKeyColor with transparent black
	*/
	bChromaKeyTexture: boolean;
	/**
	 * The threshold that components have to match for the texel to be considered equal to the ChromaKeyColor when chroma keying (<=, set to 0 to require a perfect exact match)
	*/
	ChromaKeyThreshold: number;
	/**
	 * The color that will be replaced with transparent black if chroma keying is enabled
	*/
	ChromaKeyColor: Color;
	/**
	 * Per asset specific setting to define the mip-map generation properties like sharpening and kernel size.
	*/
	MipGenSettings: TextureMipGenSettings;
	/**
	 * Can be defined to modify the roughness based on the normal map variation (mostly from mip maps).
	 * MaxAlpha comes in handy to define a base roughness if no source alpha was there.
	 * Make sure the normal map has at least as many mips as this texture.
	*/
	CompositeTexture: Texture;
	/**
	 * defines how the CompositeTexture is applied, e.g. CTM_RoughnessFromNormalAlpha
	*/
	CompositeTextureMode: ECompositeTextureMode;
	/**
	 * default 1, high values result in a stronger effect e.g 1, 2, 4, 8
	 * this is no slider because the texture update would not be fast enough
	*/
	CompositePower: number;
	/**
	 * A bias to the index of the top mip level to use.
	*/
	LODBias: number;
	/**
	 * Number of mip-levels to use for cinematic quality.
	*/
	NumCinematicMipLevels: number;
	/**
	 * This should be unchecked if using alpha channels individually as masks.
	*/
	SRGB: boolean;
	/**
	 * A flag for using the simplified legacy gamma space e.g pow(color,1/2.2) for converting from FColor to FLinearColor, if we're doing sRGB.
	*/
	bUseLegacyGamma: boolean;
	/**
	 * Never Stream
	*/
	NeverStream: boolean;
	/**
	 * If true, the RHI texture will be created using TexCreate_NoTiling
	*/
	bNoTiling: boolean;
	/**
	 * Whether to use the extra cinematic quality mip-levels, when we're forcing mip-levels to be resident.
	*/
	bUseCinematicMipLevels: boolean;
	/**
	 * Array of user data stored with the asset
	*/
	AssetUserData: AssetUserData[];
	/**
	 * Cached combined group and texture LOD bias to use.
	*/
	CachedCombinedLODBias: number;
	/**
	 * Whether the async resource release process has already been kicked off or not
	*/
	bAsyncResourceReleaseHasBeenStarted: boolean;
	/**
	 * Compression settings to use when building the texture.
	*/
	CompressionSettings: TextureCompressionSettings;
	/**
	 * The texture filtering mode to use when sampling this texture.
	*/
	Filter: TextureFilter;
	/**
	 * Texture group this texture belongs to
	*/
	LODGroup: TextureGroup;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Texture;
	static Find(Outer: UObject, ResourceName: string): Texture;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Texture;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture;
	static C(Other: UObject): Texture;
}

declare class Material extends MaterialInterface { 
	/**
	 * Physical material to use for this graphics material. Used for sounds, effects etc.
	*/
	PhysMaterial: PhysicalMaterial;
	/**
	 * Reflection.
	*/
	DiffuseColor: ColorMaterialInput;
	/**
	 * Specular Color
	*/
	SpecularColor: ColorMaterialInput;
	/**
	 * Base Color
	*/
	BaseColor: ColorMaterialInput;
	/**
	 * Metallic
	*/
	Metallic: ScalarMaterialInput;
	/**
	 * Specular
	*/
	Specular: ScalarMaterialInput;
	/**
	 * Roughness
	*/
	Roughness: ScalarMaterialInput;
	/**
	 * Normal
	*/
	Normal: VectorMaterialInput;
	/**
	 * Emission.
	*/
	EmissiveColor: ColorMaterialInput;
	/**
	 * Transmission.
	*/
	Opacity: ScalarMaterialInput;
	/**
	 * Opacity Mask
	*/
	OpacityMask: ScalarMaterialInput;
	/**
	 * The domain that the material's attributes will be evaluated in.
	 * Certain pieces of material functionality are only valid in certain domains, for example vertex normal is only valid on a surface.
	*/
	MaterialDomain: EMaterialDomain;
	/**
	 * Determines how the material's color is blended with background colors.
	*/
	BlendMode: EBlendMode;
	/**
	 * Defines how the GBuffer chanels are getting manipulated by a decal material pass. (only with MaterialDomain == MD_DeferredDecal)
	*/
	DecalBlendMode: EDecalBlendMode;
	/**
	 * Defines how the material reacts on DBuffer decals (Affects look, performance and texture/sample usage).
	 * Non DBuffer Decals can be disabled on the primitive (e.g. static mesh)
	*/
	MaterialDecalResponse: EMaterialDecalResponse;
	/**
	 * Determines how inputs are combined to create the material's final color.
	*/
	ShadingModel: EMaterialShadingModel;
	/**
	 * If BlendMode is BLEND_Masked, the surface is not rendered where OpacityMask < OpacityMaskClipValue.
	*/
	OpacityMaskClipValue: number;
	/**
	 * Adds to world position in the vertex shader.
	*/
	WorldPositionOffset: VectorMaterialInput;
	/**
	 * Offset in world space applied to tessellated vertices.
	*/
	WorldDisplacement: VectorMaterialInput;
	/**
	 * Multiplies the tessellation factors applied when a tessellation mode is set.
	*/
	TessellationMultiplier: ScalarMaterialInput;
	/**
	 * Inner material color, only used for ShadingModel=Subsurface
	*/
	SubsurfaceColor: ColorMaterialInput;
	/**
	 * Clear Coat
	*/
	ClearCoat: ScalarMaterialInput;
	/**
	 * Clear Coat Roughness
	*/
	ClearCoatRoughness: ScalarMaterialInput;
	/**
	 * output ambient occlusion to the GBuffer
	*/
	AmbientOcclusion: ScalarMaterialInput;
	/**
	 * output refraction index for translucent rendering
	 * Air:1.0 Water:1.333 Ice:1.3 Glass:~1.6 Diamond:2.42
	*/
	Refraction: ScalarMaterialInput;
	/**
	 * These inputs are evaluated in the vertex shader and allow artists to do arbitrary vertex shader operations and access them in the pixel shader.
	 * When unconnected or hidden they default to passing through the vertex UVs.
	*/
	CustomizedUVs: Vector2MaterialInput;
	/**
	 * Material Attributes
	*/
	MaterialAttributes: MaterialAttributesInput;
	/**
	 * Pixel Depth Offset
	*/
	PixelDepthOffset: ScalarMaterialInput;
	/**
	 * Indicates that the material should be rendered in the SeparateTranslucency Pass (not affected by DOF, requires bAllowSeparateTranslucency to be set in .ini).
	*/
	bEnableSeparateTranslucency: boolean;
	/**
	 * Indicates that the translucent material should not be affected by bloom or DOF. (Note: Depth testing is not available)
	*/
	bEnableMobileSeparateTranslucency: boolean;
	/**
	 * Indicates that the material should be rendered using responsive anti-aliasing. Improves sharpness of small moving particles such as sparks.
	 * Only use for small moving features because it will cause aliasing of the background.
	*/
	bEnableResponsiveAA: boolean;
	/**
	 * SSR on translucency
	*/
	bScreenSpaceReflections: boolean;
	/**
	 * Indicates that the material should be rendered without backface culling and the normal should be flipped for backfaces.
	*/
	TwoSided: boolean;
	/**
	 * Whether the material should support a dithered LOD transition.
	*/
	DitheredLODTransition: boolean;
	/**
	 * Dither opacity mask. When combined with Temporal AA this can be used as a form of limited translucency which supports all lighting features.
	*/
	DitherOpacityMask: boolean;
	/**
	 * Whether the material should allow outputting negative emissive color values.  Only allowed on unlit materials.
	*/
	bAllowNegativeEmissiveColor: boolean;
	/**
	 * Number of customized UV inputs to display.  Unconnected customized UV inputs will just pass through the vertex UVs.
	*/
	NumCustomizedUVs: number;
	/**
	 * Sets the lighting mode that will be used on this material if it is translucent.
	*/
	TranslucencyLightingMode: ETranslucencyLightingMode;
	/**
	 * Useful for artificially increasing the influence of the normal on the lighting result for translucency.
	 * A value larger than 1 increases the influence of the normal, a value smaller than 1 makes the lighting more ambient.
	*/
	TranslucencyDirectionalLightingIntensity: number;
	/**
	 * Scale used to make translucent shadows more or less opaque than the material's actual opacity.
	*/
	TranslucentShadowDensityScale: number;
	/**
	 * Scale used to make translucent self-shadowing more or less opaque than the material's shadow on other objects.
	 * This is only used when the object is casting a volumetric translucent shadow.
	*/
	TranslucentSelfShadowDensityScale: number;
	/**
	 * Used to make a second self shadow gradient, to add interesting shading in the shadow of the first.
	*/
	TranslucentSelfShadowSecondDensityScale: number;
	/**
	 * Controls the strength of the second self shadow gradient.
	*/
	TranslucentSelfShadowSecondOpacity: number;
	/**
	 * Controls how diffuse the material's backscattering is when using the MSM_Subsurface shading model.
	 * Larger exponents give a less diffuse look (smaller, brighter backscattering highlight).
	 * This is only used when the object is casting a volumetric translucent shadow from a directional light.
	*/
	TranslucentBackscatteringExponent: number;
	/**
	 * Colored extinction factor used to approximate multiple scattering in dense volumes.
	 * This is only used when the object is casting a volumetric translucent shadow.
	*/
	TranslucentMultipleScatteringExtinction: LinearColor;
	/**
	 * Local space distance to bias the translucent shadow.  Positive values move the shadow away from the light.
	*/
	TranslucentShadowStartOffset: number;
	/**
	 * Whether to draw on top of opaque pixels even if behind them. This only has meaning for translucency.
	*/
	bDisableDepthTest: boolean;
	/**
	 * Whether to generate spherical normals for particles that use this material.
	*/
	bGenerateSphericalParticleNormals: boolean;
	/**
	 * Whether the material takes a tangent space normal or a world space normal as input.
	 * (TangentSpace requires extra instructions but is often more convenient).
	*/
	bTangentSpaceNormal: boolean;
	/**
	 * If enabled, the material's emissive colour is injected into the LightPropagationVolume
	*/
	bUseEmissiveForDynamicAreaLighting: boolean;
	/**
	 * If enabled, the material's opacity defines how much GI is blocked when using the LightPropagationVolume feature
	*/
	bBlockGI: boolean;
	/**
	 * This is a special usage flag that allows a material to be assignable to any primitive type.
	 * This is useful for materials used by code to implement certain viewmodes, for example the default material or lighting only material.
	 * The cost is that nearly 20x more shaders will be compiled for the material than the average material, which will greatly increase shader compile time and memory usage.
	 * This flag should only be enabled when absolutely necessary, and is purposefully not exposed to the UI to prevent abuse.
	*/
	bUsedAsSpecialEngineMaterial: boolean;
	/**
	 * Indicates that the material and its instances can be use with skeletal meshes.
	 * This will result in the shaders required to support skeletal meshes being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithSkeletalMesh: boolean;
	/**
	 * Indicates that the material and its instances can be use with editor compositing
	 * This will result in the shaders required to support editor compositing being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithEditorCompositing: boolean;
	/**
	 * Indicates that the material and its instances can be use with particle sprites
	 * This will result in the shaders required to support particle sprites being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithParticleSprites: boolean;
	/**
	 * Indicates that the material and its instances can be use with beam trails
	 * This will result in the shaders required to support beam trails being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithBeamTrails: boolean;
	/**
	 * Indicates that the material and its instances can be use with mesh particles
	 * This will result in the shaders required to support mesh particles being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithMeshParticles: boolean;
	/**
	 * Indicates that the material and its instances can be use with static lighting
	 * This will result in the shaders required to support static lighting being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithStaticLighting: boolean;
	/**
	 * Indicates that the material and its instances can be use with morph targets
	 * This will result in the shaders required to support morph targets being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithMorphTargets: boolean;
	/**
	 * Indicates that the material and its instances can be use with spline meshes
	 * This will result in the shaders required to support spline meshes being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithSplineMeshes: boolean;
	/**
	 * Indicates that the material and its instances can be use with instanced static meshes
	 * This will result in the shaders required to support instanced static meshes being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithInstancedStaticMeshes: boolean;
	/**
	 * Indicates that the material and its instances can be use with distortion
	 * This will result in the shaders required to support distortion being compiled which will increase shader compile time and memory usage.
	*/
	bUsesDistortion: boolean;
	/**
	 * Indicates that the material and its instances can be use with clothing
	 * This will result in the shaders required to support clothing being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithClothing: boolean;
	/**
	 * Indicates that the material and its instances can be use with Slate UI and UMG
	 * This will result in the shaders required to support UI materials being compiled which will increase shader compile time and memory usage.
	*/
	bUsedWithUI: boolean;
	/**
	 * Whether to automatically set usage flags based on what the material is applied to in the editor.
	 * It can be useful to disable this on a base material with many instances, where adding another usage flag accidentally (eg bUsedWithSkeletalMeshes) can add a lot of shader permutations.
	*/
	bAutomaticallySetUsageInEditor: boolean;
	/**
	 * Forces the material to be completely rough. Saves a number of instructions and one sampler.
	*/
	bFullyRough: boolean;
	/**
	 * Forces this material to use full (highp) precision in the pixel shader.
	 * This is slower than the default (mediump) but can be used to work around precision-related rendering errors.
	 * This setting has no effect on older mobile devices that do not support high precision.
	*/
	bUseFullPrecision: boolean;
	/**
	 * Use lightmap directionality and per pixel normals. If disabled, lighting from lightmaps will be flat but cheaper.
	*/
	bUseLightmapDirectionality: boolean;
	/**
	 * Enables high quality reflections in the forward renderer. Enabling this setting reduces the number of samplers available to the material as two more samplers will be used for reflection cubemaps.
	*/
	bUseHQForwardReflections: boolean;
	/**
	 * Enables planar reflection when using the forward renderer or mobile. Enabling this setting reduces the number of samplers available to the material as one more sampler will be used for the planar reflection.
	*/
	bUsePlanarForwardReflections: boolean;
	/**
	 * The type of tessellation to apply to this object.  Note D3D11 required for anything except MTM_NoTessellation.
	*/
	D3D11TessellationMode: EMaterialTessellationMode;
	/**
	 * Prevents cracks in the surface of the mesh when using tessellation.
	*/
	bEnableCrackFreeDisplacement: boolean;
	/**
	 * Enables adaptive tessellation, which tries to maintain a uniform number of pixels per triangle.
	*/
	bEnableAdaptiveTessellation: boolean;
	/**
	 * Max Displacement
	*/
	MaxDisplacement: number;
	/**
	 * Enables a wireframe view of the mesh the material is applied to.
	*/
	Wireframe: boolean;
	/**
	 * Skips outputting velocity during the base pass.
	*/
	bOutputVelocityOnBasePass: boolean;
	/**
	 * Editor X
	*/
	EditorX: number;
	/**
	 * Editor Y
	*/
	EditorY: number;
	/**
	 * Editor Pitch
	*/
	EditorPitch: number;
	/**
	 * Editor Yaw
	*/
	EditorYaw: number;
	/**
	 * Array of material expressions, excluding Comments.  Used by the material editor.
	*/
	Expressions: MaterialExpression[];
	/**
	 * Array of comments associated with this material; viewed in the material editor.
	*/
	EditorComments: MaterialExpressionComment[];
	/**
	 * Array of all functions this material depends on.
	*/
	MaterialFunctionInfos: MaterialFunctionInfo[];
	/**
	 * Array of all parameter collections this material depends on.
	*/
	MaterialParameterCollectionInfos: MaterialParameterCollectionInfo[];
	/**
	 * true if this Material can be assumed Opaque when set to masked.
	*/
	bCanMaskedBeAssumedOpaque: boolean;
	/**
	 * true if Material is masked and uses custom opacity
	*/
	bIsMasked: boolean;
	/**
	 * true if Material is the preview material used in the material editor.
	*/
	bIsPreviewMaterial: boolean;
	/**
	 * when true, the material attributes pin is used instead of the regular pins.
	*/
	bUseMaterialAttributes: boolean;
	/**
	 * When true, translucent materials are fogged. Defaults to true.
	*/
	bUseTranslucencyVertexFog: boolean;
	/**
	 * If true the compilation environment will be changed to remove the global COMPILE_SHADERS_FOR_DEVELOPMENT flag.
	*/
	bAllowDevelopmentShaderCompile: boolean;
	/**
	 * true if this is a special material used for stats by the material editor.
	*/
	bIsMaterialEditorStatsMaterial: boolean;
	/**
	 * true if we have printed a warning about material usage for a given usage flag.
	*/
	UsageFlagWarnings: any;
	/**
	 * Where the node is inserted in the (post processing) graph, only used if domain is PostProcess
	*/
	BlendableLocation: EBlendableLocation;
	/**
	 * If multiple nodes with the same  type are inserted at the same point, this defined order and if they get combined, only used if domain is PostProcess
	*/
	BlendablePriority: number;
	/**
	 * Controls how the Refraction input is interpreted and how the refraction offset into scene color is computed for this material.
	*/
	RefractionMode: ERefractionMode;
	/**
	 * This is the refraction depth bias, larger values offset distortion to prevent closer objects from rendering into the distorted surface at acute viewing angles but increases the disconnect between surface and where the refraction starts.
	*/
	RefractionDepthBias: number;
	/**
	 * Guid that uniquely identifies this material.
	 * Any changes to the state of the material that do not appear separately in the shadermap DDC keys must cause this guid to be regenerated!
	 * For example, a modification to the Expressions array.
	 * Code changes that cause the guid to be regenerated on load should be avoided, as that requires a resave of the content to stop recompiling every load.
	*/
	StateId: Guid;
	/**
	 * Cached texture references from all expressions in the material (including nested functions).
	 * This is used to link uniform texture expressions which were stored in the DDC with the UTextures that they reference.
	*/
	ExpressionTextureReferences: Texture[];
	/**
	 * Referenced Texture Guids
	*/
	ReferencedTextureGuids: Guid[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Material;
	static Find(Outer: UObject, ResourceName: string): Material;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Material;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Material;
	static C(Other: UObject): Material;
}

declare type EAttachLocation = string | symbol;
declare var EAttachLocation = { KeepRelativeOffset:'KeepRelativeOffset',KeepWorldPosition:'KeepWorldPosition',SnapToTarget:'SnapToTarget',SnapToTargetIncludingScale:'SnapToTargetIncludingScale', };
declare type EFontCacheType = string | symbol;
declare var EFontCacheType = { Offline:'Offline',Runtime:'Runtime', };
declare class FontCharacter { 
	/**
	 * Start U
	*/
	StartU: number;
	/**
	 * Start V
	*/
	StartV: number;
	/**
	 * USize
	*/
	USize: number;
	/**
	 * VSize
	*/
	VSize: number;
	/**
	 * Texture Index
	*/
	TextureIndex: number;
	/**
	 * Vertical Offset
	*/
	VerticalOffset: number;
	clone() : FontCharacter;
	static C(Other: UObject): FontCharacter;
}

declare class IntPoint { 
	/**
	 * X
	*/
	X: number;
	/**
	 * Y
	*/
	Y: number;
	clone() : IntPoint;
	static C(Other: UObject): IntPoint;
}

declare type TextureAddress = string | symbol;
declare var TextureAddress = { TA_Wrap:'TA_Wrap',TA_Clamp:'TA_Clamp',TA_Mirror:'TA_Mirror', };
declare type ESlateBrushDrawType = string | symbol;
declare var ESlateBrushDrawType = { NoDrawType:'NoDrawType',Box:'Box',Border:'Border',Image:'Image', };
declare class Margin { 
	/**
	 * Holds the margin to the left.
	*/
	Left: number;
	/**
	 * Holds the margin to the top.
	*/
	Top: number;
	/**
	 * Holds the margin to the right.
	*/
	Right: number;
	/**
	 * Holds the margin to the bottom.
	*/
	Bottom: number;
	clone() : Margin;
	static C(Other: UObject): Margin;
}

declare type ESlateColorStylingMode = string | symbol;
declare var ESlateColorStylingMode = { UseColor_Specified:'UseColor_Specified',UseColor_Specified_Link:'UseColor_Specified_Link',UseColor_Foreground:'UseColor_Foreground',UseColor_Foreground_Subdued:'UseColor_Foreground_Subdued', };
declare class SlateColor { 
	/**
	 * The current specified color; only meaningful when ColorToUse == UseColor_Specified.
	*/
	SpecifiedColor: LinearColor;
	/**
	 * The rule for which color to pick.
	*/
	ColorUseRule: ESlateColorStylingMode;
	clone() : SlateColor;
	static C(Other: UObject): SlateColor;
	/**
	 * Slate Color Use Foreground
	*/
	static SlateColor_UseForeground(): SlateColor;
	/**
	 * Slate Color Use Subdued Foreground
	*/
	static SlateColor_UseSubduedForeground(): SlateColor;
}

declare type ESlateBrushTileType = string | symbol;
declare var ESlateBrushTileType = { NoTile:'NoTile',Horizontal:'Horizontal',Vertical:'Vertical',Both:'Both', };
declare type ESlateBrushMirrorType = string | symbol;
declare var ESlateBrushMirrorType = { NoMirror:'NoMirror',Horizontal:'Horizontal',Vertical:'Vertical',Both:'Both', };
declare type ESlateBrushImageType = string | symbol;
declare var ESlateBrushImageType = { NoImage:'NoImage',FullColor:'FullColor',Linear:'Linear', };
declare class Box2D { 
	/**
	 * Min
	*/
	Min: Vector2D;
	/**
	 * Max
	*/
	Max: Vector2D;
	/**
	 * Is Valid
	*/
	IsValid: number;
	clone() : Box2D;
	static C(Other: UObject): Box2D;
}

declare class SlateBrush { 
	/**
	 * Size of the resource in Slate Units
	*/
	ImageSize: Vector2D;
	/**
	 * How to draw the image
	*/
	DrawAs: ESlateBrushDrawType;
	/**
	 * The margin to use in Box and Border modes
	*/
	Margin: Margin;
	/**
	 * Tinting applied to the image.
	*/
	Tint: LinearColor;
	/**
	 * Tinting applied to the image.
	*/
	TintColor: SlateColor;
	/**
	 * How to tile the image in Image mode
	*/
	Tiling: ESlateBrushTileType;
	/**
	 * How to mirror the image in Image mode.  This is normally only used for dynamic image brushes where the source texture
	 *           comes from a hardware device such as a web camera.
	*/
	Mirroring: ESlateBrushMirrorType;
	/**
	 * The type of image
	*/
	ImageType: ESlateBrushImageType;
	/**
	 * The image to render for this brush, can be a UTexture or UMaterialInterface or an object implementing
	 * the AtlasedTextureInterface.
	*/
	ResourceObject: UObject;
	/**
	 * The name of the rendering resource to use
	*/
	ResourceName: string;
	/**
	 * Whether or not the brush path is a path to a UObject
	*/
	bIsDynamicallyLoaded: boolean;
	/**
	 * Whether or not the brush has a UTexture resource
	*/
	bHasUObject: boolean;
	/**
	 * Optional UV region for an image
	 * When valid - overrides UV region specified in resource proxy
	*/
	UVRegion: Box2D;
	clone() : SlateBrush;
	static C(Other: UObject): SlateBrush;
	/**
	 * Gets the resource object on a brush.  This could be a UTexture2D or a UMaterialInterface.
	*/
	GetBrushResource(): {Brush: SlateBrush, $: UObject};
	/**
	 * Gets the brush resource as a material.
	*/
	GetBrushResourceAsMaterial(): {Brush: SlateBrush, $: MaterialInterface};
	/**
	 * Gets the brush resource as a texture 2D.
	*/
	GetBrushResourceAsTexture2D(): {Brush: SlateBrush, $: Texture2D};
	/**
	 * Gets the material that allows changes to parameters at runtime.  The brush must already have a material assigned to it,
	 * if it does it will automatically be converted to a MID.
	 * @return A material that supports dynamic input from the game.
	*/
	GetDynamicMaterial(): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	/**
	 * Sets the resource on a brush to be a Material.
	*/
	SetBrushResourceToMaterial(Material?: MaterialInterface): {Brush: SlateBrush};
	/**
	 * Sets the resource on a brush to be a UTexture2D.
	*/
	SetBrushResourceToTexture(Texture?: Texture2D): {Brush: SlateBrush};
	/**
	 * Gets the resource object on a brush.  This could be a UTexture2D or a UMaterialInterface.
	*/
	static GetBrushResource(Brush?: SlateBrush): {Brush: SlateBrush, $: UObject};
	/**
	 * Gets the brush resource as a material.
	*/
	static GetBrushResourceAsMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInterface};
	/**
	 * Gets the brush resource as a texture 2D.
	*/
	static GetBrushResourceAsTexture2D(Brush?: SlateBrush): {Brush: SlateBrush, $: Texture2D};
	/**
	 * Gets the material that allows changes to parameters at runtime.  The brush must already have a material assigned to it,
	 * if it does it will automatically be converted to a MID.
	 * @return A material that supports dynamic input from the game.
	*/
	static GetDynamicMaterial(Brush?: SlateBrush): {Brush: SlateBrush, $: MaterialInstanceDynamic};
	/**
	 * Sets the resource on a brush to be a Material.
	*/
	static SetBrushResourceToMaterial(Brush?: SlateBrush,Material?: MaterialInterface): {Brush: SlateBrush};
	/**
	 * Sets the resource on a brush to be a UTexture2D.
	*/
	static SetBrushResourceToTexture(Brush?: SlateBrush,Texture?: Texture2D): {Brush: SlateBrush};
	/**
	 * Creates a Slate Brush that wont draw anything, the "Null Brush".
	 * @return A new slate brush that wont draw anything.
	*/
	static NoResourceBrush(): SlateBrush;
}

declare class Texture2D extends Texture { 
	/**
	 * Number of miplevels the texture should have resident.
	*/
	RequestedMips: number;
	/**
	 * Number of miplevels currently resident.
	*/
	ResidentMips: number;
	/**
	 * FStreamingTexture index used by the texture streaming system.
	*/
	StreamingIndex: number;
	/**
	 * * Level scope index of this texture. It is used to reduce the amount of lookup to map a texture to its level index.
	 * * Useful when building texture streaming data, as well as when filling the texture streamer with precomputed data.
	 * * It relates to FStreamingTextureBuildInfo::TextureLevelIndex and also the index in ULevel::StreamingTextureGuids.
	 * * Default value of -1, indicates that the texture has an unknown index (not yet processed). At level load time,
	 * * -2 is also used to indicate that the texture has been processed but no entry were found in the level table.
	 * * After any of these processes, the LevelIndex is reset to INDEX_NONE. Making it ready for the next level task.
	*/
	LevelIndex: number;
	/**
	 * keep track of first mip level used for ResourceMem creation
	*/
	FirstResourceMemMip: number;
	/**
	 * The imported size of the texture. Only valid on cooked builds when texture source is not
	 * available. Access ONLY via the GetImportedSize() accessor!
	*/
	ImportedSize: IntPoint;
	/**
	 * WorldSettings timestamp that tells the streamer to force all miplevels to be resident up until that time.
	*/
	ForceMipLevelsToBeResidentTimestamp: any;
	/**
	 * True if streaming is temporarily disabled so we can update subregions of this texture's resource
	 *       without streaming clobbering it. Automatically cleared before saving.
	*/
	bTemporarilyDisableStreaming: boolean;
	/**
	 * Whether the texture is currently streamable or not.
	*/
	bIsStreamable: boolean;
	/**
	 * Whether the current texture mip change request is pending cancellation.
	*/
	bHasCancelationPending: boolean;
	/**
	 * Override whether to fully stream even if texture hasn't been rendered.
	*/
	bForceMiplevelsToBeResident: boolean;
	/**
	 * Global and serialized version of ForceMiplevelsToBeResident.
	*/
	bGlobalForceMipLevelsToBeResident: boolean;
	/**
	 * Whether the texture has been painted in the editor.
	*/
	bHasBeenPaintedInEditor: boolean;
	/**
	 * The addressing mode to use for the X axis.
	*/
	AddressX: TextureAddress;
	/**
	 * The addressing mode to use for the Y axis.
	*/
	AddressY: TextureAddress;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Texture2D;
	static Find(Outer: UObject, ResourceName: string): Texture2D;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Texture2D;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Texture2D;
	/**
	 * Gets the Y size of the texture, in pixels
	*/
	GetSizeY(): number;
	/**
	 * Gets the X size of the texture, in pixels
	*/
	GetSizeX(): number;
	static C(Other: UObject): Texture2D;
	/**
	 * Adds loading splash screen with parameters
	 * @param Texture                       (in) A texture asset to be used for the splash. GearVR uses it as a path for loading icon; all other params are currently ignored by GearVR.
	 * @param TranslationInMeters (in) Initial translation of the center of the splash screen (in meters).
	 * @param Rotation                      (in) Initial rotation of the splash screen, with the origin at the center of the splash screen.
	 * @param SizeInMeters          (in) Size, in meters, of the quad with the splash screen.
	 * @param DeltaRotation         (in) Incremental rotation, that is added each 2nd frame to the quad transform. The quad is rotated around the center of the quad.
	 * @param bClearBeforeAdd       (in) If true, clears splashes before adding a new one.
	*/
	AddLoadingSplashScreen(TranslationInMeters: Vector,Rotation: Rotator,SizeInMeters: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	/**
	 * Sets a texture for loading icon mode and shows it. This call will clear all the splashes.
	*/
	ShowLoadingIcon(): void;
	/**
	 * Creates a Slate Brush from a Texture2D
	 * @param Width  When less than or equal to zero, the Width of the brush will default to the Width of the Texture
	 * @param Height  When less than or equal to zero, the Height of the brush will default to the Height of the Texture
	 * @return A new slate brush using the texture.
	*/
	MakeBrushFromTexture(Width: number,Height: number): SlateBrush;
	/**
	 * Adds loading splash screen with parameters
	 * @param Texture                       (in) A texture asset to be used for the splash. GearVR uses it as a path for loading icon; all other params are currently ignored by GearVR.
	 * @param TranslationInMeters (in) Initial translation of the center of the splash screen (in meters).
	 * @param Rotation                      (in) Initial rotation of the splash screen, with the origin at the center of the splash screen.
	 * @param SizeInMeters          (in) Size, in meters, of the quad with the splash screen.
	 * @param DeltaRotation         (in) Incremental rotation, that is added each 2nd frame to the quad transform. The quad is rotated around the center of the quad.
	 * @param bClearBeforeAdd       (in) If true, clears splashes before adding a new one.
	*/
	static AddLoadingSplashScreen(Texture: Texture2D,TranslationInMeters: Vector,Rotation: Rotator,SizeInMeters: Vector2D,DeltaRotation: Rotator,bClearBeforeAdd: boolean): void;
	/**
	 * Sets a texture for loading icon mode and shows it. This call will clear all the splashes.
	*/
	static ShowLoadingIcon(Texture: Texture2D): void;
	/**
	 * Creates a Slate Brush from a Texture2D
	 * @param Width  When less than or equal to zero, the Width of the brush will default to the Width of the Texture
	 * @param Height  When less than or equal to zero, the Height of the brush will default to the Height of the Texture
	 * @return A new slate brush using the texture.
	*/
	static MakeBrushFromTexture(Texture: Texture2D,Width: number,Height: number): SlateBrush;
}

declare type EFontImportCharacterSet = string | symbol;
declare var EFontImportCharacterSet = { FontICS_Default:'FontICS_Default',FontICS_Ansi:'FontICS_Ansi',FontICS_Symbol:'FontICS_Symbol', };
declare class FontImportOptionsData { 
	/**
	 * Name of the typeface for the font to import
	*/
	FontName: string;
	/**
	 * Height of font (point size)
	*/
	Height: number;
	/**
	 * Whether the font should be antialiased or not.  Usually you should leave this enabled.
	*/
	bEnableAntialiasing: boolean;
	/**
	 * Whether the font should be generated in bold or not
	*/
	bEnableBold: boolean;
	/**
	 * Whether the font should be generated in italics or not
	*/
	bEnableItalic: boolean;
	/**
	 * Whether the font should be generated with an underline or not
	*/
	bEnableUnderline: boolean;
	/**
	 * if true then forces PF_G8 and only maintains Alpha value and discards color
	*/
	bAlphaOnly: boolean;
	/**
	 * Character set for this font
	*/
	CharacterSet: EFontImportCharacterSet;
	/**
	 * Explicit list of characters to include in the font
	*/
	Chars: string;
	/**
	 * Range of Unicode character values to include in the font.  You can specify ranges using hyphens and/or commas (e.g. '400-900')
	*/
	UnicodeRange: string;
	/**
	 * Path on disk to a folder where files that contain a list of characters to include in the font
	*/
	CharsFilePath: string;
	/**
	 * File mask wildcard that specifies which files within the CharsFilePath to scan for characters in include in the font
	*/
	CharsFileWildcard: string;
	/**
	 * Skips generation of glyphs for any characters that are not considered 'printable'
	*/
	bCreatePrintableOnly: boolean;
	/**
	 * When specifying a range of characters and this is enabled, forces ASCII characters (0 thru 255) to be included as well
	*/
	bIncludeASCIIRange: boolean;
	/**
	 * Color of the foreground font pixels.  Usually you should leave this white and instead use the UI Styles editor to change the color of the font on the fly
	*/
	ForegroundColor: LinearColor;
	/**
	 * Enables a very simple, 1-pixel, black colored drop shadow for the generated font
	*/
	bEnableDropShadow: boolean;
	/**
	 * Horizontal size of each texture page for this font in pixels
	*/
	TexturePageWidth: number;
	/**
	 * The maximum vertical size of a texture page for this font in pixels.  The actual height of a texture page may be less than this if the font can fit within a smaller sized texture page.
	*/
	TexturePageMaxHeight: number;
	/**
	 * Horizontal padding between each font character on the texture page in pixels
	*/
	XPadding: number;
	/**
	 * Vertical padding between each font character on the texture page in pixels
	*/
	YPadding: number;
	/**
	 * How much to extend the top of the UV coordinate rectangle for each character in pixels
	*/
	ExtendBoxTop: number;
	/**
	 * How much to extend the bottom of the UV coordinate rectangle for each character in pixels
	*/
	ExtendBoxBottom: number;
	/**
	 * How much to extend the right of the UV coordinate rectangle for each character in pixels
	*/
	ExtendBoxRight: number;
	/**
	 * How much to extend the left of the UV coordinate rectangle for each character in pixels
	*/
	ExtendBoxLeft: number;
	/**
	 * Enables legacy font import mode.  This results in lower quality antialiasing and larger glyph bounds, but may be useful when debugging problems
	*/
	bEnableLegacyMode: boolean;
	/**
	 * The initial horizontal spacing adjustment between rendered characters.  This setting will be copied directly into the generated Font object's properties.
	*/
	Kerning: number;
	/**
	 * If true then the alpha channel of the font textures will store a distance field instead of a color mask
	*/
	bUseDistanceFieldAlpha: boolean;
	/**
	 * Scale factor determines how big to scale the font bitmap during import when generating distance field values
	 * Note that higher values give better quality but importing will take much longer.
	*/
	DistanceFieldScaleFactor: number;
	/**
	 * Shrinks or expands the scan radius used to determine the silhouette of the font edges.
	*/
	DistanceFieldScanRadiusScale: number;
	clone() : FontImportOptionsData;
	static C(Other: UObject): FontImportOptionsData;
}

declare class FontBulkData extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): FontBulkData;
	static Find(Outer: UObject, ResourceName: string): FontBulkData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): FontBulkData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): FontBulkData;
	static C(Other: UObject): FontBulkData;
}

declare type EFontHinting = string | symbol;
declare var EFontHinting = { Default:'Default',Auto:'Auto',AutoLight:'AutoLight',Monochrome:'Monochrome',None:'None', };
declare class FontData { 
	/**
	 * The filename of the font to use - this may not always exist on disk, as we may have previously loaded and cached the font data inside an asset
	*/
	FontFilename: string;
	/**
	 * The data associated with the font
	*/
	BulkDataPtr: FontBulkData;
	/**
	 * The hinting algorithm to use with the font
	*/
	Hinting: EFontHinting;
	/**
	 * The data associated with the font - this should always be filled in providing the source font filename is valid
	*/
	FontData: number[];
	clone() : FontData;
	static C(Other: UObject): FontData;
}

declare class TypefaceEntry { 
	/**
	 * Name used to identify this font within its typeface
	*/
	Name: string;
	/**
	 * Raw font data for this font
	*/
	Font: FontData;
	clone() : TypefaceEntry;
	static C(Other: UObject): TypefaceEntry;
}

declare class Typeface { 
	/**
	 * The fonts contained within this family
	*/
	Fonts: TypefaceEntry[];
	clone() : Typeface;
	static C(Other: UObject): Typeface;
}

declare type ERangeBoundTypes = string | symbol;
declare var ERangeBoundTypes = { Exclusive:'Exclusive',Inclusive:'Inclusive',Open:'Open', };
declare class Int32RangeBound { 
	/**
	 * Type
	*/
	Type: ERangeBoundTypes;
	/**
	 * Value
	*/
	Value: number;
	clone() : Int32RangeBound;
	static C(Other: UObject): Int32RangeBound;
}

declare class Int32Range { 
	/**
	 * Lower Bound
	*/
	LowerBound: Int32RangeBound;
	/**
	 * Upper Bound
	*/
	UpperBound: Int32RangeBound;
	clone() : Int32Range;
	static C(Other: UObject): Int32Range;
}

declare class CompositeSubFont { 
	/**
	 * Typeface data for this sub-font
	*/
	Typeface: Typeface;
	/**
	 * Array of character ranges for which this sub-font should be used
	*/
	CharacterRanges: Int32Range[];
	/**
	 * Amount to scale this sub-font so that it better matches the size of the default font
	*/
	ScalingFactor: number;
	/**
	 * Name of this sub-font. Only used by the editor UI as a convenience to let you state the purpose of the font family.
	*/
	EditorName: string;
	clone() : CompositeSubFont;
	static C(Other: UObject): CompositeSubFont;
}

declare class CompositeFont { 
	/**
	 * The default typeface that will be used when not overridden by a sub-typeface
	*/
	DefaultTypeface: Typeface;
	/**
	 * Sub-typefaces to use for a specific set of characters
	*/
	SubTypefaces: CompositeSubFont[];
	clone() : CompositeFont;
	static C(Other: UObject): CompositeFont;
}

declare class Font extends UObject { 
	/**
	 * What kind of font caching should we use? This controls which options we see
	*/
	FontCacheType: EFontCacheType;
	/**
	 * List of characters in the font.  For a MultiFont, this will include all characters in all sub-fonts!  Thus,
	 *               the number of characters in this array isn't necessary the number of characters available in the font
	*/
	Characters: FontCharacter[];
	/**
	 * Textures that store this font's glyph image data //NOTE: Do not expose this to the editor as it has nasty crash potential
	*/
	Textures: Texture2D[];
	/**
	 * True if font is 'remapped'.  That is, the character array is not a direct mapping to unicode values.  Instead,
	 *               all characters are indexed indirectly through the CharRemap array
	*/
	IsRemapped: number;
	/**
	 * Font metrics.
	*/
	EmScale: number;
	/**
	 * @todo document
	*/
	Ascent: number;
	/**
	 * @todo document
	*/
	Descent: number;
	/**
	 * @todo document
	*/
	Leading: number;
	/**
	 * Default horizontal spacing between characters when rendering text with this font
	*/
	Kerning: number;
	/**
	 * Options used when importing this font
	*/
	ImportOptions: FontImportOptionsData;
	/**
	 * Number of characters in the font, not including multiple instances of the same character (for multi-fonts).
	 *               This is cached at load-time or creation time, and is never serialized.
	*/
	NumCharacters: number;
	/**
	 * The maximum height of a character in this font.  For multi-fonts, this array will contain a maximum
	 *               character height for each multi-font, otherwise the array will contain only a single element.  This is
	 *               cached at load-time or creation time, and is never serialized.
	*/
	MaxCharHeight: number[];
	/**
	 * Scale to apply to the font.
	*/
	ScalingFactor: number;
	/**
	 * The default size of the font used for legacy Canvas APIs that don't specify a font size
	*/
	LegacyFontSize: number;
	/**
	 * The default font name to use for legacy Canvas APIs that don't specify a font name
	*/
	LegacyFontName: string;
	/**
	 * Embedded composite font data
	*/
	CompositeFont: CompositeFont;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Font;
	static Find(Outer: UObject, ResourceName: string): Font;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Font;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Font;
	static C(Other: UObject): Font;
}

declare class FontParameterValue { 
	/**
	 * Parameter Name
	*/
	ParameterName: string;
	/**
	 * Font Value
	*/
	FontValue: Font;
	/**
	 * Font Page
	*/
	FontPage: number;
	/**
	 * Expression GUID
	*/
	ExpressionGUID: Guid;
	clone() : FontParameterValue;
	static C(Other: UObject): FontParameterValue;
}

declare class ScalarParameterValue { 
	/**
	 * Parameter Name
	*/
	ParameterName: string;
	/**
	 * Parameter Value
	*/
	ParameterValue: number;
	/**
	 * Expression GUID
	*/
	ExpressionGUID: Guid;
	clone() : ScalarParameterValue;
	static C(Other: UObject): ScalarParameterValue;
}

declare class TextureParameterValue { 
	/**
	 * Parameter Name
	*/
	ParameterName: string;
	/**
	 * Parameter Value
	*/
	ParameterValue: Texture;
	/**
	 * Expression GUID
	*/
	ExpressionGUID: Guid;
	clone() : TextureParameterValue;
	static C(Other: UObject): TextureParameterValue;
}

declare class VectorParameterValue { 
	/**
	 * Parameter Name
	*/
	ParameterName: string;
	/**
	 * Parameter Value
	*/
	ParameterValue: LinearColor;
	/**
	 * Expression GUID
	*/
	ExpressionGUID: Guid;
	clone() : VectorParameterValue;
	static C(Other: UObject): VectorParameterValue;
}

declare class MaterialInstanceBasePropertyOverrides { 
	/**
	 * Enables override of the opacity mask clip value.
	*/
	bOverride_OpacityMaskClipValue: boolean;
	/**
	 * Enables override of the blend mode.
	*/
	bOverride_BlendMode: boolean;
	/**
	 * Enables override of the shading model.
	*/
	bOverride_ShadingModel: boolean;
	/**
	 * Enables override of the two sided property.
	*/
	bOverride_DitheredLODTransition: boolean;
	/**
	 * Enables override of the two sided property.
	*/
	bOverride_TwoSided: boolean;
	/**
	 * If BlendMode is BLEND_Masked, the surface is not rendered where OpacityMask < OpacityMaskClipValue.
	*/
	OpacityMaskClipValue: number;
	/**
	 * The blend mode
	*/
	BlendMode: EBlendMode;
	/**
	 * The shading model
	*/
	ShadingModel: EMaterialShadingModel;
	/**
	 * Indicates that the material should be rendered without backface culling and the normal should be flipped for backfaces.
	*/
	TwoSided: boolean;
	/**
	 * Whether the material should support a dithered LOD transition when used with the foliage system.
	*/
	DitheredLODTransition: boolean;
	clone() : MaterialInstanceBasePropertyOverrides;
	static C(Other: UObject): MaterialInstanceBasePropertyOverrides;
}

declare class MaterialInstance extends MaterialInterface { 
	/**
	 * Physical material to use for this graphics material. Used for sounds, effects etc.
	*/
	PhysMaterial: PhysicalMaterial;
	/**
	 * Parent material.
	*/
	Parent: MaterialInterface;
	/**
	 * Indicates whether the instance has static permutation resources (which are required when static parameters are present)
	 * Read directly from the rendering thread, can only be modified with the use of a FMaterialUpdateContext.
	 * When true, StaticPermutationMaterialResources will always be valid and non-null.
	*/
	bHasStaticPermutationResource: boolean;
	/**
	 * Defines if SubsurfaceProfile from this instance is used or it uses the parent one.
	*/
	bOverrideSubsurfaceProfile: boolean;
	/**
	 * Unique ID for this material, used for caching during distributed lighting
	*/
	ParentLightingGuid: Guid;
	/**
	 * Font parameters.
	*/
	FontParameterValues: FontParameterValue[];
	/**
	 * Scalar parameters.
	*/
	ScalarParameterValues: ScalarParameterValue[];
	/**
	 * Texture parameters.
	*/
	TextureParameterValues: TextureParameterValue[];
	/**
	 * Vector parameters.
	*/
	VectorParameterValues: VectorParameterValue[];
	/**
	 * Override Base Properties
	*/
	bOverrideBaseProperties: boolean;
	/**
	 * Base Property Overrides
	*/
	BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
	/**
	 * Referenced Texture Guids
	*/
	ReferencedTextureGuids: Guid[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInstance;
	static Find(Outer: UObject, ResourceName: string): MaterialInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstance;
	static C(Other: UObject): MaterialInstance;
}

declare class MaterialInstanceDynamic extends MaterialInstance { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInstanceDynamic;
	static Find(Outer: UObject, ResourceName: string): MaterialInstanceDynamic;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInstanceDynamic;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInstanceDynamic;
	/**
	 * Set an MID vector parameter value
	*/
	SetVectorParameterValue(ParameterName: string,Value: LinearColor): void;
	/**
	 * Set an MID texture parameter value
	*/
	SetTextureParameterValue(ParameterName: string,Value: Texture): void;
	/**
	 * Set a MID scalar (float) parameter value
	*/
	SetScalarParameterValue(ParameterName: string,Value: number): void;
	/**
	 * Interpolates the scalar and vector parameters of this material instance based on two other material instances, and an alpha blending factor
	 * The output is the object itself (this).
	 * Supports the case SourceA==this || SourceB==this
	 * Both material have to be from the same base material
	 * @param SourceA value that is used for Alpha=0, silently ignores the case if 0
	 * @param SourceB value that is used for Alpha=1, silently ignores the case if 0
	 * @param Alpha usually in the range 0..1, values outside the range extrapolate
	*/
	InterpolateMaterialInstanceParameters(SourceA: MaterialInstance,SourceB: MaterialInstance,Alpha: number): void;
	/**
	 * Get the current MID vector parameter value
	*/
	GetVectorParameterValue(ParameterName: string): LinearColor;
	/**
	 * Get the current MID texture parameter value
	*/
	GetTextureParameterValue(ParameterName: string): Texture;
	/**
	 * Get the current scalar (float) parameter value from an MID
	*/
	GetScalarParameterValue(ParameterName: string): number;
	/**
	 * Copies over parameters given a material interface (copy each instance following the hierarchy)
	 * Very slow implementation, avoid using at runtime. Hopefully we can replace ity later with something like CopyInterpParameters()
	 * The output is the object itself (this).
	*/
	CopyMaterialInstanceParameters(Source: MaterialInterface): void;
	/**
	 * Copy parameter values from another material instance. This will copy only
	 * parameters explicitly overridden in that material instance!!
	*/
	CopyParameterOverrides(MaterialInstance: MaterialInstance): void;
	/**
	 * Copies over parameters given a material instance (only copy from the instance, not following the hierarchy)
	 * much faster than K2_CopyMaterialInstanceParameters(),
	 * The output is the object itself (this).
	 * @param Source ignores the call if 0
	*/
	CopyInterpParameters(Source: MaterialInstance): void;
	static C(Other: UObject): MaterialInstanceDynamic;
}

declare class DecalComponent extends SceneComponent { 
	/**
	 * Decal material.
	*/
	DecalMaterial: MaterialInterface;
	/**
	 * Controls the order in which decal elements are rendered.  Higher values draw later (on top).
	 * Setting many different sort orders on many different decals prevents sorting by state and can reduce performance.
	*/
	SortOrder: number;
	/**
	 * Fade Screen Size
	*/
	FadeScreenSize: number;
	/**
	 * Time in seconds to wait before beginning to fade out the decal. Set fade duration and start delay to 0 to make persistent.
	*/
	FadeStartDelay: number;
	/**
	 * Time in seconds for the decal to fade out. Set fade duration and start delay to 0 to make persistent.
	*/
	FadeDuration: number;
	/**
	 * Automatically destroys the owning actor after fully fading out.
	*/
	bDestroyOwnerAfterFade: boolean;
	/**
	 * Decal size in local space (does not include the component scale), technically redundant but there for convenience
	*/
	DecalSize: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DecalComponent;
	static Find(Outer: UObject, ResourceName: string): DecalComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DecalComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DecalComponent;
	/**
	 * Sets the sort order for the decal component. Higher values draw later (on top). This will force the decal to reattach
	*/
	SetSortOrder(Value: number): void;
	/**
	 * Sets the decal's fade start time, duration and if the owning actor should be destroyed after the decal is fully faded out.
	 * The default value of 0 for FadeStartDelay and FadeDuration makes the decal persistent. See DecalLifetimeOpacity material
	 * node to control the look of "fading out."
	 * @param StartDelay - Time in seconds to wait before beginning to fade out the decal.
	 * @param Duration - Time in second for the decal to fade out.
	 * @param DestroyOwnerAfterFade - Should the owning actor automatically be destroyed after it is completely faded out.
	*/
	SetFadeOut(StartDelay: number,Duration: number,DestroyOwnerAfterFade: boolean): void;
	/**
	 * setting decal material on decal component. This will force the decal to reattach
	*/
	SetDecalMaterial(NewDecalMaterial: MaterialInterface): void;
	/**
	 * Get Fade Start Delay
	*/
	GetFadeStartDelay(): number;
	/**
	 * Get Fade Duration
	*/
	GetFadeDuration(): number;
	/**
	 * Accessor for decal material
	*/
	GetDecalMaterial(): MaterialInterface;
	/**
	 * Utility to allocate a new Dynamic Material Instance, set its parent to the currently applied material, and assign it
	*/
	CreateDynamicMaterialInstance(): MaterialInstanceDynamic;
	static C(Other: UObject): DecalComponent;
}

declare class MaterialInterface extends UObject { 
	/**
	 * SubsurfaceProfile, for Screen Space Subsurface Scattering
	*/
	SubsurfaceProfile: SubsurfaceProfile;
	/**
	 * The Lightmass settings for this object.
	*/
	LightmassSettings: LightmassMaterialInterfaceSettings;
	/**
	 * The mesh used by the material editor to preview the material.
	*/
	PreviewMesh: StringAssetReference;
	/**
	 * Information for thumbnail rendering
	*/
	ThumbnailInfo: ThumbnailInfo;
	/**
	 * Unique ID for this material, used for caching during distributed lighting
	*/
	LightingGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MaterialInterface;
	static Find(Outer: UObject, ResourceName: string): MaterialInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MaterialInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MaterialInterface;
	/**
	 * Return a pointer to the physical material used by this material instance.
	 * @return The physical material.
	*/
	GetPhysicalMaterial(): PhysicalMaterial;
	/**
	 * Walks up parent chain and finds the base Material that this is an instance of. Just calls the virtual GetMaterial()
	*/
	GetBaseMaterial(): Material;
	static C(Other: UObject): MaterialInterface;
	/**
	 * Spawns a decal attached to and following the specified component. Does not replicate.
	 * @param DecalMaterial - decal's material
	 * @param DecalSize - size of decal
	 * @param AttachComponent - Component to attach to.
	 * @param AttachPointName - Optional named point within the AttachComponent to spawn the emitter at
	 * @param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
	 * @param Rotation - Depending on the value of LocationType this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a realative offset
	 * @param LocationType - Specifies whether Location is a relative offset or an absolute world position
	 * @param LifeSpan - destroy decal component after time runs out (0 = infinite)
	*/
	SpawnDecalAttached(DecalSize: Vector,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,LifeSpan: number): DecalComponent;
	/**
	 * Creates a Slate Brush from a Material.  Materials don't have an implicit size, so providing a widget and height
	 * is required to hint slate with how large the image wants to be by default.
	 * @return A new slate brush using the material.
	*/
	MakeBrushFromMaterial(Width: number,Height: number): SlateBrush;
	/**
	 * Spawns a decal attached to and following the specified component. Does not replicate.
	 * @param DecalMaterial - decal's material
	 * @param DecalSize - size of decal
	 * @param AttachComponent - Component to attach to.
	 * @param AttachPointName - Optional named point within the AttachComponent to spawn the emitter at
	 * @param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
	 * @param Rotation - Depending on the value of LocationType this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a realative offset
	 * @param LocationType - Specifies whether Location is a relative offset or an absolute world position
	 * @param LifeSpan - destroy decal component after time runs out (0 = infinite)
	*/
	static SpawnDecalAttached(DecalMaterial: MaterialInterface,DecalSize: Vector,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,LifeSpan: number): DecalComponent;
	/**
	 * Creates a Slate Brush from a Material.  Materials don't have an implicit size, so providing a widget and height
	 * is required to hint slate with how large the image wants to be by default.
	 * @return A new slate brush using the material.
	*/
	static MakeBrushFromMaterial(Material: MaterialInterface,Width: number,Height: number): SlateBrush;
}

declare class OverlapInfo { 
	clone() : OverlapInfo;
	static C(Other: UObject): OverlapInfo;
}

declare type EAutoReceiveInput = string | symbol;
declare var EAutoReceiveInput = { Disabled:'Disabled',Player0:'Player0',Player1:'Player1',Player2:'Player2',Player3:'Player3',Player4:'Player4',Player5:'Player5',Player6:'Player6',Player7:'Player7', };
declare type EAutoPossessAI = string | symbol;
declare var EAutoPossessAI = { Disabled:'Disabled',PlacedInWorld:'PlacedInWorld',Spawned:'Spawned',PlacedInWorldOrSpawned:'PlacedInWorldOrSpawned', };
declare class MeshComponent extends PrimitiveComponent { 
	/**
	 * Material overrides.
	*/
	OverrideMaterials: MaterialInterface[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MeshComponent;
	static Find(Outer: UObject, ResourceName: string): MeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MeshComponent;
	/**
	 * Set all occurrences of Vector Material Parameters with ParameterName in the set of materials of the SkeletalMesh to ParameterValue
	*/
	SetVectorParameterValueOnMaterials(ParameterName: string,ParameterValue: Vector): void;
	/**
	 * Set all occurrences of Scalar Material Parameters with ParameterName in the set of materials of the SkeletalMesh to ParameterValue
	*/
	SetScalarParameterValueOnMaterials(ParameterName: string,ParameterValue: number): void;
	/**
	 * Get Materials
	*/
	GetMaterials(): MaterialInterface[];
	static C(Other: UObject): MeshComponent;
}

declare type EBoneTranslationRetargetingMode = string | symbol;
declare var EBoneTranslationRetargetingMode = { Animation:'Animation',Skeleton:'Skeleton',AnimationScaled:'AnimationScaled',AnimationRelative:'AnimationRelative', };
declare class BoneNode { 
	/**
	 * Name of bone, this is the search criteria to match with mesh bone. This will be NAME_None if deleted.
	*/
	Name: string;
	/**
	 * Parent Index. -1 if not used. The root has 0 as its parent. Do not delete the element but set this to -1. If it is revived by other reason, fix up this link.
	*/
	ParentIndex: number;
	/**
	 * Retargeting Mode for Translation Component.
	*/
	TranslationRetargetingMode: EBoneTranslationRetargetingMode;
	clone() : BoneNode;
	static C(Other: UObject): BoneNode;
}

declare class SkeletonToMeshLinkup { 
	/**
	 * Mapping table. Size must be same as size of bone tree (not Mesh Ref Pose).
	 * No index should be more than the number of bones in this skeleton
	 * -1 indicates no match for this bone - will be ignored.
	*/
	SkeletonToMeshTable: number[];
	/**
	 * Mapping table. Size must be same as size of ref pose (not bone tree).
	 * No index should be more than the number of bones in this skeletalmesh
	 * -1 indicates no match for this bone - will be ignored.
	*/
	MeshToSkeletonTable: number[];
	clone() : SkeletonToMeshLinkup;
	static C(Other: UObject): SkeletonToMeshLinkup;
}

declare class SkeletalMeshSocket extends UObject { 
	/**
	 * Defines a named attachment location on the USkeletalMesh.
	 * These are set up in editor and used as a shortcut instead of specifying
	 * everything explicitly to AttachComponent in the SkeletalMeshComponent.
	 * The Outer of a SkeletalMeshSocket should always be the USkeletalMesh.
	*/
	SocketName: string;
	/**
	 * Bone Name
	*/
	BoneName: string;
	/**
	 * Relative Location
	*/
	RelativeLocation: Vector;
	/**
	 * Relative Rotation
	*/
	RelativeRotation: Rotator;
	/**
	 * Relative Scale
	*/
	RelativeScale: Vector;
	/**
	 * If true then the hierarchy of bones this socket is attached to will always be
	 *           evaluated, even if it had previously been removed due to the current lod setting
	*/
	bForceAlwaysAnimated: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMeshSocket;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshSocket;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMeshSocket;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshSocket;
	/**
	 * Sets BoneName, RelativeLocation and RelativeRotation based on closest bone to WorldLocation and WorldNormal
	*/
	InitializeSocketFromLocation(SkelComp: SkeletalMeshComponent,WorldLocation: Vector,WorldNormal: Vector): void;
	/**
	 * Get Socket Location
	*/
	GetSocketLocation(SkelComp: SkeletalMeshComponent): Vector;
	static C(Other: UObject): SkeletalMeshSocket;
}

declare class SmartNameContainer { 
	clone() : SmartNameContainer;
	static C(Other: UObject): SmartNameContainer;
}

declare class BoneReference { 
	/**
	 * Name of bone to control. This is the main bone chain to modify from. *
	*/
	BoneName: string;
	clone() : BoneReference;
	static C(Other: UObject): BoneReference;
}

declare class BlendProfileBoneEntry { 
	/**
	 * Bone Reference
	*/
	BoneReference: BoneReference;
	/**
	 * Blend Scale
	*/
	BlendScale: number;
	clone() : BlendProfileBoneEntry;
	static C(Other: UObject): BlendProfileBoneEntry;
}

declare class BlendProfile extends UObject { 
	/**
	 * The skeleton that owns this profile
	*/
	OwningSkeleton: Skeleton;
	/**
	 * List of blend scale entries
	*/
	ProfileEntries: BlendProfileBoneEntry[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlendProfile;
	static Find(Outer: UObject, ResourceName: string): BlendProfile;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlendProfile;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlendProfile;
	static C(Other: UObject): BlendProfile;
}

declare class AnimSlotGroup { 
	/**
	 * Group Name
	*/
	GroupName: string;
	/**
	 * Slot Names
	*/
	SlotNames: string[];
	clone() : AnimSlotGroup;
	static C(Other: UObject): AnimSlotGroup;
}

declare type EConstraintTransform = string | symbol;
declare var EConstraintTransform = { Absolute:'Absolute',Relative:'Relative', };
declare class RigTransformConstraint { 
	/**
	 * EditAnywhere, Category="FTransformBaseConstraint"
	*/
	TranformType: EConstraintTransform;
	/**
	 * Parent space that are define *
	*/
	ParentSpace: string;
	/**
	 * EditAnywhere, Category="FTransformBaseConstraint"
	*/
	Weight: number;
	clone() : RigTransformConstraint;
	static C(Other: UObject): RigTransformConstraint;
}

declare class TransformBaseConstraint { 
	/**
	 * What transform type *
	*/
	TransformConstraints: RigTransformConstraint[];
	clone() : TransformBaseConstraint;
	static C(Other: UObject): TransformBaseConstraint;
}

declare class TransformBase { 
	/**
	 * Node
	*/
	UNode: string;
	/**
	 * Constraints
	*/
	Constraints: TransformBaseConstraint;
	clone() : TransformBase;
	static C(Other: UObject): TransformBase;
}

declare class UNode { 
	/**
	 * Name of the original node. We don't allow to change this. This is used for identity.*
	*/
	Name: string;
	/**
	 * We save Parent Node but if the parent node is removed, it will reset to root
	*/
	ParentName: string;
	/**
	 * Absolute transform of the node. Hoping to use this data in the future to render
	*/
	Transform: Transform;
	/**
	 * This is Display Name where it will be used to display in Retarget Manager. This name has to be unique.
	*/
	DisplayName: string;
	/**
	 * Advanced
	*/
	bAdvanced: boolean;
	clone() : UNode;
	static C(Other: UObject): UNode;
}

declare class Rig extends UObject { 
	/**
	 * Skeleton bone tree - each contains name and parent index*
	*/
	TransformBases: TransformBase[];
	/**
	 * Skeleton bone tree - each contains name and parent index*
	*/
	Nodes: UNode[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Rig;
	static Find(Outer: UObject, ResourceName: string): Rig;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Rig;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Rig;
	static C(Other: UObject): Rig;
}

declare class NameMapping { 
	/**
	 * Node Name
	*/
	NodeName: string;
	/**
	 * Bone Name
	*/
	BoneName: string;
	clone() : NameMapping;
	static C(Other: UObject): NameMapping;
}

declare class RigConfiguration { 
	/**
	 * Rig
	*/
	Rig: Rig;
	/**
	 * @todo in the future we can make this to be run-time data
	*/
	BoneMappingTable: NameMapping[];
	clone() : RigConfiguration;
	static C(Other: UObject): RigConfiguration;
}

declare class PreviewAttachedObjectPair { 
	/**
	 * the object to be attached
	*/
	AttachedObject: any;
	/**
	 * Object
	*/
	UObject: UObject;
	/**
	 * The name of the attach point of the Object (for example a bone or socket name)
	*/
	AttachedTo: string;
	clone() : PreviewAttachedObjectPair;
	static C(Other: UObject): PreviewAttachedObjectPair;
}

declare class PreviewAssetAttachContainer { 
	/**
	 * Attached Objects
	*/
	AttachedObjects: PreviewAttachedObjectPair[];
	clone() : PreviewAssetAttachContainer;
	static C(Other: UObject): PreviewAssetAttachContainer;
}

declare class Skeleton extends UObject { 
	/**
	 * Skeleton bone tree - each contains name and parent index*
	*/
	BoneTree: BoneNode[];
	/**
	 * Reference skeleton poses in local space
	*/
	RefLocalPoses: Transform[];
	/**
	 * Non-serialised cache of linkups between different skeletal meshes and this Skeleton.
	*/
	LinkupCache: SkeletonToMeshLinkup[];
	/**
	 * Array of named socket locations, set up in editor and used as a shortcut instead of specifying
	 * everything explicitly to AttachComponent in the SkeletalMeshComponent.
	*/
	Sockets: SkeletalMeshSocket[];
	/**
	 * Container for smart name mappings
	*/
	SmartNames: SmartNameContainer;
	/**
	 * List of blend profiles available in this skeleton
	*/
	BlendProfiles: BlendProfile[];
	/**
	 * serialized slot groups and slot names.
	*/
	SlotGroups: AnimSlotGroup[];
	/**
	 * The default skeletal mesh to use when previewing this skeleton
	*/
	PreviewSkeletalMesh: any;
	/**
	 * Rig Config
	*/
	RigConfig: RigConfiguration;
	/**
	 * AnimNotifiers that has been created. Right now there is no delete step for this, but in the future we'll supply delete*
	*/
	AnimationNotifies: string[];
	/**
	 * Attached assets component for this skeleton
	*/
	PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Skeleton;
	static Find(Outer: UObject, ResourceName: string): Skeleton;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Skeleton;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Skeleton;
	static C(Other: UObject): Skeleton;
}

declare class BoxSphereBounds { 
	/**
	 * Origin
	*/
	Origin: Vector;
	/**
	 * Box Extent
	*/
	BoxExtent: Vector;
	/**
	 * Sphere Radius
	*/
	SphereRadius: number;
	clone() : BoxSphereBounds;
	static C(Other: UObject): BoxSphereBounds;
}

declare class SkeletalMaterial { 
	/**
	 * Material Interface
	*/
	MaterialInterface: MaterialInterface;
	/**
	 * Enable Shadow Casting
	*/
	bEnableShadowCasting: boolean;
	/**
	 * Recompute Tangent
	*/
	bRecomputeTangent: boolean;
	clone() : SkeletalMaterial;
	static C(Other: UObject): SkeletalMaterial;
}

declare type EAxis = string | symbol;
declare var EAxis = { None:'None',X:'X',Y:'Y',Z:'Z', };
declare class BoneMirrorInfo { 
	/**
	 * The bone to mirror.
	*/
	SourceIndex: number;
	/**
	 * Axis the bone is mirrored across.
	*/
	BoneFlipAxis: EAxis;
	clone() : BoneMirrorInfo;
	static C(Other: UObject): BoneMirrorInfo;
}

declare type ETriangleSortOption = string | symbol;
declare var ETriangleSortOption = { TRISORT_None:'TRISORT_None',TRISORT_CenterRadialDistance:'TRISORT_CenterRadialDistance',TRISORT_Random:'TRISORT_Random',TRISORT_MergeContiguous:'TRISORT_MergeContiguous',TRISORT_Custom:'TRISORT_Custom',TRISORT_CustomLeftRight:'TRISORT_CustomLeftRight', };
declare type ETriangleSortAxis = string | symbol;
declare var ETriangleSortAxis = { TSA_X_Axis:'TSA_X_Axis',TSA_Y_Axis:'TSA_Y_Axis',TSA_Z_Axis:'TSA_Z_Axis', };
declare class TriangleSortSettings { 
	/**
	 * Triangle Sorting
	*/
	TriangleSorting: ETriangleSortOption;
	/**
	 * Custom Left Right Axis
	*/
	CustomLeftRightAxis: ETriangleSortAxis;
	/**
	 * Custom Left Right Bone Name
	*/
	CustomLeftRightBoneName: string;
	clone() : TriangleSortSettings;
	static C(Other: UObject): TriangleSortSettings;
}

declare type SkeletalMeshOptimizationType = string | symbol;
declare var SkeletalMeshOptimizationType = { SMOT_NumOfTriangles:'SMOT_NumOfTriangles',SMOT_MaxDeviation:'SMOT_MaxDeviation', };
declare type SkeletalMeshOptimizationImportance = string | symbol;
declare var SkeletalMeshOptimizationImportance = { SMOI_Off:'SMOI_Off',SMOI_Lowest:'SMOI_Lowest',SMOI_Low:'SMOI_Low',SMOI_Normal:'SMOI_Normal',SMOI_High:'SMOI_High',SMOI_Highest:'SMOI_Highest', };
declare class SkeletalMeshOptimizationSettings { 
	/**
	 * The method to use when optimizing the skeletal mesh LOD
	*/
	ReductionMethod: SkeletalMeshOptimizationType;
	/**
	 * If ReductionMethod equals SMOT_NumOfTriangles this value is the ratio of triangles [0-1] to remove from the mesh
	*/
	NumOfTrianglesPercentage: number;
	/**
	 * If ReductionMethod equals SMOT_MaxDeviation this value is the maximum deviation from the base mesh as a percentage of the bounding sphere.
	*/
	MaxDeviationPercentage: number;
	/**
	 * The welding threshold distance. Vertices under this distance will be welded.
	*/
	WeldingThreshold: number;
	/**
	 * Whether Normal smoothing groups should be preserved. If false then NormalsThreshold is used *
	*/
	bRecalcNormals: boolean;
	/**
	 * If the angle between two triangles are above this value, the normals will not be
	 *       smooth over the edge between those two triangles. Set in degrees. This is only used when PreserveNormals is set to false
	*/
	NormalsThreshold: number;
	/**
	 * How important the shape of the geometry is.
	*/
	SilhouetteImportance: SkeletalMeshOptimizationImportance;
	/**
	 * How important texture density is.
	*/
	TextureImportance: SkeletalMeshOptimizationImportance;
	/**
	 * How important shading quality is.
	*/
	ShadingImportance: SkeletalMeshOptimizationImportance;
	/**
	 * How important skinning quality is.
	*/
	SkinningImportance: SkeletalMeshOptimizationImportance;
	/**
	 * The ratio of bones that will be removed from the mesh
	*/
	BoneReductionRatio: number;
	/**
	 * Maximum number of bones that can be assigned to each vertex.
	*/
	MaxBonesPerVertex: number;
	/**
	 * Bones to Remove
	*/
	BonesToRemove: BoneReference[];
	/**
	 * Maximum number of bones that can be assigned to each vertex.
	*/
	BaseLOD: number;
	clone() : SkeletalMeshOptimizationSettings;
	static C(Other: UObject): SkeletalMeshOptimizationSettings;
}

declare class SkeletalMeshLODInfo { 
	/**
	 * Indicates when to use this LOD. A smaller number means use this LOD when further away.
	*/
	ScreenSize: number;
	/**
	 * Used to avoid 'flickering' when on LOD boundary. Only taken into account when moving from complex->simple.
	*/
	LODHysteresis: number;
	/**
	 * Mapping table from this LOD's materials to the USkeletalMesh materials array.
	*/
	LODMaterialMap: number[];
	/**
	 * Per-section control over whether to enable shadow casting.
	*/
	bEnableShadowCasting: boolean[];
	/**
	 * Triangle Sort Settings
	*/
	TriangleSortSettings: TriangleSortSettings[];
	/**
	 * Whether to disable morph targets for this LOD.
	*/
	bHasBeenSimplified: boolean;
	/**
	 * Reduction settings to apply when building render data.
	*/
	ReductionSettings: SkeletalMeshOptimizationSettings;
	/**
	 * This has been removed in editor. We could re-apply this in import time or by mesh reduction utilities
	*/
	RemovedBones: string[];
	clone() : SkeletalMeshLODInfo;
	static C(Other: UObject): SkeletalMeshLODInfo;
}

declare class KShapeElem { 
	clone() : KShapeElem;
	static C(Other: UObject): KShapeElem;
}

declare class Matrix { 
	/**
	 * XPlane
	*/
	XPlane: Plane;
	/**
	 * YPlane
	*/
	YPlane: Plane;
	/**
	 * ZPlane
	*/
	ZPlane: Plane;
	/**
	 * WPlane
	*/
	WPlane: Plane;
	clone() : Matrix;
	static C(Other: UObject): Matrix;
}

declare class KSphereElem extends KShapeElem { 
	/**
	 * TM
	*/
	TM: Matrix;
	/**
	 * Position of the sphere's origin
	*/
	Center: Vector;
	/**
	 * Radius of the sphere
	*/
	Radius: number;
	clone() : KSphereElem;
	static C(Other: UObject): KSphereElem;
}

declare class KBoxElem extends KShapeElem { 
	/**
	 * TM
	*/
	TM: Matrix;
	/**
	 * Position of the box's origin
	*/
	Center: Vector;
	/**
	 * Orientation of the box
	*/
	Orientation: Quat;
	/**
	 * Extent of the box along the y-axis
	*/
	X: number;
	/**
	 * Extent of the box along the y-axis
	*/
	Y: number;
	/**
	 * Extent of the box along the z-axis
	*/
	Z: number;
	clone() : KBoxElem;
	static C(Other: UObject): KBoxElem;
}

declare class KSphylElem extends KShapeElem { 
	/**
	 * The transform assumes the sphyl axis points down Z.
	*/
	TM: Matrix;
	/**
	 * Position of the capsule's origin
	*/
	Center: Vector;
	/**
	 * Orientation of the capsule
	*/
	Orientation: Quat;
	/**
	 * Radius of the capsule
	*/
	Radius: number;
	/**
	 * This is of line-segment ie. add Radius to both ends to find total length.
	*/
	Length: number;
	clone() : KSphylElem;
	static C(Other: UObject): KSphylElem;
}

declare class Box { 
	/**
	 * Min
	*/
	Min: Vector;
	/**
	 * Max
	*/
	Max: Vector;
	/**
	 * Is Valid
	*/
	IsValid: number;
	clone() : Box;
	static C(Other: UObject): Box;
}

declare class KConvexElem extends KShapeElem { 
	/**
	 * Array of indices that make up the convex hull.
	*/
	VertexData: Vector[];
	/**
	 * Bounding box of this convex hull.
	*/
	ElemBox: Box;
	/**
	 * Transform of this element
	*/
	Transform: Transform;
	clone() : KConvexElem;
	static C(Other: UObject): KConvexElem;
}

declare class KAggregateGeom { 
	/**
	 * Sphere Elems
	*/
	SphereElems: KSphereElem[];
	/**
	 * Box Elems
	*/
	BoxElems: KBoxElem[];
	/**
	 * Sphyl Elems
	*/
	SphylElems: KSphylElem[];
	/**
	 * Convex Elems
	*/
	ConvexElems: KConvexElem[];
	clone() : KAggregateGeom;
	static C(Other: UObject): KAggregateGeom;
}

declare type EPhysicsType = string | symbol;
declare var EPhysicsType = { PhysType_Default:'PhysType_Default',PhysType_Kinematic:'PhysType_Kinematic',PhysType_Simulated:'PhysType_Simulated', };
declare type EBodyCollisionResponse = string | symbol;
declare var EBodyCollisionResponse = { BodyCollision_Enabled:'BodyCollision_Enabled',BodyCollision_Disabled:'BodyCollision_Disabled', };
declare type ECollisionTraceFlag = string | symbol;
declare var ECollisionTraceFlag = { CTF_UseDefault:'CTF_UseDefault',CTF_UseSimpleAndComplex:'CTF_UseSimpleAndComplex',CTF_UseSimpleAsComplex:'CTF_UseSimpleAsComplex',CTF_UseComplexAsSimple:'CTF_UseComplexAsSimple', };
declare class BodySetup extends UObject { 
	/**
	 * Simplified collision representation of this
	*/
	AggGeom: KAggregateGeom;
	/**
	 * Used in the PhysicsAsset case. Associates this Body with Bone in a skeletal mesh.
	*/
	BoneName: string;
	/**
	 * If Unfixed it will use physics. If fixed, it will use kinematic. Default will inherit from OwnerComponent's behavior.
	*/
	PhysicsType: EPhysicsType;
	/**
	 * If true (and bEnableFullAnimWeightBodies in SkelMeshComp is true), the physics of this bone will always be blended into the skeletal mesh, regardless of what PhysicsWeight of the SkelMeshComp is.
	 * This is useful for bones that should always be physics, even when blending physics in and out for hit reactions (eg cloth or pony-tails).
	*/
	bAlwaysFullAnimWeight: boolean;
	/**
	 * Should this BodySetup be considered for the bounding box of the PhysicsAsset (and hence SkeletalMeshComponent).
	 * There is a speed improvement from having less BodySetups processed each frame when updating the bounds.
	*/
	bConsiderForBounds: boolean;
	/**
	 * If true, the physics of this mesh (only affects static meshes) will always contain ALL elements from the mesh - not just the ones enabled for collision.
	 * This is useful for forcing high detail collisions using the entire render mesh.
	*/
	bMeshCollideAll: boolean;
	/**
	 * If true, the physics triangle mesh will use double sided faces when doing scene queries.
	 * This is useful for planes and single sided meshes that need traces to work on both sides.
	*/
	bDoubleSidedGeometry: boolean;
	/**
	 * Should we generate data necessary to support collision on normal (non-mirrored) versions of this body.
	*/
	bGenerateNonMirroredCollision: boolean;
	/**
	 * Whether the cooked data is shared by multiple body setups. This is needed for per poly collision case where we don't want to duplicate cooked data, but still need multiple body setups for in place geometry changes
	*/
	bSharedCookedData: boolean;
	/**
	 * Should we generate data necessary to support collision on mirrored versions of this mesh.
	 * This halves the collision data size for this mesh, but disables collision on mirrored instances of the body.
	*/
	bGenerateMirroredCollision: boolean;
	/**
	 * Physical material to use for simple collision on this body. Encodes information about density, friction etc.
	*/
	PhysMaterial: PhysicalMaterial;
	/**
	 * Collision Type for this body. This eventually changes response to collision to others *
	*/
	CollisionReponse: EBodyCollisionResponse;
	/**
	 * Collision Trace behavior - by default, it will keep simple(convex)/complex(per-poly) separate *
	*/
	CollisionTraceFlag: ECollisionTraceFlag;
	/**
	 * Default properties of the body instance, copied into objects on instantiation, was URB_BodyInstance
	*/
	DefaultInstance: BodyInstance;
	/**
	 * Custom walkable slope setting for this body.
	*/
	WalkableSlopeOverride: WalkableSlopeOverride;
	/**
	 * Build Scale
	*/
	BuildScale: number;
	/**
	 * Build scale for this body setup (static mesh settings define this value)
	*/
	BuildScale3D: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BodySetup;
	static Find(Outer: UObject, ResourceName: string): BodySetup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BodySetup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BodySetup;
	static C(Other: UObject): BodySetup;
}

declare class PhysicalAnimationData { 
	/**
	 * The body we will be driving. We specifically hide this from users since they provide the body name and bodies below in the component API.
	*/
	BodyName: string;
	/**
	 * Whether the drive targets are in world space or local
	*/
	bIsLocalSimulation: boolean;
	/**
	 * The strength used to correct orientation error
	*/
	OrientationStrength: number;
	/**
	 * The strength used to correct angular velocity error
	*/
	AngularVelocityStrength: number;
	/**
	 * The strength used to correct linear position error. Only used for non-local simulation
	*/
	PositionStrength: number;
	/**
	 * The strength used to correct linear velocity error. Only used for non-local simulation
	*/
	VelocityStrength: number;
	/**
	 * The max force used to correct linear errors
	*/
	MaxLinearForce: number;
	/**
	 * The max force used to correct angular errors
	*/
	MaxAngularForce: number;
	clone() : PhysicalAnimationData;
	static C(Other: UObject): PhysicalAnimationData;
}

declare class PhysicalAnimationProfile { 
	/**
	 * Profile name used to identify set of physical animation parameters
	*/
	ProfileName: string;
	/**
	 * Physical animation parameters used to drive animation
	*/
	PhysicalAnimationData: PhysicalAnimationData;
	clone() : PhysicalAnimationProfile;
	static C(Other: UObject): PhysicalAnimationProfile;
}

declare class SkeletalBodySetup extends BodySetup { 
	/**
	 * dummy place for customization inside phat. Profiles are ordered dynamically and we need a static place for detail customization
	*/
	CurrentPhysicalAnimationProfile: PhysicalAnimationProfile;
	/**
	 * Physical Animation Data
	*/
	PhysicalAnimationData: PhysicalAnimationProfile[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalBodySetup;
	static Find(Outer: UObject, ResourceName: string): SkeletalBodySetup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalBodySetup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalBodySetup;
	static C(Other: UObject): SkeletalBodySetup;
}

declare class ConstraintBaseParams { 
	/**
	 * Stiffness of the soft constraint. Only used when Soft Constraint is on.
	*/
	Stiffness: number;
	/**
	 * Damping of the soft constraint. Only used when Soft Constraint is on.
	*/
	Damping: number;
	/**
	 * Controls the amount of bounce when the constraint is violated. A restitution value of 1 will bounce back with the same velocity the limit was hit. A value of 0 will stop dead.
	*/
	Restitution: number;
	/**
	 * Determines how close to the limit we have to get before turning the joint on. Larger value will be more expensive, but will do a better job not violating constraints. A smaller value will be more efficient, but easier to violate.
	*/
	ContactDistance: number;
	/**
	 * Whether we want to use a soft constraint (spring).
	*/
	bSoftConstraint: boolean;
	clone() : ConstraintBaseParams;
	static C(Other: UObject): ConstraintBaseParams;
}

declare type ELinearConstraintMotion = string | symbol;
declare var ELinearConstraintMotion = { LCM_Free:'LCM_Free',LCM_Limited:'LCM_Limited',LCM_Locked:'LCM_Locked', };
declare class LinearConstraint extends ConstraintBaseParams { 
	/**
	 * The distance allowed between between the two joint reference frames. Distance applies on all axes enabled (one axis means line, two axes implies circle, three axes implies sphere)
	*/
	Limit: number;
	/**
	 * Indicates the linear constraint applied along the X-axis. Free implies no constraint at all. Locked implies no movement along X is allowed. Limited implies the distance in the joint along all active axes must be less than the Distance provided.
	*/
	XMotion: ELinearConstraintMotion;
	/**
	 * Indicates the linear constraint applied along the X-axis. Free implies no constraint at all. Locked implies no movement along X is allowed. Limited implies the distance in the joint along all active axes must be less than the Distance provided.
	*/
	YMotion: ELinearConstraintMotion;
	/**
	 * Indicates the linear constraint applied along the X-axis. Free implies no constraint at all. Locked implies no movement along X is allowed. Limited implies the distance in the joint along all active axes must be less than the Distance provided.
	*/
	ZMotion: ELinearConstraintMotion;
	clone() : LinearConstraint;
	static C(Other: UObject): LinearConstraint;
}

declare type EAngularConstraintMotion = string | symbol;
declare var EAngularConstraintMotion = { ACM_Free:'ACM_Free',ACM_Limited:'ACM_Limited',ACM_Locked:'ACM_Locked', };
declare class ConeConstraint extends ConstraintBaseParams { 
	/**
	 * Angle of movement along the XY plane. This defines the first symmetric angle of the cone.
	*/
	Swing1LimitDegrees: number;
	/**
	 * Angle of movement along the XZ plane. This defines the second symmetric angle of the cone.
	*/
	Swing2LimitDegrees: number;
	/**
	 * Indicates whether the Swing1 limit is used.
	*/
	Swing1Motion: EAngularConstraintMotion;
	/**
	 * Indicates whether the Swing2 limit is used.
	*/
	Swing2Motion: EAngularConstraintMotion;
	clone() : ConeConstraint;
	static C(Other: UObject): ConeConstraint;
}

declare class TwistConstraint extends ConstraintBaseParams { 
	/**
	 * Symmetric angle of roll along the X-axis.
	*/
	TwistLimitDegrees: number;
	/**
	 * Indicates whether the Swing1 limit is used.
	*/
	TwistMotion: EAngularConstraintMotion;
	clone() : TwistConstraint;
	static C(Other: UObject): TwistConstraint;
}

declare class ConstraintDrive { 
	/**
	 * The spring strength of the drive. Force proportional to the position error.
	*/
	Stiffness: number;
	/**
	 * The damping strength of the drive. Force proportional to the velocity error.
	*/
	Damping: number;
	/**
	 * The force limit of the drive.
	*/
	MaxForce: number;
	/**
	 * Enables/Disables position drive (orientation if using angular drive)
	*/
	bEnablePositionDrive: boolean;
	/**
	 * Enables/Disables velocity drive (angular velocity if using angular drive)
	*/
	bEnableVelocityDrive: boolean;
	clone() : ConstraintDrive;
	static C(Other: UObject): ConstraintDrive;
}

declare class LinearDriveConstraint { 
	/**
	 * Target position the linear drive.
	*/
	PositionTarget: Vector;
	/**
	 * Target velocity the linear drive.
	*/
	VelocityTarget: Vector;
	/**
	 * XDrive
	*/
	XDrive: ConstraintDrive;
	/**
	 * YDrive
	*/
	YDrive: ConstraintDrive;
	/**
	 * ZDrive
	*/
	ZDrive: ConstraintDrive;
	/**
	 * Enable Position Drive
	*/
	bEnablePositionDrive: boolean;
	clone() : LinearDriveConstraint;
	static C(Other: UObject): LinearDriveConstraint;
}

declare type EAngularDriveMode = string | symbol;
declare var EAngularDriveMode = { SLERP:'SLERP',TwistAndSwing:'TwistAndSwing', };
declare class AngularDriveConstraint { 
	/**
	 * Controls the twist (roll) constraint drive between current orientation/velocity and target orientation/velocity. This is available as long as the twist limit is set to free or limited.
	*/
	TwistDrive: ConstraintDrive;
	/**
	 * Controls the cone constraint drive between current orientation/velocity and target orientation/velocity. This is available as long as there is at least one swing limit set to free or limited.
	*/
	SwingDrive: ConstraintDrive;
	/**
	 * Controls the SLERP (spherical lerp) drive between current orientation/velocity and target orientation/velocity. NOTE: This is only available when all three angular limits are either free or limited. Locking any angular limit will turn off the drive implicitly.
	*/
	SlerpDrive: ConstraintDrive;
	/**
	 * Target orientation relative to the the body reference frame.
	*/
	OrientationTarget: Rotator;
	/**
	 * Target angular velocity relative to the body reference frame.
	*/
	AngularVelocityTarget: Vector;
	/**
	 * Whether motors use SLERP (spherical lerp) or decompose into a Swing motor (cone constraints) and Twist motor (roll constraints). NOTE: SLERP will NOT work if any of the angular constraints are locked.
	*/
	AngularDriveMode: EAngularDriveMode;
	clone() : AngularDriveConstraint;
	static C(Other: UObject): AngularDriveConstraint;
}

declare class ConstraintProfileProperties { 
	/**
	 * Linear tolerance value in world units. If the distance error exceeds this tolerence limit, the body will be projected.
	*/
	ProjectionLinearTolerance: number;
	/**
	 * Angular tolerance value in world units. If the distance error exceeds this tolerence limit, the body will be projected.
	*/
	ProjectionAngularTolerance: number;
	/**
	 * Force needed to break the distance constraint.
	*/
	LinearBreakThreshold: number;
	/**
	 * Torque needed to break the joint.
	*/
	AngularBreakThreshold: number;
	/**
	 * Linear Limit
	*/
	LinearLimit: LinearConstraint;
	/**
	 * Cone Limit
	*/
	ConeLimit: ConeConstraint;
	/**
	 * Twist Limit
	*/
	TwistLimit: TwistConstraint;
	/**
	 * Linear Drive
	*/
	LinearDrive: LinearDriveConstraint;
	/**
	 * Angular Drive
	*/
	AngularDrive: AngularDriveConstraint;
	/**
	 * Disable collision between bodies joined by this constraint.
	*/
	bDisableCollision: boolean;
	/**
	 * If distance error between bodies exceeds 0.1 units, or rotation error exceeds 10 degrees, body will be projected to fix this.
	 * For example a chain spinning too fast will have its elements appear detached due to velocity, this will project all bodies so they still appear attached to each other.
	*/
	bEnableProjection: boolean;
	/**
	 * Whether it is possible to break the joint with angular force.
	*/
	bAngularBreakable: boolean;
	/**
	 * Whether it is possible to break the joint with linear force.
	*/
	bLinearBreakable: boolean;
	clone() : ConstraintProfileProperties;
	static C(Other: UObject): ConstraintProfileProperties;
}

declare class ConstraintInstance { 
	/**
	 * Name of bone that this joint is associated with.
	*/
	JointName: string;
	/**
	 * Name of first bone (body) that this constraint is connecting.
	 * This will be the 'child' bone in a PhysicsAsset.
	*/
	ConstraintBone1: string;
	/**
	 * Name of second bone (body) that this constraint is connecting.
	 * This will be the 'parent' bone in a PhysicsAset.
	*/
	ConstraintBone2: string;
	/**
	 * Location of constraint in Body1 reference frame.
	*/
	Pos1: Vector;
	/**
	 * Primary (twist) axis in Body1 reference frame.
	*/
	PriAxis1: Vector;
	/**
	 * Seconday axis in Body1 reference frame. Orthogonal to PriAxis1.
	*/
	SecAxis1: Vector;
	/**
	 * Location of constraint in Body2 reference frame.
	*/
	Pos2: Vector;
	/**
	 * Primary (twist) axis in Body2 reference frame.
	*/
	PriAxis2: Vector;
	/**
	 * Seconday axis in Body2 reference frame. Orthogonal to PriAxis2.
	*/
	SecAxis2: Vector;
	/**
	 * Specifies the angular offset between the two frames of reference. By default limit goes from (-Angle, +Angle)
	 * This allows you to bias the limit for swing1 swing2 and twist.
	*/
	AngularRotationOffset: Rotator;
	/**
	 * If true, linear limits scale using the absolute min of the 3d scale of the owning component
	*/
	bScaleLinearLimits: boolean;
	/**
	 * Constraint Data (properties easily swapped at runtime based on different constraint profiles)
	*/
	ProfileInstance: ConstraintProfileProperties;
	/**
	 * Disable Collision
	*/
	bDisableCollision: boolean;
	/**
	 * Enable Projection
	*/
	bEnableProjection: boolean;
	/**
	 * Projection Linear Tolerance
	*/
	ProjectionLinearTolerance: number;
	/**
	 * Projection Angular Tolerance
	*/
	ProjectionAngularTolerance: number;
	/**
	 * Linear XMotion
	*/
	LinearXMotion: ELinearConstraintMotion;
	/**
	 * Linear YMotion
	*/
	LinearYMotion: ELinearConstraintMotion;
	/**
	 * Linear ZMotion
	*/
	LinearZMotion: ELinearConstraintMotion;
	/**
	 * Linear Limit Size
	*/
	LinearLimitSize: number;
	/**
	 * Linear Limit Soft
	*/
	bLinearLimitSoft: boolean;
	/**
	 * Linear Limit Stiffness
	*/
	LinearLimitStiffness: number;
	/**
	 * Linear Limit Damping
	*/
	LinearLimitDamping: number;
	/**
	 * Linear Breakable
	*/
	bLinearBreakable: boolean;
	/**
	 * Linear Break Threshold
	*/
	LinearBreakThreshold: number;
	/**
	 * Angular Swing 1Motion
	*/
	AngularSwing1Motion: EAngularConstraintMotion;
	/**
	 * Angular Twist Motion
	*/
	AngularTwistMotion: EAngularConstraintMotion;
	/**
	 * Angular Swing 2Motion
	*/
	AngularSwing2Motion: EAngularConstraintMotion;
	/**
	 * Swing Limit Soft
	*/
	bSwingLimitSoft: boolean;
	/**
	 * Twist Limit Soft
	*/
	bTwistLimitSoft: boolean;
	/**
	 * Swing 1Limit Angle
	*/
	Swing1LimitAngle: number;
	/**
	 * Twist Limit Angle
	*/
	TwistLimitAngle: number;
	/**
	 * Swing 2Limit Angle
	*/
	Swing2LimitAngle: number;
	/**
	 * Swing Limit Stiffness
	*/
	SwingLimitStiffness: number;
	/**
	 * Swing Limit Damping
	*/
	SwingLimitDamping: number;
	/**
	 * Twist Limit Stiffness
	*/
	TwistLimitStiffness: number;
	/**
	 * Twist Limit Damping
	*/
	TwistLimitDamping: number;
	/**
	 * Angular Breakable
	*/
	bAngularBreakable: boolean;
	/**
	 * Angular Break Threshold
	*/
	AngularBreakThreshold: number;
	/**
	 * Linear XPosition Drive
	*/
	bLinearXPositionDrive: boolean;
	/**
	 * Linear XVelocity Drive
	*/
	bLinearXVelocityDrive: boolean;
	/**
	 * Linear YPosition Drive
	*/
	bLinearYPositionDrive: boolean;
	/**
	 * Linear YVelocity Drive
	*/
	bLinearYVelocityDrive: boolean;
	/**
	 * Linear ZPosition Drive
	*/
	bLinearZPositionDrive: boolean;
	/**
	 * Linear ZVelocity Drive
	*/
	bLinearZVelocityDrive: boolean;
	/**
	 * Linear Position Drive
	*/
	bLinearPositionDrive: boolean;
	/**
	 * Linear Velocity Drive
	*/
	bLinearVelocityDrive: boolean;
	/**
	 * Linear Position Target
	*/
	LinearPositionTarget: Vector;
	/**
	 * Linear Velocity Target
	*/
	LinearVelocityTarget: Vector;
	/**
	 * Linear Drive Spring
	*/
	LinearDriveSpring: number;
	/**
	 * Linear Drive Damping
	*/
	LinearDriveDamping: number;
	/**
	 * Linear Drive Force Limit
	*/
	LinearDriveForceLimit: number;
	/**
	 * Swing Position Drive
	*/
	bSwingPositionDrive: boolean;
	/**
	 * Swing Velocity Drive
	*/
	bSwingVelocityDrive: boolean;
	/**
	 * Twist Position Drive
	*/
	bTwistPositionDrive: boolean;
	/**
	 * Twist Velocity Drive
	*/
	bTwistVelocityDrive: boolean;
	/**
	 * Angular Slerp Drive
	*/
	bAngularSlerpDrive: boolean;
	/**
	 * Angular Orientation Drive
	*/
	bAngularOrientationDrive: boolean;
	/**
	 * Enable Swing Drive
	*/
	bEnableSwingDrive: boolean;
	/**
	 * Enable Twist Drive
	*/
	bEnableTwistDrive: boolean;
	/**
	 * Angular Velocity Drive
	*/
	bAngularVelocityDrive: boolean;
	/**
	 * Angular Position Target
	*/
	AngularPositionTarget: Quat;
	/**
	 * Angular Drive Mode
	*/
	AngularDriveMode: EAngularDriveMode;
	/**
	 * Angular Orientation Target
	*/
	AngularOrientationTarget: Rotator;
	/**
	 * Angular Velocity Target
	*/
	AngularVelocityTarget: Vector;
	/**
	 * Revolutions per second
	*/
	AngularDriveSpring: number;
	/**
	 * Angular Drive Damping
	*/
	AngularDriveDamping: number;
	/**
	 * Angular Drive Force Limit
	*/
	AngularDriveForceLimit: number;
	clone() : ConstraintInstance;
	static C(Other: UObject): ConstraintInstance;
}

declare class PhysicsConstraintProfileHandle { 
	/**
	 * Profile Properties
	*/
	ProfileProperties: ConstraintProfileProperties;
	/**
	 * Profile Name
	*/
	ProfileName: string;
	clone() : PhysicsConstraintProfileHandle;
	static C(Other: UObject): PhysicsConstraintProfileHandle;
}

declare class PhysicsConstraintTemplate extends UObject { 
	/**
	 * Default Instance
	*/
	DefaultInstance: ConstraintInstance;
	/**
	 * Handles to the constraint profiles applicable to this constraint
	*/
	ProfileHandles: PhysicsConstraintProfileHandle[];
	/**
	 * When no profile is selected, use these settings. Only needed in editor as we serialize it into DefaultInstance on save
	*/
	DefaultProfile: ConstraintProfileProperties;
	/**
	 * Joint Name
	*/
	JointName: string;
	/**
	 * Constraint Bone 1
	*/
	ConstraintBone1: string;
	/**
	 * Constraint Bone 2
	*/
	ConstraintBone2: string;
	/**
	 * Pos 1
	*/
	Pos1: Vector;
	/**
	 * Pri Axis 1
	*/
	PriAxis1: Vector;
	/**
	 * Sec Axis 1
	*/
	SecAxis1: Vector;
	/**
	 * Pos 2
	*/
	Pos2: Vector;
	/**
	 * Pri Axis 2
	*/
	PriAxis2: Vector;
	/**
	 * Sec Axis 2
	*/
	SecAxis2: Vector;
	/**
	 * Enable Projection
	*/
	bEnableProjection: boolean;
	/**
	 * Projection Linear Tolerance
	*/
	ProjectionLinearTolerance: number;
	/**
	 * Projection Angular Tolerance
	*/
	ProjectionAngularTolerance: number;
	/**
	 * Linear XMotion
	*/
	LinearXMotion: ELinearConstraintMotion;
	/**
	 * Linear YMotion
	*/
	LinearYMotion: ELinearConstraintMotion;
	/**
	 * Linear ZMotion
	*/
	LinearZMotion: ELinearConstraintMotion;
	/**
	 * Linear Limit Size
	*/
	LinearLimitSize: number;
	/**
	 * Linear Limit Soft
	*/
	bLinearLimitSoft: boolean;
	/**
	 * Linear Limit Stiffness
	*/
	LinearLimitStiffness: number;
	/**
	 * Linear Limit Damping
	*/
	LinearLimitDamping: number;
	/**
	 * Linear Breakable
	*/
	bLinearBreakable: boolean;
	/**
	 * Linear Break Threshold
	*/
	LinearBreakThreshold: number;
	/**
	 * Angular Swing 1Motion
	*/
	AngularSwing1Motion: EAngularConstraintMotion;
	/**
	 * Angular Swing 2Motion
	*/
	AngularSwing2Motion: EAngularConstraintMotion;
	/**
	 * Angular Twist Motion
	*/
	AngularTwistMotion: EAngularConstraintMotion;
	/**
	 * Swing Limit Soft
	*/
	bSwingLimitSoft: boolean;
	/**
	 * Twist Limit Soft
	*/
	bTwistLimitSoft: boolean;
	/**
	 * Swing 1Limit Angle
	*/
	Swing1LimitAngle: number;
	/**
	 * Swing 2Limit Angle
	*/
	Swing2LimitAngle: number;
	/**
	 * Twist Limit Angle
	*/
	TwistLimitAngle: number;
	/**
	 * Swing Limit Stiffness
	*/
	SwingLimitStiffness: number;
	/**
	 * Swing Limit Damping
	*/
	SwingLimitDamping: number;
	/**
	 * Twist Limit Stiffness
	*/
	TwistLimitStiffness: number;
	/**
	 * Twist Limit Damping
	*/
	TwistLimitDamping: number;
	/**
	 * Angular Breakable
	*/
	bAngularBreakable: boolean;
	/**
	 * Angular Break Threshold
	*/
	AngularBreakThreshold: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsConstraintTemplate;
	static Find(Outer: UObject, ResourceName: string): PhysicsConstraintTemplate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsConstraintTemplate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsConstraintTemplate;
	static C(Other: UObject): PhysicsConstraintTemplate;
}

declare class PhysicsAsset extends UObject { 
	/**
	 * Default skeletal mesh to use when previewing this PhysicsAsset etc.
	 * Is the one that was used as the basis for creating this Asset.
	*/
	DefaultSkelMesh: SkeletalMesh;
	/**
	 * Preview Skeletal Mesh
	*/
	PreviewSkeletalMesh: any;
	/**
	 * Physical Animation Profiles
	*/
	PhysicalAnimationProfiles: string[];
	/**
	 * Constraint Profiles
	*/
	ConstraintProfiles: string[];
	/**
	 * Current Physical Animation Profile Name
	*/
	CurrentPhysicalAnimationProfileName: string;
	/**
	 * Current Constraint Profile Name
	*/
	CurrentConstraintProfileName: string;
	/**
	 * Index of bodies that are marked bConsiderForBounds
	*/
	BoundsBodies: number[];
	/**
	 * Array of SkeletalBodySetup objects. Stores information about collision shape etc. for each body.
	 * Does not include body position - those are taken from mesh.
	*/
	SkeletalBodySetups: SkeletalBodySetup[];
	/**
	 * Array of RB_ConstraintSetup objects.
	 * Stores information about a joint between two bodies, such as position relative to each body, joint limits etc.
	*/
	ConstraintSetup: PhysicsConstraintTemplate[];
	/**
	 * If true, bodies of the physics asset will be put into the asynchronous physics scene. If false, they will be put into the synchronous physics scene.
	*/
	bUseAsyncScene: boolean;
	/**
	 * Body Setup
	*/
	BodySetup: BodySetup[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsAsset;
	static Find(Outer: UObject, ResourceName: string): PhysicsAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsAsset;
	static C(Other: UObject): PhysicsAsset;
}

declare class MorphTarget extends UObject { 
	/**
	 * USkeletalMesh that this vertex animation works on.
	*/
	BaseSkelMesh: SkeletalMesh;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MorphTarget;
	static Find(Outer: UObject, ResourceName: string): MorphTarget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MorphTarget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MorphTarget;
	static C(Other: UObject): MorphTarget;
}

declare class ClothPhysicsProperties { 
	/**
	 * vertical stiffness of the cloth in the range [0, 1].   usually set to 1.0
	*/
	VerticalResistance: number;
	/**
	 * Horizontal stiffness of the cloth in the range [0, 1].  usually set to 1.0
	*/
	HorizontalResistance: number;
	/**
	 * Bending stiffness of the cloth in the range [0, 1].
	*/
	BendResistance: number;
	/**
	 * Shearing stiffness of the cloth in the range [0, 1].
	*/
	ShearResistance: number;
	/**
	 * Friction coefficient in the range[0, 1]
	*/
	Friction: number;
	/**
	 * Spring damping of the cloth in the range[0, 1]
	*/
	Damping: number;
	/**
	 * Tether stiffness of the cloth in the range[0, 1].  Equivalent to 1.0-Relax in autodesk plugin.
	*/
	TetherStiffness: number;
	/**
	 * Tether Limit, corresponds to 1.0+StretchLimit parameter on Autodesk plugin.
	*/
	TetherLimit: number;
	/**
	 * Drag coefficient n the range [0, 1]
	*/
	Drag: number;
	/**
	 * Frequency for stiffness
	*/
	StiffnessFrequency: number;
	/**
	 * Gravity multiplier for this cloth.  Also called Density in Autodesk plugin.
	*/
	GravityScale: number;
	/**
	 * A mass scaling that is applied to the cloth.   Corresponds to 100X the MotionAdaptation parameter in autodesk plugin.
	*/
	MassScale: number;
	/**
	 * Amount of inertia that is kept when using local space simulation. Internal name is inertia scale
	*/
	InertiaBlend: number;
	/**
	 * Minimal amount of distance particles will keep of each other.
	*/
	SelfCollisionThickness: number;
	/**
	 * unclear what this actually does.
	*/
	SelfCollisionSquashScale: number;
	/**
	 * Self collision stiffness.  0 off, 1 for on.
	*/
	SelfCollisionStiffness: number;
	/**
	 * A computation parameter for the Solver.   Along with frame rate this probably specifies the number of solver iterations
	*/
	SolverFrequency: number;
	/**
	 * Lower (compression) Limit of SoftZone (relative to rest length).  Applied for all fiber types.  If both compression and expansion are 1.0 then there is no deadzone.
	*/
	FiberCompression: number;
	/**
	 * Upper (expansion) Limit of SoftZone (relative to rest length).  Applied to all fiber types.   Also referred to as "stretch" range by apex internally.
	*/
	FiberExpansion: number;
	/**
	 * Resistance Multiplier that's applied to within SoftZone amount for all fiber types.  0.0 for a complete deadzone (no force).  At 1.0 the spring response within the softzone is as stiff it is elsewhere.  This parameter also known as scale by Apex internally.
	*/
	FiberResistance: number;
	clone() : ClothPhysicsProperties;
	static C(Other: UObject): ClothPhysicsProperties;
}

declare class ClothingAssetData { 
	/**
	 * User-defined asset name
	*/
	AssetName: string;
	/**
	 * Apex File Name
	*/
	ApexFileName: string;
	/**
	 * the flag whether cloth physics properties are changed from UE4 editor or not
	*/
	bClothPropertiesChanged: boolean;
	/**
	 * Physics Properties
	*/
	PhysicsProperties: ClothPhysicsProperties;
	clone() : ClothingAssetData;
	static C(Other: UObject): ClothingAssetData;
}

declare class SkeletalMesh extends UObject { 
	/**
	 * Skeleton of this skeletal mesh *
	*/
	Skeleton: Skeleton;
	/**
	 * Original imported mesh bounds
	*/
	ImportedBounds: BoxSphereBounds;
	/**
	 * Bounds extended by user values below
	*/
	ExtendedBounds: BoxSphereBounds;
	/**
	 * Bound extension values in addition to imported bound in the positive direction of XYZ,
	 *     positive value increases bound size and negative value decreases bound size.
	 *     The final bound would be from [Imported Bound - Negative Bound] to [Imported Bound + Positive Bound].
	*/
	PositiveBoundsExtension: Vector;
	/**
	 * Bound extension values in addition to imported bound in the negative direction of XYZ,
	 *     positive value increases bound size and negative value decreases bound size.
	 *     The final bound would be from [Imported Bound - Negative Bound] to [Imported Bound + Positive Bound].
	*/
	NegativeBoundsExtension: Vector;
	/**
	 * List of materials applied to this mesh.
	*/
	Materials: SkeletalMaterial[];
	/**
	 * List of bones that should be mirrored.
	*/
	SkelMirrorTable: BoneMirrorInfo[];
	/**
	 * Skel Mirror Axis
	*/
	SkelMirrorAxis: EAxis;
	/**
	 * Skel Mirror Flip Axis
	*/
	SkelMirrorFlipAxis: EAxis;
	/**
	 * Struct containing information for each LOD level, such as materials to use, and when use the LOD.
	*/
	LODInfo: SkeletalMeshLODInfo[];
	/**
	 * If true, use 32 bit UVs. If false, use 16 bit UVs to save memory
	*/
	bUseFullPrecisionUVs: boolean;
	/**
	 * true if this mesh has ever been simplified with Simplygon.
	*/
	bHasBeenSimplified: boolean;
	/**
	 * Whether or not the mesh has vertex colors
	*/
	bHasVertexColors: boolean;
	/**
	 * Uses skinned data for collision data. Per poly collision cannot be used for simulation, in most cases you are better off using the physics asset
	*/
	bEnablePerPolyCollision: boolean;
	/**
	 * Physics data for the per poly collision case. In 99% of cases you will not need this and are better off using simple ragdoll collision (physics asset)
	*/
	BodySetup: BodySetup;
	/**
	 * Physics and collision information used for this USkeletalMesh, set up in PhAT.
	 * This is used for per-bone hit detection, accurate bounding box calculation and ragdoll physics for example.
	*/
	PhysicsAsset: PhysicsAsset;
	/**
	 * Physics asset whose shapes will be used for shadowing when components have bCastCharacterCapsuleDirectShadow or bCastCharacterCapsuleIndirectShadow enabled.
	 * Only spheres and sphyl shapes in the physics asset can be supported.  The more shapes used, the higher the cost of the capsule shadows will be.
	*/
	ShadowPhysicsAsset: PhysicsAsset;
	/**
	 * Importing data and options used for this mesh
	*/
	AssetImportData: AssetImportData;
	/**
	 * Path to the resource used to construct this skeletal mesh
	*/
	SourceFilePath: string;
	/**
	 * Date/Time-stamp of the file from the last import
	*/
	SourceFileTimestamp: string;
	/**
	 * Information for thumbnail rendering
	*/
	ThumbnailInfo: ThumbnailInfo;
	/**
	 * Optimization settings used to simplify LODs of this mesh.
	*/
	OptimizationSettings: SkeletalMeshOptimizationSettings[];
	/**
	 * Attached assets component for this mesh
	*/
	PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
	/**
	 * Allows artists to adjust the distance where textures using UV 0 are streamed in/out.
	 * 1.0 is the default, whereas a higher value increases the streamed-in resolution.
	 * Value can be < 0 (from legcay content, or code changes)
	*/
	StreamingDistanceMultiplier: number;
	/**
	 * Morph Targets
	*/
	MorphTargets: MorphTarget[];
	/**
	 * The section currently selected in the Editor. Used for highlighting
	*/
	SelectedEditorSection: number;
	/**
	 * The section currently selected for clothing. need to remember this index for reimporting cloth
	*/
	SelectedClothingSection: number;
	/**
	 * Height offset for the floor mesh in the editor
	*/
	FloorOffset: number;
	/**
	 * This is buffer that saves pose that is used by retargeting
	*/
	RetargetBasePose: Transform[];
	/**
	 * Clothing asset data
	*/
	ClothingAssets: ClothingAssetData[];
	/**
	 * Array of user data stored with the asset
	*/
	AssetUserData: AssetUserData[];
	/**
	 * Array of named socket locations, set up in editor and used as a shortcut instead of specifying
	 * everything explicitly to AttachComponent in the SkeletalMeshComponent.
	*/
	Sockets: SkeletalMeshSocket[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMesh;
	static Find(Outer: UObject, ResourceName: string): SkeletalMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMesh;
	/**
	 * Returns the number of sockets available. Both on this mesh and it's skeleton.
	*/
	NumSockets(): number;
	/**
	 * Checks whether the provided section is using APEX cloth. if bCheckCorrespondingSections is true
	 * disabled sections will defer to correspond sections to see if they use cloth (non-cloth sections
	 * are disabled and another section added when cloth is enabled, using this flag allows for a check
	 * on the original section to succeed)
	 * @param InSectionIndex Index to check
	 * @param bCheckCorrespondingSections Whether to check corresponding sections for disabled sections
	*/
	IsSectionUsingCloth(InSectionIndex: number,bCheckCorrespondingSections: boolean): boolean;
	/**
	 * Returns a socket by index. Max index is NumSockets(). The meshes sockets are accessed first, then the skeletons.
	*/
	GetSocketByIndex(Index: number): SkeletalMeshSocket;
	/**
	 * Get the original imported bounds of the skel mesh
	*/
	GetImportedBounds(): BoxSphereBounds;
	/**
	 * Get the extended bounds of this mesh (imported bounds plus bounds extension)
	*/
	GetBounds(): BoxSphereBounds;
	/**
	 * Find a socket object in this SkeletalMesh by name.
	 * Entering NAME_None will return NULL. If there are multiple sockets with the same name, will return the first one.
	 * Also returns the index for the socket allowing for future fast access via GetSocketByIndex()
	*/
	FindSocketAndIndex(InSocketName: string,OutIndex?: number): {OutIndex: number, $: SkeletalMeshSocket};
	/**
	 * Find a socket object in this SkeletalMesh by name.
	 * Entering NAME_None will return NULL. If there are multiple sockets with the same name, will return the first one.
	*/
	FindSocket(InSocketName: string): SkeletalMeshSocket;
	static C(Other: UObject): SkeletalMesh;
}

declare class SkelMeshComponentLODInfo { 
	/**
	 * Material corresponds to section. To show/hide each section, use this.
	*/
	HiddenMaterials: boolean[];
	clone() : SkelMeshComponentLODInfo;
	static C(Other: UObject): SkelMeshComponentLODInfo;
}

declare type EMeshComponentUpdateFlag = string | symbol;
declare var EMeshComponentUpdateFlag = { AlwaysTickPoseAndRefreshBones:'AlwaysTickPoseAndRefreshBones',AlwaysTickPose:'AlwaysTickPose',OnlyTickPoseWhenRendered:'OnlyTickPoseWhenRendered', };
declare type EPhysBodyOp = string | symbol;
declare var EPhysBodyOp = { PBO_None:'PBO_None',PBO_Term:'PBO_Term',PBO_Disable:'PBO_Disable', };
declare class SkinnedMeshComponent extends MeshComponent { 
	/**
	 * The skeletal mesh used by this component.
	*/
	SkeletalMesh: SkeletalMesh;
	/**
	 * If set, this SkeletalMeshComponent will not use its SpaceBase for bone transform, but will
	 * use the component space transforms from the MasterPoseComponent. This is used when constructing a character using multiple skeletal meshes sharing the same
	 * skeleton within the same Actor.
	*/
	MasterPoseComponent: any;
	/**
	 * When true, we will just using the bounds from our MasterPoseComponent.  This is useful for when we have a Mesh Parented
	 * to the main SkelMesh (e.g. outline mesh or a full body overdraw effect that is toggled) that is always going to be the same
	 * bounds as parent.  We want to do no calculations in that case.
	*/
	bUseBoundsFromMasterPoseComponent: boolean;
	/**
	 * Index of the chunk to preview... If set to -1, all chunks will be rendered
	*/
	ChunkIndexPreview: number;
	/**
	 * Index of the section to preview... If set to -1, all section will be rendered
	*/
	SectionIndexPreview: number;
	/**
	 * PhysicsAsset is set in SkeletalMesh by default, but you can override with this value
	*/
	PhysicsAssetOverride: PhysicsAsset;
	/**
	 * If 0, auto-select LOD level. if >0, force to (ForcedLodModel-1).
	*/
	ForcedLodModel: number;
	/**
	 * This is the min LOD that this component will use.  (e.g. if set to 2 then only 2+ LOD Models will be used.) This is useful to set on
	 * meshes which are known to be a certain distance away and still want to have better LODs when zoomed in on them.
	*/
	MinLodModel: number;
	/**
	 * LOD array info. Each index will correspond to the LOD index *
	*/
	LODInfo: SkelMeshComponentLODInfo[];
	/**
	 * Allows adjusting the desired streaming distance of streaming textures that uses UV 0.
	 * 1.0 is the default, whereas a higher value makes the textures stream in sooner from far away.
	 * A lower value (0.0-1.0) makes the textures stream in later (you have to be closer).
	 * Value can be < 0 (from legcay content, or code changes)
	*/
	StreamingDistanceMultiplier: number;
	/**
	 * Wireframe color
	*/
	WireframeColor: Color;
	/**
	 * Forces the mesh to draw in wireframe mode.
	*/
	bForceWireframe: boolean;
	/**
	 * Draw the skeleton hierarchy for this skel mesh.
	*/
	bDisplayBones: boolean;
	/**
	 * Disable Morphtarget for this component.
	*/
	bDisableMorphTarget: boolean;
	/**
	 * Don't bother rendering the skin.
	*/
	bHideSkin: boolean;
	/**
	 * If true, use per-bone motion blur on this skeletal mesh (requires additional rendering, can be disabled to save performance).
	*/
	bPerBoneMotionBlur: boolean;
	/**
	 * When true, skip using the physics asset etc. and always use the fixed bounds defined in the SkeletalMesh.
	*/
	bComponentUseFixedSkelBounds: boolean;
	/**
	 * If true, when updating bounds from a PhysicsAsset, consider _all_ BodySetups, not just those flagged with bConsiderForBounds.
	*/
	bConsiderAllBodiesForBounds: boolean;
	/**
	 * This is update frequency flag even when our Owner has not been rendered recently
	 * SMU_AlwaysTickPoseAndRefreshBones,                   // Always Tick and Refresh BoneTransforms whether rendered or not
	 * SMU_AlwaysTickPose,                                                  // Always Tick, but Refresh BoneTransforms only when rendered
	 * SMU_OnlyTickPoseWhenRendered,                                // Tick only when rendered, and it will only RefreshBoneTransforms when rendered
	*/
	MeshComponentUpdateFlag: EMeshComponentUpdateFlag;
	/**
	 * If true, UpdateTransform will always result in a call to MeshObject->Update.
	*/
	bForceMeshObjectUpdate: boolean;
	/**
	 * Whether or not we can highlight selected sections - this should really only be done in the editor
	*/
	bCanHighlightSelectedSections: boolean;
	/**
	 * true if mesh has been recently rendered, false otherwise
	*/
	bRecentlyRendered: boolean;
	/**
	 * Editor only. Used for visualizing drawing order in Animset Viewer. If < 1.0,
	 * only the specified fraction of triangles will be rendered
	*/
	ProgressiveDrawingFraction: number;
	/**
	 * Editor only. Used for manually selecting the alternate indices for
	 * TRISORT_CustomLeftRight sections.
	*/
	CustomSortAlternateIndexMode: number;
	/**
	 * Whether to use the capsule representation (when present) from a skeletal mesh's ShadowPhysicsAsset for direct shadowing from lights.
	 * This type of shadowing is approximate but handles extremely wide area shadowing well.  The softness of the shadow depends on the light's LightSourceAngle / SourceRadius.
	 * This flag will force bCastInsetShadow to be enabled.
	*/
	bCastCapsuleDirectShadow: boolean;
	/**
	 * Whether to use the capsule representation (when present) from a skeletal mesh's ShadowPhysicsAsset for shadowing indirect lighting (from lightmaps or skylight).
	*/
	bCastCapsuleIndirectShadow: boolean;
	/**
	 * LocalBounds cached, so they're computed just once.
	*/
	CachedLocalBounds: BoxSphereBounds;
	/**
	 * true when CachedLocalBounds is up to date.
	*/
	bCachedLocalBoundsUpToDate: boolean;
	/**
	 * if TRUE, Owner will determine how often animation will be updated and evaluated. See AnimUpdateRateTick()
	 * This allows to skip frames for performance. (For example based on visibility and size on screen).
	*/
	bEnableUpdateRateOptimizations: boolean;
	/**
	 * Enable on screen debugging of update rate optimization.
	 * Red = Skipping 0 frames, Green = skipping 1 frame, Blue = skipping 2 frames, black = skipping more than 2 frames.
	 * @todo: turn this into a console command.
	*/
	bDisplayDebugUpdateRateOptimizations: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkinnedMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SkinnedMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkinnedMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkinnedMeshComponent;
	/**
	 * UnHide the specified bone with name.  Currently this just enforces a scale of 0 for the hidden bones.
	 * Compoared to HideBone By Index - This keeps track of list of bones and update when LOD changes
	 * @param  BoneName            Name of bone to unhide
	*/
	UnHideBoneByName(BoneName: string): void;
	/**
	 * Transform a location/rotation from world space to bone relative space.
	 * This is handy if you know the location in world space for a bone attachment, as AttachComponent takes location/rotation in bone-relative space.
	 * @param BoneName Name of bone
	 * @param InPosition Input position
	 * @param InRotation Input rotation
	 * @param OutPosition (out) Transformed position
	 * @param OutRotation (out) Transformed rotation
	*/
	TransformToBoneSpace(BoneName: string,InPosition: Vector,InRotation: Rotator,OutPosition?: Vector,OutRotation?: Rotator): {OutPosition: Vector, OutRotation: Rotator};
	/**
	 * Transform a location/rotation in bone relative space to world space.
	 * @param BoneName Name of bone
	 * @param InPosition Input position
	 * @param InRotation Input rotation
	 * @param OutPosition (out) Transformed position
	 * @param OutRotation (out) Transformed rotation
	*/
	TransformFromBoneSpace(BoneName: string,InPosition: Vector,InRotation: Rotator,OutPosition?: Vector,OutRotation?: Rotator): {OutPosition: Vector, OutRotation: Rotator};
	/**
	 * Change the SkeletalMesh that is rendered for this Component. Will re-initialize the animation tree etc.
	 * @param NewMesh New mesh to set for this component
	 * @param bReinitPose Whether we should keep current pose or reinitialize.
	*/
	SetSkeletalMesh(NewMesh: SkeletalMesh,bReinitPose: boolean): void;
	/**
	 * Override the Physics Asset of the mesh. It uses SkeletalMesh.PhysicsAsset, but if you'd like to override use this function
	 * @param       NewPhysicsAsset New PhysicsAsset
	 * @param       bForceReInit    Force reinitialize
	*/
	SetPhysicsAsset(NewPhysicsAsset: PhysicsAsset,bForceReInit: boolean): void;
	/**
	 * Set MinLodModel of the mesh component
	 * @param       InNewMinLOD     Set new MinLodModel that make sure the LOD does not go below of this value. Range from [0, Max Number of LOD - 1]. This will affect in the next tick update.
	*/
	SetMinLOD(InNewMinLOD: number): void;
	/**
	 * Set MasterPoseComponent for this component
	 * @param NewMasterBoneComponent New MasterPoseComponent
	*/
	SetMasterPoseComponent(NewMasterBoneComponent: SkinnedMeshComponent): void;
	/**
	 * Set MinLodModel of the mesh component
	 * @param       InNewForcedLOD  Set new ForcedLODModel that forces to set the incoming LOD. Range from [1, Max Number of LOD]. This will affect in the next tick update.
	*/
	SetForcedLOD(InNewForcedLOD: number): void;
	/**
	 * Determines if the specified bone is hidden.
	 * @param  BoneName            Name of bone to check
	 * @return true if hidden
	*/
	IsBoneHiddenByName(BoneName: string): boolean;
	/**
	 * Hides the specified bone with name.  Currently this just enforces a scale of 0 for the hidden bones.
	 * Compoared to HideBone By Index - This keeps track of list of bones and update when LOD changes
	 * @param  BoneName            Name of bone to hide
	 * @param  PhysBodyOption          Option for physics bodies that attach to the bones to be hidden
	*/
	HideBoneByName(BoneName: string,PhysBodyOption: EPhysBodyOp): void;
	/**
	 * Returns bone name linked to a given named socket on the skeletal mesh component.
	 * If you're unsure to deal with sockets or bones names, you can use this function to filter through, and always return the bone name.
	 * @param       bone name or socket name
	 * @return      bone name
	*/
	GetSocketBoneName(InSocketName: string): string;
	/**
	 * Get Parent Bone of the input bone
	 * @param BoneName Name of the bone
	 * @return the name of the parent bone for the specified bone. Returns 'None' if the bone does not exist or it is the root bone
	*/
	GetParentBone(BoneName: string): string;
	/**
	 * Returns the number of bones in the skeleton.
	*/
	GetNumBones(): number;
	/**
	 * Get Bone Name from index
	 * @param BoneIndex Index of the bone
	 * @return the name of the bone at the specified index
	*/
	GetBoneName(BoneIndex: number): string;
	/**
	 * Find the index of bone by name. Looks in the current SkeletalMesh being used by this SkeletalMeshComponent.
	 * @param BoneName Name of bone to look up
	 * @return Index of the named bone in the current SkeletalMesh. Will return INDEX_NONE if bone not found.
	 * @see USkeletalMesh::GetBoneIndex.
	*/
	GetBoneIndex(BoneName: string): number;
	/**
	 * finds the closest bone to the given location
	 * @param TestLocation the location to test against
	 * @param BoneLocation (optional, out) if specified, set to the world space location of the bone that was found, or (0,0,0) if no bone was found
	 * @param IgnoreScale (optional) if specified, only bones with scaling larger than the specified factor are considered
	 * @param bRequirePhysicsAsset (optional) if true, only bones with physics will be considered
	 * @return the name of the bone that was found, or 'None' if no bone was found
	*/
	FindClosestBone(TestLocation: Vector,BoneLocation?: Vector,IgnoreScale?: number,bRequirePhysicsAsset?: boolean): {BoneLocation: Vector, $: string};
	/**
	 * Tests if BoneName is child of (or equal to) ParentBoneName.
	 * @param BoneName Name of the bone
	 * @param ParentBone Name to check
	 * @return true if child (strictly, not same). false otherwise
	 * Note - will return false if ChildBoneIndex is the same as ParentBoneIndex ie. must be strictly a child.
	*/
	BoneIsChildOf(BoneName: string,ParentBoneName: string): boolean;
	static C(Other: UObject): SkinnedMeshComponent;
}

declare type EAnimationMode = string | symbol;
declare var EAnimationMode = { AnimationBlueprint:'AnimationBlueprint',AnimationSingleNode:'AnimationSingleNode', };
declare class BlueprintCore extends UObject { 
	/**
	 * Pointer to the skeleton class; this is regenerated any time a member variable or function is added but
	 *       is usually incomplete (no code or hidden autogenerated variables are added to it)
	*/
	SkeletonGeneratedClass: UnrealEngineClass;
	/**
	 * Pointer to the 'most recent' fully generated class
	*/
	GeneratedClass: UnrealEngineClass;
	/**
	 * BackCompat:  Whether or not we need to purge references in this blueprint to the skeleton generated during compile-on-load
	*/
	bLegacyNeedToPurgeSkelRefs: boolean;
	/**
	 * BackCompat: Whether or not this blueprint's authoritative CDO data has been migrated from the SkeletonGeneratedClass CDO to the GeneratedClass CDO
	*/
	bLegacyGeneratedClassIsAuthoritative: boolean;
	/**
	 * Blueprint Guid
	*/
	BlueprintGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlueprintCore;
	static Find(Outer: UObject, ResourceName: string): BlueprintCore;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlueprintCore;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlueprintCore;
	static C(Other: UObject): BlueprintCore;
}

declare type EBlueprintCompileMode = string | symbol;
declare var EBlueprintCompileMode = { Default:'Default',Development:'Development',FinalRelease:'FinalRelease', };
declare class Struct extends Field { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Struct;
	static Find(Outer: UObject, ResourceName: string): Struct;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Struct;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Struct;
	static C(Other: UObject): Struct;
}

declare class BlueprintComponentChangedPropertyInfo { 
	/**
	 * The name of the changed property.
	*/
	PropertyName: string;
	/**
	 * The array index of the changed property.
	*/
	ArrayIndex: number;
	/**
	 * The parent struct (owner) of the changed property.
	*/
	PropertyScope: Struct;
	clone() : BlueprintComponentChangedPropertyInfo;
	static C(Other: UObject): BlueprintComponentChangedPropertyInfo;
}

declare class BlueprintCookedComponentInstancingData { 
	/**
	 * Flag indicating whether or not this contains valid cooked data. Note that an empty changed property list can also be a valid template data context.
	*/
	bIsValid: boolean;
	/**
	 * List of property info records with values that differ between the template and the component class CDO. This list will be generated at cook time.
	*/
	ChangedPropertyList: BlueprintComponentChangedPropertyInfo[];
	clone() : BlueprintCookedComponentInstancingData;
	static C(Other: UObject): BlueprintCookedComponentInstancingData;
}

declare class BPVariableMetaDataEntry { 
	/**
	 * Name of metadata key
	*/
	DataKey: string;
	/**
	 * Name of metadata value
	*/
	DataValue: string;
	clone() : BPVariableMetaDataEntry;
	static C(Other: UObject): BPVariableMetaDataEntry;
}

declare class SCS_Node extends UObject { 
	/**
	 * Template for the component to create
	*/
	ComponentTemplate: ActorComponent;
	/**
	 * Cached data for faster runtime instancing (only used in cooked builds)
	*/
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	/**
	 * If non-None, creates a variable in the class and assigns the created blueprint to it
	*/
	VariableName: string;
	/**
	 * If non-None, the assigned category name
	*/
	CategoryName: string;
	/**
	 * Socket/Bone that Node might attach to
	*/
	AttachToName: string;
	/**
	 * Component template or variable that Node might be parented to
	*/
	ParentComponentOrVariableName: string;
	/**
	 * If the node is attached to another node inherited from a parent Blueprint, this contains the name of the Blueprint parent class that owns the component template //@TODO: We can potentially remove this if/when inherited SCS component template instances are included in subobject serialization, as we could then infer that the owner class is always the same as the BP class.
	*/
	ParentComponentOwnerClassName: string;
	/**
	 * If the node is parented, this indicates whether or not the template is found in the CDO's Components array
	*/
	bIsParentComponentNative: boolean;
	/**
	 * Set of child nodes
	*/
	ChildNodes: SCS_Node[];
	/**
	 * Metadata information for this Node
	*/
	MetaDataArray: BPVariableMetaDataEntry[];
	/**
	 * Variable Guid
	*/
	VariableGuid: Guid;
	/**
	 * (DEPRECATED)
	*/
	bIsFalseRoot: boolean;
	/**
	 * (DEPRECATED) Indicates if this is a native component or not
	*/
	bIsNative: boolean;
	/**
	 * (DEPRECATED) If this is a native component, this is the name of the UActorComponent
	*/
	NativeComponentName: string;
	/**
	 * (DEPRECATED) If true, the variable name was a autogenerated and is not presented to the user
	*/
	bVariableNameAutoGenerated: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SCS_Node;
	static Find(Outer: UObject, ResourceName: string): SCS_Node;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SCS_Node;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SCS_Node;
	static C(Other: UObject): SCS_Node;
}

declare class SimpleConstructionScript extends UObject { 
	/**
	 * Root nodes of the construction script
	*/
	RootNodes: SCS_Node[];
	/**
	 * All nodes that exist in the hierarchy of this SimpleConstructionScript
	*/
	AllNodes: SCS_Node[];
	/**
	 * Default scene root node; used when no other nodes are available to use as the root
	*/
	DefaultSceneRootNode: SCS_Node;
	/**
	 * (DEPRECATED) Root node of the construction script
	*/
	RootNode: SCS_Node;
	/**
	 * (DEPRECATED) Actor Component based nodes are stored here.  They cannot be in the tree hierarchy
	*/
	ActorComponentNodes: SCS_Node[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SimpleConstructionScript;
	static Find(Outer: UObject, ResourceName: string): SimpleConstructionScript;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SimpleConstructionScript;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SimpleConstructionScript;
	static C(Other: UObject): SimpleConstructionScript;
}

declare class EdGraphSchema extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphSchema;
	static Find(Outer: UObject, ResourceName: string): EdGraphSchema;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphSchema;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphSchema;
	static C(Other: UObject): EdGraphSchema;
}

declare type EEdGraphPinDirection = string | symbol;
declare var EEdGraphPinDirection = { EGPD_Input:'EGPD_Input',EGPD_Output:'EGPD_Output', };
declare class EdGraphPinType { 
	/**
	 * Category of pin type
	*/
	PinCategory: string;
	/**
	 * Sub-category of pin type
	*/
	PinSubCategory: string;
	/**
	 * Sub-category object
	*/
	PinSubCategoryObject: any;
	/**
	 * Sub-category member reference
	*/
	PinSubCategoryMemberReference: SimpleMemberReference;
	/**
	 * Whether or not this pin represents an array of values
	*/
	bIsArray: boolean;
	/**
	 * Whether or not this pin is a value passed by reference or not
	*/
	bIsReference: boolean;
	/**
	 * Whether or not this pin is a immutable const value
	*/
	bIsConst: boolean;
	/**
	 * Whether or not this is a weak reference
	*/
	bIsWeakPointer: boolean;
	clone() : EdGraphPinType;
	static C(Other: UObject): EdGraphPinType;
}

declare class EdGraphPin_Deprecated extends UObject { 
	/**
	 * Name of this pin
	*/
	PinName: string;
	/**
	 * Used as the display name if set
	*/
	PinFriendlyName: string;
	/**
	 * The tool-tip describing this pin's purpose
	*/
	PinToolTip: string;
	/**
	 * Direction of flow of this pin (input or output)
	*/
	Direction: EEdGraphPinDirection;
	/**
	 * The type of information carried on this pin
	*/
	PinType: EdGraphPinType;
	/**
	 * Default value for this pin (used if the pin has no connections), stored as a string
	*/
	DefaultValue: string;
	/**
	 * Initial default value (the autogenerated value, to identify if the user has modified the value), stored as a string
	*/
	AutogeneratedDefaultValue: string;
	/**
	 * If the default value for this pin should be an object, we store a pointer to it
	*/
	DefaultObject: UObject;
	/**
	 * If the default value for this pin should be an FText, it is stored here.
	*/
	DefaultTextValue: string;
	/**
	 * Set of pins that we are linked to
	*/
	LinkedTo: EdGraphPin_Deprecated[];
	/**
	 * The pins created when a pin is split and hidden
	*/
	SubPins: EdGraphPin_Deprecated[];
	/**
	 * The pin that was split and generated this pin
	*/
	ParentPin: EdGraphPin_Deprecated;
	/**
	 * Pin that this pin uses for passing through reference connection
	*/
	ReferencePassThroughConnection: EdGraphPin_Deprecated;
	/**
	 * If true, this connector is currently hidden.
	*/
	bHidden: boolean;
	/**
	 * If true, this connector is unconnectable, and present only to allow the editing of the default text.
	*/
	bNotConnectable: boolean;
	/**
	 * If true, the default value of this connector is fixed and cannot be modified by the user (it's visible for reference only)
	*/
	bDefaultValueIsReadOnly: boolean;
	/**
	 * If true, the default value on this pin is ignored and should not be set
	*/
	bDefaultValueIsIgnored: boolean;
	/**
	 * If true, this pin is the focus of a diff
	*/
	bIsDiffing: boolean;
	/**
	 * If true, the pin may be hidden by user
	*/
	bAdvancedView: boolean;
	/**
	 * If true, the pin is displayed as ref
	*/
	bDisplayAsMutableRef: boolean;
	/**
	 * Pin name could be changed, so whenever possible it's good to have a persistent GUID identifying Pin to reconstruct Node seamlessly
	*/
	PersistentGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphPin_Deprecated;
	static Find(Outer: UObject, ResourceName: string): EdGraphPin_Deprecated;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphPin_Deprecated;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphPin_Deprecated;
	static C(Other: UObject): EdGraphPin_Deprecated;
}

declare type ENodeAdvancedPins = string | symbol;
declare var ENodeAdvancedPins = { NoPins:'NoPins',Shown:'Shown',Hidden:'Hidden', };
declare type ENodeEnabledState = string | symbol;
declare var ENodeEnabledState = { Enabled:'Enabled',Disabled:'Disabled',DevelopmentOnly:'DevelopmentOnly', };
declare class EdGraphNode extends UObject { 
	/**
	 * List of connector pins
	*/
	DeprecatedPins: EdGraphPin_Deprecated[];
	/**
	 * X position of node in the editor
	*/
	NodePosX: number;
	/**
	 * Y position of node in the editor
	*/
	NodePosY: number;
	/**
	 * Width of node in the editor; only used when the node can be resized
	*/
	NodeWidth: number;
	/**
	 * Height of node in the editor; only used when the node can be resized
	*/
	NodeHeight: number;
	/**
	 * If true, this node can be resized and should be drawn with a resize handle
	*/
	bCanResizeNode: boolean;
	/**
	 * Flag to check for compile error/warning
	*/
	bHasCompilerMessage: boolean;
	/**
	 * If true, this node can be renamed in the editor
	*/
	bCanRenameNode: boolean;
	/**
	 * Note for a node that lingers until saved
	*/
	NodeUpgradeMessage: string;
	/**
	 * Comment string that is drawn on the node
	*/
	NodeComment: string;
	/**
	 * Comment bubble pinned state
	*/
	bCommentBubblePinned: boolean;
	/**
	 * Comment bubble visibility
	*/
	bCommentBubbleVisible: boolean;
	/**
	 * Flag to store node specific compile error/warning
	*/
	ErrorType: number;
	/**
	 * Error/Warning description
	*/
	ErrorMsg: string;
	/**
	 * GUID to uniquely identify this node, to facilitate diff'ing versions of this graph
	*/
	NodeGuid: Guid;
	/**
	 * Enum to indicate if a node has advanced-display-pins, and if they are shown
	*/
	AdvancedPinDisplay: ENodeAdvancedPins;
	/**
	 * Indicates in what state the node is enabled, which may eliminate it from being compiled
	*/
	EnabledState: ENodeEnabledState;
	/**
	 * Indicates whether or not the user explicitly set the enabled state
	*/
	bUserSetEnabledState: boolean;
	/**
	 * (DEPRECATED) FALSE if the node is a disabled, which eliminates it from being compiled
	*/
	bIsNodeEnabled: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraphNode;
	static Find(Outer: UObject, ResourceName: string): EdGraphNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraphNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraphNode;
	static C(Other: UObject): EdGraphNode;
}

declare class EdGraph extends UObject { 
	/**
	 * The schema that this graph obeys
	*/
	Schema: UnrealEngineClass;
	/**
	 * Set of all nodes in this graph
	*/
	Nodes: EdGraphNode[];
	/**
	 * If true, graph can be edited by the user
	*/
	bEditable: boolean;
	/**
	 * If true, graph can be deleted from the whatever container it is in. For FunctionGraphs
	 * this flag is reset to false on load (unless the function is the construction script or
	 * AnimGraph)
	*/
	bAllowDeletion: boolean;
	/**
	 * If true, graph can be renamed; Note: Graph can also be renamed if bAllowDeletion is true currently
	*/
	bAllowRenaming: boolean;
	/**
	 * Child graphs that are a part of this graph; the separation is purely visual
	*/
	SubGraphs: EdGraph[];
	/**
	 * Guid for this graph
	*/
	GraphGuid: Guid;
	/**
	 * Guid of interface graph this graph comes from (used for conforming)
	*/
	InterfaceGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): EdGraph;
	static Find(Outer: UObject, ResourceName: string): EdGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EdGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EdGraph;
	static C(Other: UObject): EdGraph;
}

declare type ETimelineLengthMode = string | symbol;
declare var ETimelineLengthMode = { TL_TimelineLength:'TL_TimelineLength',TL_LastKeyFrame:'TL_LastKeyFrame', };
declare class TTTrackBase { 
	/**
	 * Name of this track
	*/
	TrackName: string;
	/**
	 * Flag to identify internal/external curve
	*/
	bIsExternalCurve: boolean;
	clone() : TTTrackBase;
	static C(Other: UObject): TTTrackBase;
}

declare class CurveBase extends UObject { 
	/**
	 * Asset Import Data
	*/
	AssetImportData: AssetImportData;
	/**
	 * The filename imported to create this object. Relative to this object's package, BaseDir() or absolute
	*/
	ImportPath: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveBase;
	static Find(Outer: UObject, ResourceName: string): CurveBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveBase;
	/**
	 * Get the value range across all curves
	*/
	GetValueRange(MinValue?: number,MaxValue?: number): {MinValue: number, MaxValue: number};
	/**
	 * Get the time range across all curves
	*/
	GetTimeRange(MinTime?: number,MaxTime?: number): {MinTime: number, MaxTime: number};
	static C(Other: UObject): CurveBase;
}

declare class KeyHandleMap { 
	clone() : KeyHandleMap;
	static C(Other: UObject): KeyHandleMap;
}

declare class IndexedCurve { 
	/**
	 * Map of which key handles go to which indices.
	*/
	KeyHandlesToIndices: KeyHandleMap;
	clone() : IndexedCurve;
	static C(Other: UObject): IndexedCurve;
}

declare type ERichCurveExtrapolation = string | symbol;
declare var ERichCurveExtrapolation = { RCCE_Cycle:'RCCE_Cycle',RCCE_CycleWithOffset:'RCCE_CycleWithOffset',RCCE_Oscillate:'RCCE_Oscillate',RCCE_Linear:'RCCE_Linear',RCCE_Constant:'RCCE_Constant',RCCE_None:'RCCE_None', };
declare type ERichCurveInterpMode = string | symbol;
declare var ERichCurveInterpMode = { RCIM_Linear:'RCIM_Linear',RCIM_Constant:'RCIM_Constant',RCIM_Cubic:'RCIM_Cubic',RCIM_None:'RCIM_None', };
declare type ERichCurveTangentMode = string | symbol;
declare var ERichCurveTangentMode = { RCTM_Auto:'RCTM_Auto',RCTM_User:'RCTM_User',RCTM_Break:'RCTM_Break',RCTM_None:'RCTM_None', };
declare type ERichCurveTangentWeightMode = string | symbol;
declare var ERichCurveTangentWeightMode = { RCTWM_WeightedNone:'RCTWM_WeightedNone',RCTWM_WeightedArrive:'RCTWM_WeightedArrive',RCTWM_WeightedLeave:'RCTWM_WeightedLeave',RCTWM_WeightedBoth:'RCTWM_WeightedBoth', };
declare class RichCurveKey { 
	/**
	 * Interpolation mode between this key and the next
	*/
	InterpMode: ERichCurveInterpMode;
	/**
	 * Mode for tangents at this key
	*/
	TangentMode: ERichCurveTangentMode;
	/**
	 * If either tangent at this key is 'weighted'
	*/
	TangentWeightMode: ERichCurveTangentWeightMode;
	/**
	 * Time at this key
	*/
	Time: number;
	/**
	 * Value at this key
	*/
	Value: number;
	/**
	 * If RCIM_Cubic, the arriving tangent at this key
	*/
	ArriveTangent: number;
	/**
	 * If RCTWM_WeightedArrive or RCTWM_WeightedBoth, the weight of the left tangent
	*/
	ArriveTangentWeight: number;
	/**
	 * If RCIM_Cubic, the leaving tangent at this key
	*/
	LeaveTangent: number;
	/**
	 * If RCTWM_WeightedLeave or RCTWM_WeightedBoth, the weight of the right tangent
	*/
	LeaveTangentWeight: number;
	clone() : RichCurveKey;
	static C(Other: UObject): RichCurveKey;
}

declare class RichCurve extends IndexedCurve { 
	/**
	 * Pre-infinity extrapolation state
	*/
	PreInfinityExtrap: ERichCurveExtrapolation;
	/**
	 * Post-infinity extrapolation state
	*/
	PostInfinityExtrap: ERichCurveExtrapolation;
	/**
	 * Sorted array of keys
	*/
	Keys: RichCurveKey[];
	/**
	 * Default value
	*/
	DefaultValue: number;
	clone() : RichCurve;
	static C(Other: UObject): RichCurve;
}

declare class CurveFloat extends CurveBase { 
	/**
	 * Keyframe data
	*/
	FloatCurve: RichCurve;
	/**
	 * Flag to represent event curve
	*/
	bIsEventCurve: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveFloat;
	static Find(Outer: UObject, ResourceName: string): CurveFloat;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveFloat;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveFloat;
	/**
	 * Evaluate this float curve at the specified time
	*/
	GetFloatValue(InTime: number): number;
	static C(Other: UObject): CurveFloat;
}

declare class TTEventTrack extends TTTrackBase { 
	/**
	 * Curve object used to store keys
	*/
	CurveKeys: CurveFloat;
	clone() : TTEventTrack;
	static C(Other: UObject): TTEventTrack;
}

declare class TTFloatTrack extends TTTrackBase { 
	/**
	 * Curve object used to define float value over time
	*/
	CurveFloat: CurveFloat;
	clone() : TTFloatTrack;
	static C(Other: UObject): TTFloatTrack;
}

declare class CurveVector extends CurveBase { 
	/**
	 * Keyframe data, one curve for X, Y and Z
	*/
	FloatCurves: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveVector;
	static Find(Outer: UObject, ResourceName: string): CurveVector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveVector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveVector;
	/**
	 * Evaluate this float curve at the specified time
	*/
	GetVectorValue(InTime: number): Vector;
	static C(Other: UObject): CurveVector;
}

declare class TTVectorTrack extends TTTrackBase { 
	/**
	 * Curve object used to define vector value over time
	*/
	CurveVector: CurveVector;
	clone() : TTVectorTrack;
	static C(Other: UObject): TTVectorTrack;
}

declare class CurveLinearColor extends CurveBase { 
	/**
	 * Keyframe data, one curve for red, green, blue, and alpha
	*/
	FloatCurves: RichCurve;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CurveLinearColor;
	static Find(Outer: UObject, ResourceName: string): CurveLinearColor;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CurveLinearColor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CurveLinearColor;
	/**
	 * Get Linear Color Value
	*/
	GetLinearColorValue(InTime: number): LinearColor;
	static C(Other: UObject): CurveLinearColor;
}

declare class TTLinearColorTrack extends TTTrackBase { 
	/**
	 * Curve object used to define color value over time
	*/
	CurveLinearColor: CurveLinearColor;
	clone() : TTLinearColorTrack;
	static C(Other: UObject): TTLinearColorTrack;
}

declare class TimelineTemplate extends UObject { 
	/**
	 * Length of this timeline
	*/
	TimelineLength: number;
	/**
	 * How we want the timeline to determine its own length (e.g. specified length, last keyframe)
	*/
	LengthMode: ETimelineLengthMode;
	/**
	 * If we want the timeline to auto-play
	*/
	bAutoPlay: boolean;
	/**
	 * If we want the timeline to loop
	*/
	bLoop: boolean;
	/**
	 * If we want the timeline to loop
	*/
	bReplicated: boolean;
	/**
	 * Compiler Validated As Wired up
	*/
	bValidatedAsWired: boolean;
	/**
	 * Set of event tracks
	*/
	EventTracks: TTEventTrack[];
	/**
	 * Set of float interpolation tracks
	*/
	FloatTracks: TTFloatTrack[];
	/**
	 * Set of vector interpolation tracks
	*/
	VectorTracks: TTVectorTrack[];
	/**
	 * Set of linear color interpolation tracks
	*/
	LinearColorTracks: TTLinearColorTrack[];
	/**
	 * Metadata information for this timeline
	*/
	MetaDataArray: BPVariableMetaDataEntry[];
	/**
	 * Timeline Guid
	*/
	TimelineGuid: Guid;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TimelineTemplate;
	static Find(Outer: UObject, ResourceName: string): TimelineTemplate;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TimelineTemplate;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TimelineTemplate;
	static C(Other: UObject): TimelineTemplate;
}

declare class ComponentKey { 
	/**
	 * Owner Class
	*/
	OwnerClass: UnrealEngineClass;
	/**
	 * SCSVariable Name
	*/
	SCSVariableName: string;
	/**
	 * Associated Guid
	*/
	AssociatedGuid: Guid;
	clone() : ComponentKey;
	static C(Other: UObject): ComponentKey;
}

declare class ComponentOverrideRecord { 
	/**
	 * Component Template
	*/
	ComponentTemplate: ActorComponent;
	/**
	 * Component Key
	*/
	ComponentKey: ComponentKey;
	/**
	 * Cooked Component Instancing Data
	*/
	CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
	clone() : ComponentOverrideRecord;
	static C(Other: UObject): ComponentOverrideRecord;
}

declare class InheritableComponentHandler extends UObject { 
	/**
	 * Records
	*/
	Records: ComponentOverrideRecord[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InheritableComponentHandler;
	static Find(Outer: UObject, ResourceName: string): InheritableComponentHandler;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InheritableComponentHandler;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InheritableComponentHandler;
	static C(Other: UObject): InheritableComponentHandler;
}

declare type EBlueprintType = string | symbol;
declare var EBlueprintType = { BPTYPE_Normal:'BPTYPE_Normal',BPTYPE_Const:'BPTYPE_Const',BPTYPE_MacroLibrary:'BPTYPE_MacroLibrary',BPTYPE_Interface:'BPTYPE_Interface',BPTYPE_LevelScript:'BPTYPE_LevelScript',BPTYPE_FunctionLibrary:'BPTYPE_FunctionLibrary', };
declare type EBlueprintStatus = string | symbol;
declare var EBlueprintStatus = { BS_Unknown:'BS_Unknown',BS_Dirty:'BS_Dirty',BS_Error:'BS_Error',BS_UpToDate:'BS_UpToDate',BS_BeingCreated:'BS_BeingCreated',BS_UpToDateWithWarnings:'BS_UpToDateWithWarnings', };
declare class BPVariableDescription { 
	/**
	 * Name of the variable
	*/
	VarName: string;
	/**
	 * A Guid that will remain constant even if the VarName changes
	*/
	VarGuid: Guid;
	/**
	 * Type of the variable
	*/
	VarType: EdGraphPinType;
	/**
	 * Friendly name of the variable
	*/
	FriendlyName: string;
	/**
	 * Category this variable should be in
	*/
	Category: string;
	/**
	 * Property flags for this variable - Changed from int32 to uint64
	*/
	PropertyFlags: any;
	/**
	 * Rep Notify Func
	*/
	RepNotifyFunc: string;
	/**
	 * Metadata information for this variable
	*/
	MetaDataArray: BPVariableMetaDataEntry[];
	/**
	 * Optional new default value stored as string
	*/
	DefaultValue: string;
	clone() : BPVariableDescription;
	static C(Other: UObject): BPVariableDescription;
}

declare class Interface extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Interface;
	static Find(Outer: UObject, ResourceName: string): Interface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Interface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Interface;
	static C(Other: UObject): Interface;
}

declare class BPInterfaceDescription { 
	/**
	 * Reference to the interface class we're adding to this blueprint
	*/
	Interface: UnrealEngineClass;
	/**
	 * References to the graphs associated with the required functions for this interface
	*/
	Graphs: EdGraph[];
	clone() : BPInterfaceDescription;
	static C(Other: UObject): BPInterfaceDescription;
}

declare class EditedDocumentInfo { 
	/**
	 * Edited Object
	*/
	EditedObject: UObject;
	/**
	 * Saved view position
	*/
	SavedViewOffset: Vector2D;
	/**
	 * Saved zoom amount
	*/
	SavedZoomAmount: number;
	clone() : EditedDocumentInfo;
	static C(Other: UObject): EditedDocumentInfo;
}

declare class Breakpoint extends UObject { 
	/**
	 * Is the breakpoint currently enabled?
	*/
	bEnabled: boolean;
	/**
	 * Node that the breakpoint is placed on
	*/
	UNode: EdGraphNode;
	/**
	 * Is this breakpoint auto-generated, and should be removed when next hit?
	*/
	bStepOnce: boolean;
	/**
	 * Step Once Was Previously Disabled
	*/
	bStepOnce_WasPreviouslyDisabled: boolean;
	/**
	 * Step Once Remove After Hit
	*/
	bStepOnce_RemoveAfterHit: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Breakpoint;
	static Find(Outer: UObject, ResourceName: string): Breakpoint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Breakpoint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Breakpoint;
	static C(Other: UObject): Breakpoint;
}

declare class EdGraphPinReference { 
	/**
	 * The node that owns the pin referred to by this struct. Updated at Set and Save time.
	*/
	OwningNode: any;
	/**
	 * The pin's unique ID. Updated at Set and Save time.
	*/
	PinId: Guid;
	clone() : EdGraphPinReference;
	static C(Other: UObject): EdGraphPinReference;
}

declare class SaveGame extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SaveGame;
	static Find(Outer: UObject, ResourceName: string): SaveGame;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SaveGame;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SaveGame;
	static C(Other: UObject): SaveGame;
	/**
	 * Save the contents of the SaveGameObject to a slot.
	 * @param SaveGameObject   Object that contains data about the save game that we want to write out
	 * @param SlotName                 Name of save game slot to save to.
	 * @param UserIndex            For some platforms, master user index to identify the user doing the saving.
	 * @return                                 Whether we successfully saved this information
	*/
	SaveGameToSlot(SlotName: string,UserIndex: number): boolean;
	/**
	 * Save the contents of the SaveGameObject to a slot.
	 * @param SaveGameObject   Object that contains data about the save game that we want to write out
	 * @param SlotName                 Name of save game slot to save to.
	 * @param UserIndex            For some platforms, master user index to identify the user doing the saving.
	 * @return                                 Whether we successfully saved this information
	*/
	static SaveGameToSlot(SaveGameObject: SaveGame,SlotName: string,UserIndex: number): boolean;
}

declare class Blueprint extends BlueprintCore { 
	/**
	 * Whether or not this blueprint should recompile itself on load
	*/
	bRecompileOnLoad: boolean;
	/**
	 * Pointer to the parent class that the generated class should derive from. This *can* be null under rare circumstances,
	 * one such case can be created by creating a blueprint (A) based on another blueprint (B), shutting down the editor, and
	 * deleting the parent blueprint.
	*/
	ParentClass: UnrealEngineClass;
	/**
	 * PRIVATE Innermost Previous CDO
	*/
	PRIVATE_InnermostPreviousCDO: UObject;
	/**
	 * When the class generated by this blueprint is loaded, it will be recompiled the first time.  After that initial recompile, subsequent loads will skip the regeneration step
	*/
	bHasBeenRegenerated: boolean;
	/**
	 * State flag to indicate whether or not the Blueprint is currently being regenerated on load
	*/
	bIsRegeneratingOnLoad: boolean;
	/**
	 * Whether or not this blueprint is newly created, and hasn't been opened in an editor yet
	*/
	bIsNewlyCreated: boolean;
	/**
	 * Whether to force opening the full (non data-only) editor for this blueprint.
	*/
	bForceFullEditor: boolean;
	/**
	 * whether or not you want to continuously rerun the construction script for an actor as you drag it in the editor, or only when the drag operation is complete
	*/
	bRunConstructionScriptOnDrag: boolean;
	/**
	 * Whether or not this blueprint's class is a const class or not.  Should set CLASS_Const in the KismetCompiler.
	*/
	bGenerateConstClass: boolean;
	/**
	 * Whether or not this blueprint's class is a abstract class or not.  Should set CLASS_Abstract in the KismetCompiler.
	*/
	bGenerateAbstractClass: boolean;
	/**
	 * shows up in the content browser when the blueprint is hovered
	*/
	BlueprintDescription: string;
	/**
	 * The category of the Blueprint, used to organize this Blueprint class when displayed in palette windows
	*/
	BlueprintCategory: string;
	/**
	 * Additional HideCategories. These are added to HideCategories from parent.
	*/
	HideCategories: string[];
	/**
	 * TRUE to show a warning when attempting to start in PIE and there is a compiler error on this Blueprint
	*/
	bDisplayCompilePIEWarning: boolean;
	/**
	 * Guid key for finding searchable data for Blueprint in the DDC
	*/
	SearchGuid: Guid;
	/**
	 * Deprecates the Blueprint, marking the generated class with the CLASS_Deprecated flag
	*/
	bDeprecate: boolean;
	/**
	 * The mode that will be used when compiling this class.
	*/
	CompileMode: EBlueprintCompileMode;
	/**
	 * 'Simple' construction script - graph of components to instance
	*/
	SimpleConstructionScript: SimpleConstructionScript;
	/**
	 * Set of pages that combine into a single uber-graph
	*/
	UbergraphPages: EdGraph[];
	/**
	 * Set of functions implemented for this class graphically
	*/
	FunctionGraphs: EdGraph[];
	/**
	 * Graphs of signatures for delegates
	*/
	DelegateSignatureGraphs: EdGraph[];
	/**
	 * Set of macros implemented for this class
	*/
	MacroGraphs: EdGraph[];
	/**
	 * Set of functions actually compiled for this class
	*/
	IntermediateGeneratedGraphs: EdGraph[];
	/**
	 * Set of functions actually compiled for this class
	*/
	EventGraphs: EdGraph[];
	/**
	 * Flag indicating that a read only duplicate of this blueprint is being created, used to disable logic in ::PostDuplicate,
	 * This flag needs to be copied on duplication (because it's the duplicated object that we're disabling on PostDuplicate),
	 * but we don't *need* to serialize it for permanent objects.
	 * Without setting this flag a blueprint will be marked dirty when it is duplicated and if saved while in this dirty
	 * state you will not be able to open the blueprint. More specifically, UClass::Rename (called by DestroyGeneratedClass)
	 * sets a dirty flag on the package. Once saved the package will fail to open because some unnamed objects are present in
	 * the pacakge.
	 * This flag can be used to avoid the package being marked as dirty in the first place. Ideally PostDuplicateObject
	 * would not rename classes that are still in use by the original object.
	*/
	bDuplicatingReadOnly: boolean;
	/**
	 * Array of component template objects, used by AddComponent function
	*/
	ComponentTemplates: ActorComponent[];
	/**
	 * Array of templates for timelines that should be created
	*/
	Timelines: TimelineTemplate[];
	/**
	 * Stores data to override (in children classes) components (created by SCS) from parent classes
	*/
	InheritableComponentHandler: InheritableComponentHandler;
	/**
	 * The type of this blueprint
	*/
	BlueprintType: EBlueprintType;
	/**
	 * The current status of this blueprint
	*/
	Status: EBlueprintStatus;
	/**
	 * Array of new variables to be added to generated class
	*/
	NewVariables: BPVariableDescription[];
	/**
	 * Array of user sorted categories
	*/
	CategorySorting: string[];
	/**
	 * Array of info about the interfaces we implement in this blueprint
	*/
	ImplementedInterfaces: BPInterfaceDescription[];
	/**
	 * The version of the blueprint system that was used to  create this blueprint
	*/
	BlueprintSystemVersion: number;
	/**
	 * Set of documents that were being edited in this blueprint, so we can open them right away
	*/
	LastEditedDocuments: EditedDocumentInfo[];
	/**
	 * Persistent debugging options
	*/
	Breakpoints: Breakpoint[];
	/**
	 * Watched Pins
	*/
	WatchedPins: EdGraphPinReference[];
	/**
	 * Deprecated Pin Watches
	*/
	DeprecatedPinWatches: EdGraphPin_Deprecated[];
	/**
	 * Information for thumbnail rendering
	*/
	ThumbnailInfo: ThumbnailInfo;
	/**
	 * The blueprint is currently compiled
	*/
	bBeingCompiled: boolean;
	/**
	 * CRC for CDO calculated right after the latest compilation used by Reinstancer to check if default values were changed
	*/
	CrcLastCompiledCDO: any;
	/**
	 * Crc Last Compiled Signature
	*/
	CrcLastCompiledSignature: any;
	/**
	 * If this BP is just a duplicate created for a specific compilation, the reference to original GeneratedClass is needed
	*/
	OriginalClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Blueprint;
	static Find(Outer: UObject, ResourceName: string): Blueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Blueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Blueprint;
	static C(Other: UObject): Blueprint;
	/**
	 * Get Blueprint Generated Class
	*/
	GetBlueprintGeneratedClass(): UnrealEngineClass;
	/**
	 * Create a new, empty SaveGame object to set data on and then pass to SaveGameToSlot.
	 * @param  SaveGameBlueprint       Blueprint of SaveGame to create
	 * @return                                         New SaveGame object to write data to
	*/
	CreateSaveGameObjectFromBlueprint(): SaveGame;
	/**
	 * Get Blueprint Generated Class
	*/
	static GetBlueprintGeneratedClass(Blueprint: Blueprint): UnrealEngineClass;
	/**
	 * Create a new, empty SaveGame object to set data on and then pass to SaveGameToSlot.
	 * @param  SaveGameBlueprint       Blueprint of SaveGame to create
	 * @return                                         New SaveGame object to write data to
	*/
	static CreateSaveGameObjectFromBlueprint(SaveGameBlueprint: Blueprint): SaveGame;
}

declare class AnimGroupInfo { 
	/**
	 * Name
	*/
	Name: string;
	/**
	 * Color
	*/
	Color: LinearColor;
	clone() : AnimGroupInfo;
	static C(Other: UObject): AnimGroupInfo;
}

declare class AnimMetaData extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimMetaData;
	static Find(Outer: UObject, ResourceName: string): AnimMetaData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimMetaData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMetaData;
	static C(Other: UObject): AnimMetaData;
}

declare class SmartName { 
	/**
	 * name
	*/
	DisplayName: string;
	/**
	 * Guid
	*/
	Guid: Guid;
	clone() : SmartName;
	static C(Other: UObject): SmartName;
}

declare class PoseData { 
	/**
	 * local space pose, # of array match with # of Tracks
	*/
	LocalSpacePose: Transform[];
	/**
	 * whether or not, the joint contains dirty transform
	 * it only blends if this is true
	 * this allows per bone blend
	 * @todo: convert to bit field?
	*/
	LocalSpacePoseMask: boolean[];
	/**
	 * # of array match with # of Curves in PoseDataContainer
	*/
	CurveData: number[];
	clone() : PoseData;
	static C(Other: UObject): PoseData;
}

declare class AnimCurveBase { 
	/**
	 * Last observed name of the curve. We store this so we can recover from situations that
	 * mean the skeleton doesn't have a mapped name for our UID (such as a user saving the an
	 * animation but not the skeleton).
	*/
	LastObservedName: string;
	/**
	 * Name
	*/
	Name: SmartName;
	/**
	 * Curve Type Flags
	*/
	CurveTypeFlags: number;
	clone() : AnimCurveBase;
	static C(Other: UObject): AnimCurveBase;
}

declare class PoseDataContainer { 
	/**
	 * pose names - horizontal data
	 * # of poses - there is no compression across tracks -
	 * unfortunately, tried TMap, but it is not great because it changes order whenever add/remove
	 * we need consistent array of names, so that it doesn't change orders
	*/
	PoseNames: SmartName[];
	/**
	 * Poses
	*/
	Poses: PoseData[];
	/**
	 * Tracks
	*/
	Tracks: string[];
	/**
	 * vertical data - the track names for bone position, and skeleton index
	*/
	TrackMap: any;
	/**
	 * curve meta data # of Curve UIDs should match with Poses.CurveValues.Num
	*/
	Curves: AnimCurveBase[];
	clone() : PoseDataContainer;
	static C(Other: UObject): PoseDataContainer;
}

declare class AnimCompositeBase extends AnimSequenceBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimCompositeBase;
	static Find(Outer: UObject, ResourceName: string): AnimCompositeBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimCompositeBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompositeBase;
	static C(Other: UObject): AnimCompositeBase;
}

declare type EAlphaBlendOption = string | symbol;
declare var EAlphaBlendOption = { Linear:'Linear',Cubic:'Cubic',HermiteCubic:'HermiteCubic',Sinusoidal:'Sinusoidal',QuadraticInOut:'QuadraticInOut',CubicInOut:'CubicInOut',QuarticInOut:'QuarticInOut',QuinticInOut:'QuinticInOut',CircularIn:'CircularIn',CircularOut:'CircularOut',CircularInOut:'CircularInOut',ExpIn:'ExpIn',ExpOut:'ExpOut',ExpInOut:'ExpInOut',Custom:'Custom', };
declare class AlphaBlend { 
	/**
	 * Type of blending used (Linear, Cubic, etc.)
	*/
	BlendOption: EAlphaBlendOption;
	/**
	 * If you're using Custom BlendOption, you can specify curve
	*/
	CustomCurve: CurveFloat;
	/**
	 * Blend Time
	*/
	BlendTime: number;
	clone() : AlphaBlend;
	static C(Other: UObject): AlphaBlend;
}

declare class AnimSyncMarker { 
	/**
	 * The name of this marker
	*/
	MarkerName: string;
	/**
	 * Time in seconds of this marker
	*/
	Time: number;
	/**
	 * The editor track this marker sits on
	*/
	TrackIndex: number;
	clone() : AnimSyncMarker;
	static C(Other: UObject): AnimSyncMarker;
}

declare class MarkerSyncData { 
	/**
	 * Authored Sync markers
	*/
	AuthoredSyncMarkers: AnimSyncMarker[];
	clone() : MarkerSyncData;
	static C(Other: UObject): MarkerSyncData;
}

declare class CompositeSection extends AnimLinkableElement { 
	/**
	 * Section Name
	*/
	SectionName: string;
	/**
	 * Start Time *
	*/
	StartTime: number;
	/**
	 * Should this animation loop.
	*/
	NextSectionName: string;
	/**
	 * Meta data that can be saved with the asset
	 * You can query by GetMetaData function
	*/
	MetaData: AnimMetaData[];
	clone() : CompositeSection;
	static C(Other: UObject): CompositeSection;
}

declare class AnimSegment { 
	/**
	 * Anim Reference to play - only allow AnimSequence or AnimComposite *
	*/
	AnimReference: AnimSequenceBase;
	/**
	 * Start Pos within this AnimCompositeBase
	*/
	StartPos: number;
	/**
	 * Time to start playing AnimSequence at.
	*/
	AnimStartTime: number;
	/**
	 * Time to end playing the AnimSequence at.
	*/
	AnimEndTime: number;
	/**
	 * Playback speed of this animation. If you'd like to reverse, set -1
	*/
	AnimPlayRate: number;
	/**
	 * Looping Count
	*/
	LoopingCount: number;
	clone() : AnimSegment;
	static C(Other: UObject): AnimSegment;
}

declare class AnimTrack { 
	/**
	 * Anim Segments
	*/
	AnimSegments: AnimSegment[];
	clone() : AnimTrack;
	static C(Other: UObject): AnimTrack;
}

declare class SlotAnimationTrack { 
	/**
	 * Slot Name
	*/
	SlotName: string;
	/**
	 * Anim Track
	*/
	AnimTrack: AnimTrack;
	clone() : SlotAnimationTrack;
	static C(Other: UObject): SlotAnimationTrack;
}

declare class BranchingPoint extends AnimLinkableElement { 
	/**
	 * Event Name
	*/
	EventName: string;
	/**
	 * Display Time
	*/
	DisplayTime: number;
	/**
	 * An offset from the DisplayTime to the actual time we will trigger the notify, as we cannot always trigger it exactly at the time the user wants
	*/
	TriggerTimeOffset: number;
	clone() : BranchingPoint;
	static C(Other: UObject): BranchingPoint;
}

declare type ERootMotionRootLock = string | symbol;
declare var ERootMotionRootLock = { RefPose:'RefPose',AnimFirstFrame:'AnimFirstFrame',Zero:'Zero', };
declare type EAnimNotifyEventType = string | symbol;
declare var EAnimNotifyEventType = { Begin:'Begin',End:'End', };
declare class BranchingPointMarker { 
	/**
	 * Notify Index
	*/
	NotifyIndex: number;
	/**
	 * Trigger Time
	*/
	TriggerTime: number;
	/**
	 * Notify Event Type
	*/
	NotifyEventType: EAnimNotifyEventType;
	clone() : BranchingPointMarker;
	static C(Other: UObject): BranchingPointMarker;
}

declare class AnimMontage extends AnimCompositeBase { 
	/**
	 * Blend in option.
	*/
	BlendIn: AlphaBlend;
	/**
	 * Blend in Time
	*/
	BlendInTime: number;
	/**
	 * Blend out option. This is only used when it blends out itself. If it's interrupted by other montages, it will use new montage's BlendIn option to blend out.
	*/
	BlendOut: AlphaBlend;
	/**
	 * Blend Out Time
	*/
	BlendOutTime: number;
	/**
	 * Time from Sequence End to trigger blend out.
	 * <0 means using BlendOutTime, so BlendOut finishes as Montage ends.
	 * >=0 means using 'SequenceEnd - BlendOutTriggerTime' to trigger blend out.
	*/
	BlendOutTriggerTime: number;
	/**
	 * If you're using marker based sync for this montage, make sure to add sync group name. For now we only support one group
	*/
	SyncGroup: string;
	/**
	 * wip: until we have UI working
	*/
	SyncSlotIndex: number;
	/**
	 * Marker Data
	*/
	MarkerData: MarkerSyncData;
	/**
	 * composite section.
	*/
	CompositeSections: CompositeSection[];
	/**
	 * slot data, each slot contains anim track
	*/
	SlotAnimTracks: SlotAnimationTrack[];
	/**
	 * Remove this when VER_UE4_MONTAGE_BRANCHING_POINT_REMOVAL is removed.
	*/
	BranchingPoints: BranchingPoint[];
	/**
	 * If this is on, it will allow extracting root motion translation. DEPRECATED in 4.5 root motion is controlled by anim sequences *
	*/
	bEnableRootMotionTranslation: boolean;
	/**
	 * If this is on, it will allow extracting root motion rotation. DEPRECATED in 4.5 root motion is controlled by anim sequences *
	*/
	bEnableRootMotionRotation: boolean;
	/**
	 * Root Bone will be locked to that position when extracting root motion. DEPRECATED in 4.5 root motion is controlled by anim sequences *
	*/
	RootMotionRootLock: ERootMotionRootLock;
	/**
	 * Preview Base pose for additive BlendSpace *
	*/
	PreviewBasePose: AnimSequence;
	/**
	 * Cached list of Branching Point markers
	*/
	BranchingPointMarkers: BranchingPointMarker[];
	/**
	 * Keep track of which AnimNotify_State are marked as BranchingPoints, so we can update their state when the Montage is ticked
	*/
	BranchingPointStateNotifyIndices: number[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimMontage;
	static Find(Outer: UObject, ResourceName: string): AnimMontage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimMontage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimMontage;
	static C(Other: UObject): AnimMontage;
}

declare type EAnimLinkMethod = string | symbol;
declare var EAnimLinkMethod = { Absolute:'Absolute',Relative:'Relative',Proportional:'Proportional', };
declare class AnimLinkableElement { 
	/**
	 * The montage that this element is currently linked to
	*/
	LinkedMontage: AnimMontage;
	/**
	 * The slot index we are currently using within LinkedMontage
	*/
	SlotIndex: number;
	/**
	 * The index of the segment we are linked to within the slot we are using
	*/
	SegmentIndex: number;
	/**
	 * The method we are using to calculate our times
	*/
	LinkMethod: EAnimLinkMethod;
	/**
	 * Cached link method used to transform the time when LinkMethod changes, always relates to the currently stored time
	*/
	CachedLinkMethod: EAnimLinkMethod;
	/**
	 * The absolute time in the montage that our currently linked segment begins
	*/
	SegmentBeginTime: number;
	/**
	 * The absolute length of our currently linked segment
	*/
	SegmentLength: number;
	/**
	 * The time of this montage. This will differ depending upon the method we are using to link the time for this element
	*/
	LinkValue: number;
	/**
	 * The Animation Sequence that this montage element will link to, when the sequence changes
	 * in either length or rate; the element will correctly place itself in relation to the sequence
	*/
	LinkedSequence: AnimSequenceBase;
	clone() : AnimLinkableElement;
	static C(Other: UObject): AnimLinkableElement;
}

declare class AnimNotify extends UObject { 
	/**
	 * Color of Notify in editor
	*/
	NotifyColor: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimNotify;
	static Find(Outer: UObject, ResourceName: string): AnimNotify;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimNotify;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotify;
	/**
	 * Received Notify
	*/
	Received_Notify(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase): boolean;
	/**
	 * Implementable event to get a custom name for the notify
	*/
	GetNotifyName(): string;
	static C(Other: UObject): AnimNotify;
}

declare class AnimNotifyState extends UObject { 
	/**
	 * Color of Notify in editor
	*/
	NotifyColor: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimNotifyState;
	static Find(Outer: UObject, ResourceName: string): AnimNotifyState;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimNotifyState;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimNotifyState;
	/**
	 * Received Notify Tick
	*/
	Received_NotifyTick(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,FrameDeltaTime: number): boolean;
	/**
	 * Received Notify End
	*/
	Received_NotifyEnd(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase): boolean;
	/**
	 * Received Notify Begin
	*/
	Received_NotifyBegin(MeshComp: SkeletalMeshComponent,Animation: AnimSequenceBase,TotalDuration: number): boolean;
	/**
	 * Implementable event to get a custom name for the notify
	*/
	GetNotifyName(): string;
	static C(Other: UObject): AnimNotifyState;
}

declare type EMontageNotifyTickType = string | symbol;
declare var EMontageNotifyTickType = { Queued:'Queued',BranchingPoint:'BranchingPoint', };
declare type ENotifyFilterType = string | symbol;
declare var ENotifyFilterType = { NoFiltering:'NoFiltering',LOD:'LOD', };
declare class AnimNotifyEvent extends AnimLinkableElement { 
	/**
	 * The user requested time for this notify
	*/
	DisplayTime: number;
	/**
	 * An offset from the DisplayTime to the actual time we will trigger the notify, as we cannot always trigger it exactly at the time the user wants
	*/
	TriggerTimeOffset: number;
	/**
	 * An offset similar to TriggerTimeOffset but used for the end scrub handle of a notify state's duration
	*/
	EndTriggerTimeOffset: number;
	/**
	 * Trigger Weight Threshold
	*/
	TriggerWeightThreshold: number;
	/**
	 * Notify Name
	*/
	NotifyName: string;
	/**
	 * Notify
	*/
	Notify: AnimNotify;
	/**
	 * Notify State Class
	*/
	NotifyStateClass: AnimNotifyState;
	/**
	 * Duration
	*/
	Duration: number;
	/**
	 * Linkable element to use for the end handle representing a notify state duration
	*/
	EndLink: AnimLinkableElement;
	/**
	 * If TRUE, this notify has been converted from an old BranchingPoint.
	*/
	bConvertedFromBranchingPoint: boolean;
	/**
	 * Montage Tick Type
	*/
	MontageTickType: EMontageNotifyTickType;
	/**
	 * Defines the chance of of this notify triggering, 0 = No Chance, 1 = Always triggers
	*/
	NotifyTriggerChance: number;
	/**
	 * Defines a method for filtering notifies (stopping them triggering) e.g. by looking at the meshes current LOD
	*/
	NotifyFilterType: ENotifyFilterType;
	/**
	 * LOD to start filtering this notify from.
	*/
	NotifyFilterLOD: number;
	/**
	 * If disabled this notify will be skipped on dedicated servers
	*/
	bTriggerOnDedicatedServer: boolean;
	/**
	 * Color of Notify in editor
	*/
	NotifyColor: Color;
	/**
	 * 'Track' that the notify exists on, used for visual placement in editor and sorting priority in runtime
	*/
	TrackIndex: number;
	clone() : AnimNotifyEvent;
	static C(Other: UObject): AnimNotifyEvent;
}

declare class FloatCurve extends AnimCurveBase { 
	/**
	 * Curve data for float.
	*/
	FloatCurve: RichCurve;
	clone() : FloatCurve;
	static C(Other: UObject): FloatCurve;
}

declare class VectorCurve extends AnimCurveBase { 
	/**
	 * Curve data for float.
	*/
	FloatCurves: RichCurve;
	clone() : VectorCurve;
	static C(Other: UObject): VectorCurve;
}

declare class TransformCurve extends AnimCurveBase { 
	/**
	 * Curve data for each transform.
	*/
	TranslationCurve: VectorCurve;
	/**
	 * Rotation curve - right now we use euler because quat also doesn't provide linear interpolation - curve editor can't handle quat interpolation
	 * If you hit gimbal lock, you should add extra key to fix it. This will cause gimbal lock.
	 * @TODO: Eventually we'll need FRotationCurve that would contain rotation curve - that will interpolate as slerp or as quaternion
	*/
	RotationCurve: VectorCurve;
	/**
	 * Scale Curve
	*/
	ScaleCurve: VectorCurve;
	clone() : TransformCurve;
	static C(Other: UObject): TransformCurve;
}

declare class RawCurveTracks { 
	/**
	 * Float Curves
	*/
	FloatCurves: FloatCurve[];
	/**
	 * @note : Currently VectorCurves are not evaluated or used for anything else but transient data for modifying bone track
	 *                      Note that it doesn't have UPROPERTY tag yet. In the future, we'd like this to be serialized, but not for now
	*/
	VectorCurves: VectorCurve[];
	/**
	 * @note : TransformCurves are used to edit additive animation in editor.
	*/
	TransformCurves: TransformCurve[];
	clone() : RawCurveTracks;
	static C(Other: UObject): RawCurveTracks;
}

declare class AnimNotifyTrack { 
	/**
	 * Track Name
	*/
	TrackName: string;
	/**
	 * Track Color
	*/
	TrackColor: LinearColor;
	clone() : AnimNotifyTrack;
	static C(Other: UObject): AnimNotifyTrack;
}

declare class AnimSequenceBase extends AnimationAsset { 
	/**
	 * Animation notifies, sorted by time (earliest notification first).
	*/
	Notifies: AnimNotifyEvent[];
	/**
	 * Length (in seconds) of this AnimSequence if played back with a speed of 1.0.
	*/
	SequenceLength: number;
	/**
	 * Number for tweaking playback rate of this animation globally.
	*/
	RateScale: number;
	/**
	 * Raw uncompressed float curve data
	*/
	RawCurveData: RawCurveTracks;
	/**
	 * if you change Notifies array, this will need to be rebuilt
	*/
	AnimNotifyTracks: AnimNotifyTrack[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimSequenceBase;
	static Find(Outer: UObject, ResourceName: string): AnimSequenceBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimSequenceBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequenceBase;
	/**
	 * Returns the total play length of the montage, if played back with a speed of 1.0.
	*/
	GetPlayLength(): number;
	static C(Other: UObject): AnimSequenceBase;
}

declare class TrackToSkeletonMap { 
	/**
	 * Index of Skeleton.BoneTree this Track belongs to.
	*/
	BoneTreeIndex: number;
	clone() : TrackToSkeletonMap;
	static C(Other: UObject): TrackToSkeletonMap;
}

declare type AnimationCompressionFormat = string | symbol;
declare var AnimationCompressionFormat = { ACF_None:'ACF_None',ACF_Float96NoW:'ACF_Float96NoW',ACF_Fixed48NoW:'ACF_Fixed48NoW',ACF_IntervalFixed32NoW:'ACF_IntervalFixed32NoW',ACF_Fixed32NoW:'ACF_Fixed32NoW',ACF_Float32NoW:'ACF_Float32NoW',ACF_Identity:'ACF_Identity', };
declare class AnimCompress extends UObject { 
	/**
	 * Name of Compression Scheme used for this asset
	*/
	Description: string;
	/**
	 * Compression algorithms requiring a skeleton should set this value to true.
	*/
	bNeedsSkeleton: boolean;
	/**
	 * Format for bitwise compression of translation data.
	*/
	TranslationCompressionFormat: AnimationCompressionFormat;
	/**
	 * Format for bitwise compression of rotation data.
	*/
	RotationCompressionFormat: AnimationCompressionFormat;
	/**
	 * Format for bitwise compression of scale data.
	*/
	ScaleCompressionFormat: AnimationCompressionFormat;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimCompress;
	static Find(Outer: UObject, ResourceName: string): AnimCompress;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimCompress;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimCompress;
	static C(Other: UObject): AnimCompress;
}

declare type EAdditiveAnimationType = string | symbol;
declare var EAdditiveAnimationType = { AAT_None:'AAT_None',AAT_LocalSpaceBase:'AAT_LocalSpaceBase',AAT_RotationOffsetMeshSpace:'AAT_RotationOffsetMeshSpace', };
declare type EAdditiveBasePoseType = string | symbol;
declare var EAdditiveBasePoseType = { ABPT_None:'ABPT_None',ABPT_RefPose:'ABPT_RefPose',ABPT_AnimScaled:'ABPT_AnimScaled',ABPT_AnimFrame:'ABPT_AnimFrame', };
declare type EAnimInterpolationType = string | symbol;
declare var EAnimInterpolationType = { Linear:'Linear',Step:'Step', };
declare class AnimSequence extends AnimSequenceBase { 
	/**
	 * Number of raw frames in this sequence (not used by engine - just for informational purposes).
	*/
	NumFrames: number;
	/**
	 * In the future, maybe keeping RawAnimSequenceTrack + TrackMap as one would be good idea to avoid inconsistent array size
	 * TrackToSkeletonMapTable(i) should contains  track mapping data for RawAnimationData(i).
	*/
	TrackToSkeletonMapTable: TrackToSkeletonMap[];
	/**
	 * Update this if the contents of RawAnimationData changes;
	*/
	RawDataGuid: Guid;
	/**
	 * This is name of RawAnimationData tracks for editoronly - if we lose skeleton, we'll need relink them
	*/
	AnimationTrackNames: string[];
	/**
	 * The compression scheme that was most recently used to compress this animation.
	 * May be NULL.
	*/
	CompressionScheme: AnimCompress;
	/**
	 * Additive animation type. *
	*/
	AdditiveAnimType: EAdditiveAnimationType;
	/**
	 * Additive refrerence pose type. Refer above enum type
	*/
	RefPoseType: EAdditiveBasePoseType;
	/**
	 * Additive reference animation if it's relevant - i.e. AnimScaled or AnimFrame *
	*/
	RefPoseSeq: AnimSequence;
	/**
	 * Additve reference frame if RefPoseType == AnimFrame *
	*/
	RefFrameIndex: number;
	/**
	 * The version of the global encoding package used at the time of import
	*/
	EncodingPkgVersion: number;
	/**
	 * Base pose to use when retargeting
	*/
	RetargetSource: string;
	/**
	 * This defines how values between keys are calculated *
	*/
	Interpolation: EAnimInterpolationType;
	/**
	 * If this is on, it will allow extracting of root motion *
	*/
	bEnableRootMotion: boolean;
	/**
	 * Root Bone will be locked to that position when extracting root motion.*
	*/
	RootMotionRootLock: ERootMotionRootLock;
	/**
	 * Force Root Bone Lock even if Root Motion is not enabled
	*/
	bForceRootLock: boolean;
	/**
	 * Have we copied root motion settings from an owning montage
	*/
	bRootMotionSettingsCopiedFromMontage: boolean;
	/**
	 * Saved version number with CompressAnimations commandlet. To help with doing it in multiple passes.
	*/
	CompressCommandletVersion: number;
	/**
	 * Do not attempt to override compression scheme when running CompressAnimations commandlet.
	 * Some high frequency animations are too sensitive and shouldn't be changed.
	*/
	bDoNotOverrideCompression: boolean;
	/**
	 * Used to track whether, or not, this sequence was compressed with it's full translation tracks
	*/
	bWasCompressedWithoutTranslations: boolean;
	/**
	 * Importing data and options used for this mesh
	*/
	AssetImportData: AssetImportData;
	/**
	 * Path to the resource used to construct this skeletal mesh
	*/
	SourceFilePath: string;
	/**
	 * Date/Time-stamp of the file from the last import
	*/
	SourceFileTimestamp: string;
	/**
	 * Needs Rebake
	*/
	bNeedsRebake: boolean;
	/**
	 * Authored Sync markers
	*/
	AuthoredSyncMarkers: AnimSyncMarker[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimSequence;
	static Find(Outer: UObject, ResourceName: string): AnimSequence;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimSequence;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimSequence;
	static C(Other: UObject): AnimSequence;
}

declare class PoseAsset extends AnimationAsset { 
	/**
	 * Animation Pose Data
	*/
	PoseContainer: PoseDataContainer;
	/**
	 * Whether or not Additive Pose or not - these are property that needs post process, so
	*/
	bAdditivePose: boolean;
	/**
	 * if -1, use ref pose
	*/
	BasePoseIndex: number;
	/**
	 * Base pose to use when retargeting
	*/
	RetargetSource: string;
	/**
	 * Source Animation
	*/
	SourceAnimation: AnimSequence;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PoseAsset;
	static Find(Outer: UObject, ResourceName: string): PoseAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PoseAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseAsset;
	static C(Other: UObject): PoseAsset;
}

declare class AnimationAsset extends UObject { 
	/**
	 * Pointer to the Skeleton this asset can be played on .
	*/
	Skeleton: Skeleton;
	/**
	 * Meta data that can be saved with the asset
	 * You can query by GetMetaData function
	*/
	MetaData: AnimMetaData[];
	/**
	 * Array of user data stored with the asset
	*/
	AssetUserData: AssetUserData[];
	/**
	 * Information for thumbnail rendering
	*/
	ThumbnailInfo: ThumbnailInfo;
	/**
	 * The default skeletal mesh to use when previewing this asset - this only applies when you open Persona using this asset// @todo: note that this doesn't retarget right now
	*/
	PreviewPoseAsset: PoseAsset;
	/**
	 * The default skeletal mesh to use when previewing this asset - this only applies when you open Persona using this asset
	*/
	PreviewSkeletalMesh: any;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimationAsset;
	static Find(Outer: UObject, ResourceName: string): AnimationAsset;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimationAsset;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimationAsset;
	static C(Other: UObject): AnimationAsset;
}

declare class AnimParentNodeAssetOverride { 
	/**
	 * New Asset
	*/
	NewAsset: AnimationAsset;
	/**
	 * Parent Node Guid
	*/
	ParentNodeGuid: Guid;
	clone() : AnimParentNodeAssetOverride;
	static C(Other: UObject): AnimParentNodeAssetOverride;
}

declare class PoseWatch extends UObject { 
	/**
	 * Node that we are trying to watch
	*/
	UNode: EdGraphNode;
	/**
	 * Pose Watch Colour
	*/
	PoseWatchColour: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PoseWatch;
	static Find(Outer: UObject, ResourceName: string): PoseWatch;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PoseWatch;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PoseWatch;
	static C(Other: UObject): PoseWatch;
}

declare class AnimBlueprint extends Blueprint { 
	/**
	 * The kind of skeleton that animation graphs compiled from the blueprint will animate
	*/
	TargetSkeleton: Skeleton;
	/**
	 * List of animation sync groups
	*/
	Groups: AnimGroupInfo[];
	/**
	 * Array of overrides to asset containing nodes in the parent that have been overridden
	*/
	ParentAssetOverrides: AnimParentNodeAssetOverride[];
	/**
	 * Array of active pose watches (pose watch allows us to see the bone pose at a
	 * particular point of the anim graph)
	*/
	PoseWatches: PoseWatch[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimBlueprint;
	static Find(Outer: UObject, ResourceName: string): AnimBlueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimBlueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimBlueprint;
	static C(Other: UObject): AnimBlueprint;
}

declare type ERootMotionMode = string | symbol;
declare var ERootMotionMode = { NoRootMotionExtraction:'NoRootMotionExtraction',IgnoreRootMotion:'IgnoreRootMotion',RootMotionFromEverything:'RootMotionFromEverything',RootMotionFromMontagesOnly:'RootMotionFromMontagesOnly', };
declare type EMontagePlayReturnType = string | symbol;
declare var EMontagePlayReturnType = { MontageLength:'MontageLength',Duration:'Duration', };
declare class MarkerSyncAnimPosition { 
	/**
	 * The marker we have passed
	*/
	PreviousMarkerName: string;
	/**
	 * The marker we are heading towards
	*/
	NextMarkerName: string;
	/**
	 * Value between 0 and 1 representing where we are:
	 *       0   we are at PreviousMarker
	 *       1   we are at NextMarker
	 *       0.5 we are half way between the two
	*/
	PositionBetweenMarkers: number;
	clone() : MarkerSyncAnimPosition;
	static C(Other: UObject): MarkerSyncAnimPosition;
}

declare class AnimInstance extends UObject { 
	/**
	 * DeltaTime *
	*/
	DeltaTime: number;
	/**
	 * This is used to extract animation. If Mesh exists, this will be overwritten by Mesh->Skeleton
	*/
	CurrentSkeleton: Skeleton;
	/**
	 * Sets where this blueprint pulls Root Motion from
	*/
	RootMotionMode: ERootMotionMode;
	/**
	 * Allows this anim instance to update its native update, blend tree, montages and asset players on
	 * a worker thread. this requires certain conditions to be met:
	 * - All access of variables in the blend tree should be a direct access of a member variable
	 * - No BlueprintUpdateAnimation event should be used (i.e. the event graph should be empty). Only native update is permitted.
	*/
	bRunUpdatesInWorkerThreads: boolean;
	/**
	 * Whether we can use parallel updates for our animations.
	 * Conditions affecting this include:
	 * - Use of BlueprintUpdateAnimation
	 * - Use of non 'fast-path' EvaluateGraphExposedInputs in the node graph
	*/
	bCanUseParallelUpdateAnimation: boolean;
	/**
	 * Selecting this option will cause the compiler to emit warnings whenever a call into Blueprint
	 * is made from the animation graph. This can help track down optimizations that need to be made.
	*/
	bWarnAboutBlueprintUsage: boolean;
	/**
	 * Called when a montage starts blending out, whether interrupted or finished
	*/
	OnMontageBlendingOut: UnrealEngineMulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
	/**
	 * Called when a montage has started
	*/
	OnMontageStarted: UnrealEngineMulticastDelegate<(Montage: AnimMontage) => void>;
	/**
	 * Called when a montage has ended, whether interrupted or finished
	*/
	OnMontageEnded: UnrealEngineMulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
	/**
	 * True when Montages are being ticked, and Montage Events should be queued.
	 * When Montage are being ticked, we queue AnimNotifies and Events. We trigger notifies first, then Montage events.
	*/
	bQueueMontageEvents: boolean;
	/**
	 * Currently Active AnimNotifyState, stored as a copy of the event as we need to
	 *               call NotifyEnd on the event after a deletion in the editor. After this the event
	 *               is removed correctly.
	*/
	ActiveAnimNotifyState: AnimNotifyEvent[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AnimInstance;
	static Find(Outer: UObject, ResourceName: string): AnimInstance;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AnimInstance;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AnimInstance;
	/**
	 * unlocks indicated AI resources of animated pawn. Will unlock only animation-locked resources.
	 *     DEPRECATED. Use UnlockAIResourcesWithAnimation instead
	*/
	UnlockAIResources(bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	/**
	 * kismet event functions
	*/
	TryGetPawnOwner(): Pawn;
	/**
	 * Stops currently playing slot animation slot or all
	*/
	StopSlotAnimation(InBlendOutTime: number,SlotNodeName: string): void;
	/**
	 * Set RootMotionMode
	*/
	SetRootMotionMode(Value: ERootMotionMode): void;
	/**
	 * Sets a morph target to a certain weight.
	*/
	SetMorphTarget(MorphTargetName: string,Value: number): void;
	/**
	 * Play normal animation asset on the slot node by creating a dynamic UAnimMontage. You can only play one asset (whether montage or animsequence) at a time per SlotGroup.
	*/
	PlaySlotAnimationAsDynamicMontage(Asset: AnimSequenceBase,SlotNodeName: string,BlendInTime: number,BlendOutTime: number,InPlayRate: number,LoopCount: number,BlendOutTriggerTime: number): AnimMontage;
	/**
	 * Play Slot Animation
	*/
	PlaySlotAnimation(Asset: AnimSequenceBase,SlotNodeName: string,BlendInTime: number,BlendOutTime: number,InPlayRate: number,LoopCount: number): number;
	/**
	 * Stops the animation montage. If reference is NULL, it will stop ALL active montages.
	*/
	Montage_Stop(InBlendOutTime: number,Montage: AnimMontage): void;
	/**
	 * Change AnimMontage play rate. NewPlayRate = 1.0 is the default playback rate.
	*/
	Montage_SetPlayRate(Montage: AnimMontage,NewPlayRate: number): void;
	/**
	 * Relink new next section AFTER SectionNameToChange in run-time
	 *     You can link section order the way you like in editor, but in run-time if you'd like to change it dynamically,
	 *     use this function to relink the next section
	 *     For example, you can have Start->Loop->Loop->Loop.... but when you want it to end, you can relink
	 *     next section of Loop to be End to finish the montage, in which case, it stops looping by Loop->End.
	 * @param SectionNameToChange : This should be the name of the Montage Section after which you want to insert a new next section
	 * @param NextSection   : new next section
	*/
	Montage_SetNextSection(SectionNameToChange: string,NextSection: string,Montage: AnimMontage): void;
	/**
	 * Resumes a paused animation montage. If reference is NULL, it will resume ALL active montages.
	*/
	Montage_Resume(Montage: AnimMontage): void;
	/**
	 * Plays an animation montage. Returns the length of the animation montage in seconds. Returns 0.f if failed to play.
	*/
	Montage_Play(MontageToPlay: AnimMontage,InPlayRate: number,ReturnValueType: EMontagePlayReturnType): number;
	/**
	 * Pauses the animation montage. If reference is NULL, it will pause ALL active montages.
	*/
	Montage_Pause(Montage: AnimMontage): void;
	/**
	 * Makes a montage jump to the end of a named section. If Montage reference is NULL, it will do that to all active montages.
	*/
	Montage_JumpToSectionsEnd(SectionName: string,Montage: AnimMontage): void;
	/**
	 * Makes a montage jump to a named section. If Montage reference is NULL, it will do that to all active montages.
	*/
	Montage_JumpToSection(SectionName: string,Montage: AnimMontage): void;
	/**
	 * Returns true if the animation montage is currently active and playing.
	 *       If reference is NULL, it will return true is ANY montage is currently active and playing.
	*/
	Montage_IsPlaying(Montage: AnimMontage): boolean;
	/**
	 * Returns true if the animation montage is active. If the Montage reference is NULL, it will return true if any Montage is active.
	*/
	Montage_IsActive(Montage: AnimMontage): boolean;
	/**
	 * Returns the name of the current animation montage section.
	*/
	Montage_GetCurrentSection(Montage: AnimMontage): string;
	/**
	 * locks indicated AI resources of animated pawn
	 *     DEPRECATED. Use LockAIResourcesWithAnimation instead
	*/
	LockAIResources(bLockMovement: boolean,LockAILogic: boolean): void;
	/**
	 * Is Sync Group Between Markers
	*/
	IsSyncGroupBetweenMarkers(InSyncGroupName: string,PreviousMarker: string,NextMarker: string,bRespectMarkerOrder: boolean): boolean;
	/**
	 * Return true if it's playing the slot animation
	*/
	IsPlayingSlotAnimation(Asset: AnimSequenceBase,SlotNodeName: string): boolean;
	/**
	 * Has Marker Been Hit This Frame
	*/
	HasMarkerBeenHitThisFrame(SyncGroup: string,MarkerName: string): boolean;
	/**
	 * --- AI communication end ---
	*/
	GetTimeToClosestMarker(SyncGroup: string,MarkerName: string,OutMarkerTime?: number): {OutMarkerTime: number, $: boolean};
	/**
	 * Get Sync Group Position
	*/
	GetSyncGroupPosition(InSyncGroupName: string): MarkerSyncAnimPosition;
	/**
	 * Get State Weight
	*/
	GetStateWeight(MachineIndex: number,StateIndex: number): number;
	/**
	 * Get the time remaining as a fraction of the duration for the most relevant animation in the source state
	*/
	GetRelevantAnimTimeRemainingFraction(MachineIndex: number,StateIndex: number): number;
	/**
	 * Get the time remaining in seconds for the most relevant animation in the source state
	*/
	GetRelevantAnimTimeRemaining(MachineIndex: number,StateIndex: number): number;
	/**
	 * Get the current accumulated time as a fraction of the length of the most relevant animation in the source state
	*/
	GetRelevantAnimTimeFraction(MachineIndex: number,StateIndex: number): number;
	/**
	 * Get the current accumulated time in seconds for the most relevant animation in the source state
	*/
	GetRelevantAnimTime(MachineIndex: number,StateIndex: number): number;
	/**
	 * Get the length in seconds of the most relevant animation in the source state
	*/
	GetRelevantAnimLength(MachineIndex: number,StateIndex: number): number;
	/**
	 * Returns the skeletal mesh component that has created this AnimInstance
	*/
	GetOwningComponent(): SkeletalMeshComponent;
	/**
	 * Returns the owning actor of this AnimInstance
	*/
	GetOwningActor(): Actor;
	/**
	 * Get the elapsed time as a fraction of the crossfade duration of a specified transition
	*/
	GetTransitionTimeElapsed(MachineIndex: number,TransitionIndex: number): number;
	/**
	 * Get the elapsed time in seconds of a specified transition
	*/
	GetTransitionTimeElapsed(MachineIndex: number,TransitionIndex: number): number;
	/**
	 * Get the crossfade duration of a specified transition
	*/
	GetTransitionCrossfadeDuration(MachineIndex: number,TransitionIndex: number): number;
	/**
	 * Get the blend weight of a specified state
	*/
	StateWeight(MachineIndex: number,StateIndex: number): number;
	/**
	 * Get the blend weight of a specified state machine
	*/
	MachineWeight(MachineIndex: number): number;
	/**
	 * Get the current elapsed time of a state within the specified state machine
	*/
	CurrentStateTime(MachineIndex: number): number;
	/**
	 * Get the time as a fraction of the asset length of an animation in an asset player node
	*/
	TimeRemaining(AssetPlayerIndex: number): number;
	/**
	 * Get the time in seconds from the end of an animation in an asset player node
	*/
	TimeRemaining(AssetPlayerIndex: number): number;
	/**
	 * Get the current accumulated time as a fraction for an asset player node
	*/
	CurrentTime(AssetPlayerIndex: number): number;
	/**
	 * Get the current accumulated time in seconds for an asset player node
	*/
	CurrentTime(AssetPlayerIndex: number): number;
	/**
	 * Gets the length in seconds of the asset referenced in an asset player node
	*/
	Length(AssetPlayerIndex: number): number;
	/**
	 * Returns the value of a named curve.
	*/
	GetCurveValue(CurveName: string): number;
	/**
	 * Returns the name of a currently active state in a state machine.
	*/
	GetCurrentStateName(MachineIndex: number): string;
	/**
	 * Get Current State Elapsed Time
	*/
	GetCurrentStateElapsedTime(MachineIndex: number): number;
	/**
	 * Get Anim Asset Player Time from End Fraction
	*/
	static GetAnimAssetPlayerTimeFromEndFraction(AnimAsset: AnimationAsset,CurrentTime: number): number;
	/**
	 * Get Anim Asset Player Time from End
	*/
	GetAnimAssetPlayerTimeFromEnd(AnimAsset: AnimationAsset,CurrentTime: number): number;
	/**
	 * Get Anim Asset Player Time Fraction
	*/
	static GetAnimAssetPlayerTimeFraction(AnimAsset: AnimationAsset,CurrentTime: number): number;
	/**
	 * Get Anim Asset Player Length
	*/
	static GetAnimAssetPlayerLength(AnimAsset: AnimationAsset): number;
	/**
	 * Clears the current morph targets.
	*/
	ClearMorphTargets(): void;
	/**
	 * Returns degree of the angle betwee velocity and Rotation forward vector
	 * The range of return will be from [-180, 180], and this can be used to feed blendspace directional value
	*/
	CalculateDirection(Velocity: Vector,BaseRotation: Rotator): number;
	/**
	 * Executed when the Animation is updated
	*/
	BlueprintUpdateAnimation(DeltaTimeX: number): void;
	/**
	 * Executed after the Animation is evaluated
	*/
	BlueprintPostEvaluateAnimation(): void;
	/**
	 * Executed when the Animation is initialized
	*/
	BlueprintInitializeAnimation(): void;
	static C(Other: UObject): AnimInstance;
	/**
	 * locks indicated AI resources of animated pawn
	*/
	LockAIResourcesWithAnimation(bLockMovement: boolean,LockAILogic: boolean): void;
	/**
	 * unlocks indicated AI resources of animated pawn. Will unlock only animation-locked resources
	*/
	UnlockAIResourcesWithAnimation(bUnlockMovement: boolean,UnlockAILogic: boolean): void;
	/**
	 * locks indicated AI resources of animated pawn
	*/
	static LockAIResourcesWithAnimation(AnimInstance: AnimInstance,bLockMovement: boolean,LockAILogic: boolean): void;
	/**
	 * unlocks indicated AI resources of animated pawn. Will unlock only animation-locked resources
	*/
	static UnlockAIResourcesWithAnimation(AnimInstance: AnimInstance,bUnlockMovement: boolean,UnlockAILogic: boolean): void;
}

declare class SingleAnimationPlayData { 
	/**
	 * @todo in the future, we should make this one UObject
	 * and have detail customization to display different things
	 * The default sequence to play on this skeletal mesh
	*/
	AnimToPlay: AnimationAsset;
	/**
	 * Default setting for looping for SequenceToPlay. This is not current state of looping.
	*/
	bSavedLooping: boolean;
	/**
	 * Default setting for playing for SequenceToPlay. This is not current state of playing.
	*/
	bSavedPlaying: boolean;
	/**
	 * Default setting for position of SequenceToPlay to play.
	*/
	SavedPosition: number;
	/**
	 * Default setting for play rate of SequenceToPlay to play.
	*/
	SavedPlayRate: number;
	clone() : SingleAnimationPlayData;
	static C(Other: UObject): SingleAnimationPlayData;
}

declare type EKinematicBonesUpdateToPhysics = string | symbol;
declare var EKinematicBonesUpdateToPhysics = { SkipSimulatingBones:'SkipSimulatingBones',SkipAllBones:'SkipAllBones', };
declare type EPhysicsTransformUpdateMode = string | symbol;
declare var EPhysicsTransformUpdateMode = { SimulationUpatesComponentTransform:'SimulationUpatesComponentTransform',ComponentTransformIsKinematic:'ComponentTransformIsKinematic', };
declare class SkeletalMeshComponent extends SkinnedMeshComponent { 
	/**
	 * Whether to use Animation Blueprint or play Single Animation Asset.
	*/
	AnimationMode: EAnimationMode;
	/**
	 * The blueprint for creating an AnimationScript.
	*/
	AnimationBlueprint: AnimBlueprint;
	/**
	 * Anim Blueprint Generated Class
	*/
	AnimBlueprintGeneratedClass: UnrealEngineClass;
	/**
	 * The AnimBlueprint class to use. Use 'SetAnimInstanceClass' to change at runtime.
	*/
	AnimClass: UnrealEngineClass;
	/**
	 * The active animation graph program instance.
	*/
	AnimScriptInstance: AnimInstance;
	/**
	 * Any running sub anim instances that need to be updates on the game thread
	*/
	SubInstances: AnimInstance[];
	/**
	 * Animation Data
	*/
	AnimationData: SingleAnimationPlayData;
	/**
	 * Cached BoneSpaceTransforms for Update Rate optimization.
	*/
	CachedBoneSpaceTransforms: Transform[];
	/**
	 * Cached SpaceBases for Update Rate optimization.
	*/
	CachedComponentSpaceTransforms: Transform[];
	/**
	 * Used to scale speed of all animations on this skeletal mesh.
	*/
	GlobalAnimRateScale: number;
	/**
	 * If true, there is at least one body in the current PhysicsAsset with a valid bone in the current SkeletalMesh
	*/
	bHasValidBodies: boolean;
	/**
	 * If we are running physics, should we update non-simulated bones based on the animation bone positions.
	*/
	KinematicBonesUpdateType: EKinematicBonesUpdateToPhysics;
	/**
	 * Whether physics simulation updates component transform.
	*/
	PhysicsTransformUpdateMode: EPhysicsTransformUpdateMode;
	/**
	 * Enables blending in of physics bodies whether Simulate or not
	*/
	bBlendPhysics: boolean;
	/**
	 * If true, simulate physics for this component on a dedicated server.
	 * This should be set if simulating physics and replicating with a dedicated server.
	 *     Note: This property cannot be changed at runtime.
	*/
	bEnablePhysicsOnDedicatedServer: boolean;
	/**
	 * If we should pass joint position to joints each frame, so that they can be used by motorized joints to drive the
	 * ragdoll based on the animation.
	*/
	bUpdateJointsFromAnimation: boolean;
	/**
	 * Disable cloth simulation and play original animation without simulation
	*/
	bDisableClothSimulation: boolean;
	/**
	 * can't collide with part of environment if total collision volumes exceed 16 capsules or 32 planes per convex
	*/
	bCollideWithEnvironment: boolean;
	/**
	 * can't collide with part of attached children if total collision volumes exceed 16 capsules or 32 planes per convex
	*/
	bCollideWithAttachedChildren: boolean;
	/**
	 * It's worth trying this option when you feel that the current cloth simulation is unstable.
	 * The scale of the actor is maintained during the simulation.
	 * It is possible to add the inertia effects to the simulation, through the inertiaScale parameter of the clothing material.
	 * So with an inertiaScale of 1.0 there should be no visible difference between local space and global space simulation.
	 * Known issues: - Currently there's simulation issues when this feature is used in 3.x (DE4076) So if localSpaceSim is enabled there's no inertia effect when the global pose of the clothing actor changes.
	*/
	bLocalSpaceSimulation: boolean;
	/**
	 * cloth morph target option
	 * This option will be applied only before playing because should do pre-calculation to reduce computation time for run-time play
	 * so it's impossible to change this option in run-time
	*/
	bClothMorphTarget: boolean;
	/**
	 * reset the clothing after moving the clothing position (called teleport)
	*/
	bResetAfterTeleport: boolean;
	/**
	 * conduct teleportation if the character's movement is greater than this threshold in 1 frame.
	 * Zero or negative values will skip the check
	 * you can also do force teleport manually using ForceNextUpdateTeleport() / ForceNextUpdateTeleportAndReset()
	*/
	TeleportDistanceThreshold: number;
	/**
	 * rotation threshold in degree, ranging from 0 to 180
	 * conduct teleportation if the character's rotation is greater than this threshold in 1 frame.
	 * Zero or negative values will skip the check
	*/
	TeleportRotationThreshold: number;
	/**
	 * weight to blend between simulated results and key-framed positions
	 * if weight is 1.0, shows only cloth simulation results and 0.0 will show only skinned results
	*/
	ClothBlendWeight: number;
	/**
	 * Offset of the root bone from the reference pose. Used to offset bounding box.
	*/
	RootBoneTranslation: Vector;
	/**
	 * Skips Ticking and Bone Refresh.
	*/
	bNoSkeletonUpdate: boolean;
	/**
	 * pauses this component's animations (doesn't tick them, but still refreshes bones)
	*/
	bPauseAnims: boolean;
	/**
	 * On InitAnim should we set to ref pose (if false use first tick of animation data)
	*/
	bUseRefPoseOnInitAnim: boolean;
	/**
	 * Uses skinned data for collision data.
	*/
	bEnablePerPolyCollision: boolean;
	/**
	 * Used for per poly collision. In 99% of cases you will be better off using a Physics Asset.
	 * This BodySetup is per instance because all modification of vertices is done in place
	*/
	BodySetup: BodySetup;
	/**
	 * If true TickPose() will not be called from the Component's TickComponent function.
	 * It will instead be called from Autonomous networking updates. See ACharacter.
	*/
	bAutonomousTickPose: boolean;
	/**
	 * If true, force the mesh into the reference pose - is an optimization.
	*/
	bForceRefpose: boolean;
	/**
	 * If bForceRefPose was set last tick.
	*/
	bOldForceRefPose: boolean;
	/**
	 * Bool that enables debug drawing of the skeleton before it is passed to the physics. Useful for debugging animation-driven physics.
	*/
	bShowPrePhysBones: boolean;
	/**
	 * If false, indicates that on the next call to UpdateSkelPose the RequiredBones array should be recalculated.
	*/
	bRequiredBonesUpToDate: boolean;
	/**
	 * If true, AnimTree has been initialised.
	*/
	bAnimTreeInitialised: boolean;
	/**
	 * If true, the Location of this Component will be included into its bounds calculation
	 * (this can be useful when using SMU_OnlyTickPoseWhenRendered on a character that moves away from the root and no bones are left near the origin of the component)
	*/
	bIncludeComponentLocationIntoBounds: boolean;
	/**
	 * If true, line checks will test against the bounding box of this skeletal mesh component and return a hit if there is a collision.
	*/
	bEnableLineCheckWithBounds: boolean;
	/**
	 * If bEnableLineCheckWithBounds is true, scale the bounds by this value before doing line check.
	*/
	LineCheckBoundsScale: Vector;
	/**
	 * Threshold for physics asset bodies above which we use an aggregate for broadphase collisions
	*/
	RagdollAggregateThreshold: number;
	/**
	 * Notification when constraint is broken.
	*/
	OnConstraintBroken: UnrealEngineMulticastDelegate<(ConstraintIndex: number) => void>;
	/**
	 * these are deprecated variables from removing SingleAnimSkeletalComponent
	 * remove if this version goes away : VER_UE4_REMOVE_SINGLENODEINSTANCE
	 * deprecated variable to be re-save
	*/
	SequenceToPlay: AnimSequence;
	/**
	 * The default sequence to play on this skeletal mesh
	*/
	AnimToPlay: AnimationAsset;
	/**
	 * Default setting for looping for SequenceToPlay. This is not current state of looping.
	*/
	bDefaultLooping: boolean;
	/**
	 * Default setting for playing for SequenceToPlay. This is not current state of playing.
	*/
	bDefaultPlaying: boolean;
	/**
	 * Default setting for position of SequenceToPlay to play.
	*/
	DefaultPosition: number;
	/**
	 * Default setting for playrate of SequenceToPlay to play.
	*/
	DefaultPlayRate: number;
	/**
	 * Keep track of when animation has been ticked to ensure it is ticked only once per frame.
	*/
	LastPoseTickTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SkeletalMeshComponent;
	static Find(Outer: UObject, ResourceName: string): SkeletalMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SkeletalMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SkeletalMeshComponent;
	/**
	 * If this component has a valid MasterPoseComponent and has previously had its cloth bound to the
	 * MCP, this function will unbind the cloth and resume simulation.
	 * @param bRestoreSimulationSpace if true and the master pose cloth was originally simulating in world
	 * space, we will restore this setting. This will cause the master component to reset which may be
	 * undesirable.
	*/
	UnbindClothFromMasterPoseComponent(bRestoreSimulationSpace: boolean): void;
	/**
	 * Stop
	*/
	Stop(): void;
	/**
	 * Set Position
	*/
	SetPosition(InPos: number,bFireNotifies: boolean): void;
	/**
	 * Set Play Rate
	*/
	SetPlayRate(Rate: number): void;
	/**
	 * This is global set up for setting physics blend weight
	 * This does multiple things automatically
	 * If PhysicsBlendWeight == 1.f, it will enable Simulation, and if PhysicsBlendWeight == 0.f, it will disable Simulation.
	 * Also it will respect each body's setup, so if the body is fixed, it won't simulate. Vice versa
	 * So if you'd like all bodies to change manually, do not use this function, but SetAllBodiesPhysicsBlendWeight
	*/
	SetPhysicsBlendWeight(PhysicsBlendWeight: number): void;
	/**
	 * Changes the value of bNotifyRigidBodyCollision on all bodies below a given bone
	 * @param bNewNotifyRigidBodyCollision   The value to assign to bNotifyRigidBodyCollision
	 * @param BoneName                                               Name of the body to turn hit notifies on (and below)
	 * @param bIncludeSelf                                   Whether to modify the given body (useful for roots with multiple children)
	*/
	SetNotifyRigidBodyCollisionBelow(bNewNotifyRigidBodyCollision: boolean,BoneName: string,bIncludeSelf: boolean): void;
	/**
	 * Set Morph Target with Name and Value(0-1)
	 * @param bRemoveZeroWeight : Used by editor code when it should stay in the active list with zero weight
	*/
	SetMorphTarget(MorphTargetName: string,Value: number,bRemoveZeroWeight: boolean): void;
	/**
	 * Disable physics blending of bones *
	*/
	SetEnablePhysicsBlending(bNewBlendPhysics: boolean): void;
	/**
	 * Enables or disables gravity to all bodies below the given bone.
	 * NAME_None indicates all bodies will be edited.
	 * In that case, consider using UPrimitiveComponent::EnableGravity.
	 * @param bEnableGravity   Whether gravity should be enabled or disabled.
	 * @param BoneName                 The name of the top most bone.
	 * @param bIncludeSelf             Whether the bone specified should be edited.
	*/
	SetEnableGravityOnAllBodiesBelow(bEnableGravity: boolean,BoneName: string,bIncludeSelf: boolean): void;
	/**
	 * Enables or disables gravity for the given bone.
	 * NAME_None indicates the root body will be edited.
	 * If the bone name given is otherwise invalid, nothing happens.
	 * @param bEnableGravity   Whether gravity should be enabled or disabled.
	 * @param BoneName                 The name of the bone to modify.
	*/
	SetEnableBodyGravity(bEnableGravity: boolean,BoneName: string): void;
	/**
	 * Sets the constraint profile properties (limits, motors, etc...) to match the constraint profile as defined in the physics asset for all constraints. If profile name is not found the joint is set to use the default constraint profile.
	*/
	SetConstraintProfileForAll(ProfileName: string,bDefaultIfNotFound: boolean): void;
	/**
	 * Sets the constraint profile properties (limits, motors, etc...) to match the constraint profile as defined in the physics asset. If profile name is not found the joint is set to use the default constraint profile.
	*/
	SetConstraintProfile(JointName: string,ProfileName: string,bDefaultIfNotFound: boolean): void;
	/**
	 * Set Cloth Max Distance Scale
	*/
	SetClothMaxDistanceScale(Scale: number): void;
	/**
	 * Changes the value of bNotifyRigidBodyCollision for a given body
	 * @param bNewNotifyRigidBodyCollision   The value to assign to bNotifyRigidBodyCollision
	 * @param BoneName                                               Name of the body to turn hit notifies on/off. None implies root body
	*/
	SetBodyNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean,BoneName: string): void;
	/**
	 * Set Anim Instance Class
	*/
	SetAnimInstanceClass(NewClass: UnrealEngineClass): void;
	/**
	 * Below are the interface to control animation when animation mode, not blueprint mode *
	*/
	SetAnimationMode(InAnimationMode: EAnimationMode): void;
	/**
	 * Set Animation
	*/
	SetAnimation(NewAnimToPlay: AnimationAsset): void;
	/**
	 * Sets the Angular Motion Ranges for a named bone
	 * @param InBoneName  Name of bone to adjust constraint ranges for
	 * @param Swing1LimitAngle       Size of limit in degrees, 0 means locked, 180 means free
	 * @param TwistLimitAngle        Size of limit in degrees, 0 means locked, 180 means free
	 * @param Swing2LimitAngle       Size of limit in degrees, 0 means locked, 180 means free
	*/
	SetAngularLimits(InBoneName: string,Swing1LimitAngle: number,TwistLimitAngle: number,Swing2LimitAngle: number): void;
	/**
	 * Enable or Disable AngularVelocityDrive. If motor is in SLERP mode it will be turned on if either EnableSwingDrive OR EnableTwistDrive are enabled. In Twist and Swing mode the twist and the swing can be controlled individually.
	*/
	SetAllMotorsAngularVelocityDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean,bSkipCustomPhysicsType: boolean): void;
	/**
	 * Enable or Disable AngularPositionDrive. If motor is in SLERP mode it will be turned on if either EnableSwingDrive OR EnableTwistDrive are enabled. In Twist and Swing mode the twist and the swing can be controlled individually.
	*/
	SetAllMotorsAngularPositionDrive(bEnableSwingDrive: boolean,bEnableTwistDrive: boolean,bSkipCustomPhysicsType: boolean): void;
	/**
	 * Set Angular Drive motors params for all constraint instances
	*/
	SetAllMotorsAngularDriveParams(InSpring: number,InDamping: number,InForceLimit: number,bSkipCustomPhysicsType: boolean): void;
	/**
	 * Set bSimulatePhysics to true for all bone bodies. Does not change the component bSimulatePhysics flag.
	*/
	SetAllBodiesSimulatePhysics(bNewSimulate: boolean): void;
	/**
	 * Set All Bodies Physics Blend Weight
	*/
	SetAllBodiesPhysicsBlendWeight(PhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
	/**
	 * Set all of the bones below passed in bone to be simulated
	*/
	SetAllBodiesBelowSimulatePhysics(InBoneName: string,bNewSimulate: boolean,bIncludeSelf: boolean): void;
	/**
	 * Set all of the bones below passed in bone to be simulated
	*/
	SetAllBodiesBelowPhysicsBlendWeight(InBoneName: string,PhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean,bIncludeSelf: boolean): void;
	/**
	 * Reset the teleport mode of a next update to 'Continuous'
	*/
	ResetClothTeleportMode(): void;
	/**
	 * Allows you to reset bodies Simulate state based on where bUsePhysics is set to true in the BodySetup.
	*/
	ResetAllBodiesSimulatePhysics(): void;
	/**
	 * Play Animation
	*/
	PlayAnimation(NewAnimToPlay: AnimationAsset,bLooping: boolean): void;
	/**
	 * Play
	*/
	Play(bLooping: boolean): void;
	/**
	 * Given a world position, find the closest point on the physics asset. Note that this is independent of collision and welding. This is based purely on animation position
	 * @param      WorldPosition                           The point we want the closest point to (i.e. for all bodies in the physics asset, find the one that has a point closest to WorldPosition)
	 * @param      ClosestPointOnPhysicsAsset      The data associated with the closest point (position, normal, etc...)
	 * @return     true if we found a closest point
	*/
	GetClosestPointOnPhysicsAsset(WorldPosition: Vector,ClosestWorldPosition?: Vector,Normal?: Vector,BoneName?: string,Distance?: number): {ClosestWorldPosition: Vector, Normal: Vector, BoneName: string, Distance: number, $: boolean};
	/**
	 * Is Playing
	*/
	IsPlaying(): boolean;
	/**
	 * Checks whether or not gravity is enabled on the given bone.
	 * NAME_None indicates the root body should be queried.
	 * If the bone name given is otherwise invalid, false is returned.
	 * @param BoneName The name of the bone to check.
	 * @return True if gravity is enabled on the bone.
	*/
	IsBodyGravityEnabled(BoneName: string): boolean;
	/**
	 * Get Position
	*/
	GetPosition(): number;
	/**
	 * Get Play Rate
	*/
	GetPlayRate(): number;
	/**
	 * Get Morph target with given name
	*/
	GetMorphTarget(MorphTargetName: string): number;
	/**
	 * Gets the current Angular state for a named bone constraint
	 * @param InBoneName  Name of bone to get constraint ranges for
	 * @param Swing1Angle current angular state of the constraint
	 * @param TwistAngle  current angular state of the constraint
	 * @param Swing2Angle current angular state of the constraint
	*/
	GetCurrentJointAngles(InBoneName: string,Swing1Angle?: number,TwistAngle?: number,Swing2Angle?: number): {Swing1Angle: number, TwistAngle: number, Swing2Angle: number};
	/**
	 * Get/Set the max distance scale of clothing mesh vertices
	*/
	GetClothMaxDistanceScale(): number;
	/**
	 * Returns the animation instance that is driving the class (if available). This is typically an instance of
	 * the class set as AnimBlueprintGeneratedClass (generated by an animation blueprint)
	*/
	GetAnimInstance(): AnimInstance;
	/**
	 * Get Animation Mode
	*/
	GetAnimationMode(): EAnimationMode;
	/**
	 * Used to indicate we should force 'teleport and reset' during the next call to UpdateClothState.
	 * This can be used to reset it from a bad state or by a teleport where the old state is not important anymore.
	*/
	ForceClothNextUpdateTeleportAndReset(): void;
	/**
	 * Used to indicate we should force 'teleport' during the next call to UpdateClothState,
	 * This will transform positions and velocities and thus keep the simulation state, just translate it to a new pose.
	*/
	ForceClothNextUpdateTeleport(): void;
	/**
	 * Clear all Morph Target that are set to this mesh
	*/
	ClearMorphTargets(): void;
	/**
	 * Break a constraint off a Gore mesh.
	 * @param       Impulse vector of impulse
	 * @param       HitLocation     location of the hit
	 * @param       InBoneName      Name of bone to break constraint for
	*/
	BreakConstraint(Impulse: Vector,HitLocation: Vector,InBoneName: string): void;
	/**
	 * If this component has a valid MasterPoseComponent then this function makes cloth items on the slave component
	 * take the transforms of the cloth items on the master component instead of simulating separately.
	 * @Note This will FORCE any cloth actor on the master component to simulate in local space. Also
	 * The meshes used in the components must be identical for the cloth to bind correctly
	*/
	BindClothToMasterPoseComponent(): void;
	/**
	 * Add impulse to all single rigid bodies below. Good for one time instant burst.
	 * @param  Impulse         Magnitude and direction of impulse to apply.
	 * @param  BoneName        If a SkeletalMeshComponent, name of body to apply impulse to. 'None' indicates root body.
	 * @param  bVelChange      If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no affect).
	 * @param bIncludeSelf If false, Force is only applied to bodies below but not given bone name.
	*/
	AddImpulseToAllBodiesBelow(Impulse: Vector,BoneName: string,bVelChange: boolean,bIncludeSelf: boolean): void;
	/**
	 * Add a force to all rigid bodies below.
	 * This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.
	 * @param  Force            Force vector to apply. Magnitude indicates strength of force.
	 * @param  BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.
	 * @param  bAccelChange If true, Force is taken as a change in acceleration instead of a physical force (i.e. mass will have no affect).
	 * @param  bIncludeSelf If false, Force is only applied to bodies below but not given bone name.
	*/
	AddForceToAllBodiesBelow(Force: Vector,BoneName: string,bAccelChange: boolean,bIncludeSelf: boolean): void;
	/**
	 * Accumulate AddPhysicsBlendWeight to physics blendweight for all of the bones below passed in bone to be simulated
	*/
	AccumulateAllBodiesBelowPhysicsBlendWeight(InBoneName: string,AddPhysicsBlendWeight: number,bSkipCustomPhysicsType: boolean): void;
	static C(Other: UObject): SkeletalMeshComponent;
}

declare class SpriteCategoryInfo { 
	/**
	 * Sprite category that the component belongs to
	*/
	Category: string;
	/**
	 * Localized name of the sprite category
	*/
	DisplayName: string;
	/**
	 * Localized description of the sprite category
	*/
	Description: string;
	clone() : SpriteCategoryInfo;
	static C(Other: UObject): SpriteCategoryInfo;
}

declare class ArrowComponent extends PrimitiveComponent { 
	/**
	 * Arrow Color
	*/
	ArrowColor: Color;
	/**
	 * Arrow Size
	*/
	ArrowSize: number;
	/**
	 * Set to limit the screen size of this arrow
	*/
	bIsScreenSizeScaled: boolean;
	/**
	 * The size on screen to limit this arrow to (in screen space)
	*/
	ScreenSize: number;
	/**
	 * If true, don't show the arrow when EngineShowFlags.BillboardSprites is disabled.
	*/
	bTreatAsASprite: boolean;
	/**
	 * Sprite category that the arrow component belongs to, if being treated as a sprite. Value serves as a key into the localization file.
	*/
	SpriteCategoryName: string;
	/**
	 * Sprite category information regarding the arrow component, if being treated as a sprite.
	*/
	SpriteInfo: SpriteCategoryInfo;
	/**
	 * If true, this arrow component is attached to a light actor
	*/
	bLightAttachment: boolean;
	/**
	 * Whether to use in-editor arrow scaling (i.e. to be affected by the global arrow scale)
	*/
	bUseInEditorScaling: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ArrowComponent;
	static Find(Outer: UObject, ResourceName: string): ArrowComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ArrowComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ArrowComponent;
	/**
	 * Updates the arrow's colour, and tells it to refresh
	*/
	SetArrowColor(NewColor: LinearColor): void;
	/**
	 * Updates the arrow's colour, and tells it to refresh
	*/
	SetArrowColor_DEPRECATED(NewColor: Color): void;
	static C(Other: UObject): ArrowComponent;
}

declare type EPlaneConstraintAxisSetting = string | symbol;
declare var EPlaneConstraintAxisSetting = { Custom:'Custom',X:'X',Y:'Y',Z:'Z',UseGlobalPhysicsSetting:'UseGlobalPhysicsSetting', };
declare class MovementComponent extends ActorComponent { 
	/**
	 * The component we move and update.
	 * If this is null at startup and bAutoRegisterUpdatedComponent is true, the owning Actor's root component will automatically be set as our UpdatedComponent at startup.
	 * @see bAutoRegisterUpdatedComponent, SetUpdatedComponent(), UpdatedPrimitive
	*/
	UpdatedComponent: SceneComponent;
	/**
	 * UpdatedComponent, cast as a UPrimitiveComponent. May be invalid if UpdatedComponent was null or not a UPrimitiveComponent.
	*/
	UpdatedPrimitive: PrimitiveComponent;
	/**
	 * Current velocity of updated component.
	*/
	Velocity: Vector;
	/**
	 * If true, movement will be constrained to a plane.
	 * @see PlaneConstraintNormal, PlaneConstraintOrigin, PlaneConstraintAxisSetting
	*/
	bConstrainToPlane: boolean;
	/**
	 * If true and plane constraints are enabled, then the updated component will be snapped to the plane when first attached.
	*/
	bSnapToPlaneAtStart: boolean;
	/**
	 * Setting that controls behavior when movement is restricted to a 2D plane defined by a specific axis/normal,
	 * so that movement along the locked axis is not be possible.
	 * @see SetPlaneConstraintAxisSetting
	*/
	PlaneConstraintAxisSetting: EPlaneConstraintAxisSetting;
	/**
	 * The normal or axis of the plane that constrains movement, if bConstrainToPlane is enabled.
	 * If for example you wanted to constrain movement to the X-Z plane (so that Y cannot change), the normal would be set to X=0 Y=1 Z=0.
	 * This is recalculated whenever PlaneConstraintAxisSetting changes. It is normalized once the component is registered with the game world.
	 * @see bConstrainToPlane, SetPlaneConstraintNormal(), SetPlaneConstraintFromVectors()
	*/
	PlaneConstraintNormal: Vector;
	/**
	 * The origin of the plane that constrains movement, if plane constraint is enabled.
	 * This defines the behavior of snapping a position to the plane, such as by SnapUpdatedComponentToPlane().
	 * @see bConstrainToPlane, SetPlaneConstraintOrigin().
	*/
	PlaneConstraintOrigin: Vector;
	/**
	 * If true, skips TickComponent() if UpdatedComponent was not recently rendered.
	*/
	bUpdateOnlyIfRendered: boolean;
	/**
	 * If true, whenever the updated component is changed, this component will enable or disable its tick dependent on whether it has something to update.
	 * This will NOT enable tick at startup if bAutoActivate is false, because presumably you have a good reason for not wanting it to start ticking initially.
	*/
	bAutoUpdateTickRegistration: boolean;
	/**
	 * If true, after registration we will add a tick dependency to tick before our owner (if we can both tick).
	 * This is important when our tick causes an update in the owner's position, so that when the owner ticks it uses the most recent position without lag.
	 * Disabling this can improve performance if both objects tick but the order of ticks doesn't matter.
	*/
	bTickBeforeOwner: boolean;
	/**
	 * If true, registers the owner's Root component as the UpdatedComponent if there is not one currently assigned.
	*/
	bAutoRegisterUpdatedComponent: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): MovementComponent;
	static Find(Outer: UObject, ResourceName: string): MovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MovementComponent;
	/**
	 * Stops movement immediately (zeroes velocity, usually zeros acceleration for components with acceleration).
	*/
	StopMovementImmediately(): void;
	/**
	 * Snap the updated component to the plane constraint, if enabled.
	*/
	SnapUpdatedComponentToPlane(): void;
	/**
	 * Assign the component we move and update.
	*/
	SetUpdatedComponent(NewUpdatedComponent: SceneComponent): void;
	/**
	 * Sets the origin of the plane that constrains movement, enforced if the plane constraint is enabled.
	*/
	SetPlaneConstraintOrigin(PlaneOrigin: Vector): void;
	/**
	 * Sets the normal of the plane that constrains movement, enforced if the plane constraint is enabled.
	 * Changing the normal automatically sets PlaneConstraintAxisSetting to "Custom".
	 * @param PlaneNormal   The normal of the plane. If non-zero in length, it will be normalized.
	*/
	SetPlaneConstraintNormal(PlaneNormal: Vector): void;
	/**
	 * Uses the Forward and Up vectors to compute the plane that constrains movement, enforced if the plane constraint is enabled.
	*/
	SetPlaneConstraintFromVectors(Forward: Vector,Up: Vector): void;
	/**
	 * Sets whether or not the plane constraint is enabled.
	*/
	SetPlaneConstraintEnabled(bEnabled: boolean): void;
	/**
	 * Set the plane constraint axis setting.
	 * Changing this setting will modify the current value of PlaneConstraintNormal.
	 * @param  NewAxisSetting New plane constraint axis setting.
	*/
	SetPlaneConstraintAxisSetting(NewAxisSetting: EPlaneConstraintAxisSetting): void;
	/**
	 * Delegate when PhysicsVolume of UpdatedComponent has been changed *
	*/
	PhysicsVolumeChanged(NewVolume: PhysicsVolume): void;
	/**
	 * Moves our UpdatedComponent by the given Delta, and sets rotation to NewRotation.
	 * Respects the plane constraint, if enabled.
	 * @return True if some movement occurred, false if no movement occurred. Result of any impact will be stored in OutHit.
	*/
	MoveUpdatedComponent(Delta: Vector,NewRotation: Rotator,OutHit?: HitResult,bSweep?: boolean,bTeleport?: boolean): {OutHit: HitResult, $: boolean};
	/**
	 * @return the result of GetMaxSpeed() * GetMaxSpeedModifier().
	*/
	GetModifiedMaxSpeed(): number;
	/**
	 * @return a scalar applied to the maximum velocity that the component can currently move.
	*/
	GetMaxSpeedModifier(): number;
	/**
	 * Returns true if the current velocity is exceeding the given max speed (usually the result of GetMaxSpeed()), within a small error tolerance.
	 * Note that under normal circumstances updates cause by acceleration will not cause this to be true, however external forces or changes in the max speed limit
	 * can cause the max speed to be violated.
	*/
	IsExceedingMaxSpeed(MaxSpeed: number): boolean;
	/**
	 * Get the plane constraint origin. This defines the behavior of snapping a position to the plane, such as by SnapUpdatedComponentToPlane().
	 * @return The origin of the plane that constrains movement, if the plane constraint is enabled.
	*/
	GetPlaneConstraintOrigin(): Vector;
	/**
	 * @return The normal of the plane that constrains movement, enforced if the plane constraint is enabled.
	*/
	GetPlaneConstraintNormal(): Vector;
	/**
	 * Get the plane constraint axis setting.
	*/
	GetPlaneConstraintAxisSetting(): EPlaneConstraintAxisSetting;
	/**
	 * @return PhysicsVolume this MovementComponent is using, or the world's default physics volume if none. *
	*/
	GetPhysicsVolume(): PhysicsVolume;
	/**
	 * @return Maximum speed of component in current movement mode.
	*/
	GetMaxSpeed(): number;
	/**
	 * @return gravity that affects this component
	*/
	GetGravityZ(): number;
	/**
	 * Constrain a normal vector (of unit length) to the plane constraint, if enabled.
	*/
	ConstrainNormalToPlane(Normal: Vector): Vector;
	/**
	 * Constrain a position vector to the plane constraint, if enabled.
	*/
	ConstrainLocationToPlane(Location: Vector): Vector;
	/**
	 * Constrain a direction vector to the plane constraint, if enabled.
	 * @see SetPlaneConstraint
	*/
	ConstrainDirectionToPlane(Direction: Vector): Vector;
	static C(Other: UObject): MovementComponent;
}

declare class MovementProperties { 
	/**
	 * If true, this Pawn is capable of crouching.
	*/
	bCanCrouch: boolean;
	/**
	 * If true, this Pawn is capable of jumping.
	*/
	bCanJump: boolean;
	/**
	 * If true, this Pawn is capable of walking or moving on the ground.
	*/
	bCanWalk: boolean;
	/**
	 * If true, this Pawn is capable of swimming or moving through fluid volumes.
	*/
	bCanSwim: boolean;
	/**
	 * If true, this Pawn is capable of flying.
	*/
	bCanFly: boolean;
	clone() : MovementProperties;
	static C(Other: UObject): MovementProperties;
}

declare class StringClassReference extends StringAssetReference { 
	clone() : StringClassReference;
	static C(Other: UObject): StringClassReference;
}

declare class NavDataConfig extends NavAgentProperties { 
	/**
	 * Name
	*/
	Name: string;
	/**
	 * Color
	*/
	Color: Color;
	/**
	 * Default Query Extent
	*/
	DefaultQueryExtent: Vector;
	/**
	 * Navigation Data Class
	*/
	NavigationDataClass: UnrealEngineClass;
	/**
	 * Navigation Data Class Name
	*/
	NavigationDataClassName: StringClassReference;
	clone() : NavDataConfig;
	static C(Other: UObject): NavDataConfig;
}

declare type ERuntimeGenerationType = string | symbol;
declare var ERuntimeGenerationType = { Static:'Static',DynamicModifiersOnly:'DynamicModifiersOnly',Dynamic:'Dynamic',LegacyGeneration:'LegacyGeneration', };
declare class SupportedAreaData { 
	/**
	 * Area Class Name
	*/
	AreaClassName: string;
	/**
	 * Area ID
	*/
	AreaID: number;
	/**
	 * Area Class
	*/
	AreaClass: UnrealEngineClass;
	clone() : SupportedAreaData;
	static C(Other: UObject): SupportedAreaData;
}

declare class NavigationData extends Actor { 
	/**
	 * Rendering Comp
	*/
	RenderingComp: PrimitiveComponent;
	/**
	 * Nav Data Config
	*/
	NavDataConfig: NavDataConfig;
	/**
	 * if set to true then this navigation data will be drawing itself when requested as part of "show navigation"
	*/
	bEnableDrawing: boolean;
	/**
	 * By default navigation will skip the first update after being successfully loaded
	 * setting bForceRebuildOnLoad to false can override this behavior
	*/
	bForceRebuildOnLoad: boolean;
	/**
	 * If set, navigation data can act as default one in navigation system's queries
	*/
	bCanBeMainNavData: boolean;
	/**
	 * If set, navigation data will be spawned in persistent level during rebuild if actor doesn't exist
	*/
	bCanSpawnOnRebuild: boolean;
	/**
	 * If true, the NavMesh can be dynamically rebuilt at runtime.
	*/
	bRebuildAtRuntime: boolean;
	/**
	 * Navigation data runtime generation options
	*/
	RuntimeGeneration: ERuntimeGenerationType;
	/**
	 * all observed paths will be processed every ObservedPathsTickInterval seconds
	*/
	ObservedPathsTickInterval: number;
	/**
	 * Navigation data versioning.
	*/
	DataVersion: any;
	/**
	 * serialized area class - ID mapping
	*/
	SupportedAreas: SupportedAreaData[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationData;
	static C(Other: UObject): NavigationData;
}

declare class NavAgentProperties extends MovementProperties { 
	/**
	 * Radius of the capsule used for navigation/pathfinding.
	*/
	AgentRadius: number;
	/**
	 * Total height of the capsule used for navigation/pathfinding.
	*/
	AgentHeight: number;
	/**
	 * Step height to use, or -1 for default value from navdata's config.
	*/
	AgentStepHeight: number;
	/**
	 * Scale factor to apply to height of bounds when searching for navmesh to project to when nav walking
	*/
	NavWalkingSearchHeightScale: number;
	/**
	 * Type of navigation data used by agent, null means "any"
	*/
	PreferredNavData: UnrealEngineClass;
	clone() : NavAgentProperties;
	static C(Other: UObject): NavAgentProperties;
}

declare class NavMovementComponent extends MovementComponent { 
	/**
	 * Properties that define how the component can move.
	*/
	NavAgentProps: NavAgentProperties;
	/**
	 * Braking distance override used with acceleration driven path following (bUseAccelerationForPaths)
	*/
	FixedPathBrakingDistance: number;
	/**
	 * If set to true NavAgentProps' radius and height will be updated with Owner's collision capsule size
	*/
	bUpdateNavAgentWithOwnersCollision: boolean;
	/**
	 * If set, FixedPathBrakingDistance will be used for path following deceleration
	*/
	bUseAccelerationForPaths: boolean;
	/**
	 * If set, FixedPathBrakingDistance will be used for path following deceleration
	*/
	bUseFixedBrakingDistanceForPaths: boolean;
	/**
	 * Expresses runtime state of character's movement. Put all temporal changes to movement properties here
	*/
	MovementState: MovementProperties;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavMovementComponent;
	static Find(Outer: UObject, ResourceName: string): NavMovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavMovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavMovementComponent;
	/**
	 * Stops movement immediately (reset velocity) but keeps following current path
	*/
	StopMovementKeepPathing(): void;
	/**
	 * Stops applying further movement (usually zeros acceleration).
	*/
	StopActiveMovement(): void;
	/**
	 * @return true if currently swimming (moving through a fluid volume)
	*/
	IsSwimming(): boolean;
	/**
	 * @return true if currently moving on the ground (e.g. walking or driving)
	*/
	IsMovingOnGround(): boolean;
	/**
	 * @return true if currently flying (moving through a non-fluid volume without resting on the ground)
	*/
	IsFlying(): boolean;
	/**
	 * @return true if currently falling (not flying, in a non-fluid volume, and not on the ground)
	*/
	IsFalling(): boolean;
	/**
	 * @return true if currently crouching
	*/
	IsCrouching(): boolean;
	static C(Other: UObject): NavMovementComponent;
}

declare class PawnMovementComponent extends NavMovementComponent { 
	/**
	 * Pawn that owns this component.
	*/
	PawnOwner: Pawn;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnMovementComponent;
	static Find(Outer: UObject, ResourceName: string): PawnMovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnMovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnMovementComponent;
	/**
	 * (Deprecated) Return the input vector in world space.
	*/
	GetInputVector(): Vector;
	/**
	 * Helper to see if move input is ignored. If there is no Pawn or UpdatedComponent, returns true, otherwise defers to the Pawn's implementation of IsMoveInputIgnored().
	*/
	IsMoveInputIgnored(): boolean;
	/**
	 * Return the pending input vector in world space. This is the most up-to-date value of the input vector, pending ConsumeMovementInputVector() which clears it.
	 * PawnMovementComponents implementing movement usually want to use either this or ConsumeInputVector() as these functions represent the most recent state of input.
	 * @return The pending input vector in world space.
	 * @see AddInputVector(), ConsumeInputVector(), GetLastInputVector()
	*/
	GetPendingInputVector(): Vector;
	/**
	 * Return the Pawn that owns UpdatedComponent.
	*/
	GetPawnOwner(): Pawn;
	/**
	 * Return the last input vector in world space that was processed by ConsumeInputVector(), which is usually done by the Pawn or PawnMovementComponent.
	 * Any user that needs to know about the input that last affected movement should use this function.
	 * @return The last input vector in world space that was processed by ConsumeInputVector().
	 * @see AddInputVector(), ConsumeInputVector(), GetPendingInputVector()
	*/
	GetLastInputVector(): Vector;
	/**
	 * Returns the pending input vector and resets it to zero.
	 *        * This should be used during a movement update (by the Pawn or PawnMovementComponent) to prevent accumulation of control input between frames.
	 *        * Copies the pending input vector to the saved input vector (GetLastMovementInputVector()).
	 *        * @return The pending input vector.
	*/
	ConsumeInputVector(): Vector;
	/**
	 * Adds the given vector to the accumulated input in world space. Input vectors are usually between 0 and 1 in magnitude.
	 * They are accumulated during a frame then applied as acceleration during the movement update.
	 * @param WorldDirection        Direction in world space to apply input
	 * @param ScaleValue            Scale to apply to input. This can be used for analog input, ie a value of 0.5 applies half the normal value.
	 * @param bForce                        If true always add the input, ignoring the result of IsMoveInputIgnored().
	 * @see APawn::AddMovementInput()
	*/
	AddInputVector(WorldVector: Vector,bForce: boolean): void;
	static C(Other: UObject): PawnMovementComponent;
}

declare type EMovementMode = string | symbol;
declare var EMovementMode = { MOVE_None:'MOVE_None',MOVE_Walking:'MOVE_Walking',MOVE_NavWalking:'MOVE_NavWalking',MOVE_Falling:'MOVE_Falling',MOVE_Swimming:'MOVE_Swimming',MOVE_Flying:'MOVE_Flying',MOVE_Custom:'MOVE_Custom', };
declare type ENetworkSmoothingMode = string | symbol;
declare var ENetworkSmoothingMode = { Disabled:'Disabled',Linear:'Linear',Exponential:'Exponential',Replay:'Replay', };
declare class FindFloorResult { 
	/**
	 * True if there was a blocking hit in the floor test that was NOT in initial penetration.
	 * The HitResult can give more info about other circumstances.
	*/
	bBlockingHit: boolean;
	/**
	 * True if the hit found a valid walkable floor.
	*/
	bWalkableFloor: boolean;
	/**
	 * True if the hit found a valid walkable floor using a line trace (rather than a sweep test, which happens when the sweep test fails to yield a walkable surface).
	*/
	bLineTrace: boolean;
	/**
	 * The distance to the floor, computed from the swept capsule trace.
	*/
	FloorDist: number;
	/**
	 * The distance to the floor, computed from the trace. Only valid if bLineTrace is true.
	*/
	LineDist: number;
	/**
	 * Hit result of the test that found a floor. Includes more specific data about the point of impact and surface normal at that point.
	*/
	HitResult: HitResult;
	clone() : FindFloorResult;
	static C(Other: UObject): FindFloorResult;
}

declare class NavAvoidanceMask { 
	/**
	 * Group 0
	*/
	bGroup0: boolean;
	/**
	 * Group 1
	*/
	bGroup1: boolean;
	/**
	 * Group 2
	*/
	bGroup2: boolean;
	/**
	 * Group 3
	*/
	bGroup3: boolean;
	/**
	 * Group 4
	*/
	bGroup4: boolean;
	/**
	 * Group 5
	*/
	bGroup5: boolean;
	/**
	 * Group 6
	*/
	bGroup6: boolean;
	/**
	 * Group 7
	*/
	bGroup7: boolean;
	/**
	 * Group 8
	*/
	bGroup8: boolean;
	/**
	 * Group 9
	*/
	bGroup9: boolean;
	/**
	 * Group 10
	*/
	bGroup10: boolean;
	/**
	 * Group 11
	*/
	bGroup11: boolean;
	/**
	 * Group 12
	*/
	bGroup12: boolean;
	/**
	 * Group 13
	*/
	bGroup13: boolean;
	/**
	 * Group 14
	*/
	bGroup14: boolean;
	/**
	 * Group 15
	*/
	bGroup15: boolean;
	/**
	 * Group 16
	*/
	bGroup16: boolean;
	/**
	 * Group 17
	*/
	bGroup17: boolean;
	/**
	 * Group 18
	*/
	bGroup18: boolean;
	/**
	 * Group 19
	*/
	bGroup19: boolean;
	/**
	 * Group 20
	*/
	bGroup20: boolean;
	/**
	 * Group 21
	*/
	bGroup21: boolean;
	/**
	 * Group 22
	*/
	bGroup22: boolean;
	/**
	 * Group 23
	*/
	bGroup23: boolean;
	/**
	 * Group 24
	*/
	bGroup24: boolean;
	/**
	 * Group 25
	*/
	bGroup25: boolean;
	/**
	 * Group 26
	*/
	bGroup26: boolean;
	/**
	 * Group 27
	*/
	bGroup27: boolean;
	/**
	 * Group 28
	*/
	bGroup28: boolean;
	/**
	 * Group 29
	*/
	bGroup29: boolean;
	/**
	 * Group 30
	*/
	bGroup30: boolean;
	/**
	 * Group 31
	*/
	bGroup31: boolean;
	clone() : NavAvoidanceMask;
	static C(Other: UObject): NavAvoidanceMask;
}

declare class CharacterMovementComponentPostPhysicsTickFunction extends TickFunction { 
	clone() : CharacterMovementComponentPostPhysicsTickFunction;
	static C(Other: UObject): CharacterMovementComponentPostPhysicsTickFunction;
}

declare class Vector_NetQuantize10 extends Vector { 
	clone() : Vector_NetQuantize10;
	static C(Other: UObject): Vector_NetQuantize10;
}

declare class RootMotionSourceSettings { 
	/**
	 * Flags
	*/
	Flags: number;
	clone() : RootMotionSourceSettings;
	static C(Other: UObject): RootMotionSourceSettings;
}

declare class RootMotionSourceGroup { 
	/**
	 * Whether this group has additive root motion sources
	*/
	bHasAdditiveSources: boolean;
	/**
	 * Whether this group has override root motion sources
	*/
	bHasOverrideSources: boolean;
	/**
	 * Saved off pre-additive-applied Velocity, used for being able to reliably add/remove additive
	 * velocity from currently computed Velocity (otherwise we would be removing additive velocity
	 * that no longer exists, like if you run into a wall and your Velocity becomes 0 - subtracting
	 * the velocity that we added heading into the wall last tick would make you go backwards. With
	 * this method we override that resulting Velocity due to obstructions
	*/
	LastPreAdditiveVelocity: Vector_NetQuantize10;
	/**
	 * True when we had additive velocity applied last tick, checked to know if we should restore
	 * LastPreAdditiveVelocity before a Velocity computation
	*/
	bIsAdditiveVelocityApplied: boolean;
	/**
	 * Aggregate Settings of the last group of accumulated sources
	*/
	LastAccumulatedSettings: RootMotionSourceSettings;
	clone() : RootMotionSourceGroup;
	static C(Other: UObject): RootMotionSourceGroup;
}

declare class RootMotionMovementParams { 
	/**
	 * Has Root Motion
	*/
	bHasRootMotion: boolean;
	/**
	 * Blend Weight
	*/
	BlendWeight: number;
	/**
	 * Root Motion Transform
	*/
	RootMotionTransform: Transform;
	clone() : RootMotionMovementParams;
	static C(Other: UObject): RootMotionMovementParams;
}

declare class CharacterMovementComponent extends PawnMovementComponent { 
	/**
	 * Character movement component belongs to
	*/
	CharacterOwner: Character;
	/**
	 * Custom gravity scale. Gravity is multiplied by this amount for the character.
	*/
	GravityScale: number;
	/**
	 * Maximum height character can step up
	*/
	MaxStepHeight: number;
	/**
	 * Initial velocity (instantaneous vertical acceleration) when jumping.
	*/
	JumpZVelocity: number;
	/**
	 * Fraction of JumpZVelocity to use when automatically "jumping off" of a base actor that's not allowed to be a base for a character. (For example, if you're not allowed to stand on other players.)
	*/
	JumpOffJumpZFactor: number;
	/**
	 * Max angle in degrees of a walkable surface. Any greater than this and it is too steep to be walkable.
	*/
	WalkableFloorAngle: number;
	/**
	 * Minimum Z value for floor normal. If less, not a walkable surface. Computed from WalkableFloorAngle.
	*/
	WalkableFloorZ: number;
	/**
	 * Actor's current movement mode (walking, falling, etc).
	 *    - walking:  Walking on a surface, under the effects of friction, and able to "step up" barriers. Vertical velocity is zero.
	 *    - falling:  Falling under the effects of gravity, after jumping or walking off the edge of a surface.
	 *    - flying:   Flying, ignoring the effects of gravity.
	 *    - swimming: Swimming through a fluid volume, under the effects of gravity and buoyancy.
	 *    - custom:   User-defined custom movement mode, including many possible sub-modes.
	 * This is automatically replicated through the Character owner and for client-server movement functions.
	 * @see SetMovementMode(), CustomMovementMode
	*/
	MovementMode: EMovementMode;
	/**
	 * Current custom sub-mode if MovementMode is set to Custom.
	 * This is automatically replicated through the Character owner and for client-server movement functions.
	 * @see SetMovementMode()
	*/
	CustomMovementMode: number;
	/**
	 * Setting that affects movement control. Higher values allow faster changes in direction.
	 * If bUseSeparateBrakingFriction is false, also affects the ability to stop more quickly when braking (whenever Acceleration is zero), where it is multiplied by BrakingFrictionFactor.
	 * When braking, this property allows you to control how much friction is applied when moving across the ground, applying an opposing force that scales with current velocity.
	 * This can be used to simulate slippery surfaces such as ice or oil by changing the value (possibly based on the material pawn is standing on).
	 * @see BrakingDecelerationWalking, BrakingFriction, bUseSeparateBrakingFriction, BrakingFrictionFactor
	*/
	GroundFriction: number;
	/**
	 * The maximum ground speed when walking. Also determines maximum lateral speed when falling.
	*/
	MaxWalkSpeed: number;
	/**
	 * The maximum ground speed when walking and crouched.
	*/
	MaxWalkSpeedCrouched: number;
	/**
	 * The maximum swimming speed.
	*/
	MaxSwimSpeed: number;
	/**
	 * The maximum flying speed.
	*/
	MaxFlySpeed: number;
	/**
	 * The maximum speed when using Custom movement mode.
	*/
	MaxCustomMovementSpeed: number;
	/**
	 * Max Acceleration (rate of change of velocity)
	*/
	MaxAcceleration: number;
	/**
	 * Factor used to multiply actual value of friction used when braking.
	 * This applies to any friction value that is currently used, which may depend on bUseSeparateBrakingFriction.
	 * @note This is 2 by default for historical reasons, a value of 1 gives the true drag equation.
	 * @see bUseSeparateBrakingFriction, GroundFriction, BrakingFriction
	*/
	BrakingFrictionFactor: number;
	/**
	 * Friction (drag) coefficient applied when braking (whenever Acceleration = 0, or if character is exceeding max speed); actual value used is this multiplied by BrakingFrictionFactor.
	 * When braking, this property allows you to control how much friction is applied when moving across the ground, applying an opposing force that scales with current velocity.
	 * Braking is composed of friction (velocity-dependent drag) and constant deceleration.
	 * This is the current value, used in all movement modes; if this is not desired, override it or bUseSeparateBrakingFriction when movement mode changes.
	 * @note Only used if bUseSeparateBrakingFriction setting is true, otherwise current friction such as GroundFriction is used.
	 * @see bUseSeparateBrakingFriction, BrakingFrictionFactor, GroundFriction, BrakingDecelerationWalking
	*/
	BrakingFriction: number;
	/**
	 * If true, BrakingFriction will be used to slow the character to a stop (when there is no Acceleration).
	 * If false, braking uses the same friction passed to CalcVelocity() (ie GroundFriction when walking), multiplied by BrakingFrictionFactor.
	 * This setting applies to all movement modes; if only desired in certain modes, consider toggling it when movement modes change.
	 * @see BrakingFriction
	*/
	bUseSeparateBrakingFriction: boolean;
	/**
	 * Deceleration when walking and not applying acceleration. This is a constant opposing force that directly lowers velocity by a constant value.
	 * @see GroundFriction, MaxAcceleration
	*/
	BrakingDecelerationWalking: number;
	/**
	 * Lateral deceleration when falling and not applying acceleration.
	 * @see MaxAcceleration
	*/
	BrakingDecelerationFalling: number;
	/**
	 * Deceleration when swimming and not applying acceleration.
	 * @see MaxAcceleration
	*/
	BrakingDecelerationSwimming: number;
	/**
	 * Deceleration when flying and not applying acceleration.
	 * @see MaxAcceleration
	*/
	BrakingDecelerationFlying: number;
	/**
	 * When falling, amount of lateral movement control available to the character.
	 * 0 = no control, 1 = full control at max speed of MaxWalkSpeed.
	*/
	AirControl: number;
	/**
	 * When falling, multiplier applied to AirControl when lateral velocity is less than AirControlBoostVelocityThreshold.
	 * Setting this to zero will disable air control boosting. Final result is clamped at 1.
	*/
	AirControlBoostMultiplier: number;
	/**
	 * When falling, if lateral velocity magnitude is less than this value, AirControl is multiplied by AirControlBoostMultiplier.
	 * Setting this to zero will disable air control boosting.
	*/
	AirControlBoostVelocityThreshold: number;
	/**
	 * Friction to apply to lateral air movement when falling.
	 * If bUseSeparateBrakingFriction is false, also affects the ability to stop more quickly when braking (whenever Acceleration is zero).
	 * @see BrakingFriction, bUseSeparateBrakingFriction
	*/
	FallingLateralFriction: number;
	/**
	 * Collision half-height when crouching (component scale is applied separately)
	*/
	CrouchedHalfHeight: number;
	/**
	 * Water buoyancy. A ratio (1.0 = neutral buoyancy, 0.0 = no buoyancy)
	*/
	Buoyancy: number;
	/**
	 * Don't allow the character to perch on the edge of a surface if the contact is this close to the edge of the capsule.
	 * Note that characters will not fall off if they are within MaxStepHeight of a walkable surface below.
	*/
	PerchRadiusThreshold: number;
	/**
	 * When perching on a ledge, add this additional distance to MaxStepHeight when determining how high above a walkable floor we can perch.
	 * Note that we still enforce MaxStepHeight to start the step up; this just allows the character to hang off the edge or step slightly higher off the floor.
	 * (@see PerchRadiusThreshold)
	*/
	PerchAdditionalHeight: number;
	/**
	 * Change in rotation per second, used when UseControllerDesiredRotation or OrientRotationToMovement are true. Set a negative value for infinite rotation rate and instant turns.
	*/
	RotationRate: Rotator;
	/**
	 * If true, smoothly rotate the Character toward the Controller's desired rotation, using RotationRate as the rate of rotation change. Overridden by OrientRotationToMovement.
	*/
	bUseControllerDesiredRotation: boolean;
	/**
	 * If true, rotate the Character toward the direction of acceleration, using RotationRate as the rate of rotation change. Overrides UseControllerDesiredRotation.
	 * Normally you will want to make sure that other settings are cleared, such as bUseControllerRotationYaw on the Character.
	*/
	bOrientRotationToMovement: boolean;
	/**
	 * True during movement update.
	 * Used internally so that attempts to change CharacterOwner and UpdatedComponent are deferred until after an update.
	 * @see IsMovementInProgress()
	*/
	bMovementInProgress: boolean;
	/**
	 * If true, high-level movement updates will be wrapped in a movement scope that accumulates updates and defers a bulk of the work until the end.
	 * When enabled, touch and hit events will not be triggered until the end of multiple moves within an update, which can improve performance.
	 * @see FScopedMovementUpdate
	*/
	bEnableScopedMovementUpdates: boolean;
	/**
	 * Ignores size of acceleration component, and forces max acceleration to drive character at full velocity.
	*/
	bForceMaxAccel: boolean;
	/**
	 * If true, movement will be performed even if there is no Controller for the Character owner.
	 * Normally without a Controller, movement will be aborted and velocity and acceleration are zeroed if the character is walking.
	 * Characters that are spawned without a Controller but with this flag enabled will initialize the movement mode to DefaultLandMovementMode or DefaultWaterMovementMode appropriately.
	 * @see DefaultLandMovementMode, DefaultWaterMovementMode
	*/
	bRunPhysicsWithNoController: boolean;
	/**
	 * Force the Character in MOVE_Walking to do a check for a valid floor even if he hasn't moved. Cleared after next floor check.
	 * Normally if bAlwaysCheckFloor is false we try to avoid the floor check unless some conditions are met, but this can be used to force the next check to always run.
	*/
	bForceNextFloorCheck: boolean;
	/**
	 * If true, the capsule needs to be shrunk on this simulated proxy, to avoid replication rounding putting us in geometry.
	 * Whenever this is set to true, this will cause the capsule to be shrunk again on the next update, and then set to false.
	*/
	bShrinkProxyCapsule: boolean;
	/**
	 * If true, Character can walk off a ledge.
	*/
	bCanWalkOffLedges: boolean;
	/**
	 * If true, Character can walk off a ledge when crouching.
	*/
	bCanWalkOffLedgesWhenCrouching: boolean;
	/**
	 * true to update CharacterOwner and UpdatedComponent after movement ends
	*/
	bDeferUpdateMoveComponent: boolean;
	/**
	 * What to update CharacterOwner and UpdatedComponent after movement ends
	*/
	DeferredUpdatedMoveComponent: SceneComponent;
	/**
	 * Maximum step height for getting out of water
	*/
	MaxOutOfWaterStepHeight: number;
	/**
	 * Z velocity applied when pawn tries to get out of water
	*/
	OutofWaterZ: number;
	/**
	 * Mass of pawn (for when momentum is imparted to it).
	*/
	Mass: number;
	/**
	 * If enabled, the player will interact with physics objects when walking into them.
	*/
	bEnablePhysicsInteraction: boolean;
	/**
	 * If enabled, the TouchForceFactor is applied per kg mass of the affected object.
	*/
	bTouchForceScaledToMass: boolean;
	/**
	 * If enabled, the PushForceFactor is applied per kg mass of the affected object.
	*/
	bPushForceScaledToMass: boolean;
	/**
	 * If enabled, the PushForce location is moved using PushForcePointZOffsetFactor. Otherwise simply use the impact point.
	*/
	bPushForceUsingZOffset: boolean;
	/**
	 * If enabled, the applied push force will try to get the physics object to the same velocity than the player, not faster. This will only
	 *               scale the force down, it will never apply more force than defined by PushForceFactor.
	*/
	bScalePushForceToVelocity: boolean;
	/**
	 * Force applied to objects we stand on (due to Mass and Gravity) is scaled by this amount.
	*/
	StandingDownwardForceScale: number;
	/**
	 * Initial impulse force to apply when the player bounces into a blocking physics object.
	*/
	InitialPushForceFactor: number;
	/**
	 * Force to apply when the player collides with a blocking physics object.
	*/
	PushForceFactor: number;
	/**
	 * Z-Offset for the position the force is applied to. 0.0f is the center of the physics object, 1.0f is the top and -1.0f is the bottom of the object.
	*/
	PushForcePointZOffsetFactor: number;
	/**
	 * Force to apply to physics objects that are touched by the player.
	*/
	TouchForceFactor: number;
	/**
	 * Minimum Force applied to touched physics objects. If < 0.0f, there is no minimum.
	*/
	MinTouchForce: number;
	/**
	 * Maximum force applied to touched physics objects. If < 0.0f, there is no maximum.
	*/
	MaxTouchForce: number;
	/**
	 * Force per kg applied constantly to all overlapping components.
	*/
	RepulsionForce: number;
	/**
	 * Deprecated properties
	*/
	bForceBraking: boolean;
	/**
	 * Multiplier to max ground speed to use when crouched
	*/
	CrouchedSpeedMultiplier: number;
	/**
	 * Upper Impact Normal Scale
	*/
	UpperImpactNormalScale: number;
	/**
	 * Current acceleration vector (with magnitude).
	 * This is calculated each update based on the input vector and the constraints of MaxAcceleration and the current movement mode.
	*/
	Acceleration: Vector;
	/**
	 * Location after last PerformMovement or SimulateMovement update. Used internally to detect changes in position from outside character movement to try to validate the current floor.
	*/
	LastUpdateLocation: Vector;
	/**
	 * Rotation after last PerformMovement or SimulateMovement update.
	*/
	LastUpdateRotation: Quat;
	/**
	 * Velocity after last PerformMovement or SimulateMovement update. Used internally to detect changes in velocity from external sources.
	*/
	LastUpdateVelocity: Vector;
	/**
	 * Timestamp when location or rotation last changed during an update. Only valid on the server.
	*/
	ServerLastTransformUpdateTimeStamp: number;
	/**
	 * Accumulated impulse to be added next tick.
	*/
	PendingImpulseToApply: Vector;
	/**
	 * Accumulated force to be added next tick.
	*/
	PendingForceToApply: Vector;
	/**
	 * Modifier to applied to values such as acceleration and max speed due to analog input.
	*/
	AnalogInputModifier: number;
	/**
	 * Max time delta for each discrete simulation step.
	 * Used primarily in the the more advanced movement modes that break up larger time steps (usually those applying gravity such as falling and walking).
	 * Lowering this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.
	 * WARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.
	 * @see MaxSimulationIterations
	*/
	MaxSimulationTimeStep: number;
	/**
	 * Max number of iterations used for each discrete simulation step.
	 * Used primarily in the the more advanced movement modes that break up larger time steps (usually those applying gravity such as falling and walking).
	 * Increasing this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.
	 * WARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.
	 * @see MaxSimulationTimeStep
	*/
	MaxSimulationIterations: number;
	/**
	 * Max distance we allow simulated proxies to depenetrate when moving out of anything but Pawns.
	 * This is generally more tolerant than with Pawns, because other geometry is either not moving, or is moving predictably with a bit of delay compared to on the server.
	 * @see MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawn, MaxDepenetrationWithPawnAsProxy
	*/
	MaxDepenetrationWithGeometry: number;
	/**
	 * Max distance we allow simulated proxies to depenetrate when moving out of anything but Pawns.
	 * This is generally more tolerant than with Pawns, because other geometry is either not moving, or is moving predictably with a bit of delay compared to on the server.
	 * @see MaxDepenetrationWithGeometry, MaxDepenetrationWithPawn, MaxDepenetrationWithPawnAsProxy
	*/
	MaxDepenetrationWithGeometryAsProxy: number;
	/**
	 * Max distance we are allowed to depenetrate when moving out of other Pawns.
	 * @see MaxDepenetrationWithGeometry, MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawnAsProxy
	*/
	MaxDepenetrationWithPawn: number;
	/**
	 * Max distance we allow simulated proxies to depenetrate when moving out of other Pawns.
	 * Typically we don't want a large value, because we receive a server authoritative position that we should not then ignore by pushing them out of the local player.
	 * @see MaxDepenetrationWithGeometry, MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawn
	*/
	MaxDepenetrationWithPawnAsProxy: number;
	/**
	 * How long to take to smoothly interpolate from the old pawn position on the client to the corrected one sent by the server. Not used by Linear smoothing.
	*/
	NetworkSimulatedSmoothLocationTime: number;
	/**
	 * How long to take to smoothly interpolate from the old pawn rotation on the client to the corrected one sent by the server. Not used by Linear smoothing.
	*/
	NetworkSimulatedSmoothRotationTime: number;
	/**
	 * Similar setting as NetworkSimulatedSmoothLocationTime but only used on Listen servers.
	*/
	ListenServerNetworkSimulatedSmoothLocationTime: number;
	/**
	 * Similar setting as NetworkSimulatedSmoothRotationTime but only used on Listen servers.
	*/
	ListenServerNetworkSimulatedSmoothRotationTime: number;
	/**
	 * Maximum distance character is allowed to lag behind server location when interpolating between updates.
	*/
	NetworkMaxSmoothUpdateDistance: number;
	/**
	 * Maximum distance beyond which character is teleported to the new server location without any smoothing.
	*/
	NetworkNoSmoothUpdateDistance: number;
	/**
	 * Smoothing mode for simulated proxies in network game.
	*/
	NetworkSmoothingMode: ENetworkSmoothingMode;
	/**
	 * Used in determining if pawn is going off ledge.  If the ledge is "shorter" than this value then the pawn will be able to walk off it. *
	*/
	LedgeCheckThreshold: number;
	/**
	 * When exiting water, jump if control pitch angle is this high or above.
	*/
	JumpOutOfWaterPitch: number;
	/**
	 * Information about the floor the Character is standing on (updated only during walking movement).
	*/
	CurrentFloor: FindFloorResult;
	/**
	 * Default movement mode when not in water. Used at player startup or when teleported.
	 * @see DefaultWaterMovementMode
	 * @see bRunPhysicsWithNoController
	*/
	DefaultLandMovementMode: EMovementMode;
	/**
	 * Default movement mode when in water. Used at player startup or when teleported.
	 * @see DefaultLandMovementMode
	 * @see bRunPhysicsWithNoController
	*/
	DefaultWaterMovementMode: EMovementMode;
	/**
	 * Ground movement mode to switch to after falling and resuming ground movement.
	 * Only allowed values are: MOVE_Walking, MOVE_NavWalking.
	 * @see SetGroundMovementMode(), GetGroundMovementMode()
	*/
	GroundMovementMode: EMovementMode;
	/**
	 * If true, walking movement always maintains horizontal velocity when moving up ramps, which causes movement up ramps to be faster parallel to the ramp surface.
	 * If false, then walking movement maintains velocity magnitude parallel to the ramp surface.
	*/
	bMaintainHorizontalGroundVelocity: boolean;
	/**
	 * If true, impart the base actor's X velocity when falling off it (which includes jumping)
	*/
	bImpartBaseVelocityX: boolean;
	/**
	 * If true, impart the base actor's Y velocity when falling off it (which includes jumping)
	*/
	bImpartBaseVelocityY: boolean;
	/**
	 * If true, impart the base actor's Z velocity when falling off it (which includes jumping)
	*/
	bImpartBaseVelocityZ: boolean;
	/**
	 * If true, impart the base component's tangential components of angular velocity when jumping or falling off it.
	 * Only those components of the velocity allowed by the separate component settings (bImpartBaseVelocityX etc) will be applied.
	 * @see bImpartBaseVelocityX, bImpartBaseVelocityY, bImpartBaseVelocityZ
	*/
	bImpartBaseAngularVelocity: boolean;
	/**
	 * Used by movement code to determine if a change in position is based on normal movement or a teleport. If not a teleport, velocity can be recomputed based on the change in position.
	*/
	bJustTeleported: boolean;
	/**
	 * True when a network replication update is received for simulated proxies.
	*/
	bNetworkUpdateReceived: boolean;
	/**
	 * True when the networked movement mode has been replicated.
	*/
	bNetworkMovementModeChanged: boolean;
	/**
	 * True when we should ignore server location difference checks for client error on this movement component
	 * This can be useful when character is moving at extreme speeds for a duration and you need it to look
	 * smooth on clients. Make sure to disable when done, as this would break this character's server-client
	 * movement correction.
	*/
	bIgnoreClientMovementErrorChecksAndCorrection: boolean;
	/**
	 * If true, event NotifyJumpApex() to CharacterOwner's controller when at apex of jump. Is cleared when event is triggered.
	 * By default this is off, and if you want the event to fire you typically set it to true when movement mode changes to "Falling" from another mode (see OnMovementModeChanged).
	*/
	bNotifyApex: boolean;
	/**
	 * Instantly stop when in flying mode and no acceleration is being applied.
	*/
	bCheatFlying: boolean;
	/**
	 * If true, try to crouch (or keep crouching) on next update. If false, try to stop crouching on next update.
	*/
	bWantsToCrouch: boolean;
	/**
	 * If true, crouching should keep the base of the capsule in place by lowering the center of the shrunken capsule. If false, the base of the capsule moves up and the center stays in place.
	 * The same behavior applies when the character uncrouches: if true, the base is kept in the same location and the center moves up. If false, the capsule grows and only moves up if the base impacts something.
	 * By default this variable is set when the movement mode changes: set to true when walking and false otherwise. Feel free to override the behavior when the movement mode changes.
	*/
	bCrouchMaintainsBaseLocation: boolean;
	/**
	 * Whether the character ignores changes in rotation of the base it is standing on.
	 * If true, the character maintains current world rotation.
	 * If false, the character rotates with the moving base.
	*/
	bIgnoreBaseRotation: boolean;
	/**
	 * Set this to true if riding on a moving base that you know is clear from non-moving world obstructions.
	 * Optimization to avoid sweeps during based movement, use with care.
	*/
	bFastAttachedMove: boolean;
	/**
	 * Whether we always force floor checks for stationary Characters while walking.
	 * Normally floor checks are avoided if possible when not moving, but this can be used to force them if there are use-cases where they are being skipped erroneously
	 * (such as objects moving up into the character from below).
	*/
	bAlwaysCheckFloor: boolean;
	/**
	 * Performs floor checks as if the character is using a shape with a flat base.
	 * This avoids the situation where characters slowly lower off the side of a ledge (as their capsule 'balances' on the edge).
	*/
	bUseFlatBaseForFloorChecks: boolean;
	/**
	 * Used to prevent reentry of JumpOff()
	*/
	bPerformingJumpOff: boolean;
	/**
	 * Used to safely leave NavWalking movement mode
	*/
	bWantsToLeaveNavWalking: boolean;
	/**
	 * If set, component will use RVO avoidance. This only runs on the server.
	*/
	bUseRVOAvoidance: boolean;
	/**
	 * Should use acceleration for path following?
	 * If true, acceleration is applied when path following to reach the target velocity.
	 * If false, path following velocity is set directly, disregarding acceleration.
	*/
	bRequestedMoveUseAcceleration: boolean;
	/**
	 * Was velocity requested by path following?
	*/
	bHasRequestedVelocity: boolean;
	/**
	 * Was acceleration requested to be always max speed?
	*/
	bRequestedMoveWithMaxSpeed: boolean;
	/**
	 * Was avoidance updated in this frame?
	*/
	bWasAvoidanceUpdated: boolean;
	/**
	 * Whether to raycast to underlying geometry to better conform navmesh-walking characters
	*/
	bProjectNavMeshWalking: boolean;
	/**
	 * Use both WorldStatic and WorldDynamic channels for NavWalking geometry conforming
	*/
	bProjectNavMeshOnBothWorldChannels: boolean;
	/**
	 * Avoidance Consideration Radius
	*/
	AvoidanceConsiderationRadius: number;
	/**
	 * Velocity requested by path following.
	 * @see RequestDirectMove()
	*/
	RequestedVelocity: Vector;
	/**
	 * No default value, for now it's assumed to be valid if GetAvoidanceManager() returns non-NULL.
	*/
	AvoidanceUID: number;
	/**
	 * Moving actor's group mask
	*/
	AvoidanceGroup: NavAvoidanceMask;
	/**
	 * Will avoid other agents if they are in one of specified groups
	*/
	GroupsToAvoid: NavAvoidanceMask;
	/**
	 * Will NOT avoid other agents if they are in one of specified groups, higher priority than GroupsToAvoid
	*/
	GroupsToIgnore: NavAvoidanceMask;
	/**
	 * De facto default value 0.5 (due to that being the default in the avoidance registration function), indicates RVO behavior.
	*/
	AvoidanceWeight: number;
	/**
	 * Temporarily holds launch velocity when pawn is to be launched so it happens at end of movement.
	*/
	PendingLaunchVelocity: Vector;
	/**
	 * How often we should raycast to project from navmesh to underlying geometry
	*/
	NavMeshProjectionInterval: number;
	/**
	 * Nav Mesh Projection Timer
	*/
	NavMeshProjectionTimer: number;
	/**
	 * Speed at which to interpolate agent navmesh offset between traces. 0: Instant (no interp) > 0: Interp speed")
	*/
	NavMeshProjectionInterpSpeed: number;
	/**
	 * Scale of the total capsule height to use for projection from navmesh to underlying geometry in the upward direction.
	 * In other words, start the trace at [CapsuleHeight * NavMeshProjectionHeightScaleUp] above nav mesh.
	*/
	NavMeshProjectionHeightScaleUp: number;
	/**
	 * Scale of the total capsule height to use for projection from navmesh to underlying geometry in the downward direction.
	 * In other words, trace down to [CapsuleHeight * NavMeshProjectionHeightScaleDown] below nav mesh.
	*/
	NavMeshProjectionHeightScaleDown: number;
	/**
	 * Post-physics tick function for this character
	*/
	PostPhysicsTickFunction: CharacterMovementComponentPostPhysicsTickFunction;
	/**
	 * Minimum time between client TimeStamp resets.
	 *        !! This has to be large enough so that we don't confuse the server if the client can stall or timeout.
	 *        We do this as we use floats for TimeStamps, and server derives DeltaTime from two TimeStamps.
	 *        As time goes on, accuracy decreases from those floating point numbers.
	 *        So we trigger a TimeStamp reset at regular intervals to maintain a high level of accuracy.
	*/
	MinTimeBetweenTimeStampResets: number;
	/**
	 * Root Motion Group containing active root motion sources being applied to movement
	*/
	CurrentRootMotion: RootMotionSourceGroup;
	/**
	 * Root Motion movement params. Holds result of anim montage root motion during PerformMovement(), and is overridden
	 *  during autonomous move playback to force historical root motion for MoveAutonomous() calls
	*/
	RootMotionParams: RootMotionMovementParams;
	/**
	 * Velocity extracted from RootMotionParams when there is anim root motion active. Invalid to use when HasAnimRootMotion() returns false.
	*/
	AnimRootMotionVelocity: Vector;
	/**
	 * True when SimulatedProxies are simulating RootMotion
	*/
	bWasSimulatingRootMotion: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CharacterMovementComponent;
	static Find(Outer: UObject, ResourceName: string): CharacterMovementComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CharacterMovementComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CharacterMovementComponent;
	/**
	 * Set the Z component of the normal of the steepest walkable surface for the character. Also computes WalkableFloorAngle.
	*/
	SetWalkableFloorZ(InWalkableFloorZ: number): void;
	/**
	 * Set the max angle in degrees of a walkable surface for the character. Also computes WalkableFloorZ.
	*/
	SetWalkableFloorAngle(InWalkableFloorAngle: number): void;
	/**
	 * Change movement mode.
	 * @param NewMovementMode       The new movement mode
	 * @param NewCustomMode         The new custom sub-mode, only applicable if NewMovementMode is Custom.
	*/
	SetMovementMode(NewMovementMode: EMovementMode,NewCustomMode: number): void;
	/**
	 * Set Groups to Ignore
	*/
	SetGroupsToIgnore(GroupFlags: number): void;
	/**
	 * Set Groups to Avoid
	*/
	SetGroupsToAvoid(GroupFlags: number): void;
	/**
	 * Set Avoidance Group
	*/
	SetAvoidanceGroup(GroupFlags: number): void;
	/**
	 * Change avoidance state and registers in RVO manager if needed
	*/
	SetAvoidanceEnabled(bEnable: boolean): void;
	/**
	 * Resending an (important) old move. Process it if not already processed.
	*/
	ServerMoveOld(OldTimeStamp: number,OldAccel: Vector_NetQuantize10,OldMoveFlags: number): void;
	/**
	 * Replicated function sent by client to server - contains client movement and view info for two moves. First move is non root motion, second is root motion.
	*/
	ServerMoveDualHybridRootMotion(TimeStamp0: number,InAccel0: Vector_NetQuantize10,PendingFlags: number,View0: any,TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,NewFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	/**
	 * Replicated function sent by client to server - contains client movement and view info for two moves.
	*/
	ServerMoveDual(TimeStamp0: number,InAccel0: Vector_NetQuantize10,PendingFlags: number,View0: any,TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,NewFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	/**
	 * Replicated function sent by client to server - contains client movement and view info.
	*/
	ServerMove(TimeStamp: number,InAccel: Vector_NetQuantize10,ClientLoc: Vector_NetQuantize100,CompressedMoveFlags: number,ClientRoll: number,View: any,ClientMovementBase: PrimitiveComponent,ClientBaseBoneName: string,ClientMovementMode: number): void;
	/**
	 * Get the Z component of the normal of the steepest walkable surface for the character. Any lower than this and it is not walkable.
	*/
	GetWalkableFloorZ(): number;
	/**
	 * Get the max angle in degrees of a walkable surface for the character.
	*/
	GetWalkableFloorAngle(): number;
	/**
	 * @return Maximum acceleration for the current state, based on MaxAcceleration and any additional modifiers.
	*/
	GetModifiedMaxAcceleration(): number;
	/**
	 * @return true if the character is in the 'Walking' movement mode.
	*/
	IsWalking(): boolean;
	/**
	 * Return true if the hit result should be considered a walkable surface for the character.
	*/
	IsWalkable(Hit: HitResult): boolean;
	/**
	 * Returns the radius within which we can stand on the edge of a surface without falling (if this is a walkable surface).
	 * Simply computed as the capsule radius minus the result of GetPerchRadiusThreshold().
	*/
	GetValidPerchRadius(): number;
	/**
	 * @return The distance from the edge of the capsule within which we don't allow the character to perch on the edge of a surface.
	*/
	GetPerchRadiusThreshold(): number;
	/**
	 * Return PrimitiveComponent we are based on (standing and walking on).
	*/
	GetMovementBase(): PrimitiveComponent;
	/**
	 * Compute the max jump height based on the JumpZVelocity velocity and gravity.
	*/
	GetMaxJumpHeight(): number;
	/**
	 * @return Maximum acceleration for the current state.
	*/
	GetMaxAcceleration(): number;
	/**
	 * If we have a movement base, get the velocity that should be imparted by that base, usually when jumping off of it.
	 * Only applies the components of the velocity enabled by bImpartBaseVelocityX, bImpartBaseVelocityY, bImpartBaseVelocityZ.
	*/
	GetImpartedMovementBaseVelocity(): Vector;
	/**
	 * @return Current acceleration, computed from input vector each update.
	*/
	GetCurrentAcceleration(): Vector;
	/**
	 * Get the Character that owns UpdatedComponent.
	*/
	GetCharacterOwner(): Character;
	/**
	 * @return Modifier [0..1] based on the magnitude of the last input vector, which is used to modify the acceleration and max speed during movement.
	*/
	GetAnalogInputModifier(): number;
	/**
	 * Make movement impossible (sets movement mode to MOVE_None).
	*/
	DisableMovement(): void;
	/**
	 * Bandwidth saving version, when velocity is zeroed
	*/
	ClientVeryShortAdjustPosition(TimeStamp: number,NewLoc: Vector,NewBase: PrimitiveComponent,NewBaseBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	/**
	 * Replicate root motion source correction to client when using root motion for movement.
	*/
	ClientAdjustRootMotionSourcePosition(TimeStamp: number,ServerRootMotion: RootMotionSourceGroup,bHasAnimRootMotion: boolean,ServerMontageTrackPosition: number,ServerLoc: Vector,ServerRotation: Vector_NetQuantizeNormal,ServerVelZ: number,ServerBase: PrimitiveComponent,ServerBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	/**
	 * Replicate position correction to client when using root motion for movement. (animation root motion specific)
	*/
	ClientAdjustRootMotionPosition(TimeStamp: number,ServerMontageTrackPosition: number,ServerLoc: Vector,ServerRotation: Vector_NetQuantizeNormal,ServerVelZ: number,ServerBase: PrimitiveComponent,ServerBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	/**
	 * Replicate position correction to client, associated with a timestamped servermove.  Client will replay subsequent moves after applying adjustment.
	*/
	ClientAdjustPosition(TimeStamp: number,NewLoc: Vector,NewVel: Vector,NewBase: PrimitiveComponent,NewBaseBoneName: string,bHasBase: boolean,bBaseRelativePosition: boolean,ServerMovementMode: number): void;
	/**
	 * If no client adjustment is needed after processing received ServerMove(), ack the good move so client can remove it from SavedMoves
	*/
	ClientAckGoodMove(TimeStamp: number): void;
	/**
	 * Called when the collision capsule touches another primitive component
	*/
	CapsuleTouched(OverlappedComp: PrimitiveComponent,Other: Actor,OtherComp: PrimitiveComponent,OtherBodyIndex: number,bFromSweep: boolean,SweepResult: HitResult): void;
	/**
	 * Updates Velocity and Acceleration based on the current state, applying the effects of friction and acceleration or deceleration. Does not apply gravity.
	 * This is used internally during movement updates. Normally you don't need to call this from outside code, but you might want to use it for custom movement modes.
	 * @param       DeltaTime                                               time elapsed since last frame.
	 * @param       Friction                                                coefficient of friction when not accelerating, or in the direction opposite acceleration.
	 * @param       bFluid                                                  true if moving through a fluid, causing Friction to always be applied regardless of acceleration.
	 * @param       BrakingDeceleration                             deceleration applied when not accelerating, or when exceeding max velocity.
	*/
	CalcVelocity(DeltaTime: number,Friction: number,bFluid: boolean,BrakingDeceleration: number): void;
	/**
	 * Add impulse to character. Impulses are accumulated each tick and applied together
	 * so multiple calls to this function will accumulate.
	 * An impulse is an instantaneous force, usually applied once. If you want to continually apply
	 * forces each frame, use AddForce().
	 * Note that changing the momentum of characters like this can change the movement mode.
	 * @param       Impulse                         Impulse to apply.
	 * @param       bVelocityChange         Whether or not the impulse is relative to mass.
	*/
	AddImpulse(Impulse: Vector,bVelocityChange: boolean): void;
	/**
	 * Add force to character. Forces are accumulated each tick and applied together
	 * so multiple calls to this function will accumulate.
	 * Forces are scaled depending on timestep, so they can be applied each frame. If you want an
	 * instantaneous force, use AddImpulse.
	 * Adding a force always takes the actor's mass into account.
	 * Note that changing the momentum of characters like this can change the movement mode.
	 * @param       Force                   Force to apply.
	*/
	AddForce(Force: Vector): void;
	static C(Other: UObject): CharacterMovementComponent;
}

declare class NavAgentSelector { 
	/**
	 * Supports Agent 0
	*/
	bSupportsAgent0: boolean;
	/**
	 * Supports Agent 1
	*/
	bSupportsAgent1: boolean;
	/**
	 * Supports Agent 2
	*/
	bSupportsAgent2: boolean;
	/**
	 * Supports Agent 3
	*/
	bSupportsAgent3: boolean;
	/**
	 * Supports Agent 4
	*/
	bSupportsAgent4: boolean;
	/**
	 * Supports Agent 5
	*/
	bSupportsAgent5: boolean;
	/**
	 * Supports Agent 6
	*/
	bSupportsAgent6: boolean;
	/**
	 * Supports Agent 7
	*/
	bSupportsAgent7: boolean;
	/**
	 * Supports Agent 8
	*/
	bSupportsAgent8: boolean;
	/**
	 * Supports Agent 9
	*/
	bSupportsAgent9: boolean;
	/**
	 * Supports Agent 10
	*/
	bSupportsAgent10: boolean;
	/**
	 * Supports Agent 11
	*/
	bSupportsAgent11: boolean;
	/**
	 * Supports Agent 12
	*/
	bSupportsAgent12: boolean;
	/**
	 * Supports Agent 13
	*/
	bSupportsAgent13: boolean;
	/**
	 * Supports Agent 14
	*/
	bSupportsAgent14: boolean;
	/**
	 * Supports Agent 15
	*/
	bSupportsAgent15: boolean;
	clone() : NavAgentSelector;
	static C(Other: UObject): NavAgentSelector;
}

declare class NavArea extends UObject { 
	/**
	 * travel cost multiplier for path distance
	*/
	DefaultCost: number;
	/**
	 * entering cost
	*/
	FixedAreaEnteringCost: number;
	/**
	 * area color in navigation view
	*/
	DrawColor: Color;
	/**
	 * restrict area only to specified agents
	*/
	SupportedAgents: NavAgentSelector;
	/**
	 * DEPRECATED AGENT CONFIG
	*/
	bSupportsAgent0: boolean;
	/**
	 * Supports Agent 1
	*/
	bSupportsAgent1: boolean;
	/**
	 * Supports Agent 2
	*/
	bSupportsAgent2: boolean;
	/**
	 * Supports Agent 3
	*/
	bSupportsAgent3: boolean;
	/**
	 * Supports Agent 4
	*/
	bSupportsAgent4: boolean;
	/**
	 * Supports Agent 5
	*/
	bSupportsAgent5: boolean;
	/**
	 * Supports Agent 6
	*/
	bSupportsAgent6: boolean;
	/**
	 * Supports Agent 7
	*/
	bSupportsAgent7: boolean;
	/**
	 * Supports Agent 8
	*/
	bSupportsAgent8: boolean;
	/**
	 * Supports Agent 9
	*/
	bSupportsAgent9: boolean;
	/**
	 * Supports Agent 10
	*/
	bSupportsAgent10: boolean;
	/**
	 * Supports Agent 11
	*/
	bSupportsAgent11: boolean;
	/**
	 * Supports Agent 12
	*/
	bSupportsAgent12: boolean;
	/**
	 * Supports Agent 13
	*/
	bSupportsAgent13: boolean;
	/**
	 * Supports Agent 14
	*/
	bSupportsAgent14: boolean;
	/**
	 * Supports Agent 15
	*/
	bSupportsAgent15: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavArea;
	static Find(Outer: UObject, ResourceName: string): NavArea;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavArea;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavArea;
	static C(Other: UObject): NavArea;
}

declare class ShapeComponent extends PrimitiveComponent { 
	/**
	 * Color used to draw the shape.
	*/
	ShapeColor: Color;
	/**
	 * Description of collision
	*/
	ShapeBodySetup: BodySetup;
	/**
	 * Only show this component if the actor is selected
	*/
	bDrawOnlyIfSelected: boolean;
	/**
	 * If true it allows Collision when placing even if collision is not enabled
	*/
	bShouldCollideWhenPlacing: boolean;
	/**
	 * If set, shape will be exported for navigation as dynamic modifier instead of using regular collision data
	*/
	bDynamicObstacle: boolean;
	/**
	 * Navigation area type (empty = default obstacle)
	*/
	AreaClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ShapeComponent;
	static Find(Outer: UObject, ResourceName: string): ShapeComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ShapeComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ShapeComponent;
	static C(Other: UObject): ShapeComponent;
}

declare class CapsuleComponent extends ShapeComponent { 
	/**
	 * Half-height, from center of capsule to the end of top or bottom hemisphere.
	 * This cannot be less than CapsuleRadius.
	*/
	CapsuleHalfHeight: number;
	/**
	 * Radius of cap hemispheres and center cylinder.
	 * This cannot be more than CapsuleHalfHeight.
	*/
	CapsuleRadius: number;
	/**
	 * Capsule Height
	*/
	CapsuleHeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CapsuleComponent;
	static Find(Outer: UObject, ResourceName: string): CapsuleComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CapsuleComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CapsuleComponent;
	/**
	 * Change the capsule size. This is the unscaled size, before component scale is applied.
	 * @param       InRadius : radius of end-cap hemispheres and center cylinder.
	 * @param       InHalfHeight : half-height, from capsule center to end of top or bottom hemisphere.
	 * @param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor.
	*/
	SetCapsuleSize(InRadius: number,InHalfHeight: number,bUpdateOverlaps: boolean): void;
	/**
	 * Set the capsule radius. This is the unscaled radius, before component scale is applied.
	 * If this capsule collides, updates touching array for owner actor.
	 * @param       Radius : radius of end-cap hemispheres and center cylinder.
	 * @param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor.
	*/
	SetCapsuleRadius(Radius: number,bUpdateOverlaps: boolean): void;
	/**
	 * Set the capsule half-height. This is the unscaled half-height, before component scale is applied.
	 * If this capsule collides, updates touching array for owner actor.
	 * @param       HalfHeight : half-height, from capsule center to end of top or bottom hemisphere.
	 * @param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor.
	*/
	SetCapsuleHalfHeight(HalfHeight: number,bUpdateOverlaps: boolean): void;
	/**
	 * Returns the capsule radius and half-height, ignoring component scaling. Half-height excludes the hemisphere end cap.
	 * @param OutRadius Radius of the capsule, ignoring component scaling.
	 * @param OutHalfHeightWithoutHemisphere Half-height of the capsule, scaled by the component scale. Excludes the hemisphere end cap.
	 * @return The capsule radius and half-height (excluding hemisphere end cap), ignoring component scaling.
	*/
	GetUnscaledCapsuleSize_WithoutHemisphere(OutRadius?: number,OutHalfHeightWithoutHemisphere?: number): {OutRadius: number, OutHalfHeightWithoutHemisphere: number};
	/**
	 * Returns the capsule radius and half-height scaled by the component scale. Half-height includes the hemisphere end cap.
	 * @param OutRadius Radius of the capsule, scaled by the component scale.
	 * @param OutHalfHeight Half-height of the capsule, scaled by the component scale. Includes the hemisphere end cap.
	 * @return The capsule radius and half-height scaled by the component scale.
	*/
	GetUnscaledCapsuleSize(OutRadius?: number,OutHalfHeight?: number): {OutRadius: number, OutHalfHeight: number};
	/**
	 * Returns the capsule radius, ignoring component scaling.
	 * @return the capsule radius, ignoring component scaling.
	*/
	GetUnscaledCapsuleRadius(): number;
	/**
	 * Returns the capsule half-height minus radius (to exclude the hemisphere), ignoring component scaling. This excludes the hemisphere end cap.
	 * From the center of the capsule this is the vertical distance along the straight cylindrical portion to the point just before the curve of top hemisphere begins.
	 * @return The capsule half-height minus radius, ignoring component scaling.
	*/
	GetUnscaledCapsuleHalfHeight_WithoutHemisphere(): number;
	/**
	 * Returns the capsule half-height, ignoring component scaling. This includes the hemisphere end cap.
	 * @return The capsule radius, ignoring component scaling.
	*/
	GetUnscaledCapsuleHalfHeight(): number;
	/**
	 * Get the scale used by this shape. This is a uniform scale that is the minimum of any non-uniform scaling.
	 * @return the scale used by this shape.
	*/
	GetShapeScale(): number;
	/**
	 * Returns the capsule radius and half-height scaled by the component scale. Half-height excludes the hemisphere end cap.
	 * @param OutRadius Radius of the capsule, ignoring component scaling.
	 * @param OutHalfHeightWithoutHemisphere Half-height of the capsule, scaled by the component scale. Excludes the hemisphere end cap.
	 * @return The capsule radius and half-height scaled by the component scale.
	*/
	GetScaledCapsuleSize_WithoutHemisphere(OutRadius?: number,OutHalfHeightWithoutHemisphere?: number): {OutRadius: number, OutHalfHeightWithoutHemisphere: number};
	/**
	 * Returns the capsule radius and half-height scaled by the component scale. Half-height includes the hemisphere end cap.
	 * @param OutRadius Radius of the capsule, scaled by the component scale.
	 * @param OutHalfHeight Half-height of the capsule, scaled by the component scale. Includes the hemisphere end cap.
	 * @return The capsule radius and half-height scaled by the component scale.
	*/
	GetScaledCapsuleSize(OutRadius?: number,OutHalfHeight?: number): {OutRadius: number, OutHalfHeight: number};
	/**
	 * Returns the capsule radius scaled by the component scale.
	 * @return The capsule radius scaled by the component scale.
	*/
	GetScaledCapsuleRadius(): number;
	/**
	 * Returns the capsule half-height minus radius (to exclude the hemisphere), scaled by the component scale.
	 * From the center of the capsule this is the vertical distance along the straight cylindrical portion to the point just before the curve of top hemisphere begins.
	 * @return The capsule half-height minus radius, scaled by the component scale.
	*/
	GetScaledCapsuleHalfHeight_WithoutHemisphere(): number;
	/**
	 * Returns the capsule half-height scaled by the component scale. This includes both the cylinder and hemisphere cap.
	 * @return The capsule half-height scaled by the component scale.
	*/
	GetScaledCapsuleHalfHeight(): number;
	static C(Other: UObject): CapsuleComponent;
}

declare class BasedMovementInfo { 
	/**
	 * Component we are based on
	*/
	MovementBase: PrimitiveComponent;
	/**
	 * Bone name on component, for skeletal meshes. NAME_None if not a skeletal mesh or if bone is invalid.
	*/
	BoneName: string;
	/**
	 * Location relative to MovementBase. Only valid if HasRelativeLocation() is true.
	*/
	Location: Vector_NetQuantize100;
	/**
	 * Rotation: relative to MovementBase if HasRelativeRotation() is true, absolute otherwise.
	*/
	Rotation: Rotator;
	/**
	 * Whether the server says that there is a base. On clients, the component may not have resolved yet.
	*/
	bServerHasBaseComponent: boolean;
	/**
	 * Whether rotation is relative to the base or absolute. It can only be relative if location is also relative.
	*/
	bRelativeRotation: boolean;
	/**
	 * Whether there is a velocity on the server. Used for forcing replication when velocity goes to zero.
	*/
	bServerHasVelocity: boolean;
	clone() : BasedMovementInfo;
	static C(Other: UObject): BasedMovementInfo;
}

declare class RepRootMotionMontage { 
	/**
	 * Whether this has useful/active data.
	*/
	bIsActive: boolean;
	/**
	 * AnimMontage providing Root Motion
	*/
	AnimMontage: AnimMontage;
	/**
	 * Track position of Montage
	*/
	Position: number;
	/**
	 * Location
	*/
	Location: Vector_NetQuantize100;
	/**
	 * Rotation
	*/
	Rotation: Rotator;
	/**
	 * Movement Relative to Base
	*/
	MovementBase: PrimitiveComponent;
	/**
	 * Bone on the MovementBase, if a skeletal mesh.
	*/
	MovementBaseBoneName: string;
	/**
	 * Additional replicated flag, if MovementBase can't be resolved on the client. So we don't use wrong data.
	*/
	bRelativePosition: boolean;
	/**
	 * Whether rotation is relative or absolute.
	*/
	bRelativeRotation: boolean;
	/**
	 * State of Root Motion Sources on Authority
	*/
	AuthoritativeRootMotion: RootMotionSourceGroup;
	/**
	 * Acceleration
	*/
	Acceleration: Vector_NetQuantize10;
	/**
	 * Velocity
	*/
	LinearVelocity: Vector_NetQuantize10;
	clone() : RepRootMotionMontage;
	static C(Other: UObject): RepRootMotionMontage;
}

declare class SimulatedRootMotionReplicatedMove { 
	/**
	 * Local time when move was received on client and saved.
	*/
	Time: number;
	/**
	 * Root Motion information
	*/
	RootMotion: RepRootMotionMontage;
	clone() : SimulatedRootMotionReplicatedMove;
	static C(Other: UObject): SimulatedRootMotionReplicatedMove;
}

declare class Character extends Pawn { 
	/**
	 * The main skeletal mesh associated with this Character (optional sub-object).
	*/
	Mesh: SkeletalMeshComponent;
	/**
	 * Arrow Component
	*/
	ArrowComponent: ArrowComponent;
	/**
	 * Movement component used for movement logic in various movement modes (walking, falling, etc), containing relevant settings and functions to control movement.
	*/
	CharacterMovement: CharacterMovementComponent;
	/**
	 * The CapsuleComponent being used for movement collision (by CharacterMovement). Always treated as being vertically aligned in simple collision check functions.
	*/
	CapsuleComponent: CapsuleComponent;
	/**
	 * Info about our current movement base (object we are standing on).
	*/
	BasedMovement: BasedMovementInfo;
	/**
	 * Replicated version of relative movement. Read-only on simulated proxies!
	*/
	ReplicatedBasedMovement: BasedMovementInfo;
	/**
	 * Scale to apply to root motion translation on this Character
	*/
	AnimRootMotionTranslationScale: number;
	/**
	 * Saved translation offset of mesh.
	*/
	BaseTranslationOffset: Vector;
	/**
	 * Saved rotation offset of mesh.
	*/
	BaseRotationOffset: Quat;
	/**
	 * CharacterMovement ServerLastTransformUpdateTimeStamp value, replicated to simulated proxies.
	*/
	ReplicatedServerLastTransformUpdateTimeStamp: number;
	/**
	 * CharacterMovement MovementMode (and custom mode) replicated for simulated proxies. Use CharacterMovementComponent::UnpackNetworkMovementMode() to translate it.
	*/
	ReplicatedMovementMode: number;
	/**
	 * Flag that we are receiving replication of the based movement.
	*/
	bInBaseReplication: boolean;
	/**
	 * Default crouched eye height
	*/
	CrouchedEyeHeight: number;
	/**
	 * Set by character movement to specify that this Character is currently crouched.
	*/
	bIsCrouched: boolean;
	/**
	 * Replay Has Root Motion Sources
	*/
	bReplayHasRootMotionSources: boolean;
	/**
	 * When true, player wants to jump
	*/
	bPressedJump: boolean;
	/**
	 * When true, applying updates to network client (replaying saved moves for a locally controlled character)
	*/
	bClientUpdating: boolean;
	/**
	 * True if Pawn was initially falling when started to replay network moves.
	*/
	bClientWasFalling: boolean;
	/**
	 * If server disagrees with root motion track position, client has to resimulate root motion from last AckedMove.
	*/
	bClientResimulateRootMotion: boolean;
	/**
	 * If server disagrees with root motion state, client has to resimulate root motion from last AckedMove.
	*/
	bClientResimulateRootMotionSources: boolean;
	/**
	 * Disable simulated gravity (set when character encroaches geometry on client, to keep him from falling through floors)
	*/
	bSimGravityDisabled: boolean;
	/**
	 * Client Check Encroachment on Net Update
	*/
	bClientCheckEncroachmentOnNetUpdate: boolean;
	/**
	 * Disable root motion on the server. When receiving a DualServerMove, where the first move is not root motion and the second is.
	*/
	bServerMoveIgnoreRootMotion: boolean;
	/**
	 * Jump key Held Time.
	 * This is the time that the player has held the jump key, in seconds.
	*/
	JumpKeyHoldTime: number;
	/**
	 * The max time the jump key can be held.
	 * Note that if StopJumping() is not called before the max jump hold time is reached,
	 * then the character will carry on receiving vertical velocity. Therefore it is usually
	 * best to call StopJumping() when jump input has ceased (such as a button up event).
	*/
	JumpMaxHoldTime: number;
	/**
	 * The max number of jumps the character can perform.
	 * Note that if JumpMaxHoldTime is non zero and StopJumping is not called, the player
	 * may be able to perform and unlimited number of jumps. Therefore it is usually
	 * best to call StopJumping() when jump input has ceased (such as a button up event).
	*/
	JumpMaxCount: number;
	/**
	 * Tracks the current number of jumps performed.
	 * This is incremented in CheckJumpInput, used in CanJump_Implementation, and reset in OnMovementModeChanged.
	 * When providing overrides for these methods, it's recommended to either manually
	 * increment / reset this value, or call the Super:: method.
	*/
	JumpCurrentCount: number;
	/**
	 * Whether or not the JumpMaxCount value has been exceeded.
	 * This is set in CheckJumpInput, used in CanJump_Implementation, and reset in OnMovementModeChanged.
	 * When providing overrides for these methods, it's recommended to either manually
	 * set / reset this value, or call the Super:: method.
	*/
	bJumpMaxCountExceeded: boolean;
	/**
	 * Broadcast when Character's jump reaches its apex. Needs CharacterMovement->bNotifyApex = true
	*/
	OnReachedJumpApex: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Event triggered at the end of a CharacterMovementComponent movement update.
	 * This is the preferred event to use rather than the Tick event when performing custom updates to CharacterMovement properties based on the current state.
	 * This is mainly due to the nature of network updates, where client corrections in position from the server can cause multiple iterations of a movement update,
	 * which allows this event to update as well, while a Tick event would not.
	 * @param       DeltaSeconds            Delta time in seconds for this update
	 * @param       InitialLocation         Location at the start of the update. May be different than the current location if movement occurred.
	 * @param       InitialVelocity         Velocity at the start of the update. May be different than the current velocity.
	*/
	OnCharacterMovementUpdated: UnrealEngineMulticastDelegate<(DeltaSeconds: number, OldLocation: Vector, OldVelocity: Vector) => void>;
	/**
	 * For LocallyControlled Autonomous clients.
	 * During a PerformMovement() after root motion is prepared, we save it off into this and
	 * then record it into our SavedMoves.
	 * During SavedMove playback we use it as our "Previous Move" SavedRootMotion which includes
	 * last received root motion from the Server
	*/
	SavedRootMotion: RootMotionSourceGroup;
	/**
	 * For LocallyControlled Autonomous clients. Saved root motion data to be used by SavedMoves.
	*/
	ClientRootMotionParams: RootMotionMovementParams;
	/**
	 * Array of previously received root motion moves from the server.
	*/
	RootMotionRepMoves: SimulatedRootMotionReplicatedMove[];
	/**
	 * Replicated Root Motion montage
	*/
	RepRootMotion: RepRootMotionMontage;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Character;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Character;
	/**
	 * Request the character to stop crouching. The request is processed on the next update of the CharacterMovementComponent.
	 * @see OnEndCrouch
	 * @see IsCrouched
	 * @see CharacterMovement->WantsToCrouch
	*/
	UnCrouch(bClientSimulation: boolean): void;
	/**
	 * Stop the character from jumping on the next update.
	 * Call this from an input event (such as a button 'up' event) to cease applying
	 * jump Z-velocity. If this is not called, then jump z-velocity will be applied
	 * until JumpMaxHoldTime is reached.
	*/
	StopJumping(): void;
	/**
	 * Stop Animation Montage. If NULL, it will stop what's currently active. The Blend Out Time is taken from the montage asset that is being stopped. *
	*/
	StopAnimMontage(AnimMontage: AnimMontage): void;
	/**
	 * Set whether this actor's movement replicates to network clients.
	*/
	SetReplicateMovement(bInReplicateMovement: boolean): void;
	/**
	 * Play Animation Montage on the character mesh *
	*/
	PlayAnimMontage(AnimMontage: AnimMontage,InPlayRate: number,StartSectionName: string): number;
	/**
	 * Event fired when the Character is walking off a surface and is about to fall because CharacterMovement->CurrentFloor became unwalkable.
	 * If CharacterMovement->MovementMode does not change during this event then the character will automatically start falling afterwards.
	 * @note Z velocity is zero during walking movement, and will be here as well. Another velocity can be computed here if desired and will be used when starting to fall.
	 * @param  PreviousFloorImpactNormal Normal of the previous walkable floor.
	 * @param  PreviousFloorContactNormal Normal of the contact with the previous walkable floor.
	 * @param  PreviousLocation     Previous character location before movement off the ledge.
	 * @param  TimeTick     Time delta of movement update resulting in moving off the ledge.
	*/
	OnWalkingOffLedge(PreviousFloorImpactNormal: Vector,PreviousFloorContactNormal: Vector,PreviousLocation: Vector,TimeDelta: number): void;
	/**
	 * Handles replicated root motion properties on simulated proxies and position correction.
	*/
	OnRep_RootMotion(): void;
	/**
	 * Rep notify for ReplicatedBasedMovement
	*/
	OnRep_ReplicatedBasedMovement(): void;
	/**
	 * Handle Crouching replicated from server
	*/
	OnRep_IsCrouched(): void;
	/**
	 * Let blueprint know that we were launched
	*/
	OnLaunched(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	/**
	 * Called upon landing when falling, to perform actions based on the Hit result.
	 * Note that movement mode is still "Falling" during this event. Current Velocity value is the velocity at the time of landing.
	 * Consider OnMovementModeChanged() as well, as that can be used once the movement mode changes to the new mode (most likely Walking).
	 * @param Hit Result describing the landing that resulted in a valid landing spot.
	 * @see OnMovementModeChanged()
	*/
	OnLanded(Hit: HitResult): void;
	/**
	 * Event fired when the character has just started jumping
	*/
	OnJumped(): void;
	/**
	 * Set a pending launch velocity on the Character. This velocity will be processed on the next CharacterMovementComponent tick,
	 * and will set it to the "falling" state. Triggers the OnLaunched event.
	 * @PARAM LaunchVelocity is the velocity to impart to the Character
	 * @PARAM bXYOverride if true replace the XY part of the Character's velocity instead of adding to it.
	 * @PARAM bZOverride if true replace the Z component of the Character's velocity instead of adding to it.
	*/
	LaunchCharacter(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	/**
	 * Event for implementing custom character movement mode. Called by CharacterMovement if MovementMode is set to Custom.
	 * @note C++ code should override UCharacterMovementComponent::PhysCustom() instead.
	 * @see UCharacterMovementComponent::PhysCustom()
	*/
	UpdateCustomMovement(DeltaTime: number): void;
	/**
	 * Event when Character crouches.
	 * @param       HalfHeightAdjust                difference between default collision half-height, and actual crouched capsule half-height.
	 * @param       ScaledHalfHeightAdjust  difference after component scale is taken in to account.
	*/
	OnStartCrouch(HalfHeightAdjust: number,ScaledHalfHeightAdjust: number): void;
	/**
	 * Called from CharacterMovementComponent to notify the character that the movement mode has changed.
	 * @param       PrevMovementMode        Movement mode before the change
	 * @param       NewMovementMode         New movement mode
	 * @param       PrevCustomMode          Custom mode before the change (applicable if PrevMovementMode is Custom)
	 * @param       NewCustomMode           New custom mode (applicable if NewMovementMode is Custom)
	*/
	OnMovementModeChanged(PrevMovementMode: EMovementMode,NewMovementMode: EMovementMode,PrevCustomMode: number,NewCustomMode: number): void;
	/**
	 * Event when Character stops crouching.
	 * @param       HalfHeightAdjust                difference between default collision half-height, and actual crouched capsule half-height.
	 * @param       ScaledHalfHeightAdjust  difference after component scale is taken in to account.
	*/
	OnEndCrouch(HalfHeightAdjust: number,ScaledHalfHeightAdjust: number): void;
	/**
	 * Make the character jump on the next update.
	 * If you want your character to jump according to the time that the jump key is held,
	 * then you can set JumpKeyHoldTime to some non-zero value. Make sure in this case to
	 * call StopJumping() when you want the jump's z-velocity to stop being applied (such
	 * as on a button up event), otherwise the character will carry on receiving the
	 * velocity until JumpKeyHoldTime is reached.
	*/
	Jump(): void;
	/**
	 * true if we are playing Root Motion right now
	*/
	IsPlayingRootMotion(): boolean;
	/**
	 * true if we are playing Root Motion right now, through a Montage with RootMotionMode == ERootMotionMode::RootMotionFromMontagesOnly.
	 * This means code path for networked root motion is enabled.
	*/
	IsPlayingNetworkedRootMotionMontage(): boolean;
	/**
	 * True if jump is actively providing a force, such as when the jump key is held and the time it has been held is less than JumpMaxHoldTime.
	 * @see CharacterMovement->IsFalling
	*/
	IsJumpProvidingForce(): boolean;
	/**
	 * Return current playing Montage *
	*/
	GetCurrentMontage(): AnimMontage;
	/**
	 * Returns current value of AnimRootMotionScale
	*/
	GetAnimRootMotionTranslationScale(): number;
	/**
	 * Request the character to start crouching. The request is processed on the next update of the CharacterMovementComponent.
	 * @see OnStartCrouch
	 * @see IsCrouched
	 * @see CharacterMovement->WantsToCrouch
	*/
	Crouch(bClientSimulation: boolean): void;
	/**
	 * Client Cheat Walk
	*/
	ClientCheatWalk(): void;
	/**
	 * Client Cheat Ghost
	*/
	ClientCheatGhost(): void;
	/**
	 * Client Cheat Fly
	*/
	ClientCheatFly(): void;
	/**
	 * Customizable event to check if the character can jump in the current state.
	 * Default implementation returns true if the character is on the ground and not crouching,
	 * has a valid CharacterMovementComponent and CanEverJump() returns true.
	 * Default implementation also allows for 'hold to jump higher' functionality:
	 * As well as returning true when on the ground, it also returns true when GetMaxJumpTime is more
	 * than zero and IsJumping returns true.
	 * @Return Whether the character can jump in the current state.
	*/
	CanJump(): boolean;
	/**
	 * Check if the character can jump in the current state.
	 * The default implementation may be overridden or extended by implementing the custom CanJump event in Blueprints.
	 * @Return Whether the character can jump in the current state.
	*/
	CanJump(): boolean;
	static C(Other: UObject): Character;
}

declare class BillboardComponent extends PrimitiveComponent { 
	/**
	 * Sprite
	*/
	Sprite: Texture2D;
	/**
	 * Is Screen Size Scaled
	*/
	bIsScreenSizeScaled: boolean;
	/**
	 * Screen Size
	*/
	ScreenSize: number;
	/**
	 * U
	*/
	U: number;
	/**
	 * UL
	*/
	UL: number;
	/**
	 * V
	*/
	V: number;
	/**
	 * VL
	*/
	VL: number;
	/**
	 * Sprite category that the component belongs to. Value serves as a key into the localization file.
	*/
	SpriteCategoryName: string;
	/**
	 * Sprite category information regarding the component
	*/
	SpriteInfo: SpriteCategoryInfo;
	/**
	 * Whether to use in-editor arrow scaling (i.e. to be affected by the global arrow scale)
	*/
	bUseInEditorScaling: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BillboardComponent;
	static Find(Outer: UObject, ResourceName: string): BillboardComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BillboardComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BillboardComponent;
	/**
	 * Change the sprite's UVs
	*/
	SetUV(NewU: number,NewUL: number,NewV: number,NewVL: number): void;
	/**
	 * Change the sprite texture and the UV's used by this component
	*/
	SetSpriteAndUV(NewSprite: Texture2D,NewU: number,NewUL: number,NewV: number,NewVL: number): void;
	/**
	 * Change the sprite texture used by this component
	*/
	SetSprite(NewSprite: Texture2D): void;
	static C(Other: UObject): BillboardComponent;
}

declare class Info extends Actor { 
	/**
	 * Sprite Component
	*/
	SpriteComponent: BillboardComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Info;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Info;
	static C(Other: UObject): Info;
}

declare class LocalMessage extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LocalMessage;
	static Find(Outer: UObject, ResourceName: string): LocalMessage;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LocalMessage;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LocalMessage;
	static C(Other: UObject): LocalMessage;
}

declare class UniqueNetIdRepl { 
	clone() : UniqueNetIdRepl;
	static C(Other: UObject): UniqueNetIdRepl;
}

declare class PlayerState extends Info { 
	/**
	 * Player's current score.
	*/
	Score: number;
	/**
	 * Replicated compressed ping for this player (holds ping in msec divided by 4)
	*/
	Ping: number;
	/**
	 * Player name, or blank if none.
	*/
	PlayerName: string;
	/**
	 * Unique net id number. Actual value varies based on current online subsystem, use it only as a guaranteed unique number per player.
	*/
	PlayerId: number;
	/**
	 * Whether this player is currently a spectator
	*/
	bIsSpectator: boolean;
	/**
	 * Whether this player can only ever be a spectator
	*/
	bOnlySpectator: boolean;
	/**
	 * True if this PlayerState is associated with an AIController
	*/
	bIsABot: boolean;
	/**
	 * Means this PlayerState came from the GameMode's InactivePlayerArray
	*/
	bIsInactive: boolean;
	/**
	 * indicates this is a PlayerState from the previous level of a seamless travel,
	 * waiting for the player to finish the transition before creating a new one
	 * this is used to avoid preserving the PlayerState in the InactivePlayerArray if the player leaves
	*/
	bFromPreviousLevel: boolean;
	/**
	 * Elapsed time on server when this PlayerState was first created.
	*/
	StartTime: number;
	/**
	 * This is used for sending game agnostic messages that can be localized
	*/
	EngineMessageClass: UnrealEngineClass;
	/**
	 * Used to match up InactivePlayerState with rejoining playercontroller.
	*/
	SavedNetworkAddress: string;
	/**
	 * The id used by the network to uniquely identify a player.
	 * NOTE: the internals of this property should *never* be exposed to the player as it's transient
	 * and opaque in meaning (ie it might mean date/time followed by something else).
	 * It is OK to use and pass around this property, though.
	*/
	UniqueId: UniqueNetIdRepl;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerState;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerState;
	/**
	 * * Can be implemented in Blueprint Child to move more properties from old to new PlayerState when reconnecting
	 * *
	 * * @param OldPlayerState         Old PlayerState, which we use to fill the new one with
	*/
	OverrideWith(OldPlayerState: PlayerState): void;
	/**
	 * * Can be implemented in Blueprint Child to move more properties from old to new PlayerState when traveling to a new level
	 * *
	 * * @param NewPlayerState         New PlayerState, which we fill with the current properties
	*/
	CopyProperties(NewPlayerState: PlayerState): void;
	/**
	 * On Rep Unique Id
	*/
	OnRep_UniqueId(): void;
	/**
	 * Replication Notification Callbacks
	*/
	OnRep_Score(): void;
	/**
	 * On Rep Player Name
	*/
	OnRep_PlayerName(): void;
	/**
	 * On Rep B Is Inactive
	*/
	OnRep_bIsInactive(): void;
	static C(Other: UObject): PlayerState;
}

declare class DamageType extends UObject { 
	/**
	 * True if this damagetype is caused by the world (falling off level, into lava, etc).
	*/
	bCausedByWorld: boolean;
	/**
	 * True to scale imparted momentum by the receiving pawn's mass for pawns using character movement
	*/
	bScaleMomentumByMass: boolean;
	/**
	 * The magnitude of impulse to apply to the Actors damaged by this type.
	*/
	DamageImpulse: number;
	/**
	 * When applying radial impulses, whether to treat as impulse or velocity change.
	*/
	bRadialDamageVelChange: boolean;
	/**
	 * How large the impulse should be applied to destructible meshes
	*/
	DestructibleImpulse: number;
	/**
	 * How much the damage spreads on a destructible mesh
	*/
	DestructibleDamageSpreadScale: number;
	/**
	 * Damage fall-off for radius damage (exponent).  Default 1.0=linear, 2.0=square of distance, etc.
	*/
	DamageFalloff: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DamageType;
	static Find(Outer: UObject, ResourceName: string): DamageType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DamageType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DamageType;
	static C(Other: UObject): DamageType;
}

declare class Player extends UObject { 
	/**
	 * The actor this player controls.
	*/
	PlayerController: PlayerController;
	/**
	 * the current speed of the connection
	*/
	CurrentNetSpeed: number;
	/**
	 * @todo document
	*/
	ConfiguredInternetSpeed: number;
	/**
	 * @todo document
	*/
	ConfiguredLanSpeed: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Player;
	static Find(Outer: UObject, ResourceName: string): Player;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Player;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Player;
	static C(Other: UObject): Player;
}

declare class InterpTrackInst extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInst;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInst;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInst;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInst;
	static C(Other: UObject): InterpTrackInst;
}

declare class InterpTrackInstDirector extends InterpTrackInst { 
	/**
	 * Old View Target
	*/
	OldViewTarget: Actor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstDirector;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstDirector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstDirector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstDirector;
	static C(Other: UObject): InterpTrackInstDirector;
}

declare class ReporterBase extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReporterBase;
	static Find(Outer: UObject, ResourceName: string): ReporterBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReporterBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReporterBase;
	static C(Other: UObject): ReporterBase;
}

declare class ReporterGraph extends ReporterBase { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReporterGraph;
	static Find(Outer: UObject, ResourceName: string): ReporterGraph;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReporterGraph;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReporterGraph;
	static C(Other: UObject): ReporterGraph;
}

declare class CanvasUVTri { 
	/**
	 * Position of first vertex
	*/
	V0_Pos: Vector2D;
	/**
	 * UV of first vertex
	*/
	V0_UV: Vector2D;
	/**
	 * Color of first vertex
	*/
	V0_Color: LinearColor;
	/**
	 * Position of second vertex
	*/
	V1_Pos: Vector2D;
	/**
	 * UV of second vertex
	*/
	V1_UV: Vector2D;
	/**
	 * Color of second vertex
	*/
	V1_Color: LinearColor;
	/**
	 * Position of third vertex
	*/
	V2_Pos: Vector2D;
	/**
	 * UV of third vertex
	*/
	V2_UV: Vector2D;
	/**
	 * Color of third vertex
	*/
	V2_Color: LinearColor;
	clone() : CanvasUVTri;
	static C(Other: UObject): CanvasUVTri;
}

declare class Canvas extends UObject { 
	/**
	 * Modifiable properties.
	*/
	OrgX: number;
	/**
	 * Origin for drawing in X.
	*/
	OrgY: number;
	/**
	 * Origin for drawing in Y.
	*/
	ClipX: number;
	/**
	 * Bottom right clipping region.
	*/
	ClipY: number;
	/**
	 * Bottom right clipping region.
	*/
	DrawColor: Color;
	/**
	 * Color for drawing.
	*/
	bCenterX: boolean;
	/**
	 * Whether to center the text horizontally (about CurX)
	*/
	bCenterY: boolean;
	/**
	 * Whether to center the text vertically (about CurY)
	*/
	bNoSmooth: boolean;
	/**
	 * Don't bilinear filter.
	*/
	SizeX: number;
	/**
	 * Zero-based actual dimensions X.
	*/
	SizeY: number;
	/**
	 * Internal.
	*/
	ColorModulate: Plane;
	/**
	 * Default Texture
	*/
	DefaultTexture: Texture2D;
	/**
	 * Default texture to use
	*/
	GradientTexture0: Texture2D;
	/**
	 * Helper class to render 2d graphs on canvas
	*/
	ReporterGraph: ReporterGraph;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Canvas;
	static Find(Outer: UObject, ResourceName: string): Canvas;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Canvas;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Canvas;
	/**
	 * Returns the clipped text size in screen space coordinates.
	 * @param RenderFont                            Font to use when determining the size of the text. If this is null, then a default engine font is used.
	 * @param RenderText                            Text to determine the size of.
	 * @param Scale                                         Scale of the font to use when determining the size of the text.
	 * @return                                                      Returns the screen space size of the text.
	*/
	ClippedTextSize(RenderFont: Font,RenderText: string,Scale: Vector2D): Vector2D;
	/**
	 * Returns the wrapped text size in screen space coordinates.
	 * @param RenderFont                            Font to use when determining the size of the text. If this is null, then a default engine font is used.
	 * @param RenderText                            Text to determine the size of.
	 * @return                                                      Returns the screen space size of the text.
	*/
	WrappedTextSize(RenderFont: Font,RenderText: string): Vector2D;
	/**
	 * Performs a projection of a world space coordinates using the projection matrix set up for the Canvas.
	 * @param WorldLocation                         World space location to project onto the Canvas rendering plane.
	 * @return                                                      Returns a vector where X, Y defines a screen space position representing the world space location.
	*/
	Project(WorldLocation: Vector): Vector;
	/**
	 * Draws a set of triangles on the Canvas.
	 * @param RenderTexture                         Texture to use when rendering the triangles. If no texture is set, then the default white texture is used.
	 * @param Triangles                                     Triangles to render.
	*/
	DrawTriangles(RenderTexture: Texture,Triangles: CanvasUVTri[]): void;
	/**
	 * Draws a texture on the Canvas.
	 * @param RenderTexture                         Texture to use when rendering. If no texture is set then this will use the default white texture.
	 * @param ScreenPosition                        Screen space position to render the texture.
	 * @param ScreenSize                            Screen space size to render the texture.
	 * @param CoordinatePosition            Normalized UV starting coordinate to use when rendering the texture.
	 * @param CoordinateSize                        Normalized UV size coordinate to use when rendering the texture.
	 * @param RenderColor                           Color to use when rendering the texture.
	 * @param BlendMode                                     Blending mode to use when rendering the texture.
	 * @param Rotation                                      Rotation, in degrees, to render the texture.
	 * @param PivotPoint                            Normalized pivot point to use when rotating the texture.
	*/
	DrawTexture(RenderTexture: Texture,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,RenderColor: LinearColor,BlendMode: EBlendMode,Rotation: number,PivotPoint: Vector2D): void;
	/**
	 * Draws text on the Canvas.
	 * @param RenderFont                            Font to use when rendering the text. If this is null, then a default engine font is used.
	 * @param RenderText                            Text to render on the Canvas.
	 * @param ScreenPosition                        Screen space position to render the text.
	 * @param RenderColor                           Color to render the text.
	 * @param Kerning                                       Horizontal spacing adjustment to modify the spacing between each letter.
	 * @param ShadowColor                           Color to render the shadow of the text.
	 * @param ShadowOffset                          Pixel offset relative to the screen space position to render the shadow of the text.
	 * @param bCentreX                                      If true, then interpret the screen space position X coordinate as the center of the rendered text.
	 * @param bCentreY                                      If true, then interpret the screen space position Y coordinate as the center of the rendered text.
	 * @param bOutlined                                     If true, then the text should be rendered with an outline.
	 * @param OutlineColor                          Color to render the outline for the text.
	*/
	DrawText(RenderFont: Font,RenderText: string,ScreenPosition: Vector2D,RenderColor: LinearColor,Kerning: number,ShadowColor: LinearColor,ShadowOffset: Vector2D,bCentreX: boolean,bCentreY: boolean,bOutlined: boolean,OutlineColor: LinearColor): void;
	/**
	 * Draws a polygon on the Canvas.
	 * @param RenderTexture                         Texture to use when rendering the triangles. If no texture is set, then the default white texture is used.
	 * @param ScreenPosition                        Screen space position to render the text.
	 * @param Radius                                        How large in pixels this polygon should be.
	 * @param NumberOfSides                         How many sides this polygon should have. This should be above or equal to three.
	 * @param RenderColor                           Color to tint the polygon.
	*/
	DrawPolygon(RenderTexture: Texture,ScreenPosition: Vector2D,Radius: Vector2D,NumberOfSides: number,RenderColor: LinearColor): void;
	/**
	 * Draws a set of triangles on the Canvas.
	 * @param RenderMaterial                        Material to use when rendering. Remember that only the emissive channel is able to be rendered as no lighting is performed when rendering to the Canvas.
	 * @param Triangles                                     Triangles to render.
	*/
	DrawMaterialTriangles(RenderMaterial: MaterialInterface,Triangles: CanvasUVTri[]): void;
	/**
	 * Draws a material on the Canvas.
	 * @param RenderMaterial                        Material to use when rendering. Remember that only the emissive channel is able to be rendered as no lighting is performed when rendering to the Canvas.
	 * @param ScreenPosition                        Screen space position to render the texture.
	 * @param ScreenSize                            Screen space size to render the texture.
	 * @param CoordinatePosition            Normalized UV starting coordinate to use when rendering the texture.
	 * @param CoordinateSize                        Normalized UV size coordinate to use when rendering the texture.
	 * @param Rotation                                      Rotation, in degrees, to render the texture.
	 * @param PivotPoint                            Normalized pivot point to use when rotating the texture.
	*/
	DrawMaterial(RenderMaterial: MaterialInterface,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,Rotation: number,PivotPoint: Vector2D): void;
	/**
	 * Draws a line on the Canvas.
	 * @param ScreenPositionA               Starting position of the line in screen space.
	 * @param ScreenPositionB               Ending position of the line in screen space.
	 * @param Thickness                             How many pixels thick this line should be.
	 * @param RenderColor                   Color to render the line.
	*/
	DrawLine(ScreenPositionA: Vector2D,ScreenPositionB: Vector2D,Thickness: number,RenderColor: LinearColor): void;
	/**
	 * Draws an unfilled box on the Canvas.
	 * @param ScreenPosition                        Screen space position to render the text.
	 * @param ScreenSize                            Screen space size to render the texture.
	 * @param Thickness                                     How many pixels thick the box lines should be.
	*/
	DrawBox(ScreenPosition: Vector2D,ScreenSize: Vector2D,Thickness: number): void;
	/**
	 * Draws a 3x3 grid border with tiled frame and tiled interior on the Canvas.
	 * @param BorderTexture                         Texture to use for border.
	 * @param BackgroundTexture                     Texture to use for border background.
	 * @param LeftBorderTexture                     Texture to use for the tiling left border.
	 * @param RightBorderTexture            Texture to use for the tiling right border.
	 * @param TopBorderTexture                      Texture to use for the tiling top border.
	 * @param BottomBorderTexture           Texture to use for the tiling bottom border.
	 * @param ScreenPosition                        Screen space position to render the texture.
	 * @param ScreenSize                            Screen space size to render the texture.
	 * @param CoordinatePosition            Normalized UV starting coordinate to use when rendering the border texture.
	 * @param CoordinateSize                        Normalized UV size coordinate to use when rendering the border texture.
	 * @param RenderColor                           Color to tint the border.
	 * @param BorderScale                           Scale of the border.
	 * @param BackgroundScale                       Scale of the background.
	 * @param Rotation                                      Rotation, in degrees, to render the texture.
	 * @param PivotPoint                            Normalized pivot point to use when rotating the texture.
	 * @param CornerSize                            Frame corner size in percent of frame texture (should be < 0.5f).
	*/
	DrawBorder(BorderTexture: Texture,BackgroundTexture: Texture,LeftBorderTexture: Texture,RightBorderTexture: Texture,TopBorderTexture: Texture,BottomBorderTexture: Texture,ScreenPosition: Vector2D,ScreenSize: Vector2D,CoordinatePosition: Vector2D,CoordinateSize: Vector2D,RenderColor: LinearColor,BorderScale: Vector2D,BackgroundScale: Vector2D,Rotation: number,PivotPoint: Vector2D,CornerSize: Vector2D): void;
	/**
	 * Performs a deprojection of a screen space coordinate using the projection matrix set up for the Canvas.
	 * @param ScreenPosition                        Screen space position to deproject to the World.
	 * @param WorldOrigin                           Vector which is the world position of the screen space position.
	 * @param WorldDirection                        Vector which can be used in a trace to determine what is "behind" the screen space position. Useful for object picking.
	*/
	Deproject(ScreenPosition: Vector2D,WorldOrigin?: Vector,WorldDirection?: Vector): {WorldOrigin: Vector, WorldDirection: Vector};
	static C(Other: UObject): Canvas;
}

declare class DebugTextInfo { 
	/**
	 * AActor related to text item
	*/
	SrcActor: Actor;
	/**
	 * Offset from SrcActor.Location to apply
	*/
	SrcActorOffset: Vector;
	/**
	 * Desired offset to interpolate to
	*/
	SrcActorDesiredOffset: Vector;
	/**
	 * Text to display
	*/
	DebugText: string;
	/**
	 * Time remaining for the debug text, -1.f == infinite
	*/
	TimeRemaining: number;
	/**
	 * Duration used to lerp desired offset
	*/
	Duration: number;
	/**
	 * Text color
	*/
	TextColor: Color;
	/**
	 * whether the offset should be treated as absolute world location of the string
	*/
	bAbsoluteLocation: boolean;
	/**
	 * If the actor moves does the text also move with it?
	*/
	bKeepAttachedToActor: boolean;
	/**
	 * Whether to draw a shadow for the text
	*/
	bDrawShadow: boolean;
	/**
	 * When we first spawn store off the original actor location for use with bKeepAttachedToActor
	*/
	OrigActorLocation: Vector;
	/**
	 * The Font which to display this as.  Will Default to GetSmallFont()*
	*/
	Font: Font;
	/**
	 * Scale to apply to font when rendering
	*/
	FontScale: number;
	clone() : DebugTextInfo;
	static C(Other: UObject): DebugTextInfo;
}

declare class HUD extends Actor { 
	/**
	 * PlayerController which owns this HUD.
	*/
	PlayerOwner: PlayerController;
	/**
	 * Tells whether the game was paused due to lost focus
	*/
	bLostFocusPaused: boolean;
	/**
	 * Whether or not the HUD should be drawn.
	*/
	bShowHUD: boolean;
	/**
	 * If true, current ViewTarget shows debug information using its DisplayDebug().
	*/
	bShowDebugInfo: boolean;
	/**
	 * If true, show hitbox debugging info.
	*/
	bShowHitBoxDebugInfo: boolean;
	/**
	 * If true, render actor overlays.
	*/
	bShowOverlays: boolean;
	/**
	 * Put shadow on debug strings
	*/
	bEnableDebugTextShadow: boolean;
	/**
	 * Holds a list of Actors that need PostRender() calls.
	*/
	PostRenderedActors: Actor[];
	/**
	 * Array of names specifying what debug info to display for viewtarget actor.
	*/
	DebugDisplay: string[];
	/**
	 * Array of names specifying what subsets of debug info to display for viewtarget actor.
	*/
	ToggledDebugCategories: string[];
	/**
	 * Canvas to Draw HUD on.  Only valid during PostRender() event.
	*/
	Canvas: Canvas;
	/**
	 * 'Foreground' debug canvas, will draw in front of Slate UI.
	*/
	DebugCanvas: Canvas;
	/**
	 * Debug Text List
	*/
	DebugTextList: DebugTextInfo[];
	/**
	 * Class filter for selecting 'ShowDebugTargetActor' when 'bShowDebugForReticleTarget' is true.
	*/
	ShowDebugTargetDesiredClass: UnrealEngineClass;
	/**
	 * Show Debug Actor used if 'bShowDebugForReticleTarget' is true, only updated if trace from reticle hit a new Actor of class 'ShowDebugTargetDesiredClass'
	*/
	ShowDebugTargetActor: Actor;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HUD;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HUD;
	/**
	 * hides or shows HUD
	*/
	ShowHUD(): void;
	/**
	 * Toggles sub categories of show debug to customize display
	*/
	ShowDebugToggleSubCategory(Category: string): void;
	/**
	 * Toggles 'ShowDebug' from showing debug info between reticle target actor (of subclass <DesiredClass>) and camera view target
	*/
	ShowDebugForReticleTargetToggle(DesiredClass: UnrealEngineClass): void;
	/**
	 * Toggles displaying properties of player's current ViewTarget
	 * DebugType input values supported by base engine include "AI", "physics", "net", "camera", and "collision"
	*/
	ShowDebug(DebugType: string): void;
	/**
	 * Remove debug strings for the given actor
	 * @param       SrcActor                        Actor whose string you wish to remove
	 * @param       bLeaveDurationText      when true text that has a finite duration will be removed, otherwise all will be removed for given actor
	*/
	RemoveDebugText(SrcActor: Actor,bLeaveDurationText: boolean): void;
	/**
	 * Remove all debug strings added via AddDebugText
	*/
	RemoveAllDebugStrings(): void;
	/**
	 * Called when a hit box is unclicked. Provides the name associated with that box.
	*/
	HitBoxReleased(BoxName: string): void;
	/**
	 * Called when a hit box no longer has the mouse over it.
	*/
	HitBoxEndCursorOver(BoxName: string): void;
	/**
	 * Called when a hit box is clicked on. Provides the name associated with that box.
	*/
	HitBoxClicked(BoxName: string): void;
	/**
	 * Called when a hit box is moused over.
	*/
	HitBoxBeginCursorOver(BoxName: string): void;
	/**
	 * Hook to allow blueprints to do custom HUD drawing. @see bSuppressNativeHUD to control HUD drawing in base class.
	 * Note:  the canvas resource used for drawing is only valid during this event, it will not be valid if drawing functions are called later (e.g. after a Delay node).
	*/
	ReceiveDrawHUD(SizeX: number,SizeY: number): void;
	/**
	 * Transforms a 3D world-space vector into 2D screen coordinates
	*/
	Project(Location: Vector): Vector;
	/**
	 * Returns the width and height of a string.
	 * @param Text                          String to draw
	 * @param OutWidth                      Returns the width in pixels of the string.
	 * @param OutHeight                     Returns the height in pixels of the string.
	 * @param Font                          Font to draw text.  If NULL, default font is chosen.
	 * @param Scale                         Scale multiplier to control size of the text.
	*/
	GetTextSize(Text: string,OutWidth?: number,OutHeight?: number,Font?: Font,Scale?: number): {OutWidth: number, OutHeight: number};
	/**
	 * Returns the PlayerController for this HUD's player.
	*/
	GetOwningPlayerController(): PlayerController;
	/**
	 * Returns the Pawn for this HUD's player.
	*/
	GetOwningPawn(): Pawn;
	/**
	 * Returns the array of actors inside a selection rectangle, with a class filter.
	 * Sample usage:
	 *       TArray<AStaticMeshActor*> ActorsInSelectionRect;
	 *              Canvas->GetActorsInSelectionRectangle<AStaticMeshActor>(FirstPoint,SecondPoint,ActorsInSelectionRect);
	 * @param FirstPoint                                    The first point, or anchor of the marquee box. Where the dragging of the marquee started in screen space.
	 * @param SecondPoint                                   The second point, where the mouse cursor currently is / the other point of the box selection, in screen space.
	 * @return OutActors                                    The actors that are within the selection box according to selection rule
	 * @param bIncludeNonCollidingComponents        Whether to include even non-colliding components of the actor when determining its bounds
	 * @param bActorMustBeFullyEnclosed     The Selection rule: whether the selection box can partially intersect Actor, or must fully enclose the Actor.
	*/
	GetActorsInSelectionRectangle(ClassFilter: UnrealEngineClass,FirstPoint: Vector2D,SecondPoint: Vector2D,OutActors?: Actor[],bIncludeNonCollidingComponents?: boolean,bActorMustBeFullyEnclosed?: boolean): {OutActors: Actor[]};
	/**
	 * Draws a textured quad on the HUD. Assumes 1:1 texel density.
	 * @param Texture                       Texture to draw.
	 * @param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
	 * @param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
	 * @param Scale                         Scale multiplier to control size of the text.
	 * @param bScalePosition        Whether the "Scale" parameter should also scale the position of this draw call.
	*/
	DrawTextureSimple(Texture: Texture,ScreenX: number,ScreenY: number,Scale: number,bScalePosition: boolean): void;
	/**
	 * Draws a textured quad on the HUD.
	 * @param Texture                       Texture to draw.
	 * @param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
	 * @param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
	 * @param ScreenW                       Screen-space width of the quad (in pixels).
	 * @param ScreenH                       Screen-space height of the quad (in pixels).
	 * @param TextureU                      Texture-space U coordinate of upper left corner of the quad
	 * @param TextureV                      Texture-space V coordinate of upper left corner of the quad.
	 * @param TextureUWidth         Texture-space width of the quad (in normalized UV distance).
	 * @param TextureVHeight        Texture-space height of the quad (in normalized UV distance).
	 * @param TintColor                     Vertex color for the quad.
	 * @param BlendMode                     Controls how to blend this quad with the scene. Translucent by default.
	 * @param Scale                         Amount to scale the entire texture (horizontally and vertically)
	 * @param bScalePosition        Whether the "Scale" parameter should also scale the position of this draw call.
	 * @param Rotation                      Amount to rotate this quad
	 * @param RotPivot                      Location (as proportion of quad, 0-1) to rotate about
	*/
	DrawTexture(Texture: Texture,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,TextureU: number,TextureV: number,TextureUWidth: number,TextureVHeight: number,TintColor: LinearColor,BlendMode: EBlendMode,Scale: number,bScalePosition: boolean,Rotation: number,RotPivot: Vector2D): void;
	/**
	 * Draws a string on the HUD.
	 * @param Text                          String to draw
	 * @param TextColor                     Color to draw string
	 * @param ScreenX                       Screen-space X coordinate of upper left corner of the string.
	 * @param ScreenY                       Screen-space Y coordinate of upper left corner of the string.
	 * @param Font                          Font to draw text.  If NULL, default font is chosen.
	 * @param Scale                         Scale multiplier to control size of the text.
	 * @param bScalePosition        Whether the "Scale" parameter should also scale the position of this draw call.
	*/
	DrawText(Text: string,TextColor: LinearColor,ScreenX: number,ScreenY: number,Font: Font,Scale: number,bScalePosition: boolean): void;
	/**
	 * Draws a colored untextured quad on the HUD.
	 * @param RectColor                     Color of the rect. Can be translucent.
	 * @param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
	 * @param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
	 * @param ScreenW                       Screen-space width of the quad (in pixels).
	 * @param ScreenH                       Screen-space height of the quad (in pixels).
	*/
	DrawRect(RectColor: LinearColor,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number): void;
	/**
	 * Draw Material Triangle
	*/
	DrawMaterialTriangle(Material: MaterialInterface,V0_Pos: Vector2D,V1_Pos: Vector2D,V2_Pos: Vector2D,V0_UV: Vector2D,V1_UV: Vector2D,V2_UV: Vector2D,V0_Color: LinearColor,V1_Color: LinearColor,V2_Color: LinearColor): void;
	/**
	 * Draws a material-textured quad on the HUD.  Assumes UVs such that the entire material is shown.
	 * @param Material                      Material to use
	 * @param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
	 * @param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
	 * @param ScreenW                       Screen-space width of the quad (in pixels).
	 * @param ScreenH                       Screen-space height of the quad (in pixels).
	 * @param Scale                         Amount to scale the entire texture (horizontally and vertically)
	 * @param bScalePosition        Whether the "Scale" parameter should also scale the position of this draw call.
	*/
	DrawMaterialSimple(Material: MaterialInterface,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,Scale: number,bScalePosition: boolean): void;
	/**
	 * Draws a material-textured quad on the HUD.
	 * @param Material                      Material to use
	 * @param ScreenX                       Screen-space X coordinate of upper left corner of the quad.
	 * @param ScreenY                       Screen-space Y coordinate of upper left corner of the quad.
	 * @param ScreenW                       Screen-space width of the quad (in pixels).
	 * @param ScreenH                       Screen-space height of the quad (in pixels).
	 * @param MaterialU                     Texture-space U coordinate of upper left corner of the quad
	 * @param MaterialV                     Texture-space V coordinate of upper left corner of the quad.
	 * @param MaterialUWidth        Texture-space width of the quad (in normalized UV distance).
	 * @param MaterialVHeight       Texture-space height of the quad (in normalized UV distance).
	 * @param Scale                         Amount to scale the entire texture (horizontally and vertically)
	 * @param bScalePosition        Whether the "Scale" parameter should also scale the position of this draw call.
	 * @param Rotation                      Amount to rotate this quad
	 * @param RotPivot                      Location (as proportion of quad, 0-1) to rotate about
	*/
	DrawMaterial(Material: MaterialInterface,ScreenX: number,ScreenY: number,ScreenW: number,ScreenH: number,MaterialU: number,MaterialV: number,MaterialUWidth: number,MaterialVHeight: number,Scale: number,bScalePosition: boolean,Rotation: number,RotPivot: Vector2D): void;
	/**
	 * Draws a 2D line on the HUD.
	 * @param StartScreenX          Screen-space X coordinate of start of the line.
	 * @param StartScreenY          Screen-space Y coordinate of start of the line.
	 * @param EndScreenX            Screen-space X coordinate of end of the line.
	 * @param EndScreenY            Screen-space Y coordinate of end of the line.
	 * @param LineColor                     Color to draw line
	 * @param LineThickness         Thickness of the line to draw
	*/
	DrawLine(StartScreenX: number,StartScreenY: number,EndScreenX: number,EndScreenY: number,LineColor: LinearColor,LineThickness: number): void;
	/**
	 * Transforms a 2D screen location into a 3D location and direction
	*/
	Deproject(ScreenX: number,ScreenY: number,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector};
	/**
	 * Add a hitbox to the hud
	 * @param Position                      Coordinates of the top left of the hit box.
	 * @param Size                          Size of the hit box.
	 * @param Name                          Name of the hit box.
	 * @param bConsumesInput        Whether click processing should continue if this hit box is clicked.
	 * @param Priority                      The priority of the box used for layering. Larger values are considered first.  Equal values are considered in the order they were added.
	*/
	AddHitBox(Position: Vector2D,Size: Vector2D,InName: string,bConsumesInput: boolean,Priority: number): void;
	/**
	 * Add debug text for a specific actor to be displayed via DrawDebugTextList().  If the debug text is invalid then it will
	 * attempt to remove any previous entries via RemoveDebugText().
	 * @param DebugText                             Text to draw
	 * @param SrcActor                              Actor to which this relates
	 * @param Duration                              Duration to display the string
	 * @param Offset                                Initial offset to render text
	 * @param DesiredOffset                 Desired offset to render text - the text will move to this location over the given duration
	 * @param TextColor                     Color of text to render
	 * @param bSkipOverwriteCheck   skips the check to see if there is already debug text for the given actor
	 * @param bAbsoluteLocation     use an absolute world location
	 * @param bKeepAttachedToActor  if this is true the text will follow the actor, otherwise it will be drawn at the location when the call was made
	 * @param InFont                                font to use
	 * @param FontScale                     scale
	 * @param bDrawShadow                   Draw shadow on this string
	*/
	AddDebugText(DebugText: string,SrcActor: Actor,Duration: number,Offset: Vector,DesiredOffset: Vector,TextColor: Color,bSkipOverwriteCheck: boolean,bAbsoluteLocation: boolean,bKeepAttachedToActor: boolean,InFont: Font,FontScale: number,bDrawShadow: boolean): void;
	static C(Other: UObject): HUD;
}

declare type ECameraProjectionMode = string | symbol;
declare var ECameraProjectionMode = { Perspective:'Perspective',Orthographic:'Orthographic', };
declare class TextureCube extends Texture { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TextureCube;
	static Find(Outer: UObject, ResourceName: string): TextureCube;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TextureCube;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TextureCube;
	static C(Other: UObject): TextureCube;
}

declare type EAutoExposureMethod = string | symbol;
declare var EAutoExposureMethod = { AEM_Histogram:'AEM_Histogram',AEM_Basic:'AEM_Basic', };
declare type EDepthOfFieldMethod = string | symbol;
declare var EDepthOfFieldMethod = { DOFM_BokehDOF:'DOFM_BokehDOF',DOFM_Gaussian:'DOFM_Gaussian',DOFM_CircleDOF:'DOFM_CircleDOF', };
declare type EAntiAliasingMethod = string | symbol;
declare var EAntiAliasingMethod = { AAM_None:'AAM_None',AAM_FXAA:'AAM_FXAA',AAM_TemporalAA:'AAM_TemporalAA', };
declare class WeightedBlendable { 
	/**
	 * 0:no effect .. 1:full effect
	*/
	Weight: number;
	/**
	 * should be of the IBlendableInterface* type but UProperties cannot express that
	*/
	UObject: UObject;
	clone() : WeightedBlendable;
	static C(Other: UObject): WeightedBlendable;
}

declare class WeightedBlendables { 
	/**
	 * Array
	*/
	Array: WeightedBlendable[];
	clone() : WeightedBlendables;
	static C(Other: UObject): WeightedBlendables;
}

declare class PostProcessSettings { 
	/**
	 * first all bOverride_... as they get grouped together into bitfields
	*/
	bOverride_WhiteTemp: boolean;
	/**
	 * Override White Tint
	*/
	bOverride_WhiteTint: boolean;
	/**
	 * Override Color Saturation
	*/
	bOverride_ColorSaturation: boolean;
	/**
	 * Override Color Contrast
	*/
	bOverride_ColorContrast: boolean;
	/**
	 * Override Color Gamma
	*/
	bOverride_ColorGamma: boolean;
	/**
	 * Override Color Gain
	*/
	bOverride_ColorGain: boolean;
	/**
	 * Override Color Offset
	*/
	bOverride_ColorOffset: boolean;
	/**
	 * Override Film White Point
	*/
	bOverride_FilmWhitePoint: boolean;
	/**
	 * Override Film Saturation
	*/
	bOverride_FilmSaturation: boolean;
	/**
	 * Override Film Channel Mixer Red
	*/
	bOverride_FilmChannelMixerRed: boolean;
	/**
	 * Override Film Channel Mixer Green
	*/
	bOverride_FilmChannelMixerGreen: boolean;
	/**
	 * Override Film Channel Mixer Blue
	*/
	bOverride_FilmChannelMixerBlue: boolean;
	/**
	 * Override Film Contrast
	*/
	bOverride_FilmContrast: boolean;
	/**
	 * Override Film Dynamic Range
	*/
	bOverride_FilmDynamicRange: boolean;
	/**
	 * Override Film Heal Amount
	*/
	bOverride_FilmHealAmount: boolean;
	/**
	 * Override Film Toe Amount
	*/
	bOverride_FilmToeAmount: boolean;
	/**
	 * Override Film Shadow Tint
	*/
	bOverride_FilmShadowTint: boolean;
	/**
	 * Override Film Shadow Tint Blend
	*/
	bOverride_FilmShadowTintBlend: boolean;
	/**
	 * Override Film Shadow Tint Amount
	*/
	bOverride_FilmShadowTintAmount: boolean;
	/**
	 * Override Film Slope
	*/
	bOverride_FilmSlope: boolean;
	/**
	 * Override Film Toe
	*/
	bOverride_FilmToe: boolean;
	/**
	 * Override Film Shoulder
	*/
	bOverride_FilmShoulder: boolean;
	/**
	 * Override Film Black Clip
	*/
	bOverride_FilmBlackClip: boolean;
	/**
	 * Override Film White Clip
	*/
	bOverride_FilmWhiteClip: boolean;
	/**
	 * Override Scene Color Tint
	*/
	bOverride_SceneColorTint: boolean;
	/**
	 * Override Scene Fringe Intensity
	*/
	bOverride_SceneFringeIntensity: boolean;
	/**
	 * Override Ambient Cubemap Tint
	*/
	bOverride_AmbientCubemapTint: boolean;
	/**
	 * Override Ambient Cubemap Intensity
	*/
	bOverride_AmbientCubemapIntensity: boolean;
	/**
	 * Override Bloom Intensity
	*/
	bOverride_BloomIntensity: boolean;
	/**
	 * Override Bloom Threshold
	*/
	bOverride_BloomThreshold: boolean;
	/**
	 * Override Bloom 1Tint
	*/
	bOverride_Bloom1Tint: boolean;
	/**
	 * Override Bloom 1Size
	*/
	bOverride_Bloom1Size: boolean;
	/**
	 * Override Bloom 2Size
	*/
	bOverride_Bloom2Size: boolean;
	/**
	 * Override Bloom 2Tint
	*/
	bOverride_Bloom2Tint: boolean;
	/**
	 * Override Bloom 3Tint
	*/
	bOverride_Bloom3Tint: boolean;
	/**
	 * Override Bloom 3Size
	*/
	bOverride_Bloom3Size: boolean;
	/**
	 * Override Bloom 4Tint
	*/
	bOverride_Bloom4Tint: boolean;
	/**
	 * Override Bloom 4Size
	*/
	bOverride_Bloom4Size: boolean;
	/**
	 * Override Bloom 5Tint
	*/
	bOverride_Bloom5Tint: boolean;
	/**
	 * Override Bloom 5Size
	*/
	bOverride_Bloom5Size: boolean;
	/**
	 * Override Bloom 6Tint
	*/
	bOverride_Bloom6Tint: boolean;
	/**
	 * Override Bloom 6Size
	*/
	bOverride_Bloom6Size: boolean;
	/**
	 * Override Bloom Size Scale
	*/
	bOverride_BloomSizeScale: boolean;
	/**
	 * Override Bloom Dirt Mask Intensity
	*/
	bOverride_BloomDirtMaskIntensity: boolean;
	/**
	 * Override Bloom Dirt Mask Tint
	*/
	bOverride_BloomDirtMaskTint: boolean;
	/**
	 * Override Bloom Dirt Mask
	*/
	bOverride_BloomDirtMask: boolean;
	/**
	 * Override Auto Exposure Method
	*/
	bOverride_AutoExposureMethod: boolean;
	/**
	 * Override Auto Exposure Low Percent
	*/
	bOverride_AutoExposureLowPercent: boolean;
	/**
	 * Override Auto Exposure High Percent
	*/
	bOverride_AutoExposureHighPercent: boolean;
	/**
	 * Override Auto Exposure Min Brightness
	*/
	bOverride_AutoExposureMinBrightness: boolean;
	/**
	 * Override Auto Exposure Max Brightness
	*/
	bOverride_AutoExposureMaxBrightness: boolean;
	/**
	 * Override Auto Exposure Speed Up
	*/
	bOverride_AutoExposureSpeedUp: boolean;
	/**
	 * Override Auto Exposure Speed Down
	*/
	bOverride_AutoExposureSpeedDown: boolean;
	/**
	 * Override Auto Exposure Bias
	*/
	bOverride_AutoExposureBias: boolean;
	/**
	 * Override Histogram Log Min
	*/
	bOverride_HistogramLogMin: boolean;
	/**
	 * Override Histogram Log Max
	*/
	bOverride_HistogramLogMax: boolean;
	/**
	 * Override Lens Flare Intensity
	*/
	bOverride_LensFlareIntensity: boolean;
	/**
	 * Override Lens Flare Tint
	*/
	bOverride_LensFlareTint: boolean;
	/**
	 * Override Lens Flare Tints
	*/
	bOverride_LensFlareTints: boolean;
	/**
	 * Override Lens Flare Bokeh Size
	*/
	bOverride_LensFlareBokehSize: boolean;
	/**
	 * Override Lens Flare Bokeh Shape
	*/
	bOverride_LensFlareBokehShape: boolean;
	/**
	 * Override Lens Flare Threshold
	*/
	bOverride_LensFlareThreshold: boolean;
	/**
	 * Override Vignette Intensity
	*/
	bOverride_VignetteIntensity: boolean;
	/**
	 * Override Grain Intensity
	*/
	bOverride_GrainIntensity: boolean;
	/**
	 * Override Grain Jitter
	*/
	bOverride_GrainJitter: boolean;
	/**
	 * Override Ambient Occlusion Intensity
	*/
	bOverride_AmbientOcclusionIntensity: boolean;
	/**
	 * Override Ambient Occlusion Static Fraction
	*/
	bOverride_AmbientOcclusionStaticFraction: boolean;
	/**
	 * Override Ambient Occlusion Radius
	*/
	bOverride_AmbientOcclusionRadius: boolean;
	/**
	 * Override Ambient Occlusion Fade Distance
	*/
	bOverride_AmbientOcclusionFadeDistance: boolean;
	/**
	 * Override Ambient Occlusion Fade Radius
	*/
	bOverride_AmbientOcclusionFadeRadius: boolean;
	/**
	 * Override Ambient Occlusion Distance
	*/
	bOverride_AmbientOcclusionDistance: boolean;
	/**
	 * Override Ambient Occlusion Radius in WS
	*/
	bOverride_AmbientOcclusionRadiusInWS: boolean;
	/**
	 * Override Ambient Occlusion Power
	*/
	bOverride_AmbientOcclusionPower: boolean;
	/**
	 * Override Ambient Occlusion Bias
	*/
	bOverride_AmbientOcclusionBias: boolean;
	/**
	 * Override Ambient Occlusion Quality
	*/
	bOverride_AmbientOcclusionQuality: boolean;
	/**
	 * Override Ambient Occlusion Mip Blend
	*/
	bOverride_AmbientOcclusionMipBlend: boolean;
	/**
	 * Override Ambient Occlusion Mip Scale
	*/
	bOverride_AmbientOcclusionMipScale: boolean;
	/**
	 * Override Ambient Occlusion Mip Threshold
	*/
	bOverride_AmbientOcclusionMipThreshold: boolean;
	/**
	 * Override LPVIntensity
	*/
	bOverride_LPVIntensity: boolean;
	/**
	 * Override LPVDirectional Occlusion Intensity
	*/
	bOverride_LPVDirectionalOcclusionIntensity: boolean;
	/**
	 * Override LPVDirectional Occlusion Radius
	*/
	bOverride_LPVDirectionalOcclusionRadius: boolean;
	/**
	 * Override LPVDiffuse Occlusion Exponent
	*/
	bOverride_LPVDiffuseOcclusionExponent: boolean;
	/**
	 * Override LPVSpecular Occlusion Exponent
	*/
	bOverride_LPVSpecularOcclusionExponent: boolean;
	/**
	 * Override LPVDiffuse Occlusion Intensity
	*/
	bOverride_LPVDiffuseOcclusionIntensity: boolean;
	/**
	 * Override LPVSpecular Occlusion Intensity
	*/
	bOverride_LPVSpecularOcclusionIntensity: boolean;
	/**
	 * Override LPVSize
	*/
	bOverride_LPVSize: boolean;
	/**
	 * Override LPVSecondary Occlusion Intensity
	*/
	bOverride_LPVSecondaryOcclusionIntensity: boolean;
	/**
	 * Override LPVSecondary Bounce Intensity
	*/
	bOverride_LPVSecondaryBounceIntensity: boolean;
	/**
	 * Override LPVGeometry Volume Bias
	*/
	bOverride_LPVGeometryVolumeBias: boolean;
	/**
	 * Override LPVVpl Injection Bias
	*/
	bOverride_LPVVplInjectionBias: boolean;
	/**
	 * Override LPVEmissive Injection Intensity
	*/
	bOverride_LPVEmissiveInjectionIntensity: boolean;
	/**
	 * Override Indirect Lighting Color
	*/
	bOverride_IndirectLightingColor: boolean;
	/**
	 * Override Indirect Lighting Intensity
	*/
	bOverride_IndirectLightingIntensity: boolean;
	/**
	 * Override Color Grading Intensity
	*/
	bOverride_ColorGradingIntensity: boolean;
	/**
	 * Override Color Grading LUT
	*/
	bOverride_ColorGradingLUT: boolean;
	/**
	 * Override Depth Of Field Focal Distance
	*/
	bOverride_DepthOfFieldFocalDistance: boolean;
	/**
	 * Override Depth Of Field Fstop
	*/
	bOverride_DepthOfFieldFstop: boolean;
	/**
	 * Override Depth Of Field Sensor Width
	*/
	bOverride_DepthOfFieldSensorWidth: boolean;
	/**
	 * Override Depth Of Field Depth Blur Radius
	*/
	bOverride_DepthOfFieldDepthBlurRadius: boolean;
	/**
	 * Override Depth Of Field Depth Blur Amount
	*/
	bOverride_DepthOfFieldDepthBlurAmount: boolean;
	/**
	 * Override Depth Of Field Focal Region
	*/
	bOverride_DepthOfFieldFocalRegion: boolean;
	/**
	 * Override Depth Of Field Near Transition Region
	*/
	bOverride_DepthOfFieldNearTransitionRegion: boolean;
	/**
	 * Override Depth Of Field Far Transition Region
	*/
	bOverride_DepthOfFieldFarTransitionRegion: boolean;
	/**
	 * Override Depth Of Field Scale
	*/
	bOverride_DepthOfFieldScale: boolean;
	/**
	 * Override Depth Of Field Max Bokeh Size
	*/
	bOverride_DepthOfFieldMaxBokehSize: boolean;
	/**
	 * Override Depth Of Field Near Blur Size
	*/
	bOverride_DepthOfFieldNearBlurSize: boolean;
	/**
	 * Override Depth Of Field Far Blur Size
	*/
	bOverride_DepthOfFieldFarBlurSize: boolean;
	/**
	 * Override Depth Of Field Method
	*/
	bOverride_DepthOfFieldMethod: boolean;
	/**
	 * Override Mobile HQGaussian
	*/
	bOverride_MobileHQGaussian: boolean;
	/**
	 * Override Depth Of Field Bokeh Shape
	*/
	bOverride_DepthOfFieldBokehShape: boolean;
	/**
	 * Override Depth Of Field Occlusion
	*/
	bOverride_DepthOfFieldOcclusion: boolean;
	/**
	 * Override Depth Of Field Color Threshold
	*/
	bOverride_DepthOfFieldColorThreshold: boolean;
	/**
	 * Override Depth Of Field Size Threshold
	*/
	bOverride_DepthOfFieldSizeThreshold: boolean;
	/**
	 * Override Depth Of Field Sky Focus Distance
	*/
	bOverride_DepthOfFieldSkyFocusDistance: boolean;
	/**
	 * Override Depth Of Field Vignette Size
	*/
	bOverride_DepthOfFieldVignetteSize: boolean;
	/**
	 * Override Motion Blur Amount
	*/
	bOverride_MotionBlurAmount: boolean;
	/**
	 * Override Motion Blur Max
	*/
	bOverride_MotionBlurMax: boolean;
	/**
	 * Override Motion Blur Per Object Size
	*/
	bOverride_MotionBlurPerObjectSize: boolean;
	/**
	 * Override Screen Percentage
	*/
	bOverride_ScreenPercentage: boolean;
	/**
	 * Override Anti Aliasing Method
	*/
	bOverride_AntiAliasingMethod: boolean;
	/**
	 * Override Screen Space Reflection Intensity
	*/
	bOverride_ScreenSpaceReflectionIntensity: boolean;
	/**
	 * Override Screen Space Reflection Quality
	*/
	bOverride_ScreenSpaceReflectionQuality: boolean;
	/**
	 * Override Screen Space Reflection Max Roughness
	*/
	bOverride_ScreenSpaceReflectionMaxRoughness: boolean;
	/**
	 * Override Screen Space Reflection Roughness Scale
	*/
	bOverride_ScreenSpaceReflectionRoughnessScale: boolean;
	/**
	 * White Temp
	*/
	WhiteTemp: number;
	/**
	 * White Tint
	*/
	WhiteTint: number;
	/**
	 * Color Saturation
	*/
	ColorSaturation: Vector;
	/**
	 * Color Contrast
	*/
	ColorContrast: Vector;
	/**
	 * Color Gamma
	*/
	ColorGamma: Vector;
	/**
	 * Color Gain
	*/
	ColorGain: Vector;
	/**
	 * Color Offset
	*/
	ColorOffset: Vector;
	/**
	 * Film White Point
	*/
	FilmWhitePoint: LinearColor;
	/**
	 * Film Shadow Tint
	*/
	FilmShadowTint: LinearColor;
	/**
	 * Film Shadow Tint Blend
	*/
	FilmShadowTintBlend: number;
	/**
	 * Film Shadow Tint Amount
	*/
	FilmShadowTintAmount: number;
	/**
	 * Film Saturation
	*/
	FilmSaturation: number;
	/**
	 * Film Channel Mixer Red
	*/
	FilmChannelMixerRed: LinearColor;
	/**
	 * Film Channel Mixer Green
	*/
	FilmChannelMixerGreen: LinearColor;
	/**
	 * Film Channel Mixer Blue
	*/
	FilmChannelMixerBlue: LinearColor;
	/**
	 * Film Contrast
	*/
	FilmContrast: number;
	/**
	 * Film Toe Amount
	*/
	FilmToeAmount: number;
	/**
	 * Film Heal Amount
	*/
	FilmHealAmount: number;
	/**
	 * Film Dynamic Range
	*/
	FilmDynamicRange: number;
	/**
	 * Film Slope
	*/
	FilmSlope: number;
	/**
	 * Film Toe
	*/
	FilmToe: number;
	/**
	 * Film Shoulder
	*/
	FilmShoulder: number;
	/**
	 * Film Black Clip
	*/
	FilmBlackClip: number;
	/**
	 * Film White Clip
	*/
	FilmWhiteClip: number;
	/**
	 * Scene tint color
	*/
	SceneColorTint: LinearColor;
	/**
	 * in percent, Scene chromatic aberration / color fringe (camera imperfection) to simulate an artifact that happens in real-world lens, mostly visible in the image corners.
	*/
	SceneFringeIntensity: number;
	/**
	 * Multiplier for all bloom contributions >=0: off, 1(default), >1 brighter
	*/
	BloomIntensity: number;
	/**
	 * minimum brightness the bloom starts having effect
	 * -1:all pixels affect bloom equally (physically correct, faster as a threshold pass is omitted), 0:all pixels affect bloom brights more, 1(default), >1 brighter
	*/
	BloomThreshold: number;
	/**
	 * Scale for all bloom sizes
	*/
	BloomSizeScale: number;
	/**
	 * Diameter size for the Bloom1 in percent of the screen width
	 * (is done in 1/2 resolution, larger values cost more performance, good for high frequency details)
	 * >=0: can be clamped because of shader limitations
	*/
	Bloom1Size: number;
	/**
	 * Diameter size for Bloom2 in percent of the screen width
	 * (is done in 1/4 resolution, larger values cost more performance)
	 * >=0: can be clamped because of shader limitations
	*/
	Bloom2Size: number;
	/**
	 * Diameter size for Bloom3 in percent of the screen width
	 * (is done in 1/8 resolution, larger values cost more performance)
	 * >=0: can be clamped because of shader limitations
	*/
	Bloom3Size: number;
	/**
	 * Diameter size for Bloom4 in percent of the screen width
	 * (is done in 1/16 resolution, larger values cost more performance, best for wide contributions)
	 * >=0: can be clamped because of shader limitations
	*/
	Bloom4Size: number;
	/**
	 * Diameter size for Bloom5 in percent of the screen width
	 * (is done in 1/32 resolution, larger values cost more performance, best for wide contributions)
	 * >=0: can be clamped because of shader limitations
	*/
	Bloom5Size: number;
	/**
	 * Diameter size for Bloom6 in percent of the screen width
	 * (is done in 1/64 resolution, larger values cost more performance, best for wide contributions)
	 * >=0: can be clamped because of shader limitations
	*/
	Bloom6Size: number;
	/**
	 * Bloom1 tint color
	*/
	Bloom1Tint: LinearColor;
	/**
	 * Bloom2 tint color
	*/
	Bloom2Tint: LinearColor;
	/**
	 * Bloom3 tint color
	*/
	Bloom3Tint: LinearColor;
	/**
	 * Bloom4 tint color
	*/
	Bloom4Tint: LinearColor;
	/**
	 * Bloom5 tint color
	*/
	Bloom5Tint: LinearColor;
	/**
	 * Bloom6 tint color
	*/
	Bloom6Tint: LinearColor;
	/**
	 * BloomDirtMask intensity
	*/
	BloomDirtMaskIntensity: number;
	/**
	 * BloomDirtMask tint color
	*/
	BloomDirtMaskTint: LinearColor;
	/**
	 * Texture that defines the dirt on the camera lens where the light of very bright objects is scattered.
	*/
	BloomDirtMask: Texture;
	/**
	 * How strong the dynamic GI from the LPV should be. 0.0 is off, 1.0 is the "normal" value, but higher values can be used to boost the effect
	*/
	LPVIntensity: number;
	/**
	 * Bias applied to light injected into the LPV in cell units. Increase to reduce bleeding through thin walls
	*/
	LPVVplInjectionBias: number;
	/**
	 * The size of the LPV volume, in Unreal units
	*/
	LPVSize: number;
	/**
	 * Secondary occlusion strength (bounce light shadows). Set to 0 to disable
	*/
	LPVSecondaryOcclusionIntensity: number;
	/**
	 * Secondary bounce light strength (bounce light shadows). Set to 0 to disable
	*/
	LPVSecondaryBounceIntensity: number;
	/**
	 * Bias applied to the geometry volume in cell units. Increase to reduce darkening due to secondary occlusion
	*/
	LPVGeometryVolumeBias: number;
	/**
	 * LPVEmissive Injection Intensity
	*/
	LPVEmissiveInjectionIntensity: number;
	/**
	 * Controls the amount of directional occlusion. Requires LPV. Values very close to 1.0 are recommended
	*/
	LPVDirectionalOcclusionIntensity: number;
	/**
	 * Occlusion Radius - 16 is recommended for most scenes
	*/
	LPVDirectionalOcclusionRadius: number;
	/**
	 * Diffuse occlusion exponent - increase for more contrast. 1 to 2 is recommended
	*/
	LPVDiffuseOcclusionExponent: number;
	/**
	 * Specular occlusion exponent - increase for more contrast. 6 to 9 is recommended
	*/
	LPVSpecularOcclusionExponent: number;
	/**
	 * Diffuse occlusion intensity - higher values provide increased diffuse occlusion.
	*/
	LPVDiffuseOcclusionIntensity: number;
	/**
	 * Specular occlusion intensity - higher values provide increased specular occlusion.
	*/
	LPVSpecularOcclusionIntensity: number;
	/**
	 * AmbientCubemap tint color
	*/
	AmbientCubemapTint: LinearColor;
	/**
	 * To scale the Ambient cubemap brightness
	 * >=0: off, 1(default), >1 brighter
	*/
	AmbientCubemapIntensity: number;
	/**
	 * The Ambient cubemap (Affects diffuse and specular shading), blends additively which if different from all other settings here
	*/
	AmbientCubemap: TextureCube;
	/**
	 * Luminance computation method
	*/
	AutoExposureMethod: EAutoExposureMethod;
	/**
	 * The eye adaptation will adapt to a value extracted from the luminance histogram of the scene color.
	 * The value is defined as having x percent below this brightness. Higher values give bright spots on the screen more priority
	 * but can lead to less stable results. Lower values give the medium and darker values more priority but might cause burn out of
	 * bright spots.
	 * >0, <100, good values are in the range 70 .. 80
	*/
	AutoExposureLowPercent: number;
	/**
	 * The eye adaptation will adapt to a value extracted from the luminance histogram of the scene color.
	 * The value is defined as having x percent below this brightness. Higher values give bright spots on the screen more priority
	 * but can lead to less stable results. Lower values give the medium and darker values more priority but might cause burn out of
	 * bright spots.
	 * >0, <100, good values are in the range 80 .. 95
	*/
	AutoExposureHighPercent: number;
	/**
	 * A good value should be positive near 0. This is the minimum brightness the auto exposure can adapt to.
	 * It should be tweaked in a dark lighting situation (too small: image appears too bright, too large: image appears too dark).
	 * Note: Tweaking emissive materials and lights or tweaking auto exposure can look the same. Tweaking auto exposure has global
	 * effect and defined the HDR range - you don't want to change that late in the project development.
	 * Eye Adaptation is disabled if MinBrightness = MaxBrightness
	*/
	AutoExposureMinBrightness: number;
	/**
	 * A good value should be positive (2 is a good value). This is the maximum brightness the auto exposure can adapt to.
	 * It should be tweaked in a bright lighting situation (too small: image appears too bright, too large: image appears too dark).
	 * Note: Tweaking emissive materials and lights or tweaking auto exposure can look the same. Tweaking auto exposure has global
	 * effect and defined the HDR range - you don't want to change that late in the project development.
	 * Eye Adaptation is disabled if MinBrightness = MaxBrightness
	*/
	AutoExposureMaxBrightness: number;
	/**
	 * >0
	*/
	AutoExposureSpeedUp: number;
	/**
	 * >0
	*/
	AutoExposureSpeedDown: number;
	/**
	 * Logarithmic adjustment for the exposure. Only used if a tonemapper is specified.
	 * 0: no adjustment, -1:2x darker, -2:4x darker, 1:2x brighter, 2:4x brighter, ...
	*/
	AutoExposureBias: number;
	/**
	 * temporary exposed until we found good values, -8: 1/256, -10: 1/1024
	*/
	HistogramLogMin: number;
	/**
	 * temporary exposed until we found good values 4: 16, 8: 256
	*/
	HistogramLogMax: number;
	/**
	 * Brightness scale of the image cased lens flares (linear)
	*/
	LensFlareIntensity: number;
	/**
	 * Tint color for the image based lens flares.
	*/
	LensFlareTint: LinearColor;
	/**
	 * Size of the Lens Blur (in percent of the view width) that is done with the Bokeh texture (note: performance cost is radius*radius)
	*/
	LensFlareBokehSize: number;
	/**
	 * Minimum brightness the lens flare starts having effect (this should be as high as possible to avoid the performance cost of blurring content that is too dark too see)
	*/
	LensFlareThreshold: number;
	/**
	 * Defines the shape of the Bokeh when the image base lens flares are blurred, cannot be blended
	*/
	LensFlareBokehShape: Texture;
	/**
	 * RGB defines the lens flare color, A it's position. This is a temporary solution.
	*/
	LensFlareTints: LinearColor;
	/**
	 * 0..1 0=off/no vignette .. 1=strong vignette
	*/
	VignetteIntensity: number;
	/**
	 * 0..1 grain jitter
	*/
	GrainJitter: number;
	/**
	 * 0..1 grain intensity
	*/
	GrainIntensity: number;
	/**
	 * 0..1 0=off/no ambient occlusion .. 1=strong ambient occlusion, defines how much it affects the non direct lighting after base pass
	*/
	AmbientOcclusionIntensity: number;
	/**
	 * 0..1 0=no effect on static lighting .. 1=AO affects the stat lighting, 0 is free meaning no extra rendering pass
	*/
	AmbientOcclusionStaticFraction: number;
	/**
	 * >0, in unreal units, bigger values means even distant surfaces affect the ambient occlusion
	*/
	AmbientOcclusionRadius: number;
	/**
	 * true: AO radius is in world space units, false: AO radius is locked the view space in 400 units
	*/
	AmbientOcclusionRadiusInWS: boolean;
	/**
	 * >0, in unreal units, at what distance the AO effect disppears in the distance (avoding artifacts and AO effects on huge object)
	*/
	AmbientOcclusionFadeDistance: number;
	/**
	 * >0, in unreal units, how many units before AmbientOcclusionFadeOutDistance it starts fading out
	*/
	AmbientOcclusionFadeRadius: number;
	/**
	 * >0, in unreal units, how wide the ambient occlusion effect should affect the geometry (in depth), will be removed - only used for non normal method which is not exposed
	*/
	AmbientOcclusionDistance: number;
	/**
	 * >0, in unreal units, bigger values means even distant surfaces affect the ambient occlusion
	*/
	AmbientOcclusionPower: number;
	/**
	 * >0, in unreal units, default (3.0) works well for flat surfaces but can reduce details
	*/
	AmbientOcclusionBias: number;
	/**
	 * 0=lowest quality..100=maximum quality, only a few quality levels are implemented, no soft transition
	*/
	AmbientOcclusionQuality: number;
	/**
	 * Affects the blend over the multiple mips (lower resolution versions) , 0:fully use full resolution, 1::fully use low resolution, around 0.6 seems to be a good value
	*/
	AmbientOcclusionMipBlend: number;
	/**
	 * Affects the radius AO radius scale over the multiple mips (lower resolution versions)
	*/
	AmbientOcclusionMipScale: number;
	/**
	 * to tweak the bilateral upsampling when using multiple mips (lower resolution versions)
	*/
	AmbientOcclusionMipThreshold: number;
	/**
	 * Adjusts indirect lighting color. (1,1,1) is default. (0,0,0) to disable GI. The show flag 'Global Illumination' must be enabled to use this property.
	*/
	IndirectLightingColor: LinearColor;
	/**
	 * Scales the indirect lighting contribution. A value of 0 disables GI. Default is 1. The show flag 'Global Illumination' must be enabled to use this property.
	*/
	IndirectLightingIntensity: number;
	/**
	 * 0..1=full intensity
	*/
	ColorGradingIntensity: number;
	/**
	 * Name of the LUT texture e.g. MyPackage01.LUTNeutral, empty if not used
	*/
	ColorGradingLUT: Texture;
	/**
	 * BokehDOF, Simple gaussian, ... Mobile supports Gaussian only.
	*/
	DepthOfFieldMethod: EDepthOfFieldMethod;
	/**
	 * Enable HQ Gaussian on high end mobile platforms. (ES3_1)
	*/
	bMobileHQGaussian: boolean;
	/**
	 * CircleDOF only: Defines the opening of the camera lens, Aperture is 1/fstop, typical lens go down to f/1.2 (large opening), larger numbers reduce the DOF effect
	*/
	DepthOfFieldFstop: number;
	/**
	 * Width of the camera sensor to assume, in mm.
	*/
	DepthOfFieldSensorWidth: number;
	/**
	 * Distance in which the Depth of Field effect should be sharp, in unreal units (cm)
	*/
	DepthOfFieldFocalDistance: number;
	/**
	 * CircleDOF only: Depth blur km for 50%
	*/
	DepthOfFieldDepthBlurAmount: number;
	/**
	 * CircleDOF only: Depth blur radius in pixels at 1920x
	*/
	DepthOfFieldDepthBlurRadius: number;
	/**
	 * Artificial region where all content is in focus, starting after DepthOfFieldFocalDistance, in unreal units  (cm)
	*/
	DepthOfFieldFocalRegion: number;
	/**
	 * To define the width of the transition region next to the focal region on the near side (cm)
	*/
	DepthOfFieldNearTransitionRegion: number;
	/**
	 * To define the width of the transition region next to the focal region on the near side (cm)
	*/
	DepthOfFieldFarTransitionRegion: number;
	/**
	 * SM5: BokehDOF only: To amplify the depth of field effect (like aperture)  0=off
	 *           ES2: Used to blend DoF. 0=off
	*/
	DepthOfFieldScale: number;
	/**
	 * BokehDOF only: Maximum size of the Depth of Field blur (in percent of the view width) (note: performance cost scales with size*size)
	*/
	DepthOfFieldMaxBokehSize: number;
	/**
	 * Gaussian only: Maximum size of the Depth of Field blur (in percent of the view width) (note: performance cost scales with size)
	*/
	DepthOfFieldNearBlurSize: number;
	/**
	 * Gaussian only: Maximum size of the Depth of Field blur (in percent of the view width) (note: performance cost scales with size)
	*/
	DepthOfFieldFarBlurSize: number;
	/**
	 * Defines the shape of the Bokeh when object get out of focus, cannot be blended
	*/
	DepthOfFieldBokehShape: Texture;
	/**
	 * Occlusion tweak factor 1 (0.18 to get natural occlusion, 0.4 to solve layer color leaking issues)
	*/
	DepthOfFieldOcclusion: number;
	/**
	 * Color threshold to do full quality DOF (BokehDOF only)
	*/
	DepthOfFieldColorThreshold: number;
	/**
	 * Size threshold to do full quality DOF (BokehDOF only)
	*/
	DepthOfFieldSizeThreshold: number;
	/**
	 * Artificial distance to allow the skybox to be in focus (e.g. 200000), <=0 to switch the feature off, only for GaussianDOF, can cost performance
	*/
	DepthOfFieldSkyFocusDistance: number;
	/**
	 * Artificial circular mask to (near) blur content outside the radius, only for GaussianDOF, diameter in percent of screen width, costs performance if the mask is used, keep Feather can Radius on default to keep it off
	*/
	DepthOfFieldVignetteSize: number;
	/**
	 * Strength of motion blur, 0:off, should be renamed to intensity
	*/
	MotionBlurAmount: number;
	/**
	 * max distortion caused by motion blur, in percent of the screen width, 0:off
	*/
	MotionBlurMax: number;
	/**
	 * The minimum projected screen radius for a primitive to be drawn in the velocity pass, percentage of screen width. smaller numbers cause more draw calls, default: 4%
	*/
	MotionBlurPerObjectSize: number;
	/**
	 * To render with lower or high resolution than it is presented,
	 * controlled by console variable,
	 * 100:off, needs to be <99 to get upsampling and lower to get performance,
	 * >100 for super sampling (slower but higher quality),
	 * only applied in game
	*/
	ScreenPercentage: number;
	/**
	 * TemporalAA, FXAA, ...
	*/
	AntiAliasingMethod: EAntiAliasingMethod;
	/**
	 * Enable/Fade/disable the Screen Space Reflection feature, in percent, avoid numbers between 0 and 1 fo consistency
	*/
	ScreenSpaceReflectionIntensity: number;
	/**
	 * 0=lowest quality..100=maximum quality, only a few quality levels are implemented, no soft transition, 50 is the default for better performance.
	*/
	ScreenSpaceReflectionQuality: number;
	/**
	 * Until what roughness we fade the screen space reflections, 0.8 works well, smaller can run faster
	*/
	ScreenSpaceReflectionMaxRoughness: number;
	/**
	 * Allows custom post process materials to be defined, using a MaterialInstance with the same Material as its parent to allow blending.
	 * For materials this needs to be the "PostProcess" domain type. This can be used for any UObject object implementing the IBlendableInterface (e.g. could be used to fade weather settings).
	*/
	WeightedBlendables: WeightedBlendables;
	/**
	 * for backwards compatibility
	*/
	Blendables: UObject[];
	clone() : PostProcessSettings;
	static C(Other: UObject): PostProcessSettings;
}

declare class MinimalViewInfo { 
	/**
	 * Location
	*/
	Location: Vector;
	/**
	 * Rotation
	*/
	Rotation: Rotator;
	/**
	 * The field of view (in degrees) in perspective mode (ignored in Orthographic mode)
	*/
	FOV: number;
	/**
	 * The desired width (in world units) of the orthographic view (ignored in Perspective mode)
	*/
	OrthoWidth: number;
	/**
	 * The near plane distance of the orthographic view (in world units)
	*/
	OrthoNearClipPlane: number;
	/**
	 * The far plane distance of the orthographic view (in world units)
	*/
	OrthoFarClipPlane: number;
	/**
	 * Aspect Ratio (Width/Height); ignored unless bConstrainAspectRatio is true
	*/
	AspectRatio: number;
	/**
	 * If bConstrainAspectRatio is true, black bars will be added if the destination view has a different aspect ratio than this camera requested.
	*/
	bConstrainAspectRatio: boolean;
	/**
	 * If true, account for the field of view angle when computing which level of detail to use for meshes.
	*/
	bUseFieldOfViewForLOD: boolean;
	/**
	 * The type of camera
	*/
	ProjectionMode: ECameraProjectionMode;
	/**
	 * Indicates if PostProcessSettings should be applied.
	*/
	PostProcessBlendWeight: number;
	/**
	 * Post-process settings to use if PostProcessBlendWeight is non-zero.
	*/
	PostProcessSettings: PostProcessSettings;
	clone() : MinimalViewInfo;
	static C(Other: UObject): MinimalViewInfo;
}

declare class CameraCacheEntry { 
	/**
	 * World time this entry was created.
	*/
	TimeStamp: number;
	/**
	 * Camera POV to cache.
	*/
	POV: MinimalViewInfo;
	clone() : CameraCacheEntry;
	static C(Other: UObject): CameraCacheEntry;
}

declare class TViewTarget { 
	/**
	 * Target Actor used to compute POV
	*/
	Target: Actor;
	/**
	 * Computed point of view
	*/
	POV: MinimalViewInfo;
	/**
	 * PlayerState (used to follow same player through pawn transitions, etc., when spectating)
	*/
	PlayerState: PlayerState;
	clone() : TViewTarget;
	static C(Other: UObject): TViewTarget;
}

declare class CameraModifier extends UObject { 
	/**
	 * If true, enables certain debug visualization features.
	*/
	bDebug: boolean;
	/**
	 * If true, no other modifiers of same priority allowed.
	*/
	bExclusive: boolean;
	/**
	 * Priority value that determines the order in which modifiers are applied. 0 = highest priority, 255 = lowest.
	*/
	Priority: number;
	/**
	 * Camera this object is associated with.
	*/
	CameraOwner: PlayerCameraManager;
	/**
	 * When blending in, alpha proceeds from 0 to 1 over this time
	*/
	AlphaInTime: number;
	/**
	 * When blending out, alpha proceeds from 1 to 0 over this time
	*/
	AlphaOutTime: number;
	/**
	 * Current blend alpha.
	*/
	Alpha: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraModifier;
	static Find(Outer: UObject, ResourceName: string): CameraModifier;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraModifier;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraModifier;
	/**
	 * @return Returns true if modifier is disabled, false otherwise.
	*/
	IsDisabled(): boolean;
	/**
	 * @return Returns the actor the camera is currently viewing.
	*/
	GetViewTarget(): Actor;
	/**
	 * Enables this modifier.
	*/
	EnableModifier(): void;
	/**
	 * Disables this modifier.
	 * @param  bImmediate  - true to disable with no blend out, false (default) to allow blend out
	*/
	DisableModifier(bImmediate: boolean): void;
	/**
	 * Called per tick that the modifier is active to allow Blueprinted modifiers to modify the camera's postprocess effects.
	 * Scaling by Alpha happens after this in code, so no need to deal with that in the blueprint.
	 * @param       DeltaTime                               Change in time since last update
	 * @param       PostProcessBlendWeight  (out) Blend weight applied to the entire postprocess structure.
	 * @param       PostProcessSettings             (out) Post process structure defining what settings and values to override.
	*/
	BlueprintModifyPostProcess(DeltaTime: number,PostProcessBlendWeight?: number,PostProcessSettings?: PostProcessSettings): {PostProcessBlendWeight: number, PostProcessSettings: PostProcessSettings};
	/**
	 * Called per tick that the modifier is active to allow Blueprinted modifiers to modify the camera's transform.
	 * Scaling by Alpha happens after this in code, so no need to deal with that in the blueprint.
	 * @param       DeltaTime       Change in time since last update
	 * @param       ViewLocation            The current camera location.
	 * @param       ViewRotation            The current camera rotation.
	 * @param       FOV                                     The current camera fov.
	 * @param       NewViewLocation         (out) The modified camera location.
	 * @param       NewViewRotation         (out) The modified camera rotation.
	 * @param       NewFOV                          (out) The modified camera FOV.
	*/
	BlueprintModifyCamera(DeltaTime: number,ViewLocation: Vector,ViewRotation: Rotator,FOV: number,NewViewLocation?: Vector,NewViewRotation?: Rotator,NewFOV?: number): {NewViewLocation: Vector, NewViewRotation: Rotator, NewFOV: number};
	static C(Other: UObject): CameraModifier;
}

declare type EParticleSystemUpdateMode = string | symbol;
declare var EParticleSystemUpdateMode = { EPSUM_RealTime:'EPSUM_RealTime',EPSUM_FixedTime:'EPSUM_FixedTime', };
declare type EEmitterRenderMode = string | symbol;
declare var EEmitterRenderMode = { ERM_Normal:'ERM_Normal',ERM_Point:'ERM_Point',ERM_Cross:'ERM_Cross',ERM_LightsOnly:'ERM_LightsOnly',ERM_None:'ERM_None', };
declare class ParticleModule extends UObject { 
	/**
	 * If true, the module performs operations on particles during Spawning
	*/
	bSpawnModule: boolean;
	/**
	 * If true, the module performs operations on particles during Updating
	*/
	bUpdateModule: boolean;
	/**
	 * If true, the module performs operations on particles during final update
	*/
	bFinalUpdateModule: boolean;
	/**
	 * If true, the module performs operations on particles during update and/or final update for GPU emitters
	*/
	bUpdateForGPUEmitter: boolean;
	/**
	 * If true, the module displays FVector curves as colors
	*/
	bCurvesAsColor: boolean;
	/**
	 * If true, the module should render its 3D visualization helper
	*/
	b3DDrawMode: boolean;
	/**
	 * If true, the module supports rendering a 3D visualization helper
	*/
	bSupported3DDrawMode: boolean;
	/**
	 * If true, the module is enabled
	*/
	bEnabled: boolean;
	/**
	 * If true, the module has had editing enabled on it
	*/
	bEditable: boolean;
	/**
	 * If true, this flag indicates that auto-generation for LOD will result in
	 * an exact duplicate of the module, regardless of the percentage.
	 * If false, it will result in a module with different settings.
	*/
	LODDuplicate: boolean;
	/**
	 * If true, the module supports RandomSeed setting
	*/
	bSupportsRandomSeed: boolean;
	/**
	 * If true, the module should be told when looping
	*/
	bRequiresLoopingNotification: boolean;
	/**
	 * The LOD levels this module is present in.
	 * Bit-flags are used to indicate validity for a given LOD level.
	 * For example, if
	 *         ((1 << Level) & LODValidity) != 0
	 * then the module is used in that LOD.
	*/
	LODValidity: number;
	/**
	 * The color to draw the modules curves in the curve editor.
	 *     If bCurvesAsColor is true, it overrides this value.
	*/
	ModuleEditorColor: Color;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModule;
	static Find(Outer: UObject, ResourceName: string): ParticleModule;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModule;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModule;
	static C(Other: UObject): ParticleModule;
}

declare type EParticleScreenAlignment = string | symbol;
declare var EParticleScreenAlignment = { PSA_FacingCameraPosition:'PSA_FacingCameraPosition',PSA_Square:'PSA_Square',PSA_Rectangle:'PSA_Rectangle',PSA_Velocity:'PSA_Velocity',PSA_AwayFromCenter:'PSA_AwayFromCenter',PSA_TypeSpecific:'PSA_TypeSpecific', };
declare type EParticleSortMode = string | symbol;
declare var EParticleSortMode = { PSORTMODE_None:'PSORTMODE_None',PSORTMODE_ViewProjDepth:'PSORTMODE_ViewProjDepth',PSORTMODE_DistanceToView:'PSORTMODE_DistanceToView',PSORTMODE_Age_OldestFirst:'PSORTMODE_Age_OldestFirst',PSORTMODE_Age_NewestFirst:'PSORTMODE_Age_NewestFirst', };
declare class DistributionLookupTable { 
	/**
	 * Op
	*/
	Op: number;
	/**
	 * Entry Count
	*/
	EntryCount: number;
	/**
	 * Entry Stride
	*/
	EntryStride: number;
	/**
	 * Sub Entry Stride
	*/
	SubEntryStride: number;
	/**
	 * Time Scale
	*/
	TimeScale: number;
	/**
	 * Time Bias
	*/
	TimeBias: number;
	/**
	 * Values
	*/
	Values: number[];
	/**
	 * Lock Flag
	*/
	LockFlag: number;
	clone() : DistributionLookupTable;
	static C(Other: UObject): DistributionLookupTable;
}

declare class RawDistribution { 
	/**
	 * Table
	*/
	Table: DistributionLookupTable;
	clone() : RawDistribution;
	static C(Other: UObject): RawDistribution;
}

declare class Distribution extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Distribution;
	static Find(Outer: UObject, ResourceName: string): Distribution;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Distribution;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Distribution;
	static C(Other: UObject): Distribution;
}

declare class DistributionFloat extends Distribution { 
	/**
	 * Can this variable be baked out to a FRawDistribution? Should be true 99% of the time
	*/
	bCanBeBaked: boolean;
	/**
	 * Baked Data Succesfully
	*/
	bBakedDataSuccesfully: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionFloat;
	static Find(Outer: UObject, ResourceName: string): DistributionFloat;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionFloat;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionFloat;
	static C(Other: UObject): DistributionFloat;
}

declare class RawDistributionFloat extends RawDistribution { 
	/**
	 * Min Value
	*/
	MinValue: number;
	/**
	 * Max Value
	*/
	MaxValue: number;
	/**
	 * Distribution
	*/
	Distribution: DistributionFloat;
	clone() : RawDistributionFloat;
	static C(Other: UObject): RawDistributionFloat;
}

declare type EParticleBurstMethod = string | symbol;
declare var EParticleBurstMethod = { EPBM_Instant:'EPBM_Instant',EPBM_Interpolated:'EPBM_Interpolated', };
declare class ParticleBurst { 
	/**
	 * The number of particles to burst
	*/
	Count: number;
	/**
	 * If >= 0, use as a range [CountLow..Count]
	*/
	CountLow: number;
	/**
	 * The time at which to burst them (0..1: emitter lifetime)
	*/
	Time: number;
	clone() : ParticleBurst;
	static C(Other: UObject): ParticleBurst;
}

declare type EParticleSubUVInterpMethod = string | symbol;
declare var EParticleSubUVInterpMethod = { PSUVIM_None:'PSUVIM_None',PSUVIM_Linear:'PSUVIM_Linear',PSUVIM_Linear_Blend:'PSUVIM_Linear_Blend',PSUVIM_Random:'PSUVIM_Random',PSUVIM_Random_Blend:'PSUVIM_Random_Blend', };
declare type EEmitterNormalsMode = string | symbol;
declare var EEmitterNormalsMode = { ENM_CameraFacing:'ENM_CameraFacing',ENM_Spherical:'ENM_Spherical',ENM_Cylindrical:'ENM_Cylindrical', };
declare type EParticleUVFlipMode = string | symbol;
declare var EParticleUVFlipMode = { None:'None',FlipUV:'FlipUV',FlipUOnly:'FlipUOnly',FlipVOnly:'FlipVOnly',RandomFlipUV:'RandomFlipUV',RandomFlipUOnly:'RandomFlipUOnly',RandomFlipVOnly:'RandomFlipVOnly',RandomFlipUVIndependent:'RandomFlipUVIndependent', };
declare class ParticleModuleRequired extends ParticleModule { 
	/**
	 * The material to utilize for the emitter at this LOD level.
	*/
	Material: MaterialInterface;
	/**
	 * Emitter Origin
	*/
	EmitterOrigin: Vector;
	/**
	 * Emitter Rotation
	*/
	EmitterRotation: Rotator;
	/**
	 * The screen alignment to utilize for the emitter at this LOD level.
	 * One of the following:
	 * PSA_FacingCameraPosition - Faces the camera position, but is not dependent on the camera rotation.
	 *                                                         This method produces more stable particles under camera rotation.
	 * PSA_Square                      - Uniform scale (via SizeX) facing the camera
	 * PSA_Rectangle           - Non-uniform scale (via SizeX and SizeY) facing the camera
	 * PSA_Velocity            - Orient the particle towards both the camera and the direction
	 *                                           the particle is moving. Non-uniform scaling is allowed.
	 * PSA_TypeSpecific        - Use the alignment method indicated int he type data module.
	*/
	ScreenAlignment: EParticleScreenAlignment;
	/**
	 * If true, update the emitter in local space
	*/
	bUseLocalSpace: boolean;
	/**
	 * If true, kill the emitter when the particle system is deactivated
	*/
	bKillOnDeactivate: boolean;
	/**
	 * If true, kill the emitter when it completes
	*/
	bKillOnCompleted: boolean;
	/**
	 * The sorting mode to use for this emitter.
	 * PSORTMODE_None                          - No sorting required.
	 * PSORTMODE_ViewProjDepth         - Sort by view projected depth of the particle.
	 * PSORTMODE_DistanceToView        - Sort by distance of particle to view in world space.
	 * PSORTMODE_Age_OldestFirst       - Sort by age, oldest drawn first.
	 * PSORTMODE_Age_NewestFirst       - Sort by age, newest drawn first.
	*/
	SortMode: EParticleSortMode;
	/**
	 * If true, the EmitterTime for the emitter will be calculated by
	 * modulating the SecondsSinceCreation by the EmitterDuration. As
	 * this can lead to issues w/ looping and variable duration, a new
	 * approach has been implemented.
	 * If false, this new approach is utilized, and the EmitterTime is
	 * simply incremented by DeltaTime each tick. When the emitter
	 * loops, it adjusts the EmitterTime by the current EmitterDuration
	 * resulting in proper looping/delay behavior.
	*/
	bUseLegacyEmitterTime: boolean;
	/**
	 * How long, in seconds, the emitter will run before looping.
	*/
	EmitterDuration: number;
	/**
	 * The low end of the emitter duration if using a range.
	*/
	EmitterDurationLow: number;
	/**
	 * If true, select the emitter duration from the range
	 *         [EmitterDurationLow..EmitterDuration]
	*/
	bEmitterDurationUseRange: boolean;
	/**
	 * If true, recalculate the emitter duration on each loop.
	*/
	bDurationRecalcEachLoop: boolean;
	/**
	 * The number of times to loop the emitter.
	 *     0 indicates loop continuously
	*/
	EmitterLoops: number;
	/**
	 * The rate at which to spawn particles
	*/
	SpawnRate: RawDistributionFloat;
	/**
	 * The method to utilize when burst-emitting particles
	*/
	ParticleBurstMethod: EParticleBurstMethod;
	/**
	 * The array of burst entries.
	*/
	BurstList: ParticleBurst[];
	/**
	 * Indicates the time (in seconds) that this emitter should be delayed in the particle system.
	*/
	EmitterDelay: number;
	/**
	 * The low end of the emitter delay if using a range.
	*/
	EmitterDelayLow: number;
	/**
	 * If true, select the emitter delay from the range
	 *         [EmitterDelayLow..EmitterDelay]
	*/
	bEmitterDelayUseRange: boolean;
	/**
	 * If true, the emitter will be delayed only on the first loop.
	*/
	bDelayFirstLoopOnly: boolean;
	/**
	 * The interpolation method to used for the SubUV image selection.
	 * One of the following:
	 * PSUVIM_None                     - Do not apply SubUV modules to this emitter.
	 * PSUVIM_Linear           - Smoothly transition between sub-images in the given order,
	 *                                           with no blending between the current and the next
	 * PSUVIM_Linear_Blend     - Smoothly transition between sub-images in the given order,
	 *                                           blending between the current and the next
	 * PSUVIM_Random           - Pick the next image at random, with no blending between
	 *                                           the current and the next
	 * PSUVIM_Random_Blend     - Pick the next image at random, blending between the current
	 *                                           and the next
	*/
	InterpolationMethod: EParticleSubUVInterpMethod;
	/**
	 * The number of sub-images horizontally in the texture
	*/
	SubImages_Horizontal: number;
	/**
	 * The number of sub-images vertically in the texture
	*/
	SubImages_Vertical: number;
	/**
	 * Whether to scale the UV or not - ie, the model wasn't setup with sub uvs
	*/
	bScaleUV: boolean;
	/**
	 * The amount of time (particle-relative, 0.0 to 1.0) to 'lock' on a random sub image
	 *     0.0 = change every frame
	 * 1.0 = select a random image at spawn and hold for the life of the particle
	*/
	RandomImageTime: number;
	/**
	 * The number of times to change a random image over the life of the particle.
	*/
	RandomImageChanges: number;
	/**
	 * Override the system MacroUV settings
	*/
	bOverrideSystemMacroUV: boolean;
	/**
	 * Local space position that UVs generated with the ParticleMacroUV material node will be centered on.
	*/
	MacroUVPosition: Vector;
	/**
	 * World space radius that UVs generated with the ParticleMacroUV material node will tile based on.
	*/
	MacroUVRadius: number;
	/**
	 * If true, use the MaxDrawCount to limit the number of particles rendered.
	 * NOTE: This does not limit the number spawned/updated, only what is drawn.
	*/
	bUseMaxDrawCount: boolean;
	/**
	 * The maximum number of particles to DRAW for this emitter.
	 * If set to 0, it will use whatever number are present.
	*/
	MaxDrawCount: number;
	/**
	 * Normal generation mode for this emitter LOD.
	*/
	EmitterNormalsMode: EEmitterNormalsMode;
	/**
	 * When EmitterNormalsMode is ENM_Spherical, particle normals are created to face away from NormalsSphereCenter.
	 * NormalsSphereCenter is in local space.
	*/
	NormalsSphereCenter: Vector;
	/**
	 * When EmitterNormalsMode is ENM_Cylindrical,
	 * particle normals are created to face away from the cylinder going through NormalsSphereCenter in the direction NormalsCylinderDirection.
	 * NormalsCylinderDirection is in local space.
	*/
	NormalsCylinderDirection: Vector;
	/**
	 * Ensures that movement generated from the orbit module is applied to velocity-aligned particles
	*/
	bOrbitModuleAffectsVelocityAlignment: boolean;
	/**
	 * Controls UV Flipping for this emitter.
	*/
	UVFlippingMode: EParticleUVFlipMode;
	/**
	 * Named material overrides for this emitter.
	 * Overrides this emitter's material(s) with those in the correspondingly named slot(s) of the owning system.
	*/
	NamedMaterialOverrides: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleRequired;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleRequired;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleRequired;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleRequired;
	static C(Other: UObject): ParticleModuleRequired;
}

declare class ParticleModuleTypeDataBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleTypeDataBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleTypeDataBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleTypeDataBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleTypeDataBase;
	static C(Other: UObject): ParticleModuleTypeDataBase;
}

declare class ParticleModuleSpawnBase extends ParticleModule { 
	/**
	 * If true, the SpawnRate of the SpawnModule of the emitter will be processed.
	 * If mutliple Spawn modules are 'stacked' in an emitter, if ANY of them
	 * have this set to false, it will not process the SpawnModule SpawnRate.
	*/
	bProcessSpawnRate: boolean;
	/**
	 * If true, the BurstList of the SpawnModule of the emitter will be processed.
	 * If mutliple Spawn modules are 'stacked' in an emitter, if ANY of them
	 * have this set to false, it will not process the SpawnModule BurstList.
	*/
	bProcessBurstList: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSpawnBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawnBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSpawnBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawnBase;
	static C(Other: UObject): ParticleModuleSpawnBase;
}

declare class ParticleModuleSpawn extends ParticleModuleSpawnBase { 
	/**
	 * The rate at which to spawn particles.
	*/
	Rate: RawDistributionFloat;
	/**
	 * The scalar to apply to the rate.
	*/
	RateScale: RawDistributionFloat;
	/**
	 * The method to utilize when burst-emitting particles.
	*/
	ParticleBurstMethod: EParticleBurstMethod;
	/**
	 * The array of burst entries.
	*/
	BurstList: ParticleBurst[];
	/**
	 * Scale all burst entries by this amount.
	*/
	BurstScale: RawDistributionFloat;
	/**
	 * If true, the SpawnRate will be scaled by the global CVar r.EmitterSpawnRateScale
	*/
	bApplyGlobalSpawnRateScale: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleSpawn;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleSpawn;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleSpawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleSpawn;
	static C(Other: UObject): ParticleModuleSpawn;
}

declare class ParticleModuleEventBase extends ParticleModule { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventBase;
	static C(Other: UObject): ParticleModuleEventBase;
}

declare type EParticleEventType = string | symbol;
declare var EParticleEventType = { EPET_Any:'EPET_Any',EPET_Spawn:'EPET_Spawn',EPET_Death:'EPET_Death',EPET_Collision:'EPET_Collision',EPET_Burst:'EPET_Burst',EPET_Blueprint:'EPET_Blueprint', };
declare class ParticleModuleEventSendToGame extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventSendToGame;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventSendToGame;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventSendToGame;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventSendToGame;
	static C(Other: UObject): ParticleModuleEventSendToGame;
}

declare class ParticleEvent_GenerateInfo { 
	/**
	 * The type of event.
	*/
	Type: EParticleEventType;
	/**
	 * How often to trigger the event (<= 1 means EVERY time).
	*/
	Frequency: number;
	/**
	 * Only fire the first time (collision only).
	*/
	ParticleFrequency: number;
	/**
	 * Only fire the first time (collision only).
	*/
	FirstTimeOnly: boolean;
	/**
	 * Only fire the last time (collision only).
	*/
	LastTimeOnly: boolean;
	/**
	 * Use the impact FVector not the hit normal (collision only).
	*/
	UseReflectedImpactVector: boolean;
	/**
	 * Use the orbit offset when computing the position at which the event occurred.
	*/
	bUseOrbitOffset: boolean;
	/**
	 * Should the event tag with a custom name? Leave blank for the default.
	*/
	CustomName: string;
	/**
	 * The events we want to fire off when this event has been generated
	*/
	ParticleModuleEventsToSendToGame: ParticleModuleEventSendToGame[];
	clone() : ParticleEvent_GenerateInfo;
	static C(Other: UObject): ParticleEvent_GenerateInfo;
}

declare class ParticleModuleEventGenerator extends ParticleModuleEventBase { 
	/**
	 * Events
	*/
	Events: ParticleEvent_GenerateInfo[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventGenerator;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventGenerator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventGenerator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventGenerator;
	static C(Other: UObject): ParticleModuleEventGenerator;
}

declare class ParticleModuleOrbitBase extends ParticleModule { 
	/**
	 * If true, distribution values will be retrieved using the EmitterTime.
	 * If false (default), they will be retrieved using the Particle.RelativeTime.
	*/
	bUseEmitterTime: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleOrbitBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrbitBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleOrbitBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrbitBase;
	static C(Other: UObject): ParticleModuleOrbitBase;
}

declare type EOrbitChainMode = string | symbol;
declare var EOrbitChainMode = { EOChainMode_Add:'EOChainMode_Add',EOChainMode_Scale:'EOChainMode_Scale',EOChainMode_Link:'EOChainMode_Link', };
declare class DistributionVector extends Distribution { 
	/**
	 * Can this variable be baked out to a FRawDistribution? Should be true 99% of the time
	*/
	bCanBeBaked: boolean;
	/**
	 * Set internally when the distribution is updated so that that FRawDistribution can know to update itself
	*/
	bIsDirty: boolean;
	/**
	 * Baked Data Succesfully
	*/
	bBakedDataSuccesfully: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DistributionVector;
	static Find(Outer: UObject, ResourceName: string): DistributionVector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DistributionVector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DistributionVector;
	static C(Other: UObject): DistributionVector;
}

declare class RawDistributionVector extends RawDistribution { 
	/**
	 * Min Value
	*/
	MinValue: number;
	/**
	 * Max Value
	*/
	MaxValue: number;
	/**
	 * Min Value Vec
	*/
	MinValueVec: Vector;
	/**
	 * Max Value Vec
	*/
	MaxValueVec: Vector;
	/**
	 * Distribution
	*/
	Distribution: DistributionVector;
	clone() : RawDistributionVector;
	static C(Other: UObject): RawDistributionVector;
}

declare class OrbitOptions { 
	/**
	 * Whether to process the data during spawning.
	*/
	bProcessDuringSpawn: boolean;
	/**
	 * Whether to process the data during updating.
	*/
	bProcessDuringUpdate: boolean;
	/**
	 * Whether to use emitter time during data retrieval.
	*/
	bUseEmitterTime: boolean;
	clone() : OrbitOptions;
	static C(Other: UObject): OrbitOptions;
}

declare class ParticleModuleOrbit extends ParticleModuleOrbitBase { 
	/**
	 * Orbit modules will chain together in the order they appear in the module stack.
	 * The combination of a module with the one prior to it is defined by using one
	 * of the following enumerations:
	 *         EOChainMode_Add         Add the values to the previous results
	 *         EOChainMode_Scale       Multiply the values by the previous results
	 *         EOChainMode_Link        'Break' the chain and apply the values from the previous results
	*/
	ChainMode: EOrbitChainMode;
	/**
	 * The amount to offset the sprite from the particle position.
	*/
	OffsetAmount: RawDistributionVector;
	/**
	 * The options associated with the OffsetAmount look-up.
	*/
	OffsetOptions: OrbitOptions;
	/**
	 * The amount (in 'turns') to rotate the offset about the particle position.
	 *         0.0 = no rotation
	 *         0.5     = 180 degree rotation
	 *         1.0 = 360 degree rotation
	*/
	RotationAmount: RawDistributionVector;
	/**
	 * The options associated with the RotationAmount look-up.
	*/
	RotationOptions: OrbitOptions;
	/**
	 * The rate (in 'turns') at which to rotate the offset about the particle positon.
	 *         0.0 = no rotation
	 *         0.5     = 180 degree rotation
	 *         1.0 = 360 degree rotation
	*/
	RotationRateAmount: RawDistributionVector;
	/**
	 * The options associated with the RotationRateAmount look-up.
	*/
	RotationRateOptions: OrbitOptions;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleOrbit;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleOrbit;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleOrbit;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleOrbit;
	static C(Other: UObject): ParticleModuleOrbit;
}

declare class ParticleModuleEventReceiverBase extends ParticleModuleEventBase { 
	/**
	 * The type of event that will generate the kill.
	*/
	EventGeneratorType: EParticleEventType;
	/**
	 * The name of the emitter of interest for generating the event.
	*/
	EventName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleModuleEventReceiverBase;
	static Find(Outer: UObject, ResourceName: string): ParticleModuleEventReceiverBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleModuleEventReceiverBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleModuleEventReceiverBase;
	static C(Other: UObject): ParticleModuleEventReceiverBase;
}

declare class ParticleLODLevel extends UObject { 
	/**
	 * The index value of the LOD level
	*/
	Level: number;
	/**
	 * True if the LOD level is enabled, meaning it should be updated and rendered.
	*/
	bEnabled: boolean;
	/**
	 * The required module for this LOD level
	*/
	RequiredModule: ParticleModuleRequired;
	/**
	 * An array of particle modules that contain the adjusted data for the LOD level
	*/
	Modules: ParticleModule[];
	/**
	 * Module<SINGULAR> used for emitter type "extension".
	*/
	TypeDataModule: ParticleModuleTypeDataBase;
	/**
	 * The SpawnRate/Burst module - required by all emitters.
	*/
	SpawnModule: ParticleModuleSpawn;
	/**
	 * The optional EventGenerator module.
	*/
	EventGenerator: ParticleModuleEventGenerator;
	/**
	 * SpawningModules - These are called to determine how many particles to spawn.
	*/
	SpawningModules: ParticleModuleSpawnBase[];
	/**
	 * SpawnModules - These are called when particles are spawned.
	*/
	SpawnModules: ParticleModule[];
	/**
	 * UpdateModules - These are called when particles are updated.
	*/
	UpdateModules: ParticleModule[];
	/**
	 * OrbitModules
	 *     These are used to do offsets of the sprite from the particle location.
	*/
	OrbitModules: ParticleModuleOrbit[];
	/**
	 * Event receiver modules only!
	*/
	EventReceiverModules: ParticleModuleEventReceiverBase[];
	/**
	 * Converted Modules
	*/
	ConvertedModules: boolean;
	/**
	 * Peak Active Particles
	*/
	PeakActiveParticles: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleLODLevel;
	static Find(Outer: UObject, ResourceName: string): ParticleLODLevel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleLODLevel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleLODLevel;
	static C(Other: UObject): ParticleLODLevel;
}

declare type EParticleSignificanceLevel = string | symbol;
declare var EParticleSignificanceLevel = { Low:'Low',Medium:'Medium',High:'High',Critical:'Critical',Num:'Num', };
declare class ParticleEmitter extends UObject { 
	/**
	 * The name of the emitter.
	*/
	EmitterName: string;
	/**
	 * Sub UVData Offset
	*/
	SubUVDataOffset: number;
	/**
	 * How to render the emitter particles. Can be one of the following:
	 *         ERM_Normal      - As the intended sprite/mesh
	 *         ERM_Point       - As a 2x2 pixel block with no scaling and the color set in EmitterEditorColor
	 *         ERM_Cross       - As a cross of lines, scaled to the size of the particle in EmitterEditorColor
	 *         ERM_None        - Do not render
	*/
	EmitterRenderMode: EEmitterRenderMode;
	/**
	 * The color of the emitter in the curve editor and debug rendering modes.
	*/
	EmitterEditorColor: Color;
	/**
	 * 'Private' data - not required by the editor
	*/
	LODLevels: ParticleLODLevel[];
	/**
	 * Converted Modules
	*/
	ConvertedModules: boolean;
	/**
	 * Peak Active Particles
	*/
	PeakActiveParticles: number;
	/**
	 * Initial allocation count - overrides calculated peak count if > 0
	*/
	InitialAllocationCount: number;
	/**
	 * Scales the spawn rate of this emitter when the engine is running in medium or low detail mode.
	 * This can be used to optimize particle draw cost in splitscreen.
	 * A value of 0 effectively disables this emitter outside of high detail mode,
	 * And this does not affect spawn per unit, unless the value is 0.
	*/
	MediumDetailSpawnRateScale: number;
	/**
	 * Quality Level Spawn Rate Scale
	*/
	QualityLevelSpawnRateScale: number;
	/**
	 * If detail mode is >= system detail mode, primitive won't be rendered.
	*/
	DetailMode: EDetailMode;
	/**
	 * This value indicates the emitter should be drawn 'collapsed' in Cascade
	*/
	bCollapsed: boolean;
	/**
	 * If true, then show only this emitter in the editor
	*/
	bIsSoloing: boolean;
	/**
	 * If true, then this emitter was 'cooked out' by the cooker.
	 * This means it was completely disabled, but to preserve any
	 * indexing schemes, it is left in place.
	*/
	bCookedOut: boolean;
	/**
	 * When true, if the current LOD is disabled the emitter will be kept alive. Otherwise, the emitter will be considered complete if the current LOD is disabled.
	*/
	bDisabledLODsKeepEmitterAlive: boolean;
	/**
	 * When true, emitters deemed insignificant will have their tick and render disabled Instantly. When false they will simple stop spawning new particles.
	*/
	bDisableWhenInsignficant: boolean;
	/**
	 * The significance level required of this emitter's owner for this emitter to be active.
	*/
	SignificanceLevel: EParticleSignificanceLevel;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleEmitter;
	static Find(Outer: UObject, ResourceName: string): ParticleEmitter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleEmitter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleEmitter;
	static C(Other: UObject): ParticleEmitter;
}

declare class CurveEdEntry { 
	/**
	 * Curve Object
	*/
	CurveObject: UObject;
	/**
	 * Curve Color
	*/
	CurveColor: Color;
	/**
	 * Curve Name
	*/
	CurveName: string;
	/**
	 * B Hide Curve
	*/
	bHideCurve: number;
	/**
	 * B Color Curve
	*/
	bColorCurve: number;
	/**
	 * B Floating Point Color Curve
	*/
	bFloatingPointColorCurve: number;
	/**
	 * B Clamp
	*/
	bClamp: number;
	/**
	 * Clamp Low
	*/
	ClampLow: number;
	/**
	 * Clamp High
	*/
	ClampHigh: number;
	clone() : CurveEdEntry;
	static C(Other: UObject): CurveEdEntry;
}

declare class CurveEdTab { 
	/**
	 * Tab Name
	*/
	TabName: string;
	/**
	 * Curves
	*/
	Curves: CurveEdEntry[];
	/**
	 * Remember the view setting for each tab.
	*/
	ViewStartInput: number;
	/**
	 * View End Input
	*/
	ViewEndInput: number;
	/**
	 * View Start Output
	*/
	ViewStartOutput: number;
	/**
	 * View End Output
	*/
	ViewEndOutput: number;
	clone() : CurveEdTab;
	static C(Other: UObject): CurveEdTab;
}

declare class InterpCurveEdSetup extends UObject { 
	/**
	 * Tabs
	*/
	Tabs: CurveEdTab[];
	/**
	 * Active Tab
	*/
	ActiveTab: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpCurveEdSetup;
	static Find(Outer: UObject, ResourceName: string): InterpCurveEdSetup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpCurveEdSetup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpCurveEdSetup;
	static C(Other: UObject): InterpCurveEdSetup;
}

declare type ParticleSystemLODMethod = string | symbol;
declare var ParticleSystemLODMethod = { PARTICLESYSTEMLODMETHOD_Automatic:'PARTICLESYSTEMLODMETHOD_Automatic',PARTICLESYSTEMLODMETHOD_DirectSet:'PARTICLESYSTEMLODMETHOD_DirectSet',PARTICLESYSTEMLODMETHOD_ActivateAutomatic:'PARTICLESYSTEMLODMETHOD_ActivateAutomatic', };
declare class ParticleSystemLOD { 
	clone() : ParticleSystemLOD;
	static C(Other: UObject): ParticleSystemLOD;
}

declare type EParticleSystemInsignificanceReaction = string | symbol;
declare var EParticleSystemInsignificanceReaction = { Auto:'Auto',Complete:'Complete',DisableTick:'DisableTick',DisableTickAndKill:'DisableTickAndKill',Num:'Num', };
declare type EParticleSystemOcclusionBoundsMethod = string | symbol;
declare var EParticleSystemOcclusionBoundsMethod = { EPSOBM_None:'EPSOBM_None',EPSOBM_ParticleBounds:'EPSOBM_ParticleBounds',EPSOBM_CustomBounds:'EPSOBM_CustomBounds', };
declare class LODSoloTrack { 
	/**
	 * Solo Enable Setting
	*/
	SoloEnableSetting: number[];
	clone() : LODSoloTrack;
	static C(Other: UObject): LODSoloTrack;
}

declare class NamedEmitterMaterial { 
	/**
	 * Name
	*/
	Name: string;
	/**
	 * Material
	*/
	Material: MaterialInterface;
	clone() : NamedEmitterMaterial;
	static C(Other: UObject): NamedEmitterMaterial;
}

declare class ParticleSystem extends UObject { 
	/**
	 * System Update Mode
	*/
	SystemUpdateMode: EParticleSystemUpdateMode;
	/**
	 * UpdateTime_FPS - the frame per second to update at in FixedTime mode
	*/
	UpdateTime_FPS: number;
	/**
	 * UpdateTime_Delta       - internal
	*/
	UpdateTime_Delta: number;
	/**
	 * WarmupTime     - the time to warm-up the particle system when first rendered
	*/
	WarmupTime: number;
	/**
	 * WarmupTickRate - the time step for each tick during warm up.
	 *        Increasing this improves performance. Decreasing, improves accuracy.
	 *        Set to 0 to use the default tick time.
	*/
	WarmupTickRate: number;
	/**
	 * Emitters       - internal - the array of emitters in the system
	*/
	Emitters: ParticleEmitter[];
	/**
	 * The component used to preview the particle system in Cascade
	*/
	PreviewComponent: ParticleSystemComponent;
	/**
	 * The angle to use when rendering the thumbnail image
	*/
	ThumbnailAngle: Rotator;
	/**
	 * The distance to place the system when rendering the thumbnail image
	*/
	ThumbnailDistance: number;
	/**
	 * The time to warm-up the system for the thumbnail image
	*/
	ThumbnailWarmup: number;
	/**
	 * Used for curve editor to remember curve-editing setup.
	*/
	CurveEdSetup: InterpCurveEdSetup;
	/**
	 * If true, the system's Z axis will be oriented toward the camera
	*/
	bOrientZAxisTowardCamera: boolean;
	/**
	 * How often (in seconds) the system should perform the LOD distance check.
	*/
	LODDistanceCheckTime: number;
	/**
	 * The method of LOD level determination to utilize for this particle system
	 *   PARTICLESYSTEMLODMETHOD_Automatic - Automatically set the LOD level, checking every LODDistanceCheckTime seconds.
	 * PARTICLESYSTEMLODMETHOD_DirectSet - LOD level is directly set by the game code.
	 * PARTICLESYSTEMLODMETHOD_ActivateAutomatic - LOD level is determined at Activation time, then left alone unless directly set by game code.
	*/
	LODMethod: ParticleSystemLODMethod;
	/**
	 * The array of distances for each LOD level in the system.
	 * Used when LODMethod is set to PARTICLESYSTEMLODMETHOD_Automatic.
	 * Example: System with 3 LOD levels
	 *         LODDistances(0) = 0.0
	 *         LODDistances(1) = 2500.0
	 *         LODDistances(2) = 5000.0
	 *         In this case, when the system is [   0.0 ..   2499.9] from the camera, LOD level 0 will be used.
	 *                                                                          [2500.0 ..   4999.9] from the camera, LOD level 1 will be used.
	 *                                                                          [5000.0 .. INFINITY] from the camera, LOD level 2 will be used.
	*/
	LODDistances: number[];
	/**
	 * LOD setting for intepolation (set by Cascade) Range [0..100]
	*/
	EditorLODSetting: number;
	/**
	 * Internal value that tracks the regenerate LOD levels preference.
	 * If true, when autoregenerating LOD levels in code, the low level will
	 * be a duplicate of the high.
	*/
	bRegenerateLODDuplicate: boolean;
	/**
	 * LODSettings
	*/
	LODSettings: ParticleSystemLOD[];
	/**
	 * Whether to use the fixed relative bounding box or calculate it every frame.
	*/
	bUseFixedRelativeBoundingBox: boolean;
	/**
	 * Fixed relative bounding box for particle system.
	*/
	FixedRelativeBoundingBox: Box;
	/**
	 * Number of seconds of emitter not being rendered that need to pass before it
	 * no longer gets ticked/ becomes inactive.
	*/
	SecondsBeforeInactive: number;
	/**
	 * Cascade 'floor' mesh information.
	*/
	FloorMesh: string;
	/**
	 * Floor Position
	*/
	FloorPosition: Vector;
	/**
	 * Floor Rotation
	*/
	FloorRotation: Rotator;
	/**
	 * Floor Scale
	*/
	FloorScale: number;
	/**
	 * Floor Scale 3D
	*/
	FloorScale3D: Vector;
	/**
	 * The background color to display in Cascade
	*/
	BackgroundColor: Color;
	/**
	 * EDITOR ONLY: Indicates that Cascade would like to have the PeakActiveParticles count reset
	*/
	bShouldResetPeakCounts: boolean;
	/**
	 * Set during load time to indicate that physics is used...
	*/
	bHasPhysics: boolean;
	/**
	 * Inidicates the old 'real-time' thumbnail rendering should be used
	*/
	bUseRealtimeThumbnail: boolean;
	/**
	 * Internal: Indicates the PSys thumbnail image is out of date
	*/
	ThumbnailImageOutOfDate: boolean;
	/**
	 * Internal: The PSys thumbnail image
	*/
	ThumbnailImage: Texture2D;
	/**
	 * How long this Particle system should delay when ActivateSystem is called on it.
	*/
	Delay: number;
	/**
	 * The low end of the emitter delay if using a range.
	*/
	DelayLow: number;
	/**
	 * If true, select the emitter delay from the range
	 *         [DelayLow..Delay]
	*/
	bUseDelayRange: boolean;
	/**
	 * Auto-deactivate system if all emitters are determined to not spawn particles again, regardless of lifetime.
	*/
	bAutoDeactivate: boolean;
	/**
	 * Minimum duration between ticks; 33=tick at max. 30FPS, 16=60FPS, 8=120FPS
	*/
	MinTimeBetweenTicks: any;
	/**
	 * The reaction this system takes when all emitters are insignificant.
	*/
	InsignificantReaction: EParticleSystemInsignificanceReaction;
	/**
	 * Time delay between all emitters becoming insignificant and the systems insignificant reaction.
	*/
	InsignificanceDelay: number;
	/**
	 * The maximum level of significance for emitters in this system. Any emitters with a higher significance will be capped at this significance level.
	*/
	MaxSignificanceLevel: EParticleSignificanceLevel;
	/**
	 * Local space position that UVs generated with the ParticleMacroUV material node will be centered on.
	*/
	MacroUVPosition: Vector;
	/**
	 * World space radius that UVs generated with the ParticleMacroUV material node will tile based on.
	*/
	MacroUVRadius: number;
	/**
	 * Which occlusion bounds method to use for this particle system.
	 * EPSOBM_None - Don't determine occlusion for this system.
	 * EPSOBM_ParticleBounds - Use the bounds of the component when determining occlusion.
	*/
	OcclusionBoundsMethod: EParticleSystemOcclusionBoundsMethod;
	/**
	 * The occlusion bounds to use if OcclusionBoundsMethod is set to EPSOBM_CustomBounds
	*/
	CustomOcclusionBounds: Box;
	/**
	 * Solo Tracking
	*/
	SoloTracking: LODSoloTrack[];
	/**
	 * Array of named material slots for use by emitters of this system.
	 * Emitters can use these instead of their own materials by providing the name to the NamedMaterialOverrides property of their required module.
	 * These materials can be overridden using CreateNamedDynamicMaterialInstance() on a ParticleSystemComponent.
	*/
	NamedMaterialSlots: NamedEmitterMaterial[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystem;
	static Find(Outer: UObject, ResourceName: string): ParticleSystem;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystem;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystem;
	/**
	 * Returns true if this system contains an emitter of the pasesd type.
	 * @ param TypeData - The emitter type to check for. Must be a child class of UParticleModuleTypeDataBase
	*/
	ContainsEmitterType(TypeData: UnrealEngineClass): boolean;
	static C(Other: UObject): ParticleSystem;
	/**
	 * Plays the specified effect attached to and following the specified component. The system will go away when the effect is complete. Does not replicate.
	 * @param EmitterTemplate - particle system to create
	 * @param AttachComponent - Component to attach to.
	 * @param AttachPointName - Optional named point within the AttachComponent to spawn the emitter at
	 * @param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
	 * @param Rotation - Depending on the value of LocationType this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a realative offset
	 * @param LocationType - Specifies whether Location is a relative offset or an absolute world position
	 * @param bAutoDestroy - Whether the component will automatically be destroyed when the particle system completes playing or whether it can be reactivated
	*/
	SpawnEmitterAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bAutoDestroy: boolean): ParticleSystemComponent;
	/**
	 * Plays the specified effect attached to and following the specified component. The system will go away when the effect is complete. Does not replicate.
	 * @param EmitterTemplate - particle system to create
	 * @param AttachComponent - Component to attach to.
	 * @param AttachPointName - Optional named point within the AttachComponent to spawn the emitter at
	 * @param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
	 * @param Rotation - Depending on the value of LocationType this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a realative offset
	 * @param LocationType - Specifies whether Location is a relative offset or an absolute world position
	 * @param bAutoDestroy - Whether the component will automatically be destroyed when the particle system completes playing or whether it can be reactivated
	*/
	static SpawnEmitterAttached(EmitterTemplate: ParticleSystem,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bAutoDestroy: boolean): ParticleSystemComponent;
}

declare type EParticleSysParamType = string | symbol;
declare var EParticleSysParamType = { PSPT_None:'PSPT_None',PSPT_Scalar:'PSPT_Scalar',PSPT_ScalarRand:'PSPT_ScalarRand',PSPT_Vector:'PSPT_Vector',PSPT_VectorRand:'PSPT_VectorRand',PSPT_Color:'PSPT_Color',PSPT_Actor:'PSPT_Actor',PSPT_Material:'PSPT_Material', };
declare class ParticleSysParam { 
	/**
	 * The name of the parameter
	*/
	Name: string;
	/**
	 * The type of parameters
	 * PSPT_None       - There is no data type
	 * PSPT_Scalar     - Use the scalar value
	 * PSPT_ScalarRand - Select a scalar value in the range [Scalar_Low..Scalar)
	 * PSPT_Vector     - Use the vector value
	 * PSPT_VectorRand - Select a vector value in the range [Vector_Low..Vector)
	 * PSPT_Color      - Use the color value
	 * PSPT_Actor      - Use the actor value
	 * PSPT_Material   - Use the material value
	*/
	ParamType: EParticleSysParamType;
	/**
	 * Scalar
	*/
	Scalar: number;
	/**
	 * Scalar Low
	*/
	Scalar_Low: number;
	/**
	 * Vector
	*/
	Vector: Vector;
	/**
	 * Vector Low
	*/
	Vector_Low: Vector;
	/**
	 * Color
	*/
	Color: Color;
	/**
	 * Actor
	*/
	Actor: Actor;
	/**
	 * Material
	*/
	Material: MaterialInterface;
	clone() : ParticleSysParam;
	static C(Other: UObject): ParticleSysParam;
}

declare class ParticleSystemReplay extends UObject { 
	/**
	 * Unique ID number for this replay clip
	*/
	ClipIDNumber: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystemReplay;
	static Find(Outer: UObject, ResourceName: string): ParticleSystemReplay;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystemReplay;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemReplay;
	static C(Other: UObject): ParticleSystemReplay;
}

declare type EAttachmentRule = string | symbol;
declare var EAttachmentRule = { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld',SnapToTarget:'SnapToTarget', };
declare type ETrailWidthMode = string | symbol;
declare var ETrailWidthMode = { ETrailWidthMode_FromCentre:'ETrailWidthMode_FromCentre',ETrailWidthMode_FromFirst:'ETrailWidthMode_FromFirst',ETrailWidthMode_FromSecond:'ETrailWidthMode_FromSecond', };
declare class ParticleSystemComponent extends PrimitiveComponent { 
	/**
	 * Template
	*/
	Template: ParticleSystem;
	/**
	 * Emitter Materials
	*/
	EmitterMaterials: MaterialInterface[];
	/**
	 * The skeletal mesh components used with the socket location module.
	 * This is to prevent them from being garbage collected.
	*/
	SkelMeshComponents: SkeletalMeshComponent[];
	/**
	 * Reset on Detach
	*/
	bResetOnDetach: boolean;
	/**
	 * whether to update the particle system on dedicated servers
	*/
	bUpdateOnDedicatedServer: boolean;
	/**
	 * If true, this Particle System will be available for recycling after it has completed. Auto-destroyed systems cannot be recycled.
	 * Some systems (currently particle trail effects) can recycle components to avoid respawning them to play new effects.
	 * This is only an optimization and does not change particle system behavior, aside from not triggering normal component initialization events more than once.
	*/
	bAllowRecycling: boolean;
	/**
	 * True if we should automatically attach to AutoAttachParent when activated, and detach from our parent when completed.
	 * This overrides any current attachment that may be present at the time of activation (deferring initial attachment until activation, if AutoAttachParent is null).
	 * When enabled, detachment occurs regardless of whether AutoAttachParent is assigned, and the relative transform from the time of activation is restored.
	 * This also disables attachment on dedicated servers, where we don't actually activate even if bAutoActivate is true.
	 * @see AutoAttachParent, AutoAttachSocketName, AutoAttachLocationType
	*/
	bAutoManageAttachment: boolean;
	/**
	 * The significance this component requires of it's emitters for them to be enabled.
	*/
	RequiredSignificance: EParticleSignificanceLevel;
	/**
	 * Array holding name instance parameters for this ParticleSystemComponent.
	 * Parameters can be used in Cascade using DistributionFloat/VectorParticleParameters.
	*/
	InstanceParameters: ParticleSysParam[];
	/**
	 * On Particle Spawn
	*/
	OnParticleSpawn: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
	/**
	 * On Particle Burst
	*/
	OnParticleBurst: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
	/**
	 * On Particle Death
	*/
	OnParticleDeath: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
	/**
	 * On Particle Collide
	*/
	OnParticleCollide: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: PhysicalMaterial) => void>;
	/**
	 * Old Position
	*/
	OldPosition: Vector;
	/**
	 * Part Sys Velocity
	*/
	PartSysVelocity: Vector;
	/**
	 * Warmup Time
	*/
	WarmupTime: number;
	/**
	 * Warmup Tick Rate
	*/
	WarmupTickRate: number;
	/**
	 * Warming Up
	*/
	bWarmingUp: boolean;
	/**
	 * Number of seconds of emitter not being rendered that need to pass before it
	 * no longer gets ticked/ becomes inactive.
	*/
	SecondsBeforeInactive: number;
	/**
	 * Time between forced UpdateTransforms for systems that use dynamically calculated bounds,
	 * Which is effectively how often the bounds are shrunk.
	*/
	MaxTimeBeforeForceUpdateTransform: number;
	/**
	 * INTERNAL. Used by the editor to set the LODLevel
	*/
	EditorLODLevel: number;
	/**
	 * Used for applying Cascade's detail mode setting to in-level particle systems
	*/
	EditorDetailMode: number;
	/**
	 * indicates that the component's LODMethod overrides the Template's
	*/
	bOverrideLODMethod: boolean;
	/**
	 * The method of LOD level determination to utilize for this particle system
	*/
	LODMethod: ParticleSystemLODMethod;
	/**
	 * Flag indicating that dynamic updating of render data should NOT occur during Tick.
	 * This is used primarily to allow for warming up and simulated effects to a certain state.
	*/
	bSkipUpdateDynamicDataDuringTick: boolean;
	/**
	 * Array of replay clips for this particle system component.  These are serialized to disk.  You really should never add anything to this in the editor.  It's exposed so that you can delete clips if you need to, but be careful when doing so!
	*/
	ReplayClips: ParticleSystemReplay[];
	/**
	 * Scales DeltaTime in UParticleSystemComponent::Tick(...)
	*/
	CustomTimeDilation: number;
	/**
	 * Called when the particle system is done
	*/
	OnSystemFinished: UnrealEngineMulticastDelegate<(PSystem: ParticleSystemComponent) => void>;
	/**
	 * Component we automatically attach to when activated, if bAutoManageAttachment is true.
	 * If null during registration, we assign the existing AttachParent and defer attachment until we activate.
	 * @see bAutoManageAttachment
	*/
	AutoAttachParent: any;
	/**
	 * Socket we automatically attach to on the AutoAttachParent, if bAutoManageAttachment is true.
	 * @see bAutoManageAttachment
	*/
	AutoAttachSocketName: string;
	/**
	 * DEPRECATED: Options for how we handle our location when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
	 * @see bAutoManageAttachment, EAttachLocation::Type
	*/
	AutoAttachLocationType: EAttachLocation;
	/**
	 * Options for how we handle our location when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
	 * @see bAutoManageAttachment, EAttachmentRule
	*/
	AutoAttachLocationRule: EAttachmentRule;
	/**
	 * Options for how we handle our rotation when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
	 * @see bAutoManageAttachment, EAttachmentRule
	*/
	AutoAttachRotationRule: EAttachmentRule;
	/**
	 * Options for how we handle our scale when we attach to the AutoAttachParent, if bAutoManageAttachment is true.
	 * @see bAutoManageAttachment, EAttachmentRule
	*/
	AutoAttachScaleRule: EAttachmentRule;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ParticleSystemComponent;
	static Find(Outer: UObject, ResourceName: string): ParticleSystemComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ParticleSystemComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ParticleSystemComponent;
	/**
	 * Set a named vector instance parameter on this ParticleSystemComponent.
	 * Updates the parameter if it already exists, or creates a new entry if not.
	*/
	SetVectorParameter(ParameterName: string,Param: Vector): void;
	/**
	 * Sets the defining data for all trails in this component.
	 * @param        InFirstSocketName       The name of the first socket for the trail.
	 * @param        InSecondSocketName      The name of the second socket for the trail.
	 * @param        InWidthMode                     How the width value is applied to the trail.
	 * @param        InWidth                         The width of the trail.
	*/
	SetTrailSourceData(InFirstSocketName: string,InSecondSocketName: string,InWidthMode: ETrailWidthMode,InWidth: number): void;
	/**
	 * Change the ParticleSystem used by this ParticleSystemComponent
	*/
	SetTemplate(NewTemplate: ParticleSystem): void;
	/**
	 * Set a named material instance parameter on this ParticleSystemComponent.
	 * Updates the parameter if it already exists, or creates a new entry if not.
	*/
	SetMaterialParameter(ParameterName: string,Param: MaterialInterface): void;
	/**
	 * Change a named float parameter
	*/
	SetFloatParameter(ParameterName: string,Param: number): void;
	/**
	 * Enables/Disables a sub-emitter
	 * @param  EmitterName                     The name of the sub-emitter to set it on
	 * @param  bNewEnableState         The value to set it to
	*/
	SetEmitterEnable(EmitterName: string,bNewEnableState: boolean): void;
	/**
	 * Set a named color instance parameter on this ParticleSystemComponent.
	 * Updates the parameter if it already exists, or creates a new entry if not.
	*/
	SetColorParameter(ParameterName: string,Param: LinearColor): void;
	/**
	 * Set the beam target tangent
	 * @param  EmitterIndex            The index of the emitter to set it on
	 * @param  NewTangentPoint         The value to set it to
	 * @param  TargetIndex                     Which beam within the emitter to set it on
	*/
	SetBeamTargetTangent(EmitterIndex: number,NewTangentPoint: Vector,TargetIndex: number): void;
	/**
	 * Set the beam target strength
	 * @param  EmitterIndex            The index of the emitter to set it on
	 * @param  NewTargetStrength       The value to set it to
	 * @param  TargetIndex                     Which beam within the emitter to set it on
	*/
	SetBeamTargetStrength(EmitterIndex: number,NewTargetStrength: number,TargetIndex: number): void;
	/**
	 * Set the beam target point
	 * @param  EmitterIndex            The index of the emitter to set it on
	 * @param  NewTargetPoint          The value to set it to
	 * @param  TargetIndex                     Which beam within the emitter to set it on
	*/
	SetBeamTargetPoint(EmitterIndex: number,NewTargetPoint: Vector,TargetIndex: number): void;
	/**
	 * Set the beam source tangent
	 * @param  EmitterIndex            The index of the emitter to set it on
	 * @param  NewTangentPoint         The value to set it to
	 * @param  SourceIndex                     Which beam within the emitter to set it on
	*/
	SetBeamSourceTangent(EmitterIndex: number,NewTangentPoint: Vector,SourceIndex: number): void;
	/**
	 * Set the beam source strength
	 * @param  EmitterIndex            The index of the emitter to set it on
	 * @param  NewSourceStrength       The value to set it to
	 * @param  SourceIndex                     Which beam within the emitter to set it on
	*/
	SetBeamSourceStrength(EmitterIndex: number,NewSourceStrength: number,SourceIndex: number): void;
	/**
	 * Set the beam source point
	 * @param  EmitterIndex            The index of the emitter to set it on
	 * @param  NewSourcePoint          The value to set it to
	 * @param  SourceIndex                     Which beam within the emitter to set it on
	*/
	SetBeamSourcePoint(EmitterIndex: number,NewSourcePoint: Vector,SourceIndex: number): void;
	/**
	 * Set the beam end point
	 * @param  EmitterIndex            The index of the emitter to set it on
	 * @param  NewEndPoint                     The value to set it to
	*/
	SetBeamEndPoint(EmitterIndex: number,NewEndPoint: Vector): void;
	/**
	 * DEPRECATED: Set AutoAttachParent, AutoAttachSocketName, AutoAttachLocationType to the specified parameters. Does not change bAutoManageAttachment; that must be set separately.
	 * @param  Parent                       Component to attach to.
	 * @param  SocketName           Socket on Parent to attach to.
	 * @param  LocationType         Option for how we handle our location when we attach to Parent.
	 * @see bAutoManageAttachment, AutoAttachParent, AutoAttachSocketName, AutoAttachLocationType
	*/
	SetAutoAttachParams(Parent: SceneComponent,SocketName: string,LocationType: EAttachLocation): void;
	/**
	 * Set AutoAttachParent, AutoAttachSocketName, AutoAttachLocationRule, AutoAttachRotationRule, AutoAttachScaleRule to the specified parameters. Does not change bAutoManageAttachment; that must be set separately.
	 * @param  Parent                       Component to attach to.
	 * @param  SocketName           Socket on Parent to attach to.
	 * @param  LocationRule         Option for how we handle our location when we attach to Parent.
	 * @param  RotationRule         Option for how we handle our rotation when we attach to Parent.
	 * @param  ScaleRule            Option for how we handle our scale when we attach to Parent.
	 * @see bAutoManageAttachment, AutoAttachParent, AutoAttachSocketName, AutoAttachLocationRule, AutoAttachRotationRule, AutoAttachScaleRule
	*/
	SetAutoAttachmentParameters(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule): void;
	/**
	 * Set a named actor instance parameter on this ParticleSystemComponent.
	 * Updates the parameter if it already exists, or creates a new entry if not.
	*/
	SetActorParameter(ParameterName: string,Param: Actor): void;
	/**
	 * Get the current number of active particles in this system
	*/
	GetNumActiveParticles(): number;
	/**
	 * Returns a named material. If this named material is not found, returns NULL.
	*/
	GetNamedMaterial(InName: string): MaterialInterface;
	/**
	 * Get the beam target tangent
	 * @param  EmitterIndex            The index of the emitter to get
	 * @param  TargetIndex                     Which beam within the emitter to get
	 * @param  OutTangentPoint         Value of target tangent
	 * @return true            EmitterIndex and TargetIndex are valid - OutTangentPoint is valid
	 *                 false           EmitterIndex or TargetIndex is invalid - OutTangentPoint is invalid
	*/
	GetBeamTargetTangent(EmitterIndex: number,TargetIndex: number,OutTangentPoint?: Vector): {OutTangentPoint: Vector, $: boolean};
	/**
	 * Get the beam target strength
	 * @param  EmitterIndex            The index of the emitter to get
	 * @param  TargetIndex                     Which beam within the emitter to get
	 * @param  OutTargetStrength       Value of target tangent
	 * @return true            EmitterIndex and TargetIndex are valid - OutTargetStrength is valid
	 *                 false           EmitterIndex or TargetIndex is invalid - OutTargetStrength is invalid
	*/
	GetBeamTargetStrength(EmitterIndex: number,TargetIndex: number,OutTargetStrength?: number): {OutTargetStrength: number, $: boolean};
	/**
	 * Get the beam target point
	 * @param  EmitterIndex            The index of the emitter to get
	 * @param  TargetIndex                     Which beam within the emitter to get
	 * @param  OutTargetPoint          Value of target point
	 * @return true            EmitterIndex and TargetIndex are valid - OutTargetPoint is valid
	 *                 false           EmitterIndex or TargetIndex is invalid - OutTargetPoint is invalid
	*/
	GetBeamTargetPoint(EmitterIndex: number,TargetIndex: number,OutTargetPoint?: Vector): {OutTargetPoint: Vector, $: boolean};
	/**
	 * Get the beam source tangent
	 * @param  EmitterIndex            The index of the emitter to get
	 * @param  SourceIndex                     Which beam within the emitter to get
	 * @param  OutTangentPoint         Value of source tangent
	 * @return true            EmitterIndex and SourceIndex are valid - OutTangentPoint is valid
	 *                 false           EmitterIndex or SourceIndex is invalid - OutTangentPoint is invalid
	*/
	GetBeamSourceTangent(EmitterIndex: number,SourceIndex: number,OutTangentPoint?: Vector): {OutTangentPoint: Vector, $: boolean};
	/**
	 * Get the beam source strength
	 * @param  EmitterIndex            The index of the emitter to get
	 * @param  SourceIndex                     Which beam within the emitter to get
	 * @param  OutSourceStrength               Value of source tangent
	 * @return true            EmitterIndex and SourceIndex are valid - OutSourceStrength is valid
	 *                 false           EmitterIndex or SourceIndex is invalid - OutSourceStrength is invalid
	*/
	GetBeamSourceStrength(EmitterIndex: number,SourceIndex: number,OutSourceStrength?: number): {OutSourceStrength: number, $: boolean};
	/**
	 * Get the beam source point
	 * @param  EmitterIndex            The index of the emitter to get
	 * @param  SourceIndex                     Which beam within the emitter to get
	 * @param  OutSourcePoint          Value of source point
	 * @return true            EmitterIndex and SourceIndex are valid - OutSourcePoint is valid
	 *                 false           EmitterIndex or SourceIndex is invalid - OutSourcePoint is invalid
	*/
	GetBeamSourcePoint(EmitterIndex: number,SourceIndex: number,OutSourcePoint?: Vector): {OutSourcePoint: Vector, $: boolean};
	/**
	 * Get the beam end point
	 * @param  EmitterIndex            The index of the emitter to get the value of
	 * @return true            EmitterIndex is valid and End point is set - OutEndPoint is valid
	 *                 false           EmitterIndex invalid or End point is not set - OutEndPoint is invalid
	*/
	GetBeamEndPoint(EmitterIndex: number,OutEndPoint?: Vector): {OutEndPoint: Vector, $: boolean};
	/**
	 * Record a kismet event.
	 * @param  InEventName                             The name of the event that fired.
	 * @param  InEmitterTime                   The emitter time when the event fired.
	 * @param  InLocation                              The location of the particle when the event fired.
	 * @param  InVelocity                              The velocity of the particle when the event fired.
	 * @param  InNormal                                Normal vector of the collision in coordinate system of the returner. Zero=none.
	*/
	GenerateParticleEvent(InEventName: string,InEmitterTime: number,InLocation: Vector,InDirection: Vector,InVelocity: Vector): void;
	/**
	 * Ends all trail emitters in this component.
	*/
	EndTrails(): void;
	/**
	 * Creates a Dynamic Material Instance for the specified named material override, optionally from the supplied material.
	 * @param Name - The slot name of the material to replace.  If invalid, the material is unchanged and NULL is returned.
	*/
	CreateNamedDynamicMaterialInstance(InName: string,SourceMaterial: MaterialInterface): MaterialInstanceDynamic;
	/**
	 * Begins all trail emitters in this component.
	 * @param        InFirstSocketName       The name of the first socket for the trail.
	 * @param        InSecondSocketName      The name of the second socket for the trail.
	 * @param        InWidthMode                     How the width value is applied to the trail.
	 * @param        InWidth                         The width of the trail.
	*/
	BeginTrails(InFirstSocketName: string,InSecondSocketName: string,InWidthMode: ETrailWidthMode,InWidth: number): void;
	static C(Other: UObject): ParticleSystemComponent;
}

declare class Emitter extends Actor { 
	/**
	 * Particle System Component
	*/
	ParticleSystemComponent: ParticleSystemComponent;
	/**
	 * Destroy on System Finish
	*/
	bDestroyOnSystemFinish: boolean;
	/**
	 * Post Update Tick Group
	*/
	bPostUpdateTickGroup: boolean;
	/**
	 * used to update status of toggleable level placed emitters on clients
	*/
	bCurrentlyActive: boolean;
	/**
	 * On Particle Spawn
	*/
	OnParticleSpawn: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
	/**
	 * On Particle Burst
	*/
	OnParticleBurst: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
	/**
	 * On Particle Death
	*/
	OnParticleDeath: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
	/**
	 * On Particle Collide
	*/
	OnParticleCollide: UnrealEngineMulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: PhysicalMaterial) => void>;
	/**
	 * Sprite Component
	*/
	SpriteComponent: BillboardComponent;
	/**
	 * Arrow Component
	*/
	ArrowComponent: ArrowComponent;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Emitter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Emitter;
	/**
	 * Toggle Active
	*/
	ToggleActive(): void;
	/**
	 * Set Vector Parameter
	*/
	SetVectorParameter(ParameterName: string,Param: Vector): void;
	/**
	 * Set Template
	*/
	SetTemplate(NewTemplate: ParticleSystem): void;
	/**
	 * Set Material Parameter
	*/
	SetMaterialParameter(ParameterName: string,Param: MaterialInterface): void;
	/**
	 * Set Float Parameter
	*/
	SetFloatParameter(ParameterName: string,Param: number): void;
	/**
	 * Set Color Parameter
	*/
	SetColorParameter(ParameterName: string,Param: LinearColor): void;
	/**
	 * Set Actor Parameter
	*/
	SetActorParameter(ParameterName: string,Param: Actor): void;
	/**
	 * Replication Notification Callbacks
	*/
	OnRep_bCurrentlyActive(): void;
	/**
	 * On Particle System Finished
	*/
	OnParticleSystemFinished(FinishedComponent: ParticleSystemComponent): void;
	/**
	 * Is Active
	*/
	IsActive(): boolean;
	/**
	 * Deactivate
	*/
	Deactivate(): void;
	/**
	 * BEGIN DEPRECATED (use component functions now in level script)
	*/
	Activate(): void;
	static C(Other: UObject): Emitter;
}

declare class EmitterCameraLensEffectBase extends Emitter { 
	/**
	 * Particle System to use
	*/
	PS_CameraEffect: ParticleSystem;
	/**
	 * The effect to use for non extreme content
	*/
	PS_CameraEffectNonExtremeContent: ParticleSystem;
	/**
	 * Camera this emitter is attached to, will be notified when emitter is destroyed
	*/
	BaseCamera: PlayerCameraManager;
	/**
	 * Effect-to-camera transform to allow arbitrary placement of the particle system .
	 * Note the X component of the location will be scaled with camera fov to keep the lens effect the same apparent size.
	*/
	RelativeTransform: Transform;
	/**
	 * This is the assumed FOV for which the effect was authored. The code will make automatic adjustments to make it look the same at different FOVs
	*/
	BaseFOV: number;
	/**
	 * true if multiple instances of this emitter can exist simultaneously, false otherwise.
	*/
	bAllowMultipleInstances: boolean;
	/**
	 * If an emitter class in this array is currently playing, do not play this effect.
	 * Useful for preventing multiple similar or expensive camera effects from playing simultaneously.
	*/
	EmittersToTreatAsSame: UnrealEngineClass[];
	/**
	 * DEPRECATED(4.11)
	*/
	DistFromCamera: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): EmitterCameraLensEffectBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): EmitterCameraLensEffectBase;
	static C(Other: UObject): EmitterCameraLensEffectBase;
}

declare type EInitialOscillatorOffset = string | symbol;
declare var EInitialOscillatorOffset = { EOO_OffsetRandom:'EOO_OffsetRandom',EOO_OffsetZero:'EOO_OffsetZero', };
declare class FOscillator { 
	/**
	 * Amplitude of the sinusoidal oscillation.
	*/
	Amplitude: number;
	/**
	 * Frequency of the sinusoidal oscillation.
	*/
	Frequency: number;
	/**
	 * Defines how to begin (either at zero, or at a randomized value.
	*/
	InitialOffset: EInitialOscillatorOffset;
	clone() : FOscillator;
	static C(Other: UObject): FOscillator;
}

declare class ROscillator { 
	/**
	 * Pitch oscillation.
	*/
	Pitch: FOscillator;
	/**
	 * Yaw oscillation.
	*/
	Yaw: FOscillator;
	/**
	 * Roll oscillation.
	*/
	Roll: FOscillator;
	clone() : ROscillator;
	static C(Other: UObject): ROscillator;
}

declare class VOscillator { 
	/**
	 * Oscillation in the X axis.
	*/
	X: FOscillator;
	/**
	 * Oscillation in the Y axis.
	*/
	Y: FOscillator;
	/**
	 * Oscillation in the Z axis.
	*/
	Z: FOscillator;
	clone() : VOscillator;
	static C(Other: UObject): VOscillator;
}

declare class SubTrackGroup { 
	/**
	 * Name of the subtrack  group
	*/
	GroupName: string;
	/**
	 * Indices to tracks in the parent track subtrack array.
	*/
	TrackIndices: number[];
	/**
	 * If this group is collapsed
	*/
	bIsCollapsed: boolean;
	/**
	 * If this group is selected
	*/
	bIsSelected: boolean;
	clone() : SubTrackGroup;
	static C(Other: UObject): SubTrackGroup;
}

declare class SupportedSubTrackInfo { 
	/**
	 * The sub track class which is supported by this track
	*/
	SupportedClass: UnrealEngineClass;
	/**
	 * The name of the subtrack
	*/
	SubTrackName: string;
	/**
	 * Index into the any subtrack group this subtrack belongs to (can be -1 for no group)
	*/
	GroupIndex: number;
	clone() : SupportedSubTrackInfo;
	static C(Other: UObject): SupportedSubTrackInfo;
}

declare type ETrackActiveCondition = string | symbol;
declare var ETrackActiveCondition = { ETAC_Always:'ETAC_Always',ETAC_GoreEnabled:'ETAC_GoreEnabled',ETAC_GoreDisabled:'ETAC_GoreDisabled', };
declare class InterpTrack extends UObject { 
	/**
	 * A list of subtracks that belong to this track
	*/
	SubTracks: InterpTrack[];
	/**
	 * A list of subtrack groups (for editor UI organization only)
	*/
	SubTrackGroups: SubTrackGroup[];
	/**
	 * A list of supported tracks that can be a subtrack of this track.
	*/
	SupportedSubTracks: SupportedSubTrackInfo[];
	/**
	 * Track Inst Class
	*/
	TrackInstClass: UnrealEngineClass;
	/**
	 * Sets the condition that must be met for this track to be enabled
	*/
	ActiveCondition: ETrackActiveCondition;
	/**
	 * Title of track type.
	*/
	TrackTitle: string;
	/**
	 * Whether there may only be one of this track in an UInterpGroup.
	*/
	bOnePerGroup: boolean;
	/**
	 * If this track can only exist inside the Director group.
	*/
	bDirGroupOnly: boolean;
	/**
	 * Whether or not this track should actually update the target actor.
	*/
	bDisableTrack: boolean;
	/**
	 * Whether or not this track is selected in the editor.
	*/
	bIsSelected: boolean;
	/**
	 * Track Icon
	*/
	TrackIcon: Texture2D;
	/**
	 * If true, the  AActor  this track is working on will have BeginAnimControl/FinishAnimControl called on it.
	*/
	bIsAnimControlTrack: boolean;
	/**
	 * If this track can only exist as a sub track.
	*/
	bSubTrackOnly: boolean;
	/**
	 * Whether or not this track is visible in the editor.
	*/
	bVisible: boolean;
	/**
	 * Whether or not this track is recording in the editor.
	*/
	bIsRecording: boolean;
	/**
	 * If this track is collapsed. (Only applies  to tracks with subtracks).
	*/
	bIsCollapsed: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrack;
	static Find(Outer: UObject, ResourceName: string): InterpTrack;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrack;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrack;
	static C(Other: UObject): InterpTrack;
}

declare class InterpGroup extends UObject { 
	/**
	 * Interp Tracks
	*/
	InterpTracks: InterpTrack[];
	/**
	 * Within an InterpData, all GroupNames must be unique.
	 * Used for naming Variable connectors on the Action in Kismet and finding each groups object.
	*/
	GroupName: string;
	/**
	 * Colour used for drawing tracks etc. related to this group.
	*/
	GroupColor: Color;
	/**
	 * Whether or not this group is folded away in the editor.
	*/
	bCollapsed: boolean;
	/**
	 * Whether or not this group is visible in the editor.
	*/
	bVisible: boolean;
	/**
	 * When enabled, this group is treated like a folder in the editor, which should only be used for organization.  Folders are never associated with actors and don't have a presence in the Kismet graph.
	*/
	bIsFolder: boolean;
	/**
	 * When true, this group is considered a 'visual child' of another group.  This doesn't at all affect the behavior of the group, it's only for visual organization.  Also, it's implied that the parent is the next prior group in the array that doesn't have a parent.
	*/
	bIsParented: boolean;
	/**
	 * When enabled, this group will be selected in the interp editor.
	*/
	bIsSelected: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroup;
	static Find(Outer: UObject, ResourceName: string): InterpGroup;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroup;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroup;
	static C(Other: UObject): InterpGroup;
}

declare class CameraAnim extends UObject { 
	/**
	 * The UInterpGroup that holds our actual interpolation data.
	*/
	CameraInterpGroup: InterpGroup;
	/**
	 * This is to preview and they only exists in editor
	*/
	PreviewInterpGroup: InterpGroup;
	/**
	 * Length, in seconds.
	*/
	AnimLength: number;
	/**
	 * AABB in local space.
	*/
	BoundingBox: Box;
	/**
	 * If true, assume all transform keys are intended be offsets from the start of the animation. This allows the animation to be authored at any world location and be applied as a delta to the camera.
	 * If false, assume all transform keys are authored relative to the world origin. Positions will be directly applied as deltas to the camera.
	*/
	bRelativeToInitialTransform: boolean;
	/**
	 * If true, assume all FOV keys are intended be offsets from the start of the animation.
	 * If false, assume all FOV keys are authored relative to the current FOV of the camera at the start of the animation.
	*/
	bRelativeToInitialFOV: boolean;
	/**
	 * The FOV
	*/
	BaseFOV: number;
	/**
	 * Default PP settings to put on the animated camera. For modifying PP without keyframes.
	*/
	BasePostProcessSettings: PostProcessSettings;
	/**
	 * Default PP blend weight to put on the animated camera. For modifying PP without keyframes.
	*/
	BasePostProcessBlendWeight: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraAnim;
	static Find(Outer: UObject, ResourceName: string): CameraAnim;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraAnim;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnim;
	static C(Other: UObject): CameraAnim;
}

declare class InterpGroupInst extends UObject { 
	/**
	 * UInterpGroup within the InterpData that this is an instance of.
	*/
	Group: InterpGroup;
	/**
	 * Actor that this Group instance is acting upon.
	 * NB: that this may be set to NULL at any time as a result of the  AActor  being destroyed.
	*/
	GroupActor: Actor;
	/**
	 * Array if InterpTrack instances. TrackInst.Num() == UInterpGroup.InterpTrack.Num() must be true.
	*/
	TrackInst: InterpTrackInst[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroupInst;
	static Find(Outer: UObject, ResourceName: string): InterpGroupInst;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroupInst;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupInst;
	static C(Other: UObject): InterpGroupInst;
}

declare type EInterpCurveMode = string | symbol;
declare var EInterpCurveMode = { CIM_Linear:'CIM_Linear',CIM_CurveAuto:'CIM_CurveAuto',CIM_Constant:'CIM_Constant',CIM_CurveUser:'CIM_CurveUser',CIM_CurveBreak:'CIM_CurveBreak',CIM_CurveAutoClamped:'CIM_CurveAutoClamped', };
declare class InterpCurvePointVector { 
	/**
	 * In Val
	*/
	InVal: number;
	/**
	 * Out Val
	*/
	OutVal: Vector;
	/**
	 * Arrive Tangent
	*/
	ArriveTangent: Vector;
	/**
	 * Leave Tangent
	*/
	LeaveTangent: Vector;
	/**
	 * Interp Mode
	*/
	InterpMode: EInterpCurveMode;
	clone() : InterpCurvePointVector;
	static C(Other: UObject): InterpCurvePointVector;
}

declare class InterpCurveVector { 
	/**
	 * Points
	*/
	Points: InterpCurvePointVector[];
	/**
	 * Is Looped
	*/
	bIsLooped: boolean;
	/**
	 * Loop Key Offset
	*/
	LoopKeyOffset: number;
	clone() : InterpCurveVector;
	static C(Other: UObject): InterpCurveVector;
}

declare class InterpLookupPoint { 
	/**
	 * Group Name
	*/
	GroupName: string;
	/**
	 * Time
	*/
	Time: number;
	clone() : InterpLookupPoint;
	static C(Other: UObject): InterpLookupPoint;
}

declare class InterpLookupTrack { 
	/**
	 * Points
	*/
	Points: InterpLookupPoint[];
	clone() : InterpLookupTrack;
	static C(Other: UObject): InterpLookupTrack;
}

declare type EInterpTrackMoveRotMode = string | symbol;
declare var EInterpTrackMoveRotMode = { IMR_Keyframed:'IMR_Keyframed',IMR_LookAtGroup:'IMR_LookAtGroup',IMR_Ignore:'IMR_Ignore', };
declare class InterpTrackMove extends InterpTrack { 
	/**
	 * Actual position keyframe data.
	*/
	PosTrack: InterpCurveVector;
	/**
	 * Actual rotation keyframe data, stored as Euler angles in degrees, for easy editing on curve.
	*/
	EulerTrack: InterpCurveVector;
	/**
	 * Lookup Track
	*/
	LookupTrack: InterpLookupTrack;
	/**
	 * When using IMR_LookAtGroup, specifies the Group which this track should always point its actor at.
	*/
	LookAtGroupName: string;
	/**
	 * Controls the tightness of the curve for the translation path.
	*/
	LinCurveTension: number;
	/**
	 * Controls the tightness of the curve for the rotation path.
	*/
	AngCurveTension: number;
	/**
	 * Use a Quaternion linear interpolation between keys.
	 * This is robust and will find the 'shortest' distance between keys, but does not support ease in/out.
	*/
	bUseQuatInterpolation: boolean;
	/**
	 * In the editor, show a small arrow at each keyframe indicating the rotation at that key.
	*/
	bShowArrowAtKeys: boolean;
	/**
	 * Disable previewing of this track - will always position  AActor  at Time=0.0. Useful when keyframing an object relative to this group.
	*/
	bDisableMovement: boolean;
	/**
	 * If false, when this track is displayed on the Curve Editor in Matinee, do not show the Translation tracks.
	*/
	bShowTranslationOnCurveEd: boolean;
	/**
	 * If false, when this track is displayed on the Curve Editor in Matinee, do not show the Rotation tracks.
	*/
	bShowRotationOnCurveEd: boolean;
	/**
	 * If true, 3D representation of this track in the 3D viewport is disabled.
	*/
	bHide3DTrack: boolean;
	/**
	 * Rot Mode
	*/
	RotMode: EInterpTrackMoveRotMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackMove;
	static Find(Outer: UObject, ResourceName: string): InterpTrackMove;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackMove;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackMove;
	static C(Other: UObject): InterpTrackMove;
}

declare class InterpTrackInstMove extends InterpTrackInst { 
	/**
	 * Saved position. Used in editor for resetting when quitting Matinee.
	*/
	ResetLocation: Vector;
	/**
	 * Saved rotation. Used in editor for resetting when quitting Matinee.
	*/
	ResetRotation: Rotator;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpTrackInstMove;
	static Find(Outer: UObject, ResourceName: string): InterpTrackInstMove;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpTrackInstMove;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpTrackInstMove;
	static C(Other: UObject): InterpTrackInstMove;
}

declare type ECameraAnimPlaySpace = string | symbol;
declare var ECameraAnimPlaySpace = { CameraLocal:'CameraLocal',World:'World',UserDefined:'UserDefined', };
declare class CameraAnimInst extends UObject { 
	/**
	 * which CameraAnim this is an instance of
	*/
	CamAnim: CameraAnim;
	/**
	 * Interp Group Inst
	*/
	InterpGroupInst: InterpGroupInst;
	/**
	 * Multiplier for playback rate.  1.0 = normal.
	*/
	PlayRate: number;
	/**
	 * cached movement track from the currently playing anim so we don't have to go find it every frame
	*/
	MoveTrack: InterpTrackMove;
	/**
	 * Move Inst
	*/
	MoveInst: InterpTrackInstMove;
	/**
	 * Play Space
	*/
	PlaySpace: ECameraAnimPlaySpace;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraAnimInst;
	static Find(Outer: UObject, ResourceName: string): CameraAnimInst;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraAnimInst;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraAnimInst;
	/**
	 * Stops this instance playing whatever animation it is playing.
	*/
	Stop(bImmediate: boolean): void;
	/**
	 * Changes the scale of the animation while playing.
	*/
	SetScale(NewDuration: number): void;
	/**
	 * Changes the running duration of this active anim, while maintaining playback position.
	*/
	SetDuration(NewDuration: number): void;
	static C(Other: UObject): CameraAnimInst;
}

declare class CameraShake extends UObject { 
	/**
	 * If true to only allow a single instance of this shake class to play at any given time.
	 * Subsequent attempts to play this shake will simply restart the timer.
	*/
	bSingleInstance: boolean;
	/**
	 * Duration in seconds of current screen shake. Less than 0 means indefinite, 0 means no oscillation.
	*/
	OscillationDuration: number;
	/**
	 * Duration of the blend-in, where the oscillation scales from 0 to 1.
	*/
	OscillationBlendInTime: number;
	/**
	 * Duration of the blend-out, where the oscillation scales from 1 to 0.
	*/
	OscillationBlendOutTime: number;
	/**
	 * Rotational oscillation
	*/
	RotOscillation: ROscillator;
	/**
	 * Positional oscillation
	*/
	LocOscillation: VOscillator;
	/**
	 * FOV oscillation
	*/
	FOVOscillation: FOscillator;
	/**
	 * Scalar defining how fast to play the anim.
	*/
	AnimPlayRate: number;
	/**
	 * Scalar defining how "intense" to play the anim.
	*/
	AnimScale: number;
	/**
	 * Linear blend-in time.
	*/
	AnimBlendInTime: number;
	/**
	 * Linear blend-out time.
	*/
	AnimBlendOutTime: number;
	/**
	 * When bRandomAnimSegment is true, this defines how long the anim should play.
	*/
	RandomAnimSegmentDuration: number;
	/**
	 * Source camera animation to play. Can be null.
	*/
	Anim: CameraAnim;
	/**
	 * If true, play a random snippet of the animation of length Duration.  Implies bLoop and bRandomStartTime = true for the CameraAnim.
	 * If false, play the full anim once, non-looped. Useful for getting variety out of a single looped CameraAnim asset.
	*/
	bRandomAnimSegment: boolean;
	/**
	 * Camera Owner
	*/
	CameraOwner: PlayerCameraManager;
	/**
	 * Overall intensity scale for this shake instance.
	*/
	ShakeScale: number;
	/**
	 * Time remaining for oscillation shakes. Less than 0.f means shake infinitely.
	*/
	OscillatorTimeRemaining: number;
	/**
	 * The playing instance of the CameraAnim-based shake, if any.
	*/
	AnimInst: CameraAnimInst;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraShake;
	static Find(Outer: UObject, ResourceName: string): CameraShake;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraShake;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraShake;
	/**
	 * Called when the shake is explicitly stopped.
	 * @param bImmediatly           If true, shake stops right away regardless of blend out settings. If false, shake may blend out according to its settings.
	*/
	ReceiveStopShake(bImmediately: boolean): void;
	/**
	 * Called when the shake starts playing
	*/
	ReceivePlayShake(Scale: number): void;
	/**
	 * Called to allow a shake to decide when it's finished playing.
	*/
	ReceiveIsFinished(): boolean;
	/**
	 * Called every tick to let the shake modify the point of view
	*/
	BlueprintUpdateCameraShake(DeltaTime: number,Alpha: number,POV: MinimalViewInfo,ModifiedPOV?: MinimalViewInfo): {ModifiedPOV: MinimalViewInfo};
	static C(Other: UObject): CameraShake;
}

declare class CameraModifier_CameraShake extends CameraModifier { 
	/**
	 * List of active CameraShake instances
	*/
	ActiveShakes: CameraShake[];
	/**
	 * Scaling factor applied to all camera shakes in when in splitscreen mode. Normally used to reduce shaking, since shakes feel more intense in a smaller viewport.
	*/
	SplitScreenShakeScale: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraModifier_CameraShake;
	static Find(Outer: UObject, ResourceName: string): CameraModifier_CameraShake;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraModifier_CameraShake;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraModifier_CameraShake;
	static C(Other: UObject): CameraModifier_CameraShake;
}

declare class MeshBuildSettings { 
	/**
	 * If true, degenerate triangles will be removed.
	*/
	bUseMikkTSpace: boolean;
	/**
	 * If true, normals in the raw mesh are ignored and recomputed.
	*/
	bRecomputeNormals: boolean;
	/**
	 * If true, tangents in the raw mesh are ignored and recomputed.
	*/
	bRecomputeTangents: boolean;
	/**
	 * If true, degenerate triangles will be removed.
	*/
	bRemoveDegenerates: boolean;
	/**
	 * Required for PNT tessellation but can be slow. Recommend disabling for larger meshes.
	*/
	bBuildAdjacencyBuffer: boolean;
	/**
	 * Required to optimize mesh in mirrored transform. Double index buffer size.
	*/
	bBuildReversedIndexBuffer: boolean;
	/**
	 * If true, Tangents will be stored at 16 bit vs 8 bit precision.
	*/
	bUseHighPrecisionTangentBasis: boolean;
	/**
	 * If true, UVs will be stored at full floating point precision.
	*/
	bUseFullPrecisionUVs: boolean;
	/**
	 * Generate Lightmap UVs
	*/
	bGenerateLightmapUVs: boolean;
	/**
	 * Min Lightmap Resolution
	*/
	MinLightmapResolution: number;
	/**
	 * Src Lightmap Index
	*/
	SrcLightmapIndex: number;
	/**
	 * Dst Lightmap Index
	*/
	DstLightmapIndex: number;
	/**
	 * Build Scale
	*/
	BuildScale: number;
	/**
	 * The local scale applied when building the mesh
	*/
	BuildScale3D: Vector;
	/**
	 * Scale to apply to the mesh when allocating the distance field volume texture.
	 * The default scale is 1, which is assuming that the mesh will be placed unscaled in the world.
	*/
	DistanceFieldResolutionScale: number;
	/**
	 * Whether to generate the distance field treating every triangle hit as a front face.
	 * When enabled prevents the distance field from being discarded due to the mesh being open, but also lowers Distance Field AO quality.
	*/
	bGenerateDistanceFieldAsIfTwoSided: boolean;
	/**
	 * Distance Field Replacement Mesh
	*/
	DistanceFieldReplacementMesh: StaticMesh;
	clone() : MeshBuildSettings;
	static C(Other: UObject): MeshBuildSettings;
}

declare type EMeshFeatureImportance = string | symbol;
declare var EMeshFeatureImportance = { Off:'Off',Lowest:'Lowest',Low:'Low',Normal:'Normal',High:'High',Highest:'Highest', };
declare class MeshReductionSettings { 
	/**
	 * Percentage of triangles to keep. 1.0 = no reduction, 0.0 = no triangles.
	*/
	PercentTriangles: number;
	/**
	 * The maximum distance in object space by which the reduced mesh may deviate from the original mesh.
	*/
	MaxDeviation: number;
	/**
	 * Threshold in object space at which vertices are welded together.
	*/
	WeldingThreshold: number;
	/**
	 * Angle at which a hard edge is introduced between faces.
	*/
	HardAngleThreshold: number;
	/**
	 * Higher values minimize change to border edges.
	*/
	SilhouetteImportance: EMeshFeatureImportance;
	/**
	 * Higher values reduce texture stretching.
	*/
	TextureImportance: EMeshFeatureImportance;
	/**
	 * Higher values try to preserve normals better.
	*/
	ShadingImportance: EMeshFeatureImportance;
	/**
	 * UPROPERTY(EditAnywhere, Category = ReductionSettings)
	 *        bool bActive;
	*/
	bRecalculateNormals: boolean;
	/**
	 * Base LODModel
	*/
	BaseLODModel: number;
	/**
	 * Generate Unique Lightmap UVs
	*/
	bGenerateUniqueLightmapUVs: boolean;
	/**
	 * Keep Symmetry
	*/
	bKeepSymmetry: boolean;
	/**
	 * Visibility Aided
	*/
	bVisibilityAided: boolean;
	/**
	 * Cull Occluded
	*/
	bCullOccluded: boolean;
	/**
	 * Higher values generates fewer samples
	*/
	VisibilityAggressiveness: EMeshFeatureImportance;
	/**
	 * Higher values minimize change to vertex color data.
	*/
	VertexColorImportance: EMeshFeatureImportance;
	clone() : MeshReductionSettings;
	static C(Other: UObject): MeshReductionSettings;
}

declare class StaticMeshSourceModel { 
	/**
	 * Settings applied when building the mesh.
	*/
	BuildSettings: MeshBuildSettings;
	/**
	 * Reduction settings to apply when building render data.
	*/
	ReductionSettings: MeshReductionSettings;
	/**
	 * LODDistance
	*/
	LODDistance: number;
	/**
	 * ScreenSize to display this LOD
	*/
	ScreenSize: number;
	clone() : StaticMeshSourceModel;
	static C(Other: UObject): StaticMeshSourceModel;
}

declare class AssetEditorOrbitCameraPosition { 
	/**
	 * Whether or not this has been set to a valid value
	*/
	bIsSet: boolean;
	/**
	 * The position to orbit the camera around
	*/
	CamOrbitPoint: Vector;
	/**
	 * The distance of the camera from the orbit point
	*/
	CamOrbitZoom: Vector;
	/**
	 * The rotation to apply around the orbit point
	*/
	CamOrbitRotation: Rotator;
	clone() : AssetEditorOrbitCameraPosition;
	static C(Other: UObject): AssetEditorOrbitCameraPosition;
}

declare class StaticMeshSocket extends UObject { 
	/**
	 * Defines a named attachment location on the UStaticMesh.
	 * These are set up in editor and used as a shortcut instead of specifying
	 * everything explicitly to AttachComponent in the StaticMeshComponent.
	 * The Outer of a StaticMeshSocket should always be the UStaticMesh.
	*/
	SocketName: string;
	/**
	 * Relative Location
	*/
	RelativeLocation: Vector;
	/**
	 * Relative Rotation
	*/
	RelativeRotation: Rotator;
	/**
	 * Relative Scale
	*/
	RelativeScale: Vector;
	/**
	 * Tag
	*/
	Tag: string;
	/**
	 * Preview Static Mesh
	*/
	PreviewStaticMesh: StaticMesh;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMeshSocket;
	static Find(Outer: UObject, ResourceName: string): StaticMeshSocket;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshSocket;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshSocket;
	static C(Other: UObject): StaticMeshSocket;
}

declare class NavCollisionCylinder { 
	/**
	 * Offset
	*/
	Offset: Vector;
	/**
	 * Radius
	*/
	Radius: number;
	/**
	 * Height
	*/
	Height: number;
	clone() : NavCollisionCylinder;
	static C(Other: UObject): NavCollisionCylinder;
}

declare class NavCollisionBox { 
	/**
	 * Offset
	*/
	Offset: Vector;
	/**
	 * Extent
	*/
	Extent: Vector;
	clone() : NavCollisionBox;
	static C(Other: UObject): NavCollisionBox;
}

declare class NavCollision extends UObject { 
	/**
	 * list of nav collision cylinders
	*/
	CylinderCollision: NavCollisionCylinder[];
	/**
	 * list of nav collision boxes
	*/
	BoxCollision: NavCollisionBox[];
	/**
	 * navigation area type (empty = default obstacle)
	*/
	AreaClass: UnrealEngineClass;
	/**
	 * If set, mesh will be used as dynamic obstacle (don't create navmesh on top, much faster adding/removing)
	*/
	bIsDynamicObstacle: boolean;
	/**
	 * If set, convex collisions will be exported offline for faster runtime navmesh building (increases memory usage)
	*/
	bGatherConvexGeometry: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavCollision;
	static Find(Outer: UObject, ResourceName: string): NavCollision;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavCollision;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavCollision;
	static C(Other: UObject): NavCollision;
}

declare class MeshSectionInfo { 
	/**
	 * Index in to the Materials array on UStaticMesh.
	*/
	MaterialIndex: number;
	/**
	 * If true, collision is enabled for this section.
	*/
	bEnableCollision: boolean;
	/**
	 * If true, this section will cast shadows.
	*/
	bCastShadow: boolean;
	clone() : MeshSectionInfo;
	static C(Other: UObject): MeshSectionInfo;
}

declare class JavascriptRawMesh { 
	/**
	 * Material index. Array[FaceId] = int32
	*/
	FaceMaterialIndices: number[];
	/**
	 * Smoothing mask. Array[FaceId] = uint32
	*/
	FaceSmoothingMasks: any[];
	/**
	 * Position in local space. Array[VertexId] = float3(x,y,z)
	*/
	VertexPositions: Vector[];
	/**
	 * Index of the vertex at this wedge. Array[WedgeId] = VertexId
	*/
	WedgeIndices: any[];
	/**
	 * Tangent, U direction. Array[WedgeId] = float3(x,y,z)
	*/
	WedgeTangentX: Vector[];
	/**
	 * Tangent, V direction. Array[WedgeId] = float3(x,y,z)
	*/
	WedgeTangentY: Vector[];
	/**
	 * Normal. Array[WedgeId] = float3(x,y,z)
	*/
	WedgeTangentZ: Vector[];
	/**
	 * Texture coordinates. Array[UVId][WedgeId]=float2(u,v)
	*/
	WedgeTexCoords_0: Vector2D[];
	/**
	 * Wedge Tex Coords 1
	*/
	WedgeTexCoords_1: Vector2D[];
	/**
	 * Wedge Tex Coords 2
	*/
	WedgeTexCoords_2: Vector2D[];
	/**
	 * Wedge Tex Coords 3
	*/
	WedgeTexCoords_3: Vector2D[];
	/**
	 * Wedge Tex Coords 4
	*/
	WedgeTexCoords_4: Vector2D[];
	/**
	 * Wedge Tex Coords 5
	*/
	WedgeTexCoords_5: Vector2D[];
	/**
	 * Wedge Tex Coords 6
	*/
	WedgeTexCoords_6: Vector2D[];
	/**
	 * Wedge Tex Coords 7
	*/
	WedgeTexCoords_7: Vector2D[];
	/**
	 * Color. Array[WedgeId]=float3(r,g,b,a)
	*/
	WedgeColors: Color[];
	/**
	 * Map from material index -> original material index at import time. It's
	 * valid for this to be empty in which case material index == original
	 * material index.
	*/
	MaterialIndexToImportIndex: number[];
	clone() : JavascriptRawMesh;
	static C(Other: UObject): JavascriptRawMesh;
	/**
	 * Compact Material Indices
	*/
	CompactMaterialIndices(): {RawMesh: JavascriptRawMesh};
	/**
	 * Empty
	*/
	Empty(): {RawMesh: JavascriptRawMesh};
	/**
	 * Helper for getting the position of a wedge.
	*/
	GetWedgePosition(WedgeIndex: number): Vector;
	/**
	 * Is Valid
	*/
	IsValid(): boolean;
	/**
	 * Returns true if the mesh contains valid information or slightly invalid information that we can fix.
	 *  - Validates that stream sizes match.
	 *  - Validates that there is at least one texture coordinate.
	 *  - Validates that indices are valid positions in the vertex stream.
	*/
	IsValidOrFixable(): boolean;
	/**
	 * Compact Material Indices
	*/
	static CompactMaterialIndices(RawMesh?: JavascriptRawMesh): {RawMesh: JavascriptRawMesh};
	/**
	 * Empty
	*/
	static Empty(RawMesh?: JavascriptRawMesh): {RawMesh: JavascriptRawMesh};
	/**
	 * Helper for getting the position of a wedge.
	*/
	static GetWedgePosition(RawMesh: JavascriptRawMesh,WedgeIndex: number): Vector;
	/**
	 * Is Valid
	*/
	static IsValid(RawMesh: JavascriptRawMesh): boolean;
	/**
	 * Returns true if the mesh contains valid information or slightly invalid information that we can fix.
	 *  - Validates that stream sizes match.
	 *  - Validates that there is at least one texture coordinate.
	 *  - Validates that indices are valid positions in the vertex stream.
	*/
	static IsValidOrFixable(RawMesh: JavascriptRawMesh): boolean;
}

declare class StaticMesh extends UObject { 
	/**
	 * Imported raw mesh bulk data.
	*/
	SourceModels: StaticMeshSourceModel[];
	/**
	 * The pixel error allowed when computing auto LOD distances.
	*/
	AutoLODPixelError: number;
	/**
	 * The LOD group to which this mesh belongs.
	*/
	LODGroup: string;
	/**
	 * If true, the distances at which LODs swap are computed automatically.
	*/
	bAutoComputeLODScreenSize: boolean;
	/**
	 * Minimum LOD to use for rendering.  This is the default setting for the mesh and can be overridden by component settings.
	*/
	MinLOD: number;
	/**
	 * Materials used by this static mesh. Individual sections index in to this array.
	*/
	Materials: MaterialInterface[];
	/**
	 * The light map resolution
	*/
	LightMapResolution: number;
	/**
	 * The light map coordinate index
	*/
	LightMapCoordinateIndex: number;
	/**
	 * Physics data.
	*/
	BodySetup: BodySetup;
	/**
	 * Specifies which mesh LOD to use for complex (per-poly) collision.
	 * Sometimes it can be desirable to use a lower poly representation for collision to reduce memory usage, improve performance and behaviour.
	 * Collision representation does not change based on distance to camera.
	*/
	LODForCollision: number;
	/**
	 * If true, use a less-conservative method of mip LOD texture factor computation.  Requires mesh to be resaved to take effect as algorithm is applied on save
	*/
	bUseMaximumStreamingTexelRatio: boolean;
	/**
	 * If true, strips unwanted complex collision data aka kDOP tree when cooking for consoles.
	 *               On the Playstation 3 data of this mesh will be stored in video memory.
	*/
	bStripComplexCollisionForConsole: boolean;
	/**
	 * If true, mesh will have NavCollision property with additional data for navmesh generation and usage.
	 *           Set to false for distant meshes (always outside navigation bounds) to save memory on collision data.
	*/
	bHasNavigationData: boolean;
	/**
	 * Allows artists to adjust the distance where textures using UV 0 are streamed in/out.
	 * 1.0 is the default, whereas a higher value increases the streamed-in resolution.
	 * Value can be < 0 (from legcay content, or code changes)
	*/
	StreamingDistanceMultiplier: number;
	/**
	 * Bias multiplier for Light Propagation Volume lighting
	*/
	LpvBiasMultiplier: number;
	/**
	 * If true, will keep geometry data CPU-accessible in cooked builds, rather than uploading to GPU memory and releasing it from CPU memory.
	 * This is required if you wish to access StaticMesh geometry data on the CPU at runtime in cooked builds (e.g. to convert StaticMesh to ProceduralMeshComponent)
	*/
	bAllowCPUAccess: boolean;
	/**
	 * Importing data and options used for this mesh
	*/
	AssetImportData: AssetImportData;
	/**
	 * Path to the resource used to construct this static mesh
	*/
	SourceFilePath: string;
	/**
	 * Date/Time-stamp of the file from the last import
	*/
	SourceFileTimestamp: string;
	/**
	 * Information for thumbnail rendering
	*/
	ThumbnailInfo: ThumbnailInfo;
	/**
	 * The stored camera position to use as a default for the static mesh editor
	*/
	EditorCameraPosition: AssetEditorOrbitCameraPosition;
	/**
	 * If the user has modified collision in any way or has custom collision imported. Used for determining if to auto generate collision on import
	*/
	bCustomizedCollision: boolean;
	/**
	 * Array of named socket locations, set up in editor and used as a shortcut instead of specifying
	 * everything explicitly to AttachComponent in the StaticMeshComponent.
	*/
	Sockets: StaticMeshSocket[];
	/**
	 * Bound extension values in the positive direction of XYZ, positive value increases bound size
	*/
	PositiveBoundsExtension: Vector;
	/**
	 * Bound extension values in the negative direction of XYZ, positive value increases bound size
	*/
	NegativeBoundsExtension: Vector;
	/**
	 * Original mesh bounds extended with Positive/NegativeBoundsExtension
	*/
	ExtendedBounds: BoxSphereBounds;
	/**
	 * Index of an element to ignore while gathering streaming texture factors.
	 * This is useful to disregard automatically generated vertex data which breaks texture factor heuristics.
	*/
	ElementToIgnoreForTexFactor: number;
	/**
	 * Array of user data stored with the asset
	*/
	AssetUserData: AssetUserData[];
	/**
	 * Pre-build navigation collision
	*/
	NavCollision: NavCollision;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMesh;
	static Find(Outer: UObject, ResourceName: string): StaticMesh;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMesh;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMesh;
	/**
	 * Returns number of Sections that this StaticMesh has, in the supplied LOD (LOD 0 is the highest)
	*/
	GetNumSections(InLOD: number): number;
	/**
	 * Returns the number of LODs used by the mesh.
	*/
	GetNumLODs(): number;
	/**
	 * Returns the number of bounds of the mesh.
	 * @return      The bounding box represented as box origin with extents and also a sphere that encapsulates that box
	*/
	GetBounds(): BoxSphereBounds;
	/**
	 * Returns the bounding box, in local space including bounds extension(s), of the StaticMesh asset
	*/
	GetBoundingBox(): Box;
	static C(Other: UObject): StaticMesh;
	/**
	 * Grab geometry data from a StaticMesh asset.
	*/
	GetSectionFromStaticMesh(LODIndex: number,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	/**
	 * Build
	*/
	Build(): void;
	/**
	 * Get Section Info
	*/
	GetSectionInfo(LODIndex: number,SectionIndex: number): MeshSectionInfo;
	/**
	 * Load the raw mesh from bulk data.
	*/
	LoadRawMesh(SourceModelIndex: number,OutMesh?: JavascriptRawMesh): {OutMesh: JavascriptRawMesh};
	/**
	 * Store a new raw mesh in the bulk data.
	*/
	SaveRawMesh(SourceModelIndex: number,InMesh?: JavascriptRawMesh): {InMesh: JavascriptRawMesh};
	/**
	 * Set Section Info
	*/
	SetSectionInfo(LODIndex: number,SectionIndex: number,Info: MeshSectionInfo): void;
	/**
	 * Grab geometry data from a StaticMesh asset.
	*/
	static GetSectionFromStaticMesh(InMesh: StaticMesh,LODIndex: number,SectionIndex: number,Vertices?: Vector[],Triangles?: number[],Normals?: Vector[],UVs?: Vector2D[],Tangents?: ProcMeshTangent[]): {Vertices: Vector[], Triangles: number[], Normals: Vector[], UVs: Vector2D[], Tangents: ProcMeshTangent[]};
	/**
	 * Build
	*/
	static Build(StaticMesh: StaticMesh): void;
	/**
	 * Get Section Info
	*/
	static GetSectionInfo(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number): MeshSectionInfo;
	/**
	 * Load the raw mesh from bulk data.
	*/
	static LoadRawMesh(StaticMesh: StaticMesh,SourceModelIndex: number,OutMesh?: JavascriptRawMesh): {OutMesh: JavascriptRawMesh};
	/**
	 * Store a new raw mesh in the bulk data.
	*/
	static SaveRawMesh(StaticMesh: StaticMesh,SourceModelIndex: number,InMesh?: JavascriptRawMesh): {InMesh: JavascriptRawMesh};
	/**
	 * Set Section Info
	*/
	static SetSectionInfo(StaticMesh: StaticMesh,LODIndex: number,SectionIndex: number,Info: MeshSectionInfo): void;
}

declare class CameraComponent extends SceneComponent { 
	/**
	 * The horizontal field of view (in degrees) in perspective mode (ignored in Orthographic mode)
	*/
	FieldOfView: number;
	/**
	 * The desired width (in world units) of the orthographic view (ignored in Perspective mode)
	*/
	OrthoWidth: number;
	/**
	 * The near plane distance of the orthographic view (in world units)
	*/
	OrthoNearClipPlane: number;
	/**
	 * The far plane distance of the orthographic view (in world units)
	*/
	OrthoFarClipPlane: number;
	/**
	 * Aspect Ratio (Width/Height)
	*/
	AspectRatio: number;
	/**
	 * If bConstrainAspectRatio is true, black bars will be added if the destination view has a different aspect ratio than this camera requested.
	*/
	bConstrainAspectRatio: boolean;
	/**
	 * If true, account for the field of view angle when computing which level of detail to use for meshes.
	*/
	bUseFieldOfViewForLOD: boolean;
	/**
	 * True if the camera's orientation and position should be locked to the HMD
	*/
	bLockToHmd: boolean;
	/**
	 * If this camera component is placed on a pawn, should it use the view/control rotation of the pawn where possible?
	 * @see APawn::GetViewRotation()
	*/
	bUsePawnControlRotation: boolean;
	/**
	 * The type of camera
	*/
	ProjectionMode: ECameraProjectionMode;
	/**
	 * Indicates if PostProcessSettings should be used when using this Camera to view through.
	*/
	PostProcessBlendWeight: number;
	/**
	 * Post process settings to use for this camera. Don't forget to check the properties you want to override
	*/
	PostProcessSettings: PostProcessSettings;
	/**
	 * Camera Mesh
	*/
	CameraMesh: StaticMesh;
	/**
	 * DEPRECATED: use bUsePawnControlRotation instead
	*/
	bUseControllerViewRotation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CameraComponent;
	static Find(Outer: UObject, ResourceName: string): CameraComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraComponent;
	/**
	 * Set Use Field Of View for LOD
	*/
	SetUseFieldOfViewForLOD(bInUseFieldOfViewForLOD: boolean): void;
	/**
	 * Set Projection Mode
	*/
	SetProjectionMode(InProjectionMode: ECameraProjectionMode): void;
	/**
	 * Set Post Process Blend Weight
	*/
	SetPostProcessBlendWeight(InPostProcessBlendWeight: number): void;
	/**
	 * Set Ortho Width
	*/
	SetOrthoWidth(InOrthoWidth: number): void;
	/**
	 * Set Ortho Near Clip Plane
	*/
	SetOrthoNearClipPlane(InOrthoNearClipPlane: number): void;
	/**
	 * Set Ortho Far Clip Plane
	*/
	SetOrthoFarClipPlane(InOrthoFarClipPlane: number): void;
	/**
	 * Set Field Of View
	*/
	SetFieldOfView(InFieldOfView: number): void;
	/**
	 * Set Constraint Aspect Ratio
	*/
	SetConstraintAspectRatio(bInConstrainAspectRatio: boolean): void;
	/**
	 * Set Aspect Ratio
	*/
	SetAspectRatio(InAspectRatio: number): void;
	/**
	 * Returns camera's Point of View.
	 * Called by Camera class. Subclass and postprocess to add any effects.
	*/
	GetCameraView(DeltaTime: number,DesiredView?: MinimalViewInfo): {DesiredView: MinimalViewInfo};
	static C(Other: UObject): CameraComponent;
}

declare class CameraActor extends Actor { 
	/**
	 * Specifies which player controller, if any, should automatically use this Camera when the controller is active.
	*/
	AutoActivateForPlayer: EAutoReceiveInput;
	/**
	 * Camera Component
	*/
	CameraComponent: CameraComponent;
	/**
	 * Scene Component
	*/
	SceneComponent: SceneComponent;
	/**
	 * Constrain Aspect Ratio
	*/
	bConstrainAspectRatio: boolean;
	/**
	 * Aspect Ratio
	*/
	AspectRatio: number;
	/**
	 * FOVAngle
	*/
	FOVAngle: number;
	/**
	 * Post Process Blend Weight
	*/
	PostProcessBlendWeight: number;
	/**
	 * Post Process Settings
	*/
	PostProcessSettings: PostProcessSettings;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CameraActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CameraActor;
	/**
	 * Returns index of the player for whom we auto-activate, or INDEX_NONE (-1) if disabled.
	*/
	GetAutoActivatePlayerIndex(): number;
	static C(Other: UObject): CameraActor;
	/**
	 * Draw a debug camera shape.
	*/
	DrawDebugCamera(CameraColor: LinearColor,Duration: number): void;
	/**
	 * Draw a debug camera shape.
	*/
	static DrawDebugCamera(CameraActor: CameraActor,CameraColor: LinearColor,Duration: number): void;
}

declare class PlayerCameraManager extends Actor { 
	/**
	 * PlayerController that owns this Camera actor
	*/
	PCOwner: PlayerController;
	/**
	 * Transform Component
	*/
	TransformComponent: SceneComponent;
	/**
	 * FOV to use by default.
	*/
	DefaultFOV: number;
	/**
	 * The default desired width (in world units) of the orthographic view (ignored in Perspective mode)
	*/
	DefaultOrthoWidth: number;
	/**
	 * Default aspect ratio
	*/
	DefaultAspectRatio: number;
	/**
	 * Cached camera properties.
	*/
	CameraCache: CameraCacheEntry;
	/**
	 * Cached camera properties, one frame old.
	*/
	LastFrameCameraCache: CameraCacheEntry;
	/**
	 * Current ViewTarget
	*/
	ViewTarget: TViewTarget;
	/**
	 * Pending view target for blending
	*/
	PendingViewTarget: TViewTarget;
	/**
	 * List of active camera modifier instances that have a chance to update the final camera POV
	*/
	ModifierList: CameraModifier[];
	/**
	 * List of modifiers to create by default for this camera
	*/
	DefaultModifiers: UnrealEngineClass[];
	/**
	 * Distance to place free camera from view target (used in certain CameraStyles)
	*/
	FreeCamDistance: number;
	/**
	 * Offset to Z free camera position (used in certain CameraStyles)
	*/
	FreeCamOffset: Vector;
	/**
	 * Offset to view target (used in certain CameraStyles)
	*/
	ViewTargetOffset: Vector;
	/**
	 * CameraBlood emitter attached to this camera
	*/
	CameraLensEffects: EmitterCameraLensEffectBase[];
	/**
	 * Cached ref to modifier for code-driven screen shakes
	*/
	CachedCameraShakeMod: CameraModifier_CameraShake;
	/**
	 * Internal pool of camera anim instance objects available for playing camera animations. Defines the max number of camera anims that can play simultaneously.
	*/
	AnimInstPool: CameraAnimInst;
	/**
	 * Internal list of active post process effects. Parallel array to PostProcessBlendCacheWeights.
	*/
	PostProcessBlendCache: PostProcessSettings[];
	/**
	 * Array of camera anim instances that are currently playing and in-use
	*/
	ActiveAnims: CameraAnimInst[];
	/**
	 * Array of camera anim instances that are not playing and available to be used.
	*/
	FreeAnims: CameraAnimInst[];
	/**
	 * Internal. Receives the output of individual camera animations.
	*/
	AnimCameraActor: CameraActor;
	/**
	 * True when this camera should use an orthographic perspective instead of FOV
	*/
	bIsOrthographic: boolean;
	/**
	 * True if server will use camera positions replicated from the client instead of calculating them locally.
	*/
	bUseClientSideCameraUpdates: boolean;
	/**
	 * Minimum view pitch, in degrees.
	*/
	ViewPitchMin: number;
	/**
	 * Maximum view pitch, in degrees.
	*/
	ViewPitchMax: number;
	/**
	 * Minimum view yaw, in degrees.
	*/
	ViewYawMin: number;
	/**
	 * Maximum view yaw, in degrees.
	*/
	ViewYawMax: number;
	/**
	 * Minimum view roll, in degrees.
	*/
	ViewRollMin: number;
	/**
	 * Maximum view roll, in degrees.
	*/
	ViewRollMax: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerCameraManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerCameraManager;
	/**
	 * Immediately stops the given shake instance and invalidates it.
	*/
	StopCameraShake(ShakeInstance: CameraShake,bImmediately: boolean): void;
	/**
	 * Stops camera fading.
	*/
	StopCameraFade(): void;
	/**
	 * Stops the given CameraAnimInst from playing.  The given pointer should be considered invalid after this.
	 * @param bImmediate    True to stop it right now and ignore blend out, false to let it blend out as indicated.
	*/
	StopCameraAnimInst(AnimInst: CameraAnimInst,bImmediate: boolean): void;
	/**
	 * Stops playing CameraShake of the given class.
	*/
	StopAllInstancesOfCameraShake(Shake: UnrealEngineClass,bImmediately: boolean): void;
	/**
	 * Stop playing all instances of the indicated CameraAnim.
	 * @param bImmediate    True to stop it right now and ignore blend out, false to let it blend out as indicated.
	*/
	StopAllInstancesOfCameraAnim(Anim: CameraAnim,bImmediate: boolean): void;
	/**
	 * Stops all active camera shakes on this camera.
	*/
	StopAllCameraShakes(bImmediately: boolean): void;
	/**
	 * Stop playing all CameraAnims on this CameraManager.
	 * @param bImmediate    True to stop it right now and ignore blend out, false to let it blend out as indicated.
	*/
	StopAllCameraAnims(bImmediate: boolean): void;
	/**
	 * Does a camera fade to/from a solid color.  Animates automatically.
	 * @param FromAlpha - Alpha at which to begin the fade. Range [0..1], where 0 is fully transparent and 1 is fully opaque solid color.
	 * @param ToAlpha - Alpha at which to finish the fade.
	 * @param Duration - How long the fade should take, in seconds.
	 * @param Color - Color to fade to/from.
	 * @param bShouldFadeAudio - True to fade audio volume along with the alpha of the solid color.
	 * @param bHoldWhenFinished - True for fade to hold at the ToAlpha until explicitly stopped (e.g. with StopCameraFade)
	*/
	StartCameraFade(FromAlpha: number,ToAlpha: number,Duration: number,Color: LinearColor,bShouldFadeAudio: boolean,bHoldWhenFinished: boolean): void;
	/**
	 * Turns on camera fading at the given opacity. Does not auto-animate, allowing user to animate themselves.
	 * Call StopCameraFade to turn fading back off.
	*/
	SetManualCameraFade(InFadeAmount: number,Color: LinearColor,bInFadeAudio: boolean): void;
	/**
	 * Removes the given camera modifier from this camera (if it's on the camera in the first place) and discards it.
	 * @return True if successfully removed, false otherwise.
	*/
	RemoveCameraModifier(ModifierToRemove: CameraModifier): boolean;
	/**
	 * Removes the given lens effect from the camera.
	 * @param Emitter - the emitter actor to remove from the camera
	*/
	RemoveCameraLensEffect(Emitter: EmitterCameraLensEffectBase): void;
	/**
	 * Plays a camera shake on this camera.
	 * @param Shake - The class of camera shake to play.
	 * @param Scale - Scalar defining how "intense" to play the shake. 1.0 is normal (as authored).
	 * @param PlaySpace - Which coordinate system to play the shake in (affects oscillations and camera anims)
	 * @param UserPlaySpaceRot - Coordinate system to play shake when PlaySpace == CAPS_UserDefined.
	*/
	PlayCameraShake(ShakeClass: UnrealEngineClass,Scale: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): CameraShake;
	/**
	 * Play the indicated CameraAnim on this camera.
	 * @param Anim The animation that should play on this instance.
	 * @param Rate                          How fast to play the animation. 1.0 is normal.
	 * @param Scale                         How "intense" to play the animation. 1.0 is normal.
	 * @param BlendInTime           Time to linearly ramp in.
	 * @param BlendOutTime          Time to linearly ramp out.
	 * @param bLoop                         True to loop the animation if it hits the end.
	 * @param bRandomStartTime      Whether or not to choose a random time to start playing. Useful with bLoop=true and a duration to randomize things like shakes.
	 * @param Duration                      Optional total playtime for this animation, including blends. 0 means to use animations natural duration, or infinite if looping.
	 * @param PlaySpace                     Which space to play the animation in.
	 * @param UserPlaySpaceRot  Custom play space, used when PlaySpace is UserDefined.
	 * @return The CameraAnim instance, which can be stored to manipulate/stop the anim after the fact.
	*/
	PlayCameraAnim(Anim: CameraAnim,Rate: number,Scale: number,BlendInTime: number,BlendOutTime: number,bLoop: boolean,bRandomStartTime: boolean,Duration: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): CameraAnimInst;
	/**
	 * Returns the PlayerController that owns this camera.
	*/
	GetOwningPlayerController(): PlayerController;
	/**
	 * @return Returns the camera's current full FOV angle, in degrees.
	*/
	GetFOVAngle(): number;
	/**
	 * @return Returns camera's current rotation.
	*/
	GetCameraRotation(): Rotator;
	/**
	 * @return Returns camera's current location.
	*/
	GetCameraLocation(): Vector;
	/**
	 * Returns camera modifier for this camera of the given class, if it exists.
	 * Exact class match only. If there are multiple modifiers of the same class, the first one is returned.
	*/
	FindCameraModifierByClass(ModifierClass: UnrealEngineClass): CameraModifier;
	/**
	 * Removes all camera lens effects.
	*/
	ClearCameraLensEffects(): void;
	/**
	 * Blueprint hook to allow blueprints to override existing camera behavior or implement custom cameras.
	 * If this function returns true, we will use the given returned values and skip further calculations to determine
	 * final camera POV.
	*/
	BlueprintUpdateCamera(CameraTarget: Actor,NewCameraLocation?: Vector,NewCameraRotation?: Rotator,NewCameraFOV?: number): {NewCameraLocation: Vector, NewCameraRotation: Rotator, NewCameraFOV: number, $: boolean};
	/**
	 * Creates and initializes a new camera modifier of the specified class.
	 * @param ModifierClass - The class of camera modifier to create.
	 * @return Returns the newly created camera modifier.
	*/
	AddNewCameraModifier(ModifierClass: UnrealEngineClass): CameraModifier;
	/**
	 * Creates a camera lens effect of the given class on this camera.
	 * @param LensEffectEmitterClass - Class of lens effect emitter to create.
	 * @return Returns the new emitter actor.
	*/
	AddCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): EmitterCameraLensEffectBase;
	static C(Other: UObject): PlayerCameraManager;
}

declare class DrawFrustumComponent extends PrimitiveComponent { 
	/**
	 * Color to draw the wireframe frustum.
	*/
	FrustumColor: Color;
	/**
	 * Angle of longest dimension of view shape.
	 * If the angle is 0 then an orthographic projection is used
	*/
	FrustumAngle: number;
	/**
	 * Ratio of horizontal size over vertical size.
	*/
	FrustumAspectRatio: number;
	/**
	 * Distance from origin to start drawing the frustum.
	*/
	FrustumStartDist: number;
	/**
	 * Distance from origin to stop drawing the frustum.
	*/
	FrustumEndDist: number;
	/**
	 * optional texture to show on the near plane
	*/
	Texture: Texture;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): DrawFrustumComponent;
	static Find(Outer: UObject, ResourceName: string): DrawFrustumComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DrawFrustumComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DrawFrustumComponent;
	static C(Other: UObject): DrawFrustumComponent;
}

declare class DebugCameraController extends PlayerController { 
	/**
	 * Whether to show information about the selected actor on the debug camera HUD.
	*/
	bShowSelectedInfo: boolean;
	/**
	 * @todo document
	*/
	bIsFrozenRendering: boolean;
	/**
	 * @todo document
	*/
	DrawFrustum: DrawFrustumComponent;
	/**
	 * Allows control over the speed of the spectator pawn. This scales the speed based on the InitialMaxSpeed.
	*/
	SpeedScale: number;
	/**
	 * Initial max speed of the spectator pawn when we start possession.
	*/
	InitialMaxSpeed: number;
	/**
	 * Initial acceleration of the spectator pawn when we start possession.
	*/
	InitialAccel: number;
	/**
	 * Initial deceleration of the spectator pawn when we start possession.
	*/
	InitialDecel: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DebugCameraController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DebugCameraController;
	/**
	 * Toggles the display of debug info and input commands for the Debug Camera.
	*/
	ToggleDisplay(): void;
	/**
	 * @todo document
	*/
	ShowDebugSelectedInfo(): void;
	/**
	 * Function called on deactivation of debug camera controller.
	 * @param RestoredPC The Player Controller that the player input is being returned to.
	*/
	OnDeactivate(RestoredPC: PlayerController): void;
	/**
	 * Called when an actor has been selected with the primary key (e.g. left mouse button).
	 * @param SelectHitLocation The exact world-space location where the selection trace hit the New Selected Actor.
	 * @param SelectHitNormal The world-space surface normal of the New Selected Actor at the hit location.
	*/
	OnActorSelected(NewSelectedActor: Actor,SelectHitLocation: Vector,SelectHitNormal: Vector,Hit: HitResult): void;
	/**
	 * Function called on activation of debug camera controller.
	 * @param OriginalPC The active player controller before this debug camera controller was possessed by the player.
	*/
	OnActivate(OriginalPC: PlayerController): void;
	/**
	 * Get Selected Actor
	*/
	GetSelectedActor(): Actor;
	static C(Other: UObject): DebugCameraController;
}

declare class CheatManager extends UObject { 
	/**
	 * Debug camera - used to have independent camera without stopping gameplay
	*/
	DebugCameraControllerRef: DebugCameraController;
	/**
	 * Debug camera - used to have independent camera without stopping gameplay.
	 * If the Outer PlayerController::DebugCameraClass is valid then it is used instead of default DebugCameraController class.
	*/
	DebugCameraControllerClass: UnrealEngineClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CheatManager;
	static Find(Outer: UObject, ResourceName: string): CheatManager;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CheatManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CheatManager;
	/**
	 * Return to walking movement mode from Fly or Ghost cheat.
	*/
	Walk(): void;
	/**
	 * Make controlled pawn the viewtarget again.
	*/
	ViewSelf(): void;
	/**
	 * View from the point of view of player with PlayerName S.
	*/
	ViewPlayer(S: string): void;
	/**
	 * View from the point of view of an AActor of class DesiredClass.  Each subsequent ViewClass cycles through the list of actors of that class.
	*/
	ViewClass(DesiredClass: UnrealEngineClass): void;
	/**
	 * View from the point of view of AActor with Name ActorName.
	*/
	ViewActor(ActorName: string): void;
	/**
	 * Toggle between debug camera/player camera without locking gameplay and with locking local player controller input.
	*/
	ToggleDebugCamera(): void;
	/**
	 * toggles AI logging
	*/
	ToggleAILogging(): void;
	/**
	 * Test all volumes in the world to the player controller's view location*
	*/
	TestCollisionDistance(): void;
	/**
	 * Teleport to surface player is looking at.
	*/
	Teleport(): void;
	/**
	 * Load Classname and spawn an actor of that class
	*/
	Summon(ClassName: string): void;
	/**
	 * Stream out the given level.
	*/
	StreamLevelOut(PackageName: string): void;
	/**
	 * Stream in the given level.
	*/
	StreamLevelIn(PackageName: string): void;
	/**
	 * Modify time dilation to change apparent speed of passage of time. e.g. "Slomo 0.1" makes everything move very slowly, while "Slomo 10" makes everything move very fast.
	*/
	Slomo(NewTimeDilation: number): void;
	/**
	 * Translate world origin to this player position
	*/
	SetWorldOrigin(): void;
	/**
	 * Sets navigation drawing distance. Relevant only in non-editor modes. *
	*/
	SetNavDrawDistance(DrawDistance: number): void;
	/**
	 * Exec function to return the mouse sensitivity to its default value
	*/
	SetMouseSensitivityToDefault(): void;
	/**
	 * Server Toggle AILogging
	*/
	ServerToggleAILogging(): void;
	/**
	 * Called when the Cheat Manager is first initialized.
	*/
	InitCheatManager(): void;
	/**
	 * Builds the navigation mesh (or rebuilds it). *
	*/
	RebuildNavigation(): void;
	/**
	 * Freeze everything in the level except for players.
	*/
	PlayersOnly(): void;
	/**
	 * Load the given level.
	*/
	OnlyLoadLevel(PackageName: string): void;
	/**
	 * Logs the current location in bugit format without taking screenshot and further routing.
	*/
	LogLoc(): void;
	/**
	 * Backwards compatibility exec function for people used to it instead of using InvertAxisKey
	*/
	InvertMouse(): void;
	/**
	 * Invulnerability cheat.
	*/
	God(): void;
	/**
	 * Pawn no longer collides with the world, and can fly
	*/
	Ghost(): void;
	/**
	 * Pause the game for Delay seconds.
	*/
	FreezeFrame(Delay: number): void;
	/**
	 * Pawn can fly.
	*/
	Fly(): void;
	/**
	 * This will force a flush of the output log to file
	*/
	FlushLog(): void;
	/**
	 * Dump current state of voice chat
	*/
	DumpVoiceMutingState(): void;
	/**
	 * Dump known party information
	*/
	DumpPartyState(): void;
	/**
	 * Dump online session information
	*/
	DumpOnlineSessionState(): void;
	/**
	 * Dump known chat information
	*/
	DumpChatState(): void;
	/**
	 * Destroy the actor you're looking at.
	*/
	DestroyTarget(): void;
	/**
	 * Destroys (by calling destroy directly) all non-player pawns of class aClass in the level
	*/
	DestroyPawns(aClass: UnrealEngineClass): void;
	/**
	 * Destroy all pawns except for the (pawn) target.  If no (pawn) target is found we don't destroy anything.
	*/
	DestroyAllPawnsExceptTarget(): void;
	/**
	 * Destroy all actors of class aClass
	*/
	DestroyAll(aClass: UnrealEngineClass): void;
	/**
	 * Change Trace capsule size *
	*/
	DebugCapsuleSweepSize(HalfHeight: number,Radius: number): void;
	/**
	 * Capture current local PC's pawn's location and add to persistent list *
	*/
	DebugCapsuleSweepPawn(): void;
	/**
	 * Change Trace Complex setting *
	*/
	DebugCapsuleSweepComplex(bTraceComplex: boolean): void;
	/**
	 * Clear persistent list for trace capture *
	*/
	DebugCapsuleSweepClear(): void;
	/**
	 * Change Trace Channel *
	*/
	DebugCapsuleSweepChannel(Channel: ECollisionChannel): void;
	/**
	 * Capture current trace and add to persistent list *
	*/
	DebugCapsuleSweepCapture(): void;
	/**
	 * Toggle capsule trace debugging. Will trace a capsule from current view point and show where it hits the world
	*/
	DebugCapsuleSweep(): void;
	/**
	 * Damage the actor you're looking at (sourced from the player).
	*/
	DamageTarget(DamageAmount: number): void;
	/**
	 * Executes commands listed in CheatScript.ScriptName ini section of DefaultGame.ini
	*/
	CheatScript(ScriptName: string): void;
	/**
	 * Scale the player's size to be F * default size.
	*/
	ChangeSize(F: number): void;
	/**
	 * This will create a BugItGo string for us.  Nice for calling form c++ where you just want the string and no Screenshots *
	*/
	BugItStringCreator(ViewLocation: Vector,ViewRotation: Rotator,GoString?: string,LocString?: string): {GoString: string, LocString: string};
	/**
	 * This will move the player and set their rotation to the passed in values.
	 * We have this version of the BugIt family as it is easier to type in just raw numbers in the console.
	*/
	BugItGo(X: number,Y: number,Z: number,Pitch: number,Yaw: number,Roll: number): void;
	/**
	 * This function is used to print out the BugIt location.  It prints out copy and paste versions for both IMing someone to type in
	 * and also a gameinfo ?options version so that you can append it to your launching url and be taken to the correct place.
	 * Additionally, it will take a screen shot so reporting bugs is a one command action!
	*/
	BugIt(ScreenShotDescription: string): void;
	static C(Other: UObject): CheatManager;
}

declare class KeyBind { 
	/**
	 * The key to be bound to the command
	*/
	Key: Key;
	/**
	 * The command to execute when the key is pressed/released
	*/
	Command: string;
	/**
	 * Whether the control key needs to be held when the key event occurs
	*/
	Control: boolean;
	/**
	 * Whether the shift key needs to be held when the key event occurs
	*/
	Shift: boolean;
	/**
	 * Whether the alt key needs to be held when the key event occurs
	*/
	Alt: boolean;
	/**
	 * Whether the command key needs to be held when the key event occurs
	*/
	Cmd: boolean;
	/**
	 * Whether the control key must not be held when the key event occurs
	*/
	bIgnoreCtrl: boolean;
	/**
	 * Whether the shift key must not be held when the key event occurs
	*/
	bIgnoreShift: boolean;
	/**
	 * Whether the alt key must not be held when the key event occurs
	*/
	bIgnoreAlt: boolean;
	/**
	 * Whether the command key must not be held when the key event occurs
	*/
	bIgnoreCmd: boolean;
	/**
	 * Disabled
	*/
	bDisabled: boolean;
	clone() : KeyBind;
	static C(Other: UObject): KeyBind;
}

declare class PlayerInput extends UObject { 
	/**
	 * Generic bindings of keys to Exec()-compatible strings for development purposes only
	*/
	DebugExecBindings: KeyBind[];
	/**
	 * List of Axis Mappings that have been inverted
	*/
	InvertedAxis: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PlayerInput;
	static Find(Outer: UObject, ResourceName: string): PlayerInput;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerInput;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerInput;
	/**
	 * Exec function to change the mouse sensitivity
	*/
	SetMouseSensitivity(Sensitivity: number): void;
	/**
	 * Exec function to add a debug exec command
	*/
	SetBind(BindName: string,Command: string): void;
	/**
	 * Exec function to invert an axis key
	*/
	InvertAxisKey(AxisKey: Key): void;
	/**
	 * Exec function to invert an axis mapping
	*/
	InvertAxis(AxisName: string): void;
	/**
	 * Exec function to reset mouse smoothing values
	*/
	ClearSmoothing(): void;
	static C(Other: UObject): PlayerInput;
}

declare class RuntimeFloatCurve { 
	/**
	 * Editor Curve Data
	*/
	EditorCurveData: RichCurve;
	/**
	 * External Curve
	*/
	ExternalCurve: CurveFloat;
	clone() : RuntimeFloatCurve;
	static C(Other: UObject): RuntimeFloatCurve;
}

declare class ForceFeedbackChannelDetails { 
	/**
	 * Affects Left Large
	*/
	bAffectsLeftLarge: boolean;
	/**
	 * Affects Left Small
	*/
	bAffectsLeftSmall: boolean;
	/**
	 * Affects Right Large
	*/
	bAffectsRightLarge: boolean;
	/**
	 * Affects Right Small
	*/
	bAffectsRightSmall: boolean;
	/**
	 * Curve
	*/
	Curve: RuntimeFloatCurve;
	clone() : ForceFeedbackChannelDetails;
	static C(Other: UObject): ForceFeedbackChannelDetails;
}

declare class ForceFeedbackEffect extends UObject { 
	/**
	 * Channel Details
	*/
	ChannelDetails: ForceFeedbackChannelDetails[];
	/**
	 * Duration of force feedback pattern in seconds.
	*/
	Duration: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ForceFeedbackEffect;
	static Find(Outer: UObject, ResourceName: string): ForceFeedbackEffect;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ForceFeedbackEffect;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ForceFeedbackEffect;
	static C(Other: UObject): ForceFeedbackEffect;
}

declare class ActiveForceFeedbackEffect { 
	/**
	 * Force Feedback Effect
	*/
	ForceFeedbackEffect: ForceFeedbackEffect;
	clone() : ActiveForceFeedbackEffect;
	static C(Other: UObject): ActiveForceFeedbackEffect;
}

declare class ChildConnection extends NetConnection { 
	/**
	 * Parent
	*/
	Parent: NetConnection;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ChildConnection;
	static Find(Outer: UObject, ResourceName: string): ChildConnection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ChildConnection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildConnection;
	static C(Other: UObject): ChildConnection;
}

declare class Property extends Field { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Property;
	static Find(Outer: UObject, ResourceName: string): Property;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Property;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Property;
	static C(Other: UObject): Property;
}

declare class NetDriver extends UObject { 
	/**
	 * Used to specify the class to use for connections
	*/
	NetConnectionClassName: string;
	/**
	 * @todo document
	*/
	MaxDownloadSize: number;
	/**
	 * @todo document
	*/
	bClampListenServerTickRate: boolean;
	/**
	 * @todo document
	*/
	NetServerMaxTickRate: number;
	/**
	 * @todo document
	*/
	MaxInternetClientRate: number;
	/**
	 * @todo document
	*/
	MaxClientRate: number;
	/**
	 * Amount of time a server will wait before traveling to next map, gives clients time to receive final RPCs on existing level @see NextSwitchCountdown
	*/
	ServerTravelPause: number;
	/**
	 * @todo document
	*/
	SpawnPrioritySeconds: number;
	/**
	 * @todo document
	*/
	RelevantTimeout: number;
	/**
	 * @todo document
	*/
	KeepAliveTime: number;
	/**
	 * Amount of time to wait for a new net connection to be established before destroying the connection
	*/
	InitialConnectTimeout: number;
	/**
	 * Amount of time to wait before considering an established connection timed out.
	 * Typically shorter than the time to wait on a new connection because this connection
	 * should already have been setup and any interruption should be trapped quicker.
	*/
	ConnectionTimeout: number;
	/**
	 * If true, ignore timeouts completely.  Should be used only in development
	*/
	bNoTimeouts: boolean;
	/**
	 * Connection to the server (this net driver is a client)
	*/
	ServerConnection: NetConnection;
	/**
	 * Array of connections to clients (this net driver is a host)
	*/
	ClientConnections: NetConnection[];
	/**
	 * World this net driver is associated with
	*/
	World: World;
	/**
	 * The loaded UClass of the net connection type to use
	*/
	NetConnectionClass: UnrealEngineClass;
	/**
	 * @todo document
	*/
	RoleProperty: Property;
	/**
	 * @todo document
	*/
	RemoteRoleProperty: Property;
	/**
	 * Used to specify the net driver to filter actors with (NAME_None || NAME_GameNetDriver is the default net driver)
	*/
	NetDriverName: string;
	/**
	 * Accumulated time for the net driver, updated by Tick
	*/
	Time: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NetDriver;
	static Find(Outer: UObject, ResourceName: string): NetDriver;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NetDriver;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetDriver;
	static C(Other: UObject): NetDriver;
}

declare class PackageMap extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PackageMap;
	static Find(Outer: UObject, ResourceName: string): PackageMap;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PackageMap;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PackageMap;
	static C(Other: UObject): PackageMap;
}

declare class Channel extends UObject { 
	/**
	 * Connection
	*/
	Connection: NetConnection;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Channel;
	static Find(Outer: UObject, ResourceName: string): Channel;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Channel;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Channel;
	static C(Other: UObject): Channel;
}

declare class NetConnection extends Player { 
	/**
	 * child connections for secondary viewports
	*/
	Children: ChildConnection[];
	/**
	 * Owning net driver
	*/
	Driver: NetDriver;
	/**
	 * Package map between local and remote. (negotiates net serialization)
	*/
	PackageMap: PackageMap;
	/**
	 * @todo document
	*/
	OpenChannels: Channel[];
	/**
	 * @todo document
	*/
	SentTemporaries: Actor[];
	/**
	 * The actor that is currently being viewed/controlled by the owning controller
	*/
	ViewTarget: Actor;
	/**
	 * Reference to controlling actor (usually PlayerController)
	*/
	OwningActor: Actor;
	/**
	 * Max Packet
	*/
	MaxPacket: number;
	/**
	 * Maximum packet size.
	*/
	InternalAck: boolean;
	/**
	 * Net id of remote player on this connection. Only valid on client connections (server side).
	*/
	PlayerId: UniqueNetIdRepl;
	/**
	 * Internal.
	*/
	LastReceiveTime: any;
	/**
	 * The channels that need ticking. This will be a subset of OpenChannels, only including
	 * channels that need to process either dormancy or queued bunches. Should be a significant
	 * optimization over ticking and calling virtual functions on the potentially hundreds of
	 * OpenChannels every frame.
	*/
	ChannelsToTick: Channel[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NetConnection;
	static Find(Outer: UObject, ResourceName: string): NetConnection;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NetConnection;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NetConnection;
	static C(Other: UObject): NetConnection;
}

declare type EMouseCursor = string | symbol;
declare var EMouseCursor = { None:'None',Default:'Default',TextEditBeam:'TextEditBeam',ResizeLeftRight:'ResizeLeftRight',ResizeUpDown:'ResizeUpDown',ResizeSouthEast:'ResizeSouthEast',ResizeSouthWest:'ResizeSouthWest',CardinalCross:'CardinalCross',Crosshairs:'Crosshairs',Hand:'Hand',GrabHand:'GrabHand',GrabHandClosed:'GrabHandClosed',SlashedCircle:'SlashedCircle',EyeDropper:'EyeDropper', };
declare type EControllerAnalogStick = string | symbol;
declare var EControllerAnalogStick = { CAS_LeftStick:'CAS_LeftStick',CAS_RightStick:'CAS_RightStick', };
declare class InputComponent extends ActorComponent { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InputComponent;
	static Find(Outer: UObject, ResourceName: string): InputComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InputComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InputComponent;
	/**
	 * Returns true if the given key/button was down last frame and up this frame.
	*/
	WasControllerKeyJustReleased(Key: Key): boolean;
	/**
	 * Returns true if the given key/button was up last frame and down this frame.
	*/
	WasControllerKeyJustPressed(Key: Key): boolean;
	/**
	 * Returns true if the given key/button is pressed on the input of the controller (if present)
	*/
	IsControllerKeyDown(Key: Key): boolean;
	/**
	 * Returns the location of a touch, and if it's held down
	*/
	GetTouchState(FingerIndex: number,LocationX?: number,LocationY?: number,bIsCurrentlyPressed?: boolean): {LocationX: number, LocationY: number, bIsCurrentlyPressed: boolean};
	/**
	 * Returns the vector value for the given key/button.
	*/
	GetControllerVectorKeyState(Key: Key): Vector;
	/**
	 * Retrieves how far the mouse moved this frame.
	*/
	GetControllerMouseDelta(DeltaX?: number,DeltaY?: number): {DeltaX: number, DeltaY: number};
	/**
	 * Returns how long the given key/button has been down.  Returns 0 if it's up or it just went down this frame.
	*/
	GetControllerKeyTimeDown(Key: Key): number;
	/**
	 * Retrieves the X and Y displacement of the given analog stick.  For WhickStick, 0 = left, 1 = right.
	*/
	GetControllerAnalogStickState(WhichStick: EControllerAnalogStick,StickX?: number,StickY?: number): {StickX: number, StickY: number};
	/**
	 * Returns the analog value for the given key/button.  If analog isn't supported, returns 1 for down and 0 for up.
	*/
	GetControllerAnalogKeyState(Key: Key): number;
	static C(Other: UObject): InputComponent;
}

declare class TouchInputControl { 
	/**
	 * For sticks, this is the Thumb
	*/
	Image1: Texture2D;
	/**
	 * For sticks, this is the Background
	*/
	Image2: Texture2D;
	/**
	 * The center point of the control (if <= 1.0, it's relative to screen, > 1.0 is absolute)
	*/
	Center: Vector2D;
	/**
	 * The size of the control (if <= 1.0, it's relative to screen, > 1.0 is absolute)
	*/
	VisualSize: Vector2D;
	/**
	 * For sticks, the size of the thumb (if <= 1.0, it's relative to screen, > 1.0 is absolute)
	*/
	ThumbSize: Vector2D;
	/**
	 * The interactive size of the control (if <= 1.0, it's relative to screen, > 1.0 is absolute)
	*/
	InteractionSize: Vector2D;
	/**
	 * The scale for control input
	*/
	InputScale: Vector2D;
	/**
	 * The main input to send from this control (for sticks, this is the horizontal axis)
	*/
	MainInputKey: Key;
	/**
	 * The alternate input to send from this control (for sticks, this is the vertical axis)
	*/
	AltInputKey: Key;
	clone() : TouchInputControl;
	static C(Other: UObject): TouchInputControl;
}

declare class TouchInterface extends UObject { 
	/**
	 * Controls
	*/
	Controls: TouchInputControl[];
	/**
	 * Opacity (0.0 - 1.0) of all controls while any control is active
	*/
	ActiveOpacity: number;
	/**
	 * Opacity (0.0 - 1.0) of all controls while no controls are active
	*/
	InactiveOpacity: number;
	/**
	 * How long after user interaction will all controls fade out to Inactive Opacity
	*/
	TimeUntilDeactive: number;
	/**
	 * How long after going inactive will controls reset/recenter themselves (0.0 will disable this feature)
	*/
	TimeUntilReset: number;
	/**
	 * How long after joystick enabled for touch (0.0 will disable this feature)
	*/
	ActivationDelay: number;
	/**
	 * Whether to prevent joystick re-center
	*/
	bPreventRecenter: boolean;
	/**
	 * Delay at startup before virtual joystick is drawn
	*/
	StartupDelay: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): TouchInterface;
	static Find(Outer: UObject, ResourceName: string): TouchInterface;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): TouchInterface;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): TouchInterface;
	static C(Other: UObject): TouchInterface;
}

declare class SphereComponent extends ShapeComponent { 
	/**
	 * The radius of the sphere *
	*/
	SphereRadius: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SphereComponent;
	static Find(Outer: UObject, ResourceName: string): SphereComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SphereComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SphereComponent;
	/**
	 * Change the sphere radius. This is the unscaled radius, before component scale is applied.
	 * @param       InSphereRadius: the new sphere radius
	 * @param       bUpdateOverlaps: if true and this shape is registered and collides, updates touching array for owner actor.
	*/
	SetSphereRadius(InSphereRadius: number,bUpdateOverlaps: boolean): void;
	/**
	 * @return the radius of the sphere, ignoring component scale.
	*/
	GetUnscaledSphereRadius(): number;
	/**
	 * Get the scale used by this shape. This is a uniform scale that is the minimum of any non-uniform scaling.
	 * @return the scale used by this shape.
	*/
	GetShapeScale(): number;
	/**
	 * @return the radius of the sphere, with component scale applied.
	*/
	GetScaledSphereRadius(): number;
	static C(Other: UObject): SphereComponent;
}

declare class PackedNormal { 
	/**
	 * X
	*/
	X: number;
	/**
	 * Y
	*/
	Y: number;
	/**
	 * Z
	*/
	Z: number;
	/**
	 * W
	*/
	W: number;
	clone() : PackedNormal;
	static C(Other: UObject): PackedNormal;
}

declare class PaintedVertex { 
	/**
	 * Position
	*/
	Position: Vector;
	/**
	 * Normal
	*/
	Normal: PackedNormal;
	/**
	 * Color
	*/
	Color: Color;
	clone() : PaintedVertex;
	static C(Other: UObject): PaintedVertex;
}

declare class StaticMeshComponentLODInfo { 
	/**
	 * Vertex data cached at the time this LOD was painted, if any
	*/
	PaintedVertices: PaintedVertex[];
	clone() : StaticMeshComponentLODInfo;
	static C(Other: UObject): StaticMeshComponentLODInfo;
}

declare class StreamingTextureBuildInfo { 
	/**
	 * The relative bounding box for this entry. The relative bounds is a bound equal or smaller than the component bounds and represent
	 * the merged LOD section bounds of all LOD section referencing the given texture. When the level transform is modified following
	 * a call to ApplyLevelTransform, this relative bound becomes deprecated as it was computed from the transform at build time.
	*/
	PackedRelativeBox: any;
	/**
	 * The level scope identifier of the texture. When building the texture streaming data, each level holds a list of all referred texture Guids.
	 * This is required to prevent loading textures on platforms which would not require the texture to be loaded, and is a consequence of the texture
	 * streaming build not being platform specific (the same streaming data is build for every platform target). Could also apply to quality level.
	*/
	TextureLevelIndex: number;
	/**
	 * The texel factor for this texture. This represent the world size a texture square holding with unit UVs.
	 * This value is a combination of the TexelFactor from the mesh and also the material scale.
	 * It does not take into consideration StreamingDistanceMultiplier, or texture group scale.
	*/
	TexelFactor: number;
	clone() : StreamingTextureBuildInfo;
	static C(Other: UObject): StreamingTextureBuildInfo;
}

declare class LightmassPrimitiveSettings { 
	/**
	 * If true, this object will be lit as if it receives light from both sides of its polygons.
	*/
	bUseTwoSidedLighting: boolean;
	/**
	 * If true, this object will only shadow indirect lighting.
	*/
	bShadowIndirectOnly: boolean;
	/**
	 * If true, allow using the emissive for static lighting.
	*/
	bUseEmissiveForStaticLighting: boolean;
	/**
	 * Typically the triangle normal is used for hemisphere gathering which prevents incorrect self-shadowing from artist-tweaked vertex normals.
	 * However in the case of foliage whose vertex normal has been setup to match the underlying terrain, gathering in the direction of the vertex normal is desired.
	*/
	bUseVertexNormalForHemisphereGather: boolean;
	/**
	 * Direct lighting falloff exponent for mesh area lights created from emissive areas on this primitive.
	*/
	EmissiveLightFalloffExponent: number;
	/**
	 * Direct lighting influence radius.
	 * The default is 0, which means the influence radius should be automatically generated based on the emissive light brightness.
	 * Values greater than 0 override the automatic method.
	*/
	EmissiveLightExplicitInfluenceRadius: number;
	/**
	 * Scales the emissive contribution of all materials applied to this object.
	*/
	EmissiveBoost: number;
	/**
	 * Scales the diffuse contribution of all materials applied to this object.
	*/
	DiffuseBoost: number;
	/**
	 * Fraction of samples taken that must be occluded in order to reach full occlusion.
	*/
	FullyOccludedSamplesFraction: number;
	clone() : LightmassPrimitiveSettings;
	static C(Other: UObject): LightmassPrimitiveSettings;
}

declare class ProcMeshVertex { 
	/**
	 * Vertex position
	*/
	Position: Vector;
	/**
	 * Vertex normal
	*/
	Normal: Vector;
	/**
	 * Vertex tangent
	*/
	Tangent: ProcMeshTangent;
	/**
	 * Vertex color
	*/
	Color: Color;
	/**
	 * Vertex texture co-ordinate
	*/
	UV0: Vector2D;
	clone() : ProcMeshVertex;
	static C(Other: UObject): ProcMeshVertex;
}

declare class ProcMeshSection { 
	/**
	 * Vertex buffer for this section
	*/
	ProcVertexBuffer: ProcMeshVertex[];
	/**
	 * Index buffer for this section
	*/
	ProcIndexBuffer: number[];
	/**
	 * Local bounding box of section
	*/
	SectionLocalBox: Box;
	/**
	 * Should we build collision data for triangles in this section
	*/
	bEnableCollision: boolean;
	/**
	 * Should we display this section
	*/
	bSectionVisible: boolean;
	clone() : ProcMeshSection;
	static C(Other: UObject): ProcMeshSection;
}

declare type EProcMeshSliceCapOption = string | symbol;
declare var EProcMeshSliceCapOption = { NoCap:'NoCap',CreateNewSectionForCap:'CreateNewSectionForCap',UseLastSectionForCap:'UseLastSectionForCap', };
declare class ProceduralMeshComponent extends MeshComponent { 
	/**
	 * Controls whether the complex (Per poly) geometry should be treated as 'simple' collision.
	 * Should be set to false if this component is going to be given simple collision and simulated.
	*/
	bUseComplexAsSimpleCollision: boolean;
	/**
	 * Collision data
	*/
	ProcMeshBodySetup: BodySetup;
	/**
	 * Array of sections of mesh
	*/
	ProcMeshSections: ProcMeshSection[];
	/**
	 * Convex shapes used for simple collision
	*/
	CollisionConvexElems: KConvexElem[];
	/**
	 * Local space bounds of mesh
	*/
	LocalBounds: BoxSphereBounds;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ProceduralMeshComponent;
	static Find(Outer: UObject, ResourceName: string): ProceduralMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ProceduralMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ProceduralMeshComponent;
	/**
	 * Updates a section of this procedural mesh component. This is faster than CreateMeshSection, but does not let you change topology. Collision info is also updated.
	 * @param  Vertices                        Vertex buffer of all vertex positions to use for this mesh section.
	 * @param  Normals                         Optional array of normal vectors for each vertex. If supplied, must be same length as Vertices array.
	 * @param  UV0                                     Optional array of texture co-ordinates for each vertex. If supplied, must be same length as Vertices array.
	 * @param  VertexColors            Optional array of colors for each vertex. If supplied, must be same length as Vertices array.
	 * @param  Tangents                        Optional array of tangent vector for each vertex. If supplied, must be same length as Vertices array.
	*/
	UpdateMeshSection(SectionIndex: number,Vertices: Vector[],Normals: Vector[],UV0: Vector2D[],VertexColors: LinearColor[],Tangents: ProcMeshTangent[]): void;
	/**
	 * Updates a section of this procedural mesh component. This is faster than CreateMeshSection, but does not let you change topology. Collision info is also updated.
	 * This function is deprecated for Blueprints because it uses the unsupported 'Color' type. Use new 'Create Mesh Section' function which uses LinearColor instead.
	 * @param  Vertices                        Vertex buffer of all vertex positions to use for this mesh section.
	 * @param  Normals                         Optional array of normal vectors for each vertex. If supplied, must be same length as Vertices array.
	 * @param  UV0                                     Optional array of texture co-ordinates for each vertex. If supplied, must be same length as Vertices array.
	 * @param  VertexColors            Optional array of colors for each vertex. If supplied, must be same length as Vertices array.
	 * @param  Tangents                        Optional array of tangent vector for each vertex. If supplied, must be same length as Vertices array.
	*/
	UpdateMeshSectionFColor(SectionIndex: number,Vertices: Vector[],Normals: Vector[],UV0: Vector2D[],VertexColors: Color[],Tangents: ProcMeshTangent[]): void;
	/**
	 * Control visibility of a particular section
	*/
	SetMeshSectionVisible(SectionIndex: number,bNewVisibility: boolean): void;
	/**
	 * Returns whether a particular section is currently visible
	*/
	IsMeshSectionVisible(SectionIndex: number): boolean;
	/**
	 * Returns number of sections currently created for this component
	*/
	GetNumSections(): number;
	/**
	 * Create/replace a section for this procedural mesh component.
	 * @param  SectionIndex            Index of the section to create or replace.
	 * @param  Vertices                        Vertex buffer of all vertex positions to use for this mesh section.
	 * @param  Triangles                       Index buffer indicating which vertices make up each triangle. Length must be a multiple of 3.
	 * @param  Normals                         Optional array of normal vectors for each vertex. If supplied, must be same length as Vertices array.
	 * @param  UV0                                     Optional array of texture co-ordinates for each vertex. If supplied, must be same length as Vertices array.
	 * @param  VertexColors            Optional array of colors for each vertex. If supplied, must be same length as Vertices array.
	 * @param  Tangents                        Optional array of tangent vector for each vertex. If supplied, must be same length as Vertices array.
	 * @param  bCreateCollision        Indicates whether collision should be created for this section. This adds significant cost.
	*/
	CreateMeshSection(SectionIndex: number,Vertices: Vector[],Triangles: number[],Normals: Vector[],UV0: Vector2D[],VertexColors: LinearColor[],Tangents: ProcMeshTangent[],bCreateCollision: boolean): void;
	/**
	 * Create/replace a section for this procedural mesh component.
	 * This function is deprecated for Blueprints because it uses the unsupported 'Color' type. Use new 'Create Mesh Section' function which uses LinearColor instead.
	 * @param  SectionIndex            Index of the section to create or replace.
	 * @param  Vertices                        Vertex buffer of all vertex positions to use for this mesh section.
	 * @param  Triangles                       Index buffer indicating which vertices make up each triangle. Length must be a multiple of 3.
	 * @param  Normals                         Optional array of normal vectors for each vertex. If supplied, must be same length as Vertices array.
	 * @param  UV0                                     Optional array of texture co-ordinates for each vertex. If supplied, must be same length as Vertices array.
	 * @param  VertexColors            Optional array of colors for each vertex. If supplied, must be same length as Vertices array.
	 * @param  Tangents                        Optional array of tangent vector for each vertex. If supplied, must be same length as Vertices array.
	 * @param  bCreateCollision        Indicates whether collision should be created for this section. This adds significant cost.
	*/
	CreateMeshSectionFColor(SectionIndex: number,Vertices: Vector[],Triangles: number[],Normals: Vector[],UV0: Vector2D[],VertexColors: Color[],Tangents: ProcMeshTangent[],bCreateCollision: boolean): void;
	/**
	 * Clear a section of the procedural mesh. Other sections do not change index.
	*/
	ClearMeshSection(SectionIndex: number): void;
	/**
	 * Add simple collision convex to this component
	*/
	ClearCollisionConvexMeshes(): void;
	/**
	 * Clear all mesh sections and reset to empty state
	*/
	ClearAllMeshSections(): void;
	/**
	 * Add simple collision convex to this component
	*/
	AddCollisionConvexMesh(ConvexVerts: Vector[]): void;
	static C(Other: UObject): ProceduralMeshComponent;
	/**
	 * Slice the ProceduralMeshComponent (including simple convex collision) using a plane. Optionally create 'cap' geometry.
	 * @param  InProcMesh                              ProceduralMeshComponent to slice
	 * @param  PlanePosition                   Point on the plane to use for slicing, in world space
	 * @param  PlaneNormal                             Normal of plane used for slicing. Geometry on the positive side of the plane will be kept.
	 * @param  bCreateOtherHalf                If true, an additional ProceduralMeshComponent (OutOtherHalfProcMesh) will be created using the other half of the sliced geometry
	 * @param  OutOtherHalfProcMesh    If bCreateOtherHalf is set, this is the new component created. Its owner will be the same as the supplied InProcMesh.
	 * @param  CapOption                               If and how to create 'cap' geometry on the slicing plane
	 * @param  CapMaterial                             If creating a new section for the cap, assign this material to that section
	*/
	SliceProceduralMesh(PlanePosition: Vector,PlaneNormal: Vector,bCreateOtherHalf: boolean,OutOtherHalfProcMesh?: ProceduralMeshComponent,CapOption?: EProcMeshSliceCapOption,CapMaterial?: MaterialInterface): {OutOtherHalfProcMesh: ProceduralMeshComponent};
	/**
	 * Slice the ProceduralMeshComponent (including simple convex collision) using a plane. Optionally create 'cap' geometry.
	 * @param  InProcMesh                              ProceduralMeshComponent to slice
	 * @param  PlanePosition                   Point on the plane to use for slicing, in world space
	 * @param  PlaneNormal                             Normal of plane used for slicing. Geometry on the positive side of the plane will be kept.
	 * @param  bCreateOtherHalf                If true, an additional ProceduralMeshComponent (OutOtherHalfProcMesh) will be created using the other half of the sliced geometry
	 * @param  OutOtherHalfProcMesh    If bCreateOtherHalf is set, this is the new component created. Its owner will be the same as the supplied InProcMesh.
	 * @param  CapOption                               If and how to create 'cap' geometry on the slicing plane
	 * @param  CapMaterial                             If creating a new section for the cap, assign this material to that section
	*/
	static SliceProceduralMesh(InProcMesh: ProceduralMeshComponent,PlanePosition: Vector,PlaneNormal: Vector,bCreateOtherHalf: boolean,OutOtherHalfProcMesh?: ProceduralMeshComponent,CapOption?: EProcMeshSliceCapOption,CapMaterial?: MaterialInterface): {OutOtherHalfProcMesh: ProceduralMeshComponent};
}

declare type EVertexPaintAxis = string | symbol;
declare var EVertexPaintAxis = { X:'X',Y:'Y',Z:'Z', };
declare class StaticMeshComponent extends MeshComponent { 
	/**
	 * If 0, auto-select LOD level. if >0, force to (ForcedLodModel-1).
	*/
	ForcedLodModel: number;
	/**
	 * LOD that was desired for rendering this StaticMeshComponent last frame.
	*/
	PreviousLODLevel: number;
	/**
	 * Whether to override the MinLOD setting of the static mesh asset with the MinLOD of this component.
	*/
	bOverrideMinLOD: boolean;
	/**
	 * Specifies the smallest LOD that will be used for this component.
	 * This is ignored if ForcedLodModel is enabled.
	*/
	MinLOD: number;
	/**
	 * Static Mesh
	*/
	StaticMesh: StaticMesh;
	/**
	 * If true, WireframeColorOverride will be used. If false, color is determined based on mobility and physics simulation settings
	*/
	bOverrideWireframeColor: boolean;
	/**
	 * Wireframe color to use if bOverrideWireframeColor is true
	*/
	WireframeColorOverride: Color;
	/**
	 * The section currently selected in the Editor. Used for highlighting
	*/
	SelectedEditorSection: number;
	/**
	 * Index of the section to preview. If set to INDEX_NONE, all section will be rendered. Used for isolating in Static Mesh Tool *
	*/
	SectionIndexPreview: number;
	/**
	 * If true, bForceNavigationObstacle flag will take priority over navigation data stored in StaticMesh
	*/
	bOverrideNavigationExport: boolean;
	/**
	 * Allows overriding navigation export behavior per component: full collisions or dynamic obstacle
	*/
	bForceNavigationObstacle: boolean;
	/**
	 * If true, mesh painting is disallowed on this instance. Set if vertex colors are overridden in a construction script.
	*/
	bDisallowMeshPaintPerInstance: boolean;
	/**
	 * Ignore this instance of this static mesh when calculating streaming information.
	 * This can be useful when doing things like applying character textures to static geometry,
	 * to avoid them using distance-based streaming.
	*/
	bIgnoreInstanceForTextureStreaming: boolean;
	/**
	 * Whether to override the lightmap resolution defined in the static mesh.
	*/
	bOverrideLightMapRes: boolean;
	/**
	 * Light map resolution to use on this component, used if bOverrideLightMapRes is true
	*/
	OverriddenLightMapRes: number;
	/**
	 * Allows adjusting the desired resolution of streaming textures that uses UV 0.  1.0 is the default, whereas a higher value increases the streamed-in resolution.
	*/
	StreamingDistanceMultiplier: number;
	/**
	 * Subdivision step size for static vertex lighting.
	*/
	SubDivisionStepSize: number;
	/**
	 * Whether to use subdivisions or just the triangle's vertices.
	*/
	bUseSubDivisions: boolean;
	/**
	 * Irrelevant Lights
	*/
	IrrelevantLights: Guid[];
	/**
	 * Static mesh LOD data.  Contains static lighting data along with instanced mesh vertex colors.
	*/
	LODData: StaticMeshComponentLODInfo[];
	/**
	 * The list of texture, bounds and scales. As computed in the texture streaming build process.
	*/
	StreamingTextureData: StreamingTextureBuildInfo[];
	/**
	 * Use the collision profile specified in the StaticMesh asset.
	*/
	bUseDefaultCollision: boolean;
	/**
	 * Derived data key of the static mesh, used to determine if an update from the source static mesh is required.
	*/
	StaticMeshDerivedDataKey: string;
	/**
	 * The Lightmass settings for this object.
	*/
	LightmassSettings: LightmassPrimitiveSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): StaticMeshComponent;
	static Find(Outer: UObject, ResourceName: string): StaticMeshComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): StaticMeshComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): StaticMeshComponent;
	/**
	 * Change the StaticMesh used by this instance.
	*/
	SetStaticMesh(NewMesh: StaticMesh): boolean;
	/**
	 * Set Forced Lod Model
	*/
	SetForcedLodModel(NewForcedLodModel: number): void;
	/**
	 * On Rep Static Mesh
	*/
	OnRep_StaticMesh(OldStaticMesh: StaticMesh): void;
	/**
	 * Get Local bounds
	*/
	GetLocalBounds(Min?: Vector,Max?: Vector): {Min: Vector, Max: Vector};
	static C(Other: UObject): StaticMeshComponent;
	/**
	 * Copy materials from StaticMeshComponent to ProceduralMeshComponent.
	*/
	CopyProceduralMeshFromStaticMeshComponent(LODIndex: number,ProcMeshComponent: ProceduralMeshComponent,bCreateCollision: boolean): void;
	/**
	 * Paints vertex colors on a mesh component lerping from the start to the end color along the specified axis.
	*/
	PaintVerticesLerpAlongAxis(StartColor: LinearColor,EndColor: LinearColor,Axis: EVertexPaintAxis,bConvertToSRGB: boolean): void;
	/**
	 * Paints vertex colors on a mesh component in a specified color.
	*/
	PaintVerticesSingleColor(FillColor: LinearColor,bConvertToSRGB: boolean): void;
	/**
	 * Removes vertex colors on a mesh component
	*/
	RemovePaintedVertices(): void;
	/**
	 * Copy materials from StaticMeshComponent to ProceduralMeshComponent.
	*/
	static CopyProceduralMeshFromStaticMeshComponent(StaticMeshComponent: StaticMeshComponent,LODIndex: number,ProcMeshComponent: ProceduralMeshComponent,bCreateCollision: boolean): void;
	/**
	 * Paints vertex colors on a mesh component lerping from the start to the end color along the specified axis.
	*/
	static PaintVerticesLerpAlongAxis(StaticMeshComponent: StaticMeshComponent,StartColor: LinearColor,EndColor: LinearColor,Axis: EVertexPaintAxis,bConvertToSRGB: boolean): void;
	/**
	 * Paints vertex colors on a mesh component in a specified color.
	*/
	static PaintVerticesSingleColor(StaticMeshComponent: StaticMeshComponent,FillColor: LinearColor,bConvertToSRGB: boolean): void;
	/**
	 * Removes vertex colors on a mesh component
	*/
	static RemovePaintedVertices(StaticMeshComponent: StaticMeshComponent): void;
}

declare class DefaultPawn extends Pawn { 
	/**
	 * Base turn rate, in deg/sec. Other scaling may affect final turn rate.
	*/
	BaseTurnRate: number;
	/**
	 * Base lookup rate, in deg/sec. Other scaling may affect final lookup rate.
	*/
	BaseLookUpRate: number;
	/**
	 * DefaultPawn movement component
	*/
	MovementComponent: PawnMovementComponent;
	/**
	 * Collision Component
	*/
	CollisionComponent: SphereComponent;
	/**
	 * Mesh Component
	*/
	MeshComponent: StaticMeshComponent;
	/**
	 * If true, adds default input bindings for movement and camera look.
	*/
	bAddDefaultMovementBindings: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DefaultPawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultPawn;
	/**
	 * Called via input to turn at a given rate.
	 * @param Rate  This is a normalized rate, i.e. 1.0 means 100% of desired turn rate
	*/
	TurnAtRate(Rate: number): void;
	/**
	 * Input callback on yaw (turn) input.
	*/
	Turn(Val: number): void;
	/**
	 * Input callback to move up in world space (or down if Val is negative).
	 * @param Val Amount of movement in the world up direction (or down if negative).
	 * @see APawn::AddMovementInput()
	*/
	MoveUp_World(Val: number): void;
	/**
	 * Input callback to strafe right in local space (or left if Val is negative).
	 * @param Val Amount of movement in the right direction (or left if negative).
	 * @see APawn::AddMovementInput()
	*/
	MoveRight(Val: number): void;
	/**
	 * Input callback to move forward in local space (or backward if Val is negative).
	 * @param Val Amount of movement in the forward direction (or backward if negative).
	 * @see APawn::AddMovementInput()
	*/
	MoveForward(Val: number): void;
	/**
	 * Called via input to look up at a given rate (or down if Rate is negative).
	 * @param Rate   This is a normalized rate, i.e. 1.0 means 100% of desired turn rate
	*/
	LookUpAtRate(Rate: number): void;
	/**
	 * Input callback on pitch (look up) input.
	*/
	LookUp(Val: number): void;
	static C(Other: UObject): DefaultPawn;
}

declare class SpectatorPawn extends DefaultPawn { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SpectatorPawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SpectatorPawn;
	static C(Other: UObject): SpectatorPawn;
}

declare type EControllerHand = string | symbol;
declare var EControllerHand = { Left:'Left',Right:'Right',Pad:'Pad',ExternalCamera:'ExternalCamera',Special_1:'Special_1',Special_2:'Special_2',Special_3:'Special_3',Special_4:'Special_4',Special_5:'Special_5',Special_6:'Special_6',Special_7:'Special_7',Special_8:'Special_8',Special_9:'Special_9', };
declare type EViewTargetBlendFunction = string | symbol;
declare var EViewTargetBlendFunction = { VTBlend_Linear:'VTBlend_Linear',VTBlend_Cubic:'VTBlend_Cubic',VTBlend_EaseIn:'VTBlend_EaseIn',VTBlend_EaseOut:'VTBlend_EaseOut',VTBlend_EaseInOut:'VTBlend_EaseInOut', };
declare class ViewTargetTransitionParams { 
	/**
	 * Total duration of blend to pending view target. 0 means no blending.
	*/
	BlendTime: number;
	/**
	 * Function to apply to the blend parameter.
	*/
	BlendFunction: EViewTargetBlendFunction;
	/**
	 * Exponent, used by certain blend functions to control the shape of the curve.
	*/
	BlendExp: number;
	/**
	 * If true, lock outgoing viewtarget to last frame's camera POV for the remainder of the blend.
	 * This is useful if you plan to teleport the old viewtarget, but don't want to affect the blend.
	*/
	bLockOutgoing: boolean;
	clone() : ViewTargetTransitionParams;
	static C(Other: UObject): ViewTargetTransitionParams;
}

declare class HapticFeedbackEffect_Base extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HapticFeedbackEffect_Base;
	static Find(Outer: UObject, ResourceName: string): HapticFeedbackEffect_Base;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HapticFeedbackEffect_Base;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HapticFeedbackEffect_Base;
	static C(Other: UObject): HapticFeedbackEffect_Base;
}

declare type EDynamicForceFeedbackAction = string | symbol;
declare var EDynamicForceFeedbackAction = { Start:'Start',Update:'Update',Stop:'Stop', };
declare class LatentActionInfo { 
	/**
	 * The resume point within the function to execute
	*/
	Linkage: number;
	/**
	 * the UUID for this action
	*/
	UUID: number;
	/**
	 * The function to execute.
	*/
	ExecutionFunction: string;
	/**
	 * Object to execute the function on.
	*/
	CallbackTarget: UObject;
	clone() : LatentActionInfo;
	static C(Other: UObject): LatentActionInfo;
}

declare type EObjectTypeQuery = string | symbol;
declare var EObjectTypeQuery = { ObjectTypeQuery1:'ObjectTypeQuery1',ObjectTypeQuery2:'ObjectTypeQuery2',ObjectTypeQuery3:'ObjectTypeQuery3',ObjectTypeQuery4:'ObjectTypeQuery4',ObjectTypeQuery5:'ObjectTypeQuery5',ObjectTypeQuery6:'ObjectTypeQuery6',ObjectTypeQuery7:'ObjectTypeQuery7',ObjectTypeQuery8:'ObjectTypeQuery8',ObjectTypeQuery9:'ObjectTypeQuery9',ObjectTypeQuery10:'ObjectTypeQuery10',ObjectTypeQuery11:'ObjectTypeQuery11',ObjectTypeQuery12:'ObjectTypeQuery12',ObjectTypeQuery13:'ObjectTypeQuery13',ObjectTypeQuery14:'ObjectTypeQuery14',ObjectTypeQuery15:'ObjectTypeQuery15',ObjectTypeQuery16:'ObjectTypeQuery16',ObjectTypeQuery17:'ObjectTypeQuery17',ObjectTypeQuery18:'ObjectTypeQuery18',ObjectTypeQuery19:'ObjectTypeQuery19',ObjectTypeQuery20:'ObjectTypeQuery20',ObjectTypeQuery21:'ObjectTypeQuery21',ObjectTypeQuery22:'ObjectTypeQuery22',ObjectTypeQuery23:'ObjectTypeQuery23',ObjectTypeQuery24:'ObjectTypeQuery24',ObjectTypeQuery25:'ObjectTypeQuery25',ObjectTypeQuery26:'ObjectTypeQuery26',ObjectTypeQuery27:'ObjectTypeQuery27',ObjectTypeQuery28:'ObjectTypeQuery28',ObjectTypeQuery29:'ObjectTypeQuery29',ObjectTypeQuery30:'ObjectTypeQuery30',ObjectTypeQuery31:'ObjectTypeQuery31',ObjectTypeQuery32:'ObjectTypeQuery32',ObjectTypeQuery_MAX:'ObjectTypeQuery_MAX', };
declare type ETraceTypeQuery = string | symbol;
declare var ETraceTypeQuery = { TraceTypeQuery1:'TraceTypeQuery1',TraceTypeQuery2:'TraceTypeQuery2',TraceTypeQuery3:'TraceTypeQuery3',TraceTypeQuery4:'TraceTypeQuery4',TraceTypeQuery5:'TraceTypeQuery5',TraceTypeQuery6:'TraceTypeQuery6',TraceTypeQuery7:'TraceTypeQuery7',TraceTypeQuery8:'TraceTypeQuery8',TraceTypeQuery9:'TraceTypeQuery9',TraceTypeQuery10:'TraceTypeQuery10',TraceTypeQuery11:'TraceTypeQuery11',TraceTypeQuery12:'TraceTypeQuery12',TraceTypeQuery13:'TraceTypeQuery13',TraceTypeQuery14:'TraceTypeQuery14',TraceTypeQuery15:'TraceTypeQuery15',TraceTypeQuery16:'TraceTypeQuery16',TraceTypeQuery17:'TraceTypeQuery17',TraceTypeQuery18:'TraceTypeQuery18',TraceTypeQuery19:'TraceTypeQuery19',TraceTypeQuery20:'TraceTypeQuery20',TraceTypeQuery21:'TraceTypeQuery21',TraceTypeQuery22:'TraceTypeQuery22',TraceTypeQuery23:'TraceTypeQuery23',TraceTypeQuery24:'TraceTypeQuery24',TraceTypeQuery25:'TraceTypeQuery25',TraceTypeQuery26:'TraceTypeQuery26',TraceTypeQuery27:'TraceTypeQuery27',TraceTypeQuery28:'TraceTypeQuery28',TraceTypeQuery29:'TraceTypeQuery29',TraceTypeQuery30:'TraceTypeQuery30',TraceTypeQuery31:'TraceTypeQuery31',TraceTypeQuery32:'TraceTypeQuery32',TraceTypeQuery_MAX:'TraceTypeQuery_MAX', };
declare type ETravelType = string | symbol;
declare var ETravelType = { TRAVEL_Absolute:'TRAVEL_Absolute',TRAVEL_Partial:'TRAVEL_Partial',TRAVEL_Relative:'TRAVEL_Relative', };
declare type EAudioOutputTarget = string | symbol;
declare var EAudioOutputTarget = { Speaker:'Speaker',Controller:'Controller',ControllerFallbackToSpeaker:'ControllerFallbackToSpeaker', };
declare class SoundClassProperties { 
	/**
	 * Volume multiplier.
	*/
	Volume: number;
	/**
	 * Pitch multiplier.
	*/
	Pitch: number;
	/**
	 * The amount of stereo sounds to bleed to the rear speakers
	*/
	StereoBleed: number;
	/**
	 * The amount of a sound to bleed to the LFE channel
	*/
	LFEBleed: number;
	/**
	 * Voice center channel volume - Not a multiplier (no propagation)
	*/
	VoiceCenterChannelVolume: number;
	/**
	 * Volume of the radio filter effect
	*/
	RadioFilterVolume: number;
	/**
	 * Volume at which the radio filter kicks in
	*/
	RadioFilterVolumeThreshold: number;
	/**
	 * Sound mix voice - whether to apply audio effects
	*/
	bApplyEffects: boolean;
	/**
	 * Whether to artificially prioritise the component to play
	*/
	bAlwaysPlay: boolean;
	/**
	 * Whether or not this sound plays when the game is paused in the UI
	*/
	bIsUISound: boolean;
	/**
	 * Whether or not this is music (propagates only if parent is true)
	*/
	bIsMusic: boolean;
	/**
	 * Whether or not this sound class has reverb applied
	*/
	bReverb: boolean;
	/**
	 * Whether or not this sound class forces sounds to the center channel
	*/
	bCenterChannelOnly: boolean;
	/**
	 * Whether the Interior/Exterior volume and LPF modifiers should be applied
	*/
	bApplyAmbientVolumes: boolean;
	/**
	 * Which output target the sound should be played through
	*/
	OutputTarget: EAudioOutputTarget;
	clone() : SoundClassProperties;
	static C(Other: UObject): SoundClassProperties;
}

declare class AudioEQEffect { 
	/**
	 * Center frequency in Hz for band 0
	*/
	FrequencyCenter0: number;
	/**
	 * Boost/cut of band 0
	*/
	Gain0: number;
	/**
	 * Bandwidth of band 0. Region is center frequency +/- Bandwidth /2
	*/
	Bandwidth0: number;
	/**
	 * Center frequency in Hz for band 1
	*/
	FrequencyCenter1: number;
	/**
	 * Boost/cut of band 1
	*/
	Gain1: number;
	/**
	 * Bandwidth of band 1. Region is center frequency +/- Bandwidth /2
	*/
	Bandwidth1: number;
	/**
	 * Center frequency in Hz for band 2
	*/
	FrequencyCenter2: number;
	/**
	 * Boost/cut of band 2
	*/
	Gain2: number;
	/**
	 * Bandwidth of band 2. Region is center frequency +/- Bandwidth /2
	*/
	Bandwidth2: number;
	/**
	 * Center frequency in Hz for band 3
	*/
	FrequencyCenter3: number;
	/**
	 * Boost/cut of band 3
	*/
	Gain3: number;
	/**
	 * Bandwidth of band 3. Region is center frequency +/- Bandwidth /2
	*/
	Bandwidth3: number;
	clone() : AudioEQEffect;
	static C(Other: UObject): AudioEQEffect;
}

declare class SoundClassAdjuster { 
	/**
	 * The sound class this adjuster affects.
	*/
	SoundClassObject: SoundClass;
	/**
	 * A multiplier applied to the volume.
	*/
	VolumeAdjuster: number;
	/**
	 * A multiplier applied to the pitch.
	*/
	PitchAdjuster: number;
	/**
	 * Set to true to apply this adjuster to all children of the sound class.
	*/
	bApplyToChildren: boolean;
	/**
	 * A multiplier applied to VoiceCenterChannelVolume.
	*/
	VoiceCenterChannelVolumeAdjuster: number;
	clone() : SoundClassAdjuster;
	static C(Other: UObject): SoundClassAdjuster;
}

declare class SoundMix extends UObject { 
	/**
	 * Whether to apply the EQ effect
	*/
	bApplyEQ: boolean;
	/**
	 * EQPriority
	*/
	EQPriority: number;
	/**
	 * EQSettings
	*/
	EQSettings: AudioEQEffect;
	/**
	 * Array of changes to be applied to groups.
	*/
	SoundClassEffects: SoundClassAdjuster[];
	/**
	 * Initial delay in seconds before the the mix is applied.
	*/
	InitialDelay: number;
	/**
	 * Time taken in seconds for the mix to fade in.
	*/
	FadeInTime: number;
	/**
	 * Duration of mix, negative means it will be applied until another mix is set.
	*/
	Duration: number;
	/**
	 * Time taken in seconds for the mix to fade out.
	*/
	FadeOutTime: number;
	/**
	 * Transient property used to trigger real-time updates of the active EQ filter for editor previewing
	*/
	bChanged: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundMix;
	static Find(Outer: UObject, ResourceName: string): SoundMix;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundMix;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundMix;
	static C(Other: UObject): SoundMix;
}

declare class PassiveSoundMixModifier { 
	/**
	 * The SoundMix to activate
	*/
	SoundMix: SoundMix;
	/**
	 * Minimum volume level required to activate SoundMix. Below this value the SoundMix will not be active.
	*/
	MinVolumeThreshold: number;
	/**
	 * Maximum volume level required to activate SoundMix. Above this value the SoundMix will not be active.
	*/
	MaxVolumeThreshold: number;
	clone() : PassiveSoundMixModifier;
	static C(Other: UObject): PassiveSoundMixModifier;
}

declare class SoundClass extends UObject { 
	/**
	 * Configurable properties like volume and priority.
	*/
	Properties: SoundClassProperties;
	/**
	 * Child Classes
	*/
	ChildClasses: SoundClass[];
	/**
	 * SoundMix Modifiers to activate automatically when a sound of this class is playing.
	*/
	PassiveSoundMixModifiers: PassiveSoundMixModifier[];
	/**
	 * Parent Class
	*/
	ParentClass: SoundClass;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundClass;
	static Find(Outer: UObject, ResourceName: string): SoundClass;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundClass;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundClass;
	static C(Other: UObject): SoundClass;
}

declare type EMaxConcurrentResolutionRule = string | symbol;
declare var EMaxConcurrentResolutionRule = { PreventNew:'PreventNew',StopOldest:'StopOldest',StopFarthestThenPreventNew:'StopFarthestThenPreventNew',StopFarthestThenOldest:'StopFarthestThenOldest',StopLowestPriority:'StopLowestPriority',StopQuietest:'StopQuietest',StopLowestPriorityThenPreventNew:'StopLowestPriorityThenPreventNew', };
declare class SoundConcurrencySettings { 
	/**
	 * The max number of allowable concurrent active voices for voices playing in this concurrency group.
	*/
	MaxCount: number;
	/**
	 * Whether or not to limit the concurrency to per sound owner (i.e. the actor that plays the sound). If the sound doesn't have an owner, it falls back to global concurrency.
	*/
	bLimitToOwner: boolean;
	/**
	 * Which concurrency resolution policy to use if max voice count is reached.
	*/
	ResolutionRule: EMaxConcurrentResolutionRule;
	/**
	 * The amount of attenuation to apply to older voice instances in this concurrency group. This reduces volume of older voices in a concurrency group as new voices play.
	 * AppliedVolumeScale = Math.Pow(DuckingScale, VoiceGeneration)
	*/
	VolumeScale: number;
	clone() : SoundConcurrencySettings;
	static C(Other: UObject): SoundConcurrencySettings;
}

declare class SoundConcurrency extends UObject { 
	/**
	 * Concurrency
	*/
	Concurrency: SoundConcurrencySettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundConcurrency;
	static Find(Outer: UObject, ResourceName: string): SoundConcurrency;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundConcurrency;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundConcurrency;
	static C(Other: UObject): SoundConcurrency;
}

declare type ESoundDistanceModel = string | symbol;
declare var ESoundDistanceModel = { ATTENUATION_Linear:'ATTENUATION_Linear',ATTENUATION_Logarithmic:'ATTENUATION_Logarithmic',ATTENUATION_Inverse:'ATTENUATION_Inverse',ATTENUATION_LogReverse:'ATTENUATION_LogReverse',ATTENUATION_NaturalSound:'ATTENUATION_NaturalSound',ATTENUATION_Custom:'ATTENUATION_Custom', };
declare type ESoundDistanceCalc = string | symbol;
declare var ESoundDistanceCalc = { SOUNDDISTANCE_Normal:'SOUNDDISTANCE_Normal',SOUNDDISTANCE_InfiniteXYPlane:'SOUNDDISTANCE_InfiniteXYPlane',SOUNDDISTANCE_InfiniteXZPlane:'SOUNDDISTANCE_InfiniteXZPlane',SOUNDDISTANCE_InfiniteYZPlane:'SOUNDDISTANCE_InfiniteYZPlane', };
declare type EAttenuationShape = string | symbol;
declare var EAttenuationShape = { Sphere:'Sphere',Capsule:'Capsule',Box:'Box',Cone:'Cone', };
declare type ESoundSpatializationAlgorithm = string | symbol;
declare var ESoundSpatializationAlgorithm = { SPATIALIZATION_Default:'SPATIALIZATION_Default',SPATIALIZATION_HRTF:'SPATIALIZATION_HRTF', };
declare class AttenuationSettings { 
	/**
	 * Enable attenuation via volume.
	*/
	bAttenuate: boolean;
	/**
	 * Enable the source to be positioned in 3D.
	*/
	bSpatialize: boolean;
	/**
	 * Enable attenuation via low pass filter.
	*/
	bAttenuateWithLPF: boolean;
	/**
	 * Whether or not listener-focus calculations are enabled for this attenuation.
	*/
	bEnableListenerFocus: boolean;
	/**
	 * Whether or not to enable line-of-sight occlusion checking for the sound that plays in this audio component.
	*/
	bEnableOcclusion: boolean;
	/**
	 * Whether or not to enable complex geometry occlusion checks.
	*/
	bUseComplexCollisionForOcclusion: boolean;
	/**
	 * The type of volume versus distance algorithm to use for the attenuation model.
	*/
	DistanceAlgorithm: ESoundDistanceModel;
	/**
	 * Custom Attenuation Curve
	*/
	CustomAttenuationCurve: RuntimeFloatCurve;
	/**
	 * Distance Type
	*/
	DistanceType: ESoundDistanceCalc;
	/**
	 * The shape of the attenuation volume.
	*/
	AttenuationShape: EAttenuationShape;
	/**
	 * The volume at maximum distance in deciBels.
	*/
	dBAttenuationAtMax: number;
	/**
	 * At what distance we start treating the sound source as spatialized
	*/
	OmniRadius: number;
	/**
	 * The distance between left and right stereo channels when stereo assets spatialized.
	*/
	StereoSpread: number;
	/**
	 * Which spatialization algorithm to use if spatializing mono sources.
	*/
	SpatializationAlgorithm: ESoundSpatializationAlgorithm;
	/**
	 * Radius Min
	*/
	RadiusMin: number;
	/**
	 * Radius Max
	*/
	RadiusMax: number;
	/**
	 * The dimensions to use for the attenuation shape. Interpretation of the values differ per shape.
	 *          Sphere  - X is Sphere Radius. Y and Z are unused
	 *          Capsule - X is Capsule Half Height, Y is Capsule Radius, Z is unused
	 *          Box     - X, Y, and Z are the Box's dimensions
	 *          Cone    - X is Cone Radius, Y is Cone Angle, Z is Cone Falloff Angle
	*/
	AttenuationShapeExtents: Vector;
	/**
	 * The distance back from the sound's origin to begin the cone when using the cone attenuation shape.
	*/
	ConeOffset: number;
	/**
	 * The distance over which falloff occurs.
	*/
	FalloffDistance: number;
	/**
	 * The range at which to start applying a low pass filter.
	*/
	LPFRadiusMin: number;
	/**
	 * The range at which to apply the maximum amount of low pass filter.
	*/
	LPFRadiusMax: number;
	/**
	 * The Frequency in hertz at which to set the LPF when the sound is at LPFRadiusMin. (defaults to bypass)
	*/
	LPFFrequencyAtMin: number;
	/**
	 * The Frequency in hertz at which to set the LPF when the sound is at LPFRadiusMax.
	*/
	LPFFrequencyAtMax: number;
	/**
	 * Azimuth angle (in degrees) relative to the listener forward vector which defines the focus region of sounds. Sounds playing at an angle less than this will be in focus.
	*/
	FocusAzimuth: number;
	/**
	 * Azimuth angle (in degrees) relative to the listener forward vector which defines the non-focus region of sounds. Sounds playing at an angle greater than this will be out of focus.
	*/
	NonFocusAzimuth: number;
	/**
	 * Amount to scale the distance calculation of sounds that are in-focus. Can be used to make in-focus sounds appear to be closer or further away than they actually are.
	*/
	FocusDistanceScale: number;
	/**
	 * Amount to scale the distance calculation of sounds that are not in-focus. Can be used to make in-focus sounds appear to be closer or further away than they actually are.
	*/
	NonFocusDistanceScale: number;
	/**
	 * Amount to scale the priority of sounds that are in focus. Can be used to boost the priority of sounds that are in focus.
	*/
	FocusPriorityScale: number;
	/**
	 * Amount to scale the priority of sounds that are not in-focus. Can be used to reduce the priority of sounds that are not in focus.
	*/
	NonFocusPriorityScale: number;
	/**
	 * Amount to attenuate sounds that are in focus. Can be overridden at the sound-level.
	*/
	FocusVolumeAttenuation: number;
	/**
	 * Amount to attenuate sounds that are not in focus. Can be overridden at the sound-level.
	*/
	NonFocusVolumeAttenuation: number;
	/**
	 * Which trace channel to use for audio occlusion checks.
	*/
	OcclusionTraceChannel: ECollisionChannel;
	/**
	 * The low pass filter frequency (in hertz) to apply if the sound playing in this audio component is occluded. This will override the frequency set in LowPassFilterFrequency. A frequency of 0.0 is the device sample rate and will bypass the filter.
	*/
	OcclusionLowPassFilterFrequency: number;
	/**
	 * The amount of volume attenuation to apply to sounds which are occluded.
	*/
	OcclusionVolumeAttenuation: number;
	/**
	 * The amount of time in seconds to interpolate to the target OcclusionLowPassFilterFrequency when a sound is occluded.
	*/
	OcclusionInterpolationTime: number;
	clone() : AttenuationSettings;
	static C(Other: UObject): AttenuationSettings;
}

declare class SoundAttenuation extends UObject { 
	/**
	 * Attenuation
	*/
	Attenuation: AttenuationSettings;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundAttenuation;
	static Find(Outer: UObject, ResourceName: string): SoundAttenuation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundAttenuation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundAttenuation;
	static C(Other: UObject): SoundAttenuation;
}

declare type ESoundGroup = string | symbol;
declare var ESoundGroup = { SOUNDGROUP_Default:'SOUNDGROUP_Default',SOUNDGROUP_Effects:'SOUNDGROUP_Effects',SOUNDGROUP_UI:'SOUNDGROUP_UI',SOUNDGROUP_Music:'SOUNDGROUP_Music',SOUNDGROUP_Voice:'SOUNDGROUP_Voice',SOUNDGROUP_GameSoundGroup1:'SOUNDGROUP_GameSoundGroup1',SOUNDGROUP_GameSoundGroup2:'SOUNDGROUP_GameSoundGroup2',SOUNDGROUP_GameSoundGroup3:'SOUNDGROUP_GameSoundGroup3',SOUNDGROUP_GameSoundGroup4:'SOUNDGROUP_GameSoundGroup4',SOUNDGROUP_GameSoundGroup5:'SOUNDGROUP_GameSoundGroup5',SOUNDGROUP_GameSoundGroup6:'SOUNDGROUP_GameSoundGroup6',SOUNDGROUP_GameSoundGroup7:'SOUNDGROUP_GameSoundGroup7',SOUNDGROUP_GameSoundGroup8:'SOUNDGROUP_GameSoundGroup8',SOUNDGROUP_GameSoundGroup9:'SOUNDGROUP_GameSoundGroup9',SOUNDGROUP_GameSoundGroup10:'SOUNDGROUP_GameSoundGroup10',SOUNDGROUP_GameSoundGroup11:'SOUNDGROUP_GameSoundGroup11',SOUNDGROUP_GameSoundGroup12:'SOUNDGROUP_GameSoundGroup12',SOUNDGROUP_GameSoundGroup13:'SOUNDGROUP_GameSoundGroup13',SOUNDGROUP_GameSoundGroup14:'SOUNDGROUP_GameSoundGroup14',SOUNDGROUP_GameSoundGroup15:'SOUNDGROUP_GameSoundGroup15',SOUNDGROUP_GameSoundGroup16:'SOUNDGROUP_GameSoundGroup16',SOUNDGROUP_GameSoundGroup17:'SOUNDGROUP_GameSoundGroup17',SOUNDGROUP_GameSoundGroup18:'SOUNDGROUP_GameSoundGroup18',SOUNDGROUP_GameSoundGroup19:'SOUNDGROUP_GameSoundGroup19',SOUNDGROUP_GameSoundGroup20:'SOUNDGROUP_GameSoundGroup20', };
declare class SubtitleCue { 
	/**
	 * The text to appear in the subtitle.
	*/
	Text: string;
	/**
	 * The time at which the subtitle is to be displayed, in seconds relative to the beginning of the line.
	*/
	Time: number;
	clone() : SubtitleCue;
	static C(Other: UObject): SubtitleCue;
}

declare class LocalizedSubtitle { 
	/**
	 * The 3-letter language for this subtitle
	*/
	LanguageExt: string;
	/**
	 * Subtitle cues.  If empty, use SoundNodeWave's SpokenText as the subtitle.  Will often be empty,
	 * as the contents of the subtitle is commonly identical to what is spoken.
	*/
	Subtitles: SubtitleCue[];
	/**
	 * true if this sound is considered to contain mature content.
	*/
	bMature: boolean;
	/**
	 * true if the subtitles have been split manually.
	*/
	bManualWordWrap: boolean;
	/**
	 * true if the subtitles should be displayed one line at a time.
	*/
	bSingleLine: boolean;
	clone() : LocalizedSubtitle;
	static C(Other: UObject): LocalizedSubtitle;
}

declare class SoundWave extends SoundBase { 
	/**
	 * Platform agnostic compression quality. 1..100 with 1 being best compression and 100 being best quality.
	*/
	CompressionQuality: number;
	/**
	 * If set, when played directly (not through a sound cue) the wave will be played looping.
	*/
	bLooping: boolean;
	/**
	 * Whether this sound can be streamed to avoid increased memory usage
	*/
	bStreaming: boolean;
	/**
	 * Priority of this sound when streaming (lower priority streams may not always play)
	*/
	StreamingPriority: number;
	/**
	 * If set to true if this sound is considered to contain mature/adult content.
	*/
	bMature: boolean;
	/**
	 * If set to true will disable automatic generation of line breaks - use if the subtitles have been split manually.
	*/
	bManualWordWrap: boolean;
	/**
	 * If set to true the subtitles display as a sequence of single lines as opposed to multiline.
	*/
	bSingleLine: boolean;
	/**
	 * Allows sound to play at 0 volume, otherwise will stop the sound when the sound is silent.
	*/
	bVirtualizeWhenSilent: boolean;
	/**
	 * Sound Group
	*/
	SoundGroup: ESoundGroup;
	/**
	 * A localized version of the text that is actually spoken phonetically in the audio.
	*/
	SpokenText: string;
	/**
	 * The priority of the subtitle.
	*/
	SubtitlePriority: number;
	/**
	 * Playback volume of sound 0 to 1 - Default is 1.0.
	*/
	Volume: number;
	/**
	 * Playback pitch for sound - Minimum is 0.4, maximum is 2.0 - it is a simple linear multiplier to the SampleRate.
	*/
	Pitch: number;
	/**
	 * Number of channels of multichannel data; 1 or 2 for regular mono and stereo files
	*/
	NumChannels: number;
	/**
	 * Cached sample rate for displaying in the tools
	*/
	SampleRate: number;
	/**
	 * Offsets into the bulk data for the source wav data
	*/
	ChannelOffsets: number[];
	/**
	 * Sizes of the bulk data for the source wav data
	*/
	ChannelSizes: number[];
	/**
	 * Size of RawPCMData, or what RawPCMData would be if the sound was fully decompressed
	*/
	RawPCMDataSize: number;
	/**
	 * Subtitle cues.  If empty, use SpokenText as the subtitle.  Will often be empty,
	 * as the contents of the subtitle is commonly identical to what is spoken.
	*/
	Subtitles: SubtitleCue[];
	/**
	 * Provides contextual information for the sound to the translator.
	*/
	Comment: string;
	/**
	 * The array of the subtitles for each language. Generated at cook time.
	*/
	LocalizedSubtitles: LocalizedSubtitle[];
	/**
	 * Source File Path
	*/
	SourceFilePath: string;
	/**
	 * Source File Timestamp
	*/
	SourceFileTimestamp: string;
	/**
	 * Asset Import Data
	*/
	AssetImportData: AssetImportData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundWave;
	static Find(Outer: UObject, ResourceName: string): SoundWave;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundWave;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundWave;
	static C(Other: UObject): SoundWave;
}

declare class AudioComponentParam { 
	/**
	 * Name of the parameter
	*/
	ParamName: string;
	/**
	 * Value of the parameter when used as a float
	*/
	FloatParam: number;
	/**
	 * Value of the parameter when used as a boolean
	*/
	BoolParam: boolean;
	/**
	 * Value of the parameter when used as an integer
	*/
	IntParam: number;
	/**
	 * Value of the parameter when used as a sound wave
	*/
	SoundWaveParam: SoundWave;
	clone() : AudioComponentParam;
	static C(Other: UObject): AudioComponentParam;
}

declare class AudioComponent extends SceneComponent { 
	/**
	 * The sound to be played
	*/
	Sound: SoundBase;
	/**
	 * Array of per-instance parameters for this AudioComponent.
	*/
	InstanceParameters: AudioComponentParam[];
	/**
	 * Optional sound group this AudioComponent belongs to
	*/
	SoundClassOverride: SoundClass;
	/**
	 * Auto destroy this component on completion
	*/
	bAutoDestroy: boolean;
	/**
	 * Stop sound when owner is destroyed
	*/
	bStopWhenOwnerDestroyed: boolean;
	/**
	 * Whether the wave instances should remain active if they're dropped by the prioritization code. Useful for e.g. vehicle sounds that shouldn't cut out.
	*/
	bShouldRemainActiveIfDropped: boolean;
	/**
	 * Is this audio component allowed to be spatialized?
	*/
	bAllowSpatialization: boolean;
	/**
	 * Should the Attenuation Settings asset be used (false) or should the properties set directly on the component be used for attenuation properties
	*/
	bOverrideAttenuation: boolean;
	/**
	 * Whether or not this sound plays when the game is paused in the UI
	*/
	bIsUISound: boolean;
	/**
	 * Whether or not to apply a low-pass filter to the sound that plays in this audio component.
	*/
	bEnableLowPassFilter: boolean;
	/**
	 * Override Priority
	*/
	bOverridePriority: boolean;
	/**
	 * The lower bound to use when randomly determining a pitch multiplier
	*/
	PitchModulationMin: number;
	/**
	 * The upper bound to use when randomly determining a pitch multiplier
	*/
	PitchModulationMax: number;
	/**
	 * The lower bound to use when randomly determining a volume multiplier
	*/
	VolumeModulationMin: number;
	/**
	 * The upper bound to use when randomly determining a volume multiplier
	*/
	VolumeModulationMax: number;
	/**
	 * A volume multiplier to apply to sounds generated by this component
	*/
	VolumeMultiplier: number;
	/**
	 * A priority value that is used for sounds that play on this component that scales against final output volume.
	*/
	Priority: number;
	/**
	 * Volume Weighted Priority Scale
	*/
	VolumeWeightedPriorityScale: number;
	/**
	 * A pitch multiplier to apply to sounds generated by this component
	*/
	PitchMultiplier: number;
	/**
	 * High Frequency Gain Multiplier
	*/
	HighFrequencyGainMultiplier: number;
	/**
	 * The frequency of the lowpass filter (in hertz) to apply to this voice. A frequency of 0.0 is the device sample rate and will bypass the filter.
	*/
	LowPassFilterFrequency: number;
	/**
	 * If bOverrideSettings is false, the asset to use to determine attenuation properties for sounds generated by this component
	*/
	AttenuationSettings: SoundAttenuation;
	/**
	 * If bOverrideSettings is true, the attenuation properties to use for sounds generated by this component
	*/
	AttenuationOverrides: AttenuationSettings;
	/**
	 * What sound concurrency to use for sounds generated by this audio component
	*/
	ConcurrencySettings: SoundConcurrency;
	/**
	 * called when we finish playing audio, either because it played to completion or because a Stop() call turned it off early
	*/
	OnAudioFinished: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Called when subtitles are sent to the SubtitleManager.  Set this delegate if you want to hijack the subtitles for other purposes
	*/
	OnQueueSubtitles: UnrealEngineDelegate<(Subtitles: SubtitleCue[], CueDuration: number) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AudioComponent;
	static Find(Outer: UObject, ResourceName: string): AudioComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AudioComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AudioComponent;
	/**
	 * Stop an audio component playing its sound cue, issue any delegates if needed
	*/
	Stop(): void;
	/**
	 * Set a sound wave instance parameter for use in sound cues played by this audio component
	*/
	SetWaveParameter(InName: string,InWave: SoundWave): void;
	/**
	 * Set a new volume multiplier
	*/
	SetVolumeMultiplier(NewVolumeMultiplier: number): void;
	/**
	 * Set whether sounds generated by this audio component should be considered UI sounds
	*/
	SetUISound(bInUISound: boolean): void;
	/**
	 * Set what sound is played by this component
	*/
	SetSound(NewSound: SoundBase): void;
	/**
	 * Set a new pitch multiplier
	*/
	SetPitchMultiplier(NewPitchMultiplier: number): void;
	/**
	 * Set an integer instance parameter for use in sound cues played by this audio component
	*/
	SetIntegerParameter(InName: string,InInt: number): void;
	/**
	 * Set a float instance parameter for use in sound cues played by this audio component
	*/
	SetFloatParameter(InName: string,InFloat: number): void;
	/**
	 * Set a boolean instance parameter for use in sound cues played by this audio component
	*/
	SetBooleanParameter(InName: string,InBool: boolean): void;
	/**
	 * Start a sound playing on an audio component
	*/
	Play(StartTime: number): void;
	/**
	 * @return true if this component is currently playing a SoundCue.
	*/
	IsPlaying(): boolean;
	/**
	 * This is used in place of "stop" when it is desired to fade the volume of the sound before stopping.
	 * If FadeTime is 0.0, this is the same as calling Stop().
	 * If FadeTime is > 0.0, this will adjust the volume multiplier to FadeVolumeLevel over FadeInTime seconds
	 * and then stop the sound.
	 * @param FadeOutDuration how long it should take to reach the FadeVolumeLevel
	 * @param FadeVolumeLevel the percentage of the AudioComponents's calculated volume in which to fade to
	*/
	FadeOut(FadeOutDuration: number,FadeVolumeLevel: number): void;
	/**
	 * This can be used in place of "play" when it is desired to fade in the sound over time.
	 * If FadeTime is 0.0, the change in volume is instant.
	 * If FadeTime is > 0.0, the multiplier will be increased from 0 to FadeVolumeLevel over FadeIn seconds.
	 * @param FadeInDuration how long it should take to reach the FadeVolumeLevel
	 * @param FadeVolumeLevel the percentage of the AudioComponents's calculated volume to fade to
	*/
	FadeIn(FadeInDuration: number,FadeVolumeLevel: number,StartTime: number): void;
	/**
	 * BP Get Attenuation Settings to Apply
	*/
	GetAttenuationSettingsToApply(OutAttenuationSettings?: AttenuationSettings): {OutAttenuationSettings: AttenuationSettings, $: boolean};
	/**
	 * This will allow one to adjust the volume of an AudioComponent on the fly
	*/
	AdjustVolume(AdjustVolumeDuration: number,AdjustVolumeLevel: number): void;
	/**
	 * Modify the attenuation settings of the audio component
	*/
	AdjustAttenuation(InAttenuationSettings: AttenuationSettings): void;
	static C(Other: UObject): AudioComponent;
}

declare class SoundBase extends UObject { 
	/**
	 * Sound class this sound belongs to
	*/
	SoundClassObject: SoundClass;
	/**
	 * When "stat sounds -debug" has been specified, draw this sound's attenuation shape when the sound is audible. For debugging purpose only.
	*/
	bDebug: boolean;
	/**
	 * Override Concurrency
	*/
	bOverrideConcurrency: boolean;
	/**
	 * Ignore Focus
	*/
	bIgnoreFocus: boolean;
	/**
	 * If bOverridePlayback is false, the sound concurrency settings to use for this sound.
	*/
	SoundConcurrencySettings: SoundConcurrency;
	/**
	 * If bOverridePlayback is true, concurrency settings to use.
	*/
	ConcurrencyOverrides: SoundConcurrencySettings;
	/**
	 * Max Concurrent Resolution Rule
	*/
	MaxConcurrentResolutionRule: EMaxConcurrentResolutionRule;
	/**
	 * Maximum number of times this sound can be played concurrently.
	*/
	MaxConcurrentPlayCount: number;
	/**
	 * Duration of sound in seconds.
	*/
	Duration: number;
	/**
	 * Attenuation settings package for the sound
	*/
	AttenuationSettings: SoundAttenuation;
	/**
	 * Sound priority (higher value is higher priority) used for concurrency resolution. This priority value is weighted against the final volume of the sound.
	*/
	Priority: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SoundBase;
	static Find(Outer: UObject, ResourceName: string): SoundBase;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SoundBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SoundBase;
	static C(Other: UObject): SoundBase;
	/**
	 * Plays a sound attached to and following the specified component. This is a fire and forget sound. Replication is also not handled at this point.
	 * @param Sound - sound to play
	 * @param AttachComponent - Component to attach to.
	 * @param AttachPointName - Optional named point within the AttachComponent to play the sound at
	 * @param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
	 * @param Rotation - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a relative offset
	 * @param LocationType - Specifies whether Location is a relative offset or an absolute world position
	 * @param bStopWhenAttachedToDestroyed - Specifies whether the sound should stop playing when the owner of the attach to component is destroyed.
	 * @param VolumeMultiplier - Volume multiplier
	 * @param PitchMultiplier - PitchMultiplier
	 * @param StartTime - How far in to the sound to begin playback at
	 * @param AttenuationSettings - Override attenuation settings package to play sound with
	 * @param ConcurrencySettings - Override concurrency settings package to play sound with
	 * @return An audio component to manipulate the spawned sound
	*/
	SpawnSoundAttached(AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency): AudioComponent;
	/**
	 * Plays a sound attached to and following the specified component. This is a fire and forget sound. Replication is also not handled at this point.
	 * @param Sound - sound to play
	 * @param AttachComponent - Component to attach to.
	 * @param AttachPointName - Optional named point within the AttachComponent to play the sound at
	 * @param Location - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world position that will be translated to a relative offset
	 * @param Rotation - Depending on the value of Location Type this is either a relative offset from the attach component/point or an absolute world rotation that will be translated to a relative offset
	 * @param LocationType - Specifies whether Location is a relative offset or an absolute world position
	 * @param bStopWhenAttachedToDestroyed - Specifies whether the sound should stop playing when the owner of the attach to component is destroyed.
	 * @param VolumeMultiplier - Volume multiplier
	 * @param PitchMultiplier - PitchMultiplier
	 * @param StartTime - How far in to the sound to begin playback at
	 * @param AttenuationSettings - Override attenuation settings package to play sound with
	 * @param ConcurrencySettings - Override concurrency settings package to play sound with
	 * @return An audio component to manipulate the spawned sound
	*/
	static SpawnSoundAttached(Sound: SoundBase,AttachToComponent: SceneComponent,AttachPointName: string,Location: Vector,Rotation: Rotator,LocationType: EAttachLocation,bStopWhenAttachedToDestroyed: boolean,VolumeMultiplier: number,PitchMultiplier: number,StartTime: number,AttenuationSettings: SoundAttenuation,ConcurrencySettings: SoundConcurrency): AudioComponent;
}

declare class Visual extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Visual;
	static Find(Outer: UObject, ResourceName: string): Visual;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Visual;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Visual;
	static C(Other: UObject): Visual;
}

declare class PanelWidget extends Widget { 
	/**
	 * The slots in the widget holding the child widgets of this panel.
	*/
	Slots: PanelSlot[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PanelWidget;
	static Find(Outer: UObject, ResourceName: string): PanelWidget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PanelWidget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PanelWidget;
	/**
	 * Removes a child by it's index.
	*/
	RemoveChildAt(Index: number): boolean;
	/**
	 * Removes a specific widget from the container.
	 * @return true if the widget was found and removed.
	*/
	RemoveChild(Content: Widget): boolean;
	/**
	 * @return true if panel contains this widget
	*/
	HasChild(Content: Widget): boolean;
	/**
	 * @return true if there are any child widgets in the panel
	*/
	HasAnyChildren(): boolean;
	/**
	 * Gets number of child widgets in the container.
	*/
	GetChildrenCount(): number;
	/**
	 * Gets the index of a specific child widget
	*/
	GetChildIndex(Content: Widget): number;
	/**
	 * Gets the widget at an index.
	 * @param Index The index of the widget.
	 * @return The widget at the given index, or nothing if there is no widget there.
	*/
	GetChildAt(Index: number): Widget;
	/**
	 * Remove all child widgets from the panel widget.
	*/
	ClearChildren(): void;
	/**
	 * Adds a new child widget to the container.  Returns the base slot type,
	 * requires casting to turn it into the type specific to the container.
	*/
	AddChild(Content: Widget): PanelSlot;
	static C(Other: UObject): PanelWidget;
}

declare class PanelSlot extends Visual { 
	/**
	 * Parent
	*/
	Parent: PanelWidget;
	/**
	 * Content
	*/
	Content: Widget;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PanelSlot;
	static Find(Outer: UObject, ResourceName: string): PanelSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PanelSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PanelSlot;
	static C(Other: UObject): PanelSlot;
}

declare type ESlateVisibility = string | symbol;
declare var ESlateVisibility = { Visible:'Visible',Collapsed:'Collapsed',Hidden:'Hidden',HitTestInvisible:'HitTestInvisible',SelfHitTestInvisible:'SelfHitTestInvisible', };
declare class WidgetTransform { 
	/**
	 * The amount to translate the widget in slate units
	*/
	Translation: Vector2D;
	/**
	 * The scale to apply to the widget
	*/
	Scale: Vector2D;
	/**
	 * The amount to shear the widget in slate units
	*/
	Shear: Vector2D;
	/**
	 * The angle in degrees to rotate
	*/
	Angle: number;
	clone() : WidgetTransform;
	static C(Other: UObject): WidgetTransform;
}

declare type EUINavigationRule = string | symbol;
declare var EUINavigationRule = { Escape:'Escape',Explicit:'Explicit',Wrap:'Wrap',Stop:'Stop',Custom:'Custom',Invalid:'Invalid', };
declare class WidgetNavigationData { 
	/**
	 * Rule
	*/
	Rule: EUINavigationRule;
	/**
	 * Widget to Focus
	*/
	WidgetToFocus: string;
	clone() : WidgetNavigationData;
	static C(Other: UObject): WidgetNavigationData;
}

declare class WidgetNavigation extends UObject { 
	/**
	 * Happens when the user presses up arrow, joystick, d-pad.
	*/
	Up: WidgetNavigationData;
	/**
	 * Happens when the user presses down arrow, joystick, d-pad.
	*/
	Down: WidgetNavigationData;
	/**
	 * Happens when the user presses left arrow, joystick, d-pad.
	*/
	Left: WidgetNavigationData;
	/**
	 * Happens when the user presses right arrow, joystick, d-pad.
	*/
	Right: WidgetNavigationData;
	/**
	 * Happens when the user presses Tab.
	*/
	Next: WidgetNavigationData;
	/**
	 * Happens when the user presses Shift+Tab.
	*/
	Previous: WidgetNavigationData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): WidgetNavigation;
	static Find(Outer: UObject, ResourceName: string): WidgetNavigation;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WidgetNavigation;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WidgetNavigation;
	static C(Other: UObject): WidgetNavigation;
}

declare class PropertyPathSegment { 
	/**
	 * The sub-component of the property path, a single value between .'s of the path
	*/
	Name: string;
	/**
	 * The optional array index.
	*/
	ArrayIndex: number;
	/**
	 * The cached Class or ScriptStruct that was used last to resolve Name to a property.
	*/
	Struct: Struct;
	/**
	 * The cached property on the Struct that this Name resolved to on it last time Resolve was called, if
	 * the Struct doesn't change, this value is returned to avoid performing another Field lookup.
	*/
	Field: Field;
	clone() : PropertyPathSegment;
	static C(Other: UObject): PropertyPathSegment;
}

declare class DynamicPropertyPath { 
	/**
	 * Segments
	*/
	Segments: PropertyPathSegment[];
	clone() : DynamicPropertyPath;
	static C(Other: UObject): DynamicPropertyPath;
}

declare class PropertyBinding extends UObject { 
	/**
	 * The source object to use as the initial container to resolve the Source Property Path on.
	*/
	SourceObject: any;
	/**
	 * The property path to trace to resolve this binding on the Source Object
	*/
	SourcePath: DynamicPropertyPath;
	/**
	 * Used to determine if a binding already exists on the object and if this binding can be safely removed.
	*/
	DestinationProperty: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PropertyBinding;
	static Find(Outer: UObject, ResourceName: string): PropertyBinding;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PropertyBinding;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PropertyBinding;
	static C(Other: UObject): PropertyBinding;
}

declare type EWidgetDesignFlags = string | symbol;
declare var EWidgetDesignFlags = { None:'None',Designing:'Designing',ShowOutline:'ShowOutline', };
declare class JavascriptSlateWidget { 
	clone() : JavascriptSlateWidget;
	static C(Other: UObject): JavascriptSlateWidget;
	/**
	 * Editor Add Modal Window
	*/
	EditorAddModalWindow(): void;
	/**
	 * Add Window
	*/
	AddWindow(): void;
	/**
	 * Add Window as Native Child
	*/
	AddWindowAsNativeChild(RootWindow: JavascriptSlateWidget): void;
	/**
	 * Editor Add Modal Window
	*/
	static EditorAddModalWindow(Widget: JavascriptSlateWidget): void;
	/**
	 * Add Window
	*/
	static AddWindow(NewWindow: JavascriptSlateWidget): void;
	/**
	 * Add Window as Native Child
	*/
	static AddWindowAsNativeChild(NewWindow: JavascriptSlateWidget,RootWindow: JavascriptSlateWidget): void;
	/**
	 * Get Root Window
	*/
	static GetRootWindow(): JavascriptSlateWidget;
}

declare type EHorizontalAlignment = string | symbol;
declare var EHorizontalAlignment = { HAlign_Fill:'HAlign_Fill',HAlign_Left:'HAlign_Left',HAlign_Center:'HAlign_Center',HAlign_Right:'HAlign_Right', };
declare type EVerticalAlignment = string | symbol;
declare var EVerticalAlignment = { VAlign_Fill:'VAlign_Fill',VAlign_Top:'VAlign_Top',VAlign_Center:'VAlign_Center',VAlign_Bottom:'VAlign_Bottom', };
declare class BorderSlot extends PanelSlot { 
	/**
	 * The padding area between the slot and the content it contains.
	*/
	Padding: Margin;
	/**
	 * The alignment of the object horizontally.
	*/
	HorizontalAlignment: EHorizontalAlignment;
	/**
	 * The alignment of the object vertically.
	*/
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BorderSlot;
	static Find(Outer: UObject, ResourceName: string): BorderSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BorderSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BorderSlot;
	/**
	 * Set Vertical Alignment
	*/
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	/**
	 * Set Padding
	*/
	SetPadding(InPadding: Margin): void;
	/**
	 * Set Horizontal Alignment
	*/
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject): BorderSlot;
}

declare class Anchors { 
	/**
	 * Holds the minimum anchors, left + top.
	*/
	Minimum: Vector2D;
	/**
	 * Holds the maximum anchors, right + bottom.
	*/
	Maximum: Vector2D;
	clone() : Anchors;
	static C(Other: UObject): Anchors;
}

declare class AnchorData { 
	/**
	 * Offset.
	*/
	Offsets: Margin;
	/**
	 * Anchors.
	*/
	Anchors: Anchors;
	/**
	 * Alignment is the pivot point of the widget.  Starting in the upper left at (0,0),
	 * ending in the lower right at (1,1).  Moving the alignment point allows you to move
	 * the origin of the widget.
	*/
	Alignment: Vector2D;
	clone() : AnchorData;
	static C(Other: UObject): AnchorData;
}

declare class CanvasPanelSlot extends PanelSlot { 
	/**
	 * The anchoring information for the slot
	*/
	LayoutData: AnchorData;
	/**
	 * When AutoSize is true we use the widget's desired size
	*/
	bAutoSize: boolean;
	/**
	 * The order priority this widget is rendered in.  Higher values are rendered last (and so they will appear to be on top).
	*/
	ZOrder: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): CanvasPanelSlot;
	static Find(Outer: UObject, ResourceName: string): CanvasPanelSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): CanvasPanelSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): CanvasPanelSlot;
	/**
	 * Sets the z-order on the slot
	*/
	SetZOrder(InZOrder: number): void;
	/**
	 * Sets the size of the slot
	*/
	SetSize(InSize: Vector2D): void;
	/**
	 * Sets the position of the slot
	*/
	SetPosition(InPosition: Vector2D): void;
	/**
	 * Sets the offset data of the slot, which could be position and size, or margins depending on the anchor points
	*/
	SetOffsets(InOffset: Margin): void;
	/**
	 * Sets the anchors on the slot
	*/
	SetMinimum(InMinimumAnchors: Vector2D): void;
	/**
	 * Sets the anchors on the slot
	*/
	SetMaximum(InMaximumAnchors: Vector2D): void;
	/**
	 * Sets the layout data of the slot
	*/
	SetLayout(InLayoutData: AnchorData): void;
	/**
	 * Sets if the slot to be auto-sized
	*/
	SetAutoSize(InbAutoSize: boolean): void;
	/**
	 * Sets the anchors on the slot
	*/
	SetAnchors(InAnchors: Anchors): void;
	/**
	 * Sets the alignment on the slot
	*/
	SetAlignment(InAlignment: Vector2D): void;
	/**
	 * Gets the z-order on the slot
	*/
	GetZOrder(): number;
	/**
	 * Gets the size of the slot
	*/
	GetSize(): Vector2D;
	/**
	 * Gets the position of the slot
	*/
	GetPosition(): Vector2D;
	/**
	 * Gets the offset data of the slot, which could be position and size, or margins depending on the anchor points
	*/
	GetOffsets(): Margin;
	/**
	 * Gets the layout data of the slot
	*/
	GetLayout(): AnchorData;
	/**
	 * Gets if the slot to be auto-sized
	*/
	GetAutoSize(): boolean;
	/**
	 * Gets the anchors on the slot
	*/
	GetAnchors(): Anchors;
	/**
	 * Gets the alignment on the slot
	*/
	GetAlignment(): Vector2D;
	static C(Other: UObject): CanvasPanelSlot;
}

declare class GridSlot extends PanelSlot { 
	/**
	 * The padding area between the slot and the content it contains.
	*/
	Padding: Margin;
	/**
	 * The alignment of the object horizontally.
	*/
	HorizontalAlignment: EHorizontalAlignment;
	/**
	 * The alignment of the object vertically.
	*/
	VerticalAlignment: EVerticalAlignment;
	/**
	 * The row index of the cell this slot is in
	*/
	Row: number;
	/**
	 * Row Span
	*/
	RowSpan: number;
	/**
	 * The column index of the cell this slot is in
	*/
	Column: number;
	/**
	 * Column Span
	*/
	ColumnSpan: number;
	/**
	 * Positive values offset this cell to be hit-tested and drawn on top of others. Default is 0; i.e. no offset.
	*/
	Layer: number;
	/**
	 * Offset this slot's content by some amount; positive values offset to lower right
	*/
	Nudge: Vector2D;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GridSlot;
	static Find(Outer: UObject, ResourceName: string): GridSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GridSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GridSlot;
	/**
	 * Set Vertical Alignment
	*/
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	/**
	 * How many rows this this slot spans over
	*/
	SetRowSpan(InRowSpan: number): void;
	/**
	 * Sets the row index of the slot, this determines what cell the slot is in the panel
	*/
	SetRow(InRow: number): void;
	/**
	 * Set Padding
	*/
	SetPadding(InPadding: Margin): void;
	/**
	 * Sets positive values offset this cell to be hit-tested and drawn on top of others.
	*/
	SetLayer(InLayer: number): void;
	/**
	 * Set Horizontal Alignment
	*/
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	/**
	 * How many columns this slot spans over
	*/
	SetColumnSpan(InColumnSpan: number): void;
	/**
	 * Sets the column index of the slot, this determines what cell the slot is in the panel
	*/
	SetColumn(InColumn: number): void;
	static C(Other: UObject): GridSlot;
}

declare type ESlateSizeRule = string | symbol;
declare var ESlateSizeRule = { Automatic:'Automatic',Fill:'Fill', };
declare class SlateChildSize { 
	/**
	 * The parameter of the size rule.
	*/
	Value: number;
	/**
	 * The sizing rule of the content.
	*/
	SizeRule: ESlateSizeRule;
	clone() : SlateChildSize;
	static C(Other: UObject): SlateChildSize;
}

declare class HorizontalBoxSlot extends PanelSlot { 
	/**
	 * The amount of padding between the slots parent and the content.
	*/
	Padding: Margin;
	/**
	 * How much space this slot should occupy in the direction of the panel.
	*/
	Size: SlateChildSize;
	/**
	 * Horizontal Alignment
	*/
	HorizontalAlignment: EHorizontalAlignment;
	/**
	 * Vertical Alignment
	*/
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): HorizontalBoxSlot;
	static Find(Outer: UObject, ResourceName: string): HorizontalBoxSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): HorizontalBoxSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): HorizontalBoxSlot;
	/**
	 * Set Vertical Alignment
	*/
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	/**
	 * Set Size
	*/
	SetSize(InSize: SlateChildSize): void;
	/**
	 * Set Padding
	*/
	SetPadding(InPadding: Margin): void;
	/**
	 * Set Horizontal Alignment
	*/
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject): HorizontalBoxSlot;
}

declare class OverlaySlot extends PanelSlot { 
	/**
	 * The padding area between the slot and the content it contains.
	*/
	Padding: Margin;
	/**
	 * The alignment of the object horizontally.
	*/
	HorizontalAlignment: EHorizontalAlignment;
	/**
	 * The alignment of the object vertically.
	*/
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): OverlaySlot;
	static Find(Outer: UObject, ResourceName: string): OverlaySlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): OverlaySlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): OverlaySlot;
	/**
	 * Set Vertical Alignment
	*/
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	/**
	 * Set Padding
	*/
	SetPadding(InPadding: Margin): void;
	/**
	 * Set Horizontal Alignment
	*/
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject): OverlaySlot;
}

declare class UniformGridSlot extends PanelSlot { 
	/**
	 * The alignment of the object horizontally.
	*/
	HorizontalAlignment: EHorizontalAlignment;
	/**
	 * The alignment of the object vertically.
	*/
	VerticalAlignment: EVerticalAlignment;
	/**
	 * The row index of the cell this slot is in
	*/
	Row: number;
	/**
	 * The column index of the cell this slot is in
	*/
	Column: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): UniformGridSlot;
	static Find(Outer: UObject, ResourceName: string): UniformGridSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): UniformGridSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): UniformGridSlot;
	/**
	 * Set Vertical Alignment
	*/
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	/**
	 * Sets the row index of the slot, this determines what cell the slot is in the panel
	*/
	SetRow(InRow: number): void;
	/**
	 * Set Horizontal Alignment
	*/
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	/**
	 * Sets the column index of the slot, this determines what cell the slot is in the panel
	*/
	SetColumn(InColumn: number): void;
	static C(Other: UObject): UniformGridSlot;
}

declare class VerticalBoxSlot extends PanelSlot { 
	/**
	 * The padding area between the slot and the content it contains.
	*/
	Padding: Margin;
	/**
	 * How much space this slot should occupy in the direction of the panel.
	*/
	Size: SlateChildSize;
	/**
	 * The alignment of the object horizontally.
	*/
	HorizontalAlignment: EHorizontalAlignment;
	/**
	 * The alignment of the object vertically.
	*/
	VerticalAlignment: EVerticalAlignment;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): VerticalBoxSlot;
	static Find(Outer: UObject, ResourceName: string): VerticalBoxSlot;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): VerticalBoxSlot;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): VerticalBoxSlot;
	/**
	 * Set Vertical Alignment
	*/
	SetVerticalAlignment(InVerticalAlignment: EVerticalAlignment): void;
	/**
	 * Set Size
	*/
	SetSize(InSize: SlateChildSize): void;
	/**
	 * Set Padding
	*/
	SetPadding(InPadding: Margin): void;
	/**
	 * Set Horizontal Alignment
	*/
	SetHorizontalAlignment(InHorizontalAlignment: EHorizontalAlignment): void;
	static C(Other: UObject): VerticalBoxSlot;
}

declare class Widget extends Visual { 
	/**
	 * Allows controls to be exposed as variables in a blueprint.  Not all controls need to be exposed
	 * as variables, so this allows only the most useful ones to end up being exposed.
	*/
	bIsVariable: boolean;
	/**
	 * Flag if the Widget was created from a blueprint
	*/
	bCreatedByConstructionScript: boolean;
	/**
	 * The parent slot of the UWidget.  Allows us to easily inline edit the layout controlling this widget.
	*/
	Slot: PanelSlot;
	/**
	 * Sets whether this widget can be modified interactively by the user
	*/
	bIsEnabled: boolean;
	/**
	 * A bindable delegate for bIsEnabled
	*/
	bIsEnabledDelegate: UnrealEngineDelegate<() => boolean>;
	/**
	 * Tooltip text to show when the user hovers over the widget with the mouse
	*/
	ToolTipText: string;
	/**
	 * A bindable delegate for ToolTipText
	*/
	ToolTipTextDelegate: UnrealEngineDelegate<() => string>;
	/**
	 * Tooltip widget to show when the user hovers over the widget with the mouse
	*/
	ToolTipWidget: Widget;
	/**
	 * A bindable delegate for ToolTipWidget
	*/
	ToolTipWidgetDelegate: UnrealEngineDelegate<() => Widget>;
	/**
	 * The visibility of the widget
	*/
	Visiblity: ESlateVisibility;
	/**
	 * The visibility of the widget
	*/
	Visibility: ESlateVisibility;
	/**
	 * A bindable delegate for Visibility
	*/
	VisibilityDelegate: UnrealEngineDelegate<() => ESlateVisibility>;
	/**
	 * Override Cursor
	*/
	bOverride_Cursor: boolean;
	/**
	 * The cursor to show when the mouse is over the widget
	*/
	Cursor: EMouseCursor;
	/**
	 * If true prevents the widget or its child's geometry or layout information from being cached.  If this widget
	 * changes every frame, but you want it to still be in an invalidation panel you should make it as volatile
	 * instead of invalidating it every frame, which would prevent the invalidation panel from actually
	 * ever caching anything.
	*/
	bIsVolatile: boolean;
	/**
	 * The render transform of the widget allows for arbitrary 2D transforms to be applied to the widget.
	*/
	RenderTransform: WidgetTransform;
	/**
	 * The render transform pivot controls the location about which transforms are applied.
	 * This value is a normalized coordinate about which things like rotations will occur.
	*/
	RenderTransformPivot: Vector2D;
	/**
	 * The navigation object for this widget is optionally created if the user has configured custom
	 * navigation rules for this widget in the widget designer.  Those rules determine how navigation transitions
	 * can occur between widgets.
	*/
	Navigation: WidgetNavigation;
	/**
	 * Stores the design time flag setting if the widget is hidden inside the designer
	*/
	bHiddenInDesigner: boolean;
	/**
	 * Stores the design time flag setting if the widget is expanded inside the designer
	*/
	bExpandedInDesigner: boolean;
	/**
	 * Native property bindings.
	*/
	NativeBindings: PropertyBinding[];
	/**
	 * Any flags used by the designer at edit time.
	*/
	DesignerFlags: EWidgetDesignFlags;
	/**
	 * The friendly name for this widget displayed in the designer and BP graph.
	*/
	DisplayLabel: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Widget;
	static Find(Outer: UObject, ResourceName: string): Widget;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Widget;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Widget;
	/**
	 * Sets the visibility of the widget.
	*/
	SetVisibility(InVisibility: ESlateVisibility): void;
	/**
	 * Sets the focus to this widget for a specific user
	*/
	SetUserFocus(PlayerController: PlayerController): void;
	/**
	 * Sets the tooltip text for the widget.
	*/
	SetToolTipText(InToolTipText: string): void;
	/**
	 * Sets a custom widget as the tooltip of the widget.
	*/
	SetToolTip(Widget: Widget): void;
	/**
	 * Set Render Translation
	*/
	SetRenderTranslation(Translation: Vector2D): void;
	/**
	 * Set Render Transform Pivot
	*/
	SetRenderTransformPivot(Pivot: Vector2D): void;
	/**
	 * Set Render Transform
	*/
	SetRenderTransform(InTransform: WidgetTransform): void;
	/**
	 * Set Render Shear
	*/
	SetRenderShear(Shear: Vector2D): void;
	/**
	 * Set Render Scale
	*/
	SetRenderScale(Scale: Vector2D): void;
	/**
	 * Set Render Angle
	*/
	SetRenderAngle(Angle: number): void;
	/**
	 * Sets the focus to this widget.
	*/
	SetKeyboardFocus(): void;
	/**
	 * Sets the current enabled status of the widget
	*/
	SetIsEnabled(bInIsEnabled: boolean): void;
	/**
	 * Sets the cursor to show over the widget.
	*/
	SetCursor(InCursor: EMouseCursor): void;
	/**
	 * Resets the cursor to use on the widget, removing any customization for it.
	*/
	ResetCursor(): void;
	/**
	 * Removes the widget from its parent widget.  If this widget was added to the player's screen or the viewport
	 * it will also be removed from those containers.
	*/
	RemoveFromParent(): void;
	/**
	 * @return true if the widget is Visible, HitTestInvisible or SelfHitTestInvisible.
	*/
	IsVisible(): boolean;
	/**
	 * @return true if the widget is currently being hovered by a pointer device
	*/
	IsHovered(): boolean;
	/**
	 * Invalidates the widget from the view of a layout caching widget that may own this widget.
	 * will force the owning widget to redraw and cache children on the next paint pass.
	*/
	InvalidateLayoutAndVolatility(): void;
	/**
	 * @return true if any descendant widget is focused by a specific user.
	*/
	HasUserFocusedDescendants(PlayerController: PlayerController): boolean;
	/**
	 * @return true if this widget is focused by a specific user.
	*/
	HasUserFocus(PlayerController: PlayerController): boolean;
	/**
	 * Checks to see if this widget is the current mouse captor
	 * @return  True if this widget has captured the mouse
	*/
	HasMouseCapture(): boolean;
	/**
	 * Checks to see if this widget currently has the keyboard focus
	 * @return  True if this widget has keyboard focus
	*/
	HasKeyboardFocus(): boolean;
	/**
	 * @return true if any descendant widget is focused by any user.
	*/
	HasAnyUserFocusedDescendants(): boolean;
	/**
	 * @return true if this widget is focused by any user.
	*/
	HasAnyUserFocus(): boolean;
	/**
	 * Gets the current visibility of the widget.
	*/
	GetVisibility(): ESlateVisibility;
	/**
	 * Gets the parent widget
	*/
	GetParent(): PanelWidget;
	/**
	 * Gets the current enabled status of the widget
	*/
	GetIsEnabled(): boolean;
	/**
	 * Gets the widgets desired size.
	 * NOTE: The underlying Slate widget must exist and be valid, also at least one pre-pass must
	 *       have occurred before this value will be of any use.
	 * @return The widget's desired size
	*/
	GetDesiredSize(): Vector2D;
	/**
	 * Sets the forced volatility of the widget.
	*/
	ForceVolatile(bForce: boolean): void;
	/**
	 * Forces a pre-pass.  A pre-pass caches the desired size of the widget hierarchy owned by this widget.
	 * One pre-pass is already happens for every widget before Tick occurs.  You only need to perform another
	 * pre-pass if you are adding child widgets this frame and want them to immediately be visible this frame.
	*/
	ForceLayoutPrepass(): void;
	static C(Other: UObject): Widget;
	/**
	 * Open Popup Window
	*/
	OpenPopupWindow(PopupDesiredSize: Vector2D,HeadingText: string): void;
	/**
	 * Compute Desired Size
	*/
	ComputeDesiredSize(LayoutScaleMultiplier: number): Vector2D;
	/**
	 * Take Widget
	*/
	TakeWidget(): JavascriptSlateWidget;
	/**
	 * Gets the slot object on the child widget as a Border Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a border panel.
	*/
	SlotAsBorderSlot(): BorderSlot;
	/**
	 * Gets the slot object on the child widget as a Canvas Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a canvas panel.
	*/
	SlotAsCanvasSlot(): CanvasPanelSlot;
	/**
	 * Gets the slot object on the child widget as a Grid Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a grid panel.
	*/
	SlotAsGridSlot(): GridSlot;
	/**
	 * Gets the slot object on the child widget as a Horizontal Box Slot, allowing you to manipulate its information.
	 * @param Widget The child widget of a Horizontal Box.
	*/
	SlotAsHorizontalBoxSlot(): HorizontalBoxSlot;
	/**
	 * Gets the slot object on the child widget as a Overlay Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a overlay panel.
	*/
	SlotAsOverlaySlot(): OverlaySlot;
	/**
	 * Gets the slot object on the child widget as a Uniform Grid Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a uniform grid panel.
	*/
	SlotAsUniformGridSlot(): UniformGridSlot;
	/**
	 * Gets the slot object on the child widget as a Vertical Box Slot, allowing you to manipulate its information.
	 * @param Widget The child widget of a Vertical Box.
	*/
	SlotAsVerticalBoxSlot(): VerticalBoxSlot;
	/**
	 * Open Popup Window
	*/
	static OpenPopupWindow(Widget: Widget,PopupDesiredSize: Vector2D,HeadingText: string): void;
	/**
	 * Compute Desired Size
	*/
	static ComputeDesiredSize(Widget: Widget,LayoutScaleMultiplier: number): Vector2D;
	/**
	 * Take Widget
	*/
	static TakeWidget(Widget: Widget): JavascriptSlateWidget;
	/**
	 * Gets the slot object on the child widget as a Border Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a border panel.
	*/
	static SlotAsBorderSlot(Widget: Widget): BorderSlot;
	/**
	 * Gets the slot object on the child widget as a Canvas Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a canvas panel.
	*/
	static SlotAsCanvasSlot(Widget: Widget): CanvasPanelSlot;
	/**
	 * Gets the slot object on the child widget as a Grid Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a grid panel.
	*/
	static SlotAsGridSlot(Widget: Widget): GridSlot;
	/**
	 * Gets the slot object on the child widget as a Horizontal Box Slot, allowing you to manipulate its information.
	 * @param Widget The child widget of a Horizontal Box.
	*/
	static SlotAsHorizontalBoxSlot(Widget: Widget): HorizontalBoxSlot;
	/**
	 * Gets the slot object on the child widget as a Overlay Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a overlay panel.
	*/
	static SlotAsOverlaySlot(Widget: Widget): OverlaySlot;
	/**
	 * Gets the slot object on the child widget as a Uniform Grid Slot, allowing you to manipulate layout information.
	 * @param Widget The child widget of a uniform grid panel.
	*/
	static SlotAsUniformGridSlot(Widget: Widget): UniformGridSlot;
	/**
	 * Gets the slot object on the child widget as a Vertical Box Slot, allowing you to manipulate its information.
	 * @param Widget The child widget of a Vertical Box.
	*/
	static SlotAsVerticalBoxSlot(Widget: Widget): VerticalBoxSlot;
}

declare type EMouseLockMode = string | symbol;
declare var EMouseLockMode = { DoNotLock:'DoNotLock',LockOnCapture:'LockOnCapture',LockAlways:'LockAlways', };
declare class PlayerController extends Controller { 
	/**
	 * UPlayer associated with this PlayerController.  Could be a local player or a net connection.
	*/
	Player: Player;
	/**
	 * Used in net games so client can acknowledge it possessed a specific pawn.
	*/
	AcknowledgedPawn: Pawn;
	/**
	 * Director track that's currently possessing this player controller, or none if not possessed.
	*/
	ControllingDirTrackInst: InterpTrackInstDirector;
	/**
	 * Heads up display associated with this PlayerController.
	*/
	MyHUD: HUD;
	/**
	 * Camera manager associated with this Player Controller.
	*/
	PlayerCameraManager: PlayerCameraManager;
	/**
	 * PlayerCamera class should be set for each game, otherwise Engine.PlayerCameraManager is used
	*/
	PlayerCameraManagerClass: UnrealEngineClass;
	/**
	 * True to allow this player controller to manage the camera target for you,
	 * typically by using the possessed pawn as the camera target. Set to false
	 * if you want to manually control the camera target.
	*/
	bAutoManageActiveCameraTarget: boolean;
	/**
	 * Used to replicate the view rotation of targets not owned/possessed by this PlayerController.
	*/
	TargetViewRotation: Rotator;
	/**
	 * Interp speed for blending remote view rotation for smoother client updates
	*/
	SmoothTargetViewRotationSpeed: number;
	/**
	 * The actors which the camera shouldn't see - e.g. used to hide actors which the camera penetrates
	*/
	HiddenActors: Actor[];
	/**
	 * Used to make sure the client is kept synchronized when in a spectator state
	*/
	LastSpectatorStateSynchTime: number;
	/**
	 * Last location synced on the server for a spectator.
	*/
	LastSpectatorSyncLocation: Vector;
	/**
	 * Last rotation synced on the server for a spectator.
	*/
	LastSpectatorSyncRotation: Rotator;
	/**
	 * Cap set by server on bandwidth from client to server in bytes/sec (only has impact if >=2600)
	*/
	ClientCap: number;
	/**
	 * Object that manages "cheat" commands.  Not instantiated in shipping builds.
	*/
	CheatManager: CheatManager;
	/**
	 * class of my CheatManager.
	*/
	CheatClass: UnrealEngineClass;
	/**
	 * Object that manages player input.
	*/
	PlayerInput: PlayerInput;
	/**
	 * Active Force Feedback Effects
	*/
	ActiveForceFeedbackEffects: ActiveForceFeedbackEffect[];
	/**
	 * True if PlayerController is currently waiting for the match to start or to respawn. Only valid in Spectating state.
	*/
	bPlayerIsWaiting: boolean;
	/**
	 * index identifying players using the same base connection (splitscreen clients)
	 * Used by netcode to match replicated PlayerControllers to the correct splitscreen viewport and child connection
	 * replicated via special internal code, not through normal variable replication
	*/
	NetPlayerIndex: number;
	/**
	 * this is set on the OLD PlayerController when performing a swap over a network connection
	 * so we know what connection we're waiting on acknowledgment from to finish destroying this PC
	 * (or when the connection is closed)
	 * @see GameMode::SwapPlayerControllers()
	*/
	PendingSwapConnection: NetConnection;
	/**
	 * The net connection this controller is communicating on, NULL for local players on server
	*/
	NetConnection: NetConnection;
	/**
	 * Yaw input speed scaling
	*/
	InputYawScale: number;
	/**
	 * Pitch input speed scaling
	*/
	InputPitchScale: number;
	/**
	 * Roll input speed scaling
	*/
	InputRollScale: number;
	/**
	 * Whether the mouse cursor should be displayed.
	*/
	bShowMouseCursor: boolean;
	/**
	 * Whether actor/component click events should be generated.
	*/
	bEnableClickEvents: boolean;
	/**
	 * Whether actor/component touch events should be generated.
	*/
	bEnableTouchEvents: boolean;
	/**
	 * Whether actor/component mouse over events should be generated.
	*/
	bEnableMouseOverEvents: boolean;
	/**
	 * Whether actor/component touch over events should be generated.
	*/
	bEnableTouchOverEvents: boolean;
	/**
	 * Force Feedback Enabled
	*/
	bForceFeedbackEnabled: boolean;
	/**
	 * Click Event Keys
	*/
	ClickEventKeys: Key[];
	/**
	 * Default Mouse Cursor
	*/
	DefaultMouseCursor: EMouseCursor;
	/**
	 * Current Mouse Cursor
	*/
	CurrentMouseCursor: EMouseCursor;
	/**
	 * Default trace channel used for determining what world object was clicked on.
	*/
	DefaultClickTraceChannel: ECollisionChannel;
	/**
	 * Trace channel currently being used for determining what world object was clicked on.
	*/
	CurrentClickTraceChannel: ECollisionChannel;
	/**
	 * Hit Result Trace Distance
	*/
	HitResultTraceDistance: number;
	/**
	 * InputComponent we use when player is in Inactive state.
	*/
	InactiveStateInputComponent: InputComponent;
	/**
	 * The currently set touch interface
	*/
	CurrentTouchInterface: TouchInterface;
	/**
	 * The pawn used when spectating (NULL if not spectating).
	*/
	SpectatorPawn: SpectatorPawn;
	/**
	 * The location used internally when there is no pawn or spectator, to know where to spawn the spectator or focus the camera on death.
	*/
	SpawnLocation: Vector;
	/**
	 * Set during SpawnActor once and never again to indicate the intent of this controller instance (SERVER ONLY)
	*/
	bIsLocalPlayerController: boolean;
	/**
	 * Counter for this players seamless travels (used along with the below value, to restrict ServerNotifyLoadedWorld)
	*/
	SeamlessTravelCount: any;
	/**
	 * The value of SeamlessTravelCount, upon the last call to GameMode::HandleSeamlessTravelPlayer; used to detect seamless travel
	*/
	LastCompletedSeamlessTravelCount: any;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PlayerController;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PlayerController;
	/**
	 * Returns true if the given key/button was down last frame and up this frame.
	*/
	WasInputKeyJustReleased(Key: Key): boolean;
	/**
	 * Returns true if the given key/button was up last frame and down this frame.
	*/
	WasInputKeyJustPressed(Key: Key): boolean;
	/**
	 * Toggle voice chat on and off
	 * @param bSpeaking enable or disable voice chat
	*/
	ToggleSpeaking(bInSpeaking: boolean): void;
	/**
	 * SwitchLevel to the given MapURL.
	*/
	SwitchLevel(URL: string): void;
	/**
	 * Stops a playing haptic feedback curve
	 * @param        HapticEffect                    The haptic effect to stop
	 * @param        Hand                                    Which hand to stop the effect for
	*/
	StopHapticEffect(Hand: EControllerHand): void;
	/**
	 * Fire the player's currently selected weapon with the optional firemode.
	*/
	StartFire(FireModeNum: number): void;
	/**
	 * Set the virtual joystick visibility.
	*/
	SetVirtualJoystickVisibility(bVisible: boolean): void;
	/**
	 * Set the view target blending with variable control
	 * @param NewViewTarget - new actor to set as view target
	 * @param BlendTime - time taken to blend
	 * @param BlendFunc - Cubic, Linear etc functions for blending
	 * @param BlendExp -  Exponent, used by certain blend functions to control the shape of the curve.
	 * @param bLockOutgoing - If true, lock outgoing viewtarget to last frame's camera position for the remainder of the blend.
	*/
	SetViewTargetWithBlend(NewViewTarget: Actor,BlendTime: number,BlendFunc: EViewTargetBlendFunction,BlendExp: number,bLockOutgoing: boolean): void;
	/**
	 * Trys to set the player's name to the given name.
	*/
	SetName(S: string): void;
	/**
	 * Sets the value of the haptics for the specified hand directly, using frequency and amplitude.  NOTE:  If a curve is already
	 * playing for this hand, it will be cancelled in favour of the specified values.
	 * @param        Frequency                               The normalized frequency [0.0, 1.0] to play through the haptics system
	 * @param        Amplitude                               The normalized amplitude [0.0, 1.0] to set the haptic feedback to
	 * @param        Hand                                    Which hand to play the effect on
	*/
	SetHapticsByValue(Frequency: number,Amplitude: number,Hand: EControllerHand): void;
	/**
	 * Sets the light color of the player's controller
	 * @param        Color                                   The color for the light to be
	*/
	SetControllerLightColor(Color: Color): void;
	/**
	 * Server/SP only function for changing whether the player is in cinematic mode.  Updates values of various state variables, then replicates the call to the client
	 * to sync the current cinematic mode.
	 * @param       bInCinematicMode        specify true if the player is entering cinematic mode; false if the player is leaving cinematic mode.
	 * @param       bHidePlayer                     specify true to hide the player's pawn (only relevant if bInCinematicMode is true)
	 * @param       bAffectsHUD                     specify true if we should show/hide the HUD to match the value of bCinematicMode
	 * @param       bAffectsMovement        specify true to disable movement in cinematic mode, enable it when leaving
	 * @param       bAffectsTurning         specify true to disable turning in cinematic mode or enable it when leaving
	*/
	SetCinematicMode(bInCinematicMode: boolean,bHidePlayer: boolean,bAffectsHUD: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean): void;
	/**
	 * Used to override the default positioning of the audio listener
	 * @param AttachToComponent Optional component to attach the audio listener to
	 * @param Location Depending on whether Component is attached this is either an offset from its location or an absolute position
	 * @param Rotation Depending on whether Component is attached this is either an offset from its rotation or an absolute rotation
	*/
	SetAudioListenerOverride(AttachToComponent: SceneComponent,Location: Vector,Rotation: Rotator): void;
	/**
	 * Move camera to current user
	*/
	ServerViewSelf(TransitionParams: ViewTargetTransitionParams): void;
	/**
	 * Move camera to previous player on round ended or spectating
	*/
	ServerViewPrevPlayer(): void;
	/**
	 * Move camera to next player on round ended or spectating
	*/
	ServerViewNextPlayer(): void;
	/**
	 * Used by client to request server to confirm current viewtarget (server will respond with ClientSetViewTarget() ).
	*/
	ServerVerifyViewTarget(): void;
	/**
	 * Called when the client adds/removes a streamed level
	 * the server will only replicate references to Actors in visible levels so that it's impossible to send references to
	 * Actors the client has not initialized
	 * @param PackageName the name of the package for the level whose status changed
	*/
	ServerUpdateLevelVisibility(PackageName: string,bIsVisible: boolean): void;
	/**
	 * If PlayerCamera.bUseClientSideCameraUpdates is set, client will replicate camera positions to the server. // @TODO - combine pitch/yaw into one int, maybe also send location compressed
	*/
	ServerUpdateCamera(CamLoc: Vector_NetQuantize,CamPitchAndYaw: number): void;
	/**
	 * Tell the server to unmute a player for this controller
	 * @param PlayerId player id to unmute
	*/
	ServerUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
	/**
	 * Used by UGameplayDebuggingControllerComponent to replicate messages for AI debugging in network games.
	*/
	ServerToggleAILogging(): void;
	/**
	 * Notifies the server that the client has ticked gameplay code, and should no longer get the extended "still loading" timeout grace period
	*/
	ServerShortTimeout(): void;
	/**
	 * Indicate that the Spectator is waiting to join/respawn.
	*/
	ServerSetSpectatorWaiting(bWaiting: boolean): void;
	/**
	 * When spectating, updates spectator location/rotation and pings the server to make sure spectating should continue.
	*/
	ServerSetSpectatorLocation(NewLoc: Vector,NewRot: Rotator): void;
	/**
	 * Attempts to restart this player, generally called from the client upon respawn request.
	*/
	ServerRestartPlayer(): void;
	/**
	 * Replicate pause request to the server
	*/
	ServerPause(): void;
	/**
	 * Called to notify the server when the client has loaded a new world via seamless traveling
	 * @param WorldPackageName the name of the world package that was loaded
	*/
	ServerNotifyLoadedWorld(WorldPackageName: string): void;
	/**
	 * Tell the server to mute a player for this controller
	 * @param PlayerId player id to mute
	*/
	ServerMutePlayer(PlayerId: UniqueNetIdRepl): void;
	/**
	 * Reliable version of ServerCheckClientPossession to be used when there is no likely danger of spamming the network.
	*/
	ServerCheckClientPossessionReliable(): void;
	/**
	 * Tells the server to make sure the possessed pawn is in sync with the client.
	*/
	ServerCheckClientPossession(): void;
	/**
	 * Change name of server
	*/
	ServerChangeName(S: string): void;
	/**
	 * change mode of camera
	*/
	ServerCamera(NewMode: string): void;
	/**
	 * acknowledge possession of pawn
	*/
	ServerAcknowledgePossession(P: Pawn): void;
	/**
	 * Sends a command to the console to execute if not shipping version
	*/
	SendToConsole(Command: string): void;
	/**
	 * Restarts the current level
	*/
	RestartLevel(): void;
	/**
	 * Convert a World Space 3D position into a 2D Screen Space position.
	 * @return true if the world coordinate was successfully projected to the screen.
	*/
	ConvertWorldLocationToScreenLocation(WorldLocation: Vector,ScreenLocation?: Vector2D): {ScreenLocation: Vector2D, $: boolean};
	/**
	 * Play a haptic feedback curve on the player's controller
	 * @param        HapticEffect                    The haptic effect to play
	 * @param        Hand                                    Which hand to play the effect on
	 * @param        Scale                                   Scale between 0.0 and 1.0 on the intensity of playback
	*/
	PlayHapticEffect(HapticEffect: HapticFeedbackEffect_Base,Hand: EControllerHand,Scale: number,bLoop: boolean): void;
	/**
	 * Latent action that controls the playing of force feedback
	 * Begins playing when Start is called.  Calling Update or Stop if the feedback is not active will have no effect.
	 * Completed will execute when Stop is called or the duration ends.
	 * When Update is called the Intensity, Duration, and affect values will be updated with the current inputs
	 * @param       Intensity                               How strong the feedback should be.  Valid values are between 0.0 and 1.0
	 * @param       Duration                                How long the feedback should play for.  If the value is negative it will play until stopped
	 * @param   bAffectsLeftLarge           Whether the intensity should be applied to the large left servo
	 * @param   bAffectsLeftSmall           Whether the intensity should be applied to the small left servo
	 * @param   bAffectsRightLarge          Whether the intensity should be applied to the large right servo
	 * @param   bAffectsRightSmall          Whether the intensity should be applied to the small right servo
	*/
	PlayDynamicForceFeedback(Intensity: number,Duration: number,bAffectsLeftLarge: boolean,bAffectsLeftSmall: boolean,bAffectsRightLarge: boolean,bAffectsRightSmall: boolean,Action: EDynamicForceFeedbackAction,LatentInfo: LatentActionInfo): void;
	/**
	 * Command to try to pause the game.
	*/
	Pause(): void;
	/**
	 * Notify from server that Visual Logger is recording, to show that information on client about possible performance issues
	*/
	OnServerStartedVisualLogger(bIsLogging: boolean): void;
	/**
	 * Causes the client to travel to the given URL
	*/
	LocalTravel(URL: string): void;
	/**
	 * Returns true if the given key/button is pressed on the input of the controller (if present)
	*/
	IsInputKeyDown(Key: Key): boolean;
	/**
	 * Helper to get the size of the HUD canvas for this player controller.  Returns 0 if there is no HUD
	*/
	GetViewportSize(SizeX?: number,SizeY?: number): {SizeX: number, SizeY: number};
	/**
	 * Get the Pawn used when spectating. NULL when not spectating.
	*/
	GetSpectatorPawn(): SpectatorPawn;
	/**
	 * Retrieves the X and Y screen coordinates of the mouse cursor. Returns false if there is no associated mouse device
	*/
	GetMousePosition(LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	/**
	 * Returns the vector value for the given key/button.
	*/
	GetInputVectorKeyState(Key: Key): Vector;
	/**
	 * Retrieves the X and Y screen coordinates of the specified touch key. Returns false if the touch index is not down
	*/
	GetInputTouchState(FingerIndex: ETouchIndex,LocationX?: number,LocationY?: number,bIsCurrentlyPressed?: boolean): {LocationX: number, LocationY: number, bIsCurrentlyPressed: boolean};
	/**
	 * Retrieves how far the mouse moved this frame.
	*/
	GetInputMouseDelta(DeltaX?: number,DeltaY?: number): {DeltaX: number, DeltaY: number};
	/**
	 * Retrieves the current motion state of the player's input device
	*/
	GetInputMotionState(Tilt?: Vector,RotationRate?: Vector,Gravity?: Vector,Acceleration?: Vector): {Tilt: Vector, RotationRate: Vector, Gravity: Vector, Acceleration: Vector};
	/**
	 * Returns how long the given key/button has been down.  Returns 0 if it's up or it just went down this frame.
	*/
	GetInputKeyTimeDown(Key: Key): number;
	/**
	 * Retrieves the X and Y displacement of the given analog stick.
	*/
	GetInputAnalogStickState(WhichStick: EControllerAnalogStick,StickX?: number,StickY?: number): {StickX: number, StickY: number};
	/**
	 * Returns the analog value for the given key/button.  If analog isn't supported, returns 1 for down and 0 for up.
	*/
	GetInputAnalogKeyState(Key: Key): number;
	/**
	 * Gets the HUD currently being used by this player controller
	*/
	GetHUD(): HUD;
	/**
	 * Get Hit Result Under Finger for Objects
	*/
	GetHitResultUnderFingerForObjects(FingerIndex: ETouchIndex,ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	/**
	 * Get Hit Result Under Finger by Channel
	*/
	GetHitResultUnderFingerByChannel(FingerIndex: ETouchIndex,TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	/**
	 * Get Hit Result Under Finger
	*/
	GetHitResultUnderFinger(FingerIndex: ETouchIndex,TraceChannel: ECollisionChannel,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	/**
	 * Get Hit Result Under Cursor for Objects
	*/
	GetHitResultUnderCursorForObjects(ObjectTypes: EObjectTypeQuery[],bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	/**
	 * Get Hit Result Under Cursor by Channel
	*/
	GetHitResultUnderCursorByChannel(TraceChannel: ETraceTypeQuery,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	/**
	 * Get Hit Result Under Cursor
	*/
	GetHitResultUnderCursor(TraceChannel: ECollisionChannel,bTraceComplex: boolean,HitResult?: HitResult): {HitResult: HitResult, $: boolean};
	/**
	 * Returns the location the PlayerController is focused on.
	 * If there is a possessed Pawn, returns the Pawn's location.
	 * If there is a spectator Pawn, returns that Pawn's location.
	 * Otherwise, returns the PlayerController's spawn location (usually the last known Pawn location after it has died).
	*/
	GetFocalLocation(): Vector;
	/**
	 * Set the field of view to NewFOV
	*/
	FOV(NewFOV: number): void;
	/**
	 * Enables cheats within the game
	*/
	EnableCheats(): void;
	/**
	 * Convert current mouse 2D position to World Space 3D position and direction. Returns false if unable to determine value. *
	*/
	ConvertScreenLocationToWorldSpace(ScreenX: number,ScreenY: number,WorldLocation?: Vector,WorldDirection?: Vector): {WorldLocation: Vector, WorldDirection: Vector, $: boolean};
	/**
	 * Convert current mouse 2D position to World Space 3D position and direction. Returns false if unable to determine value. *
	*/
	ConvertMouseLocationToWorldSpace(WorldLocation?: Vector,WorldDirection?: Vector): {WorldLocation: Vector, WorldDirection: Vector, $: boolean};
	/**
	 * Console control commands, useful when remote debugging so you can't touch the console the normal way
	*/
	ConsoleKey(Key: Key): void;
	/**
	 * Notify client they were kicked from the server
	*/
	ClientWasKicked(KickReason: string): void;
	/**
	 * Tells the client that the server has all the information it needs and that it
	 * is ok to start sending voice packets. The server will already send voice packets
	 * when this function is called, since it is set server side and then forwarded
	 * NOTE: This is done as an RPC instead of variable replication because ordering matters
	*/
	ClientVoiceHandshakeComplete(): void;
	/**
	 * Replicated Update streaming status
	 * @param PackageName - Name of the level package name used for loading.
	 * @param bNewShouldBeLoaded - Whether the level should be loaded
	 * @param bNewShouldBeVisible - Whether the level should be visible if it is loaded
	 * @param bNewShouldBlockOnLoad - Whether we want to force a blocking load
	 * @param LODIndex                              - Current LOD index for a streaming level
	*/
	ClientUpdateLevelStreamingStatus(PackageName: string,bNewShouldBeLoaded: boolean,bNewShouldBeVisible: boolean,bNewShouldBlockOnLoad: boolean,LODIndex: number): void;
	/**
	 * Tell the client to unmute a player for this controller
	 * @param PlayerId player id to unmute
	*/
	ClientUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
	/**
	 * Internal clientside implementation of ClientTravel - use ClientTravel to call this
	 * @param URL                           A string containing the mapname (or IP address) to travel to, along with option key/value pairs
	 * @param TravelType            specifies whether the client should append URL options used in previous travels; if true is specified
	 *                                                      for the bSeamlesss parameter, this value must be TRAVEL_Relative.
	 * @param bSeamless                     Indicates whether to use seamless travel (requires TravelType of TRAVEL_Relative)
	 * @param MapPackageGuid        The GUID of the map package to travel to - this is used to find the file when it has been autodownloaded,
	 *                                                      so it is only needed for clients
	*/
	ClientTravelInternal(URL: string,TravelType: ETravelType,bSeamless: boolean,MapPackageGuid: Guid): void;
	/**
	 * Travel to a different map or IP address. Calls the PreClientTravel event before doing anything.
	 * NOTE: This is implemented as a locally executed wrapper for ClientTravelInternal, to avoid API compatability breakage
	 * @param URL                           A string containing the mapname (or IP address) to travel to, along with option key/value pairs
	 * @param TravelType            specifies whether the client should append URL options used in previous travels; if true is specified
	 *                                                      for the bSeamlesss parameter, this value must be TRAVEL_Relative.
	 * @param bSeamless                     Indicates whether to use seamless travel (requires TravelType of TRAVEL_Relative)
	 * @param MapPackageGuid        The GUID of the map package to travel to - this is used to find the file when it has been autodownloaded,
	 *                                                      so it is only needed for clients
	*/
	ClientTravel(URL: string,TravelType: ETravelType,bSeamless: boolean,MapPackageGuid: Guid): void;
	/**
	 * @todo document
	*/
	ClientTeamMessage(SenderPlayerState: PlayerState,S: string,Type: string,MsgLifeTime: number): void;
	/**
	 * Stops a playing force feedback pattern
	 * @param       ForceFeedbackEffect             If set only patterns from that effect will be stopped
	 * @param       Tag                                             If not none only the pattern with this tag will be stopped
	*/
	ClientStopForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect,Tag: string): void;
	/**
	 * Stop camera shake on client.
	*/
	ClientStopCameraShake(Shake: UnrealEngineClass,bImmediately: boolean): void;
	/**
	 * Stop camera animation on client.
	*/
	ClientStopCameraAnim(AnimToStop: CameraAnim): void;
	/**
	 * Notify client that the session is starting
	*/
	ClientStartOnlineSession(): void;
	/**
	 * Spawn a camera lens effect (e.g. blood).
	*/
	ClientSpawnCameraLensEffect(LensEffectEmitterClass: UnrealEngineClass): void;
	/**
	 * Set the view target
	 * @param A - new actor to set as view target
	 * @param TransitionParams - parameters to use for controlling the transition
	*/
	ClientSetViewTarget(A: Actor,TransitionParams: ViewTargetTransitionParams): void;
	/**
	 * Indicate that the Spectator is waiting to join/respawn.
	*/
	ClientSetSpectatorWaiting(bWaiting: boolean): void;
	/**
	 * Set the client's class of HUD and spawns a new instance of it. If there was already a HUD active, it is destroyed.
	*/
	ClientSetHUD(NewHUDClass: UnrealEngineClass): void;
	/**
	 * Forces the streaming system to disregard the normal logic for the specified duration and
	 * instead always load all mip-levels for all textures used by the specified material.
	 * @param Material              - The material whose textures should be forced into memory.
	 * @param ForceDuration - Number of seconds to keep all mip-levels in memory, disregarding the normal priority logic.
	 * @param CinematicTextureGroups        - Bitfield indicating which texture groups that use extra high-resolution mips
	*/
	ClientSetForceMipLevelsToBeResident(Material: MaterialInterface,ForceDuration: number,CinematicTextureGroups: number): void;
	/**
	 * Called by the server to synchronize cinematic transitions with the client
	*/
	ClientSetCinematicMode(bInCinematicMode: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean,bAffectsHUD: boolean): void;
	/**
	 * Replicated function to set camera style on client
	 * @param       NewCamMode, name defining the new camera mode
	*/
	ClientSetCameraMode(NewCamMode: string): void;
	/**
	 * Tell client to fade camera
	 * @Param bEnableFading - true if we should apply FadeColor/FadeAmount to the screen
	 * @Param FadeColor - Color to fade to
	 * @Param FadeAlpha - Amount of fading to apply
	 * @Param FadeTime - length of time for fade to occur over
	 * @Param bFadeAudio - true to apply fading of audio alongside the video
	*/
	ClientSetCameraFade(bEnableFading: boolean,FadeColor: Color,FadeAlpha: Vector2D,FadeTime: number,bFadeAudio: boolean): void;
	/**
	 * Tells the client to block until all pending level streaming actions are complete.
	 * Happens at the end of the tick primarily used to force update the client ASAP at join time.
	*/
	ClientSetBlockOnAsyncLoading(): void;
	/**
	 * Return the client to the main menu gracefully
	*/
	ClientReturnToMainMenu(ReturnReason: string): void;
	/**
	 * Assign Pawn to player, but avoid calling ClientRestart if we have already accepted this pawn
	*/
	ClientRetryClientRestart(NewPawn: Pawn): void;
	/**
	 * Tell client to restart the level
	*/
	ClientRestart(NewPawn: Pawn): void;
	/**
	 * Tell client to reset the PlayerController
	*/
	ClientReset(): void;
	/**
	 * Development RPC for testing object reference replication
	*/
	ClientRepObjRef(UObject: UObject): void;
	/**
	 * send client localized message id
	*/
	ClientReceiveLocalizedMessage(Message: UnrealEngineClass,Switch: number,RelatedPlayerState_1: PlayerState,RelatedPlayerState_2: PlayerState,OptionalObject: UObject): void;
	/**
	 * Forces the streaming system to disregard the normal logic for the specified duration and
	 * instead always load all mip-levels for all textures used by the specified actor.
	 * @param ForcedActor           - The actor whose textures should be forced into memory.
	 * @param ForceDuration         - Number of seconds to keep all mip-levels in memory, disregarding the normal priority logic.
	 * @param bEnableStreaming      - Whether to start (true) or stop (false) streaming
	 * @param CinematicTextureGroups        - Bitfield indicating which texture groups that use extra high-resolution mips
	*/
	ClientPrestreamTextures(ForcedActor: Actor,ForceDuration: number,bEnableStreaming: boolean,CinematicTextureGroups: number): void;
	/**
	 * Asynchronously loads the given level in preparation for a streaming map transition.
	 * the server sends one function per level name since dynamic arrays can't be replicated
	 * @param LevelNames - the names of the level packages to load. LevelNames[0] will be the new persistent (primary) level
	 * @param bFirst - whether this is the first item in the list (so clear the list first)
	 * @param bLast - whether this is the last item in the list (so start preparing the change after receiving it)
	*/
	ClientPrepareMapChange(LevelName: string,bFirst: boolean,bLast: boolean): void;
	/**
	 * Play sound client-side at the specified location
	 * @param Sound - Sound to play
	 * @param Location - Location to play the sound at
	 * @param VolumeMultiplier - Volume multiplier to apply to the sound
	 * @param PitchMultiplier - Pitch multiplier to apply to the sound
	*/
	ClientPlaySoundAtLocation(Sound: SoundBase,Location: Vector,VolumeMultiplier: number,PitchMultiplier: number): void;
	/**
	 * Play sound client-side (so only the client will hear it)
	 * @param Sound - Sound to play
	 * @param VolumeMultiplier - Volume multiplier to apply to the sound
	 * @param PitchMultiplier - Pitch multiplier to apply to the sound
	*/
	ClientPlaySound(Sound: SoundBase,VolumeMultiplier: number,PitchMultiplier: number): void;
	/**
	 * Play a force feedback pattern on the player's controller
	 * @param       ForceFeedbackEffect             The force feedback pattern to play
	 * @param       bLooping                                Whether the pattern should be played repeatedly or be a single one shot
	 * @param       Tag                                             A tag that allows stopping of an effect.  If another effect with this Tag is playing, it will be stopped and replaced
	*/
	ClientPlayForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect,bLooping: boolean,Tag: string): void;
	/**
	 * Play Camera Shake
	 * @param Shake - Camera shake animation to play
	 * @param Scale - Scalar defining how "intense" to play the anim
	 * @param PlaySpace - Which coordinate system to play the shake in (used for CameraAnims within the shake).
	 * @param UserPlaySpaceRot - Matrix used when PlaySpace = CAPS_UserDefined
	*/
	ClientPlayCameraShake(Shake: UnrealEngineClass,Scale: number,PlaySpace: ECameraAnimPlaySpace,UserPlaySpaceRot: Rotator): void;
	/**
	 * Play the indicated CameraAnim on this camera.
	 * @param AnimToPlay - Camera animation to play
	 * @param Scale - "Intensity" scalar.  This is the scale at which the anim was first played.
	 * @param Rate -  Multiplier for playback rate.  1.0 = normal.
	 * @param BlendInTime - Time to interpolate in from zero, for smooth starts
	 * @param BlendOutTime - Time to interpolate out to zero, for smooth finishes
	 * @param bLoop - True if the animation should loop, false otherwise
	 * @param bRandomStartTime - Whether or not to choose a random time to start playing.  Only really makes sense for bLoop = true
	 * @param Space - Animation play area
	 * @param CustomPlaySpace - Matrix used when Space = CAPS_UserDefined
	*/
	ClientPlayCameraAnim(AnimToPlay: CameraAnim,Scale: number,Rate: number,BlendInTime: number,BlendOutTime: number,bLoop: boolean,bRandomStartTime: boolean,Space: ECameraAnimPlaySpace,CustomPlaySpace: Rotator): void;
	/**
	 * Tell the client to mute a player for this controller
	 * @param PlayerId player id to mute
	*/
	ClientMutePlayer(PlayerId: UniqueNetIdRepl): void;
	/**
	 * Outputs a message to HUD
	 * @param S - message to display
	 * @param Type - @todo document
	 * @param MsgLifeTime - Optional length of time to display 0 = default time
	*/
	ClientMessage(S: string,Type: string,MsgLifeTime: number): void;
	/**
	 * calls IgnoreMoveInput on client
	*/
	ClientIgnoreMoveInput(bIgnore: boolean): void;
	/**
	 * calls IgnoreLookInput on client
	*/
	ClientIgnoreLookInput(bIgnore: boolean): void;
	/**
	 * Server uses this to force client into NewState .
	 * @Note ALL STATE NAMES NEED TO BE DEFINED IN name table in UnrealNames.h to be correctly replicated (so they are mapped to the same thing on client and server).
	*/
	ClientGotoState(NewState: string): void;
	/**
	 * Replicated function called by GameHasEnded().
	 * @param       EndGameFocus - actor to view with camera
	 * @param       bIsWinner - true if this controller is on winning team
	*/
	ClientGameEnded(EndGameFocus: Actor,bIsWinner: boolean): void;
	/**
	 * Forces GC at the end of the tick on the client
	*/
	ClientForceGarbageCollection(): void;
	/**
	 * Tells the client to block until all pending level streaming actions are complete
	 * happens at the end of the tick
	 * primarily used to force update the client ASAP at join time
	*/
	ClientFlushLevelStreaming(): void;
	/**
	 * Notify client that the session is about to start
	*/
	ClientEndOnlineSession(): void;
	/**
	 * Tell the client to enable or disable voice chat (not muting)
	 * @param bEnable enable or disable voice chat
	*/
	ClientEnableNetworkVoice(bEnable: boolean): void;
	/**
	 * Actually performs the level transition prepared by PrepareMapChange().
	*/
	ClientCommitMapChange(): void;
	/**
	 * Removes all Camera Lens Effects.
	*/
	ClientClearCameraLensEffects(): void;
	/**
	 * Set CurrentNetSpeed to the lower of its current value and Cap.
	*/
	ClientCapBandwidth(Cap: number): void;
	/**
	 * Tells client to cancel any pending map change.
	*/
	ClientCancelPendingMapChange(): void;
	/**
	 * Adds a location to the texture streaming system for the specified duration.
	*/
	ClientAddTextureStreamingLoc(InLoc: Vector,Duration: number,bOverrideLocation: boolean): void;
	/**
	 * Clear any overrides that have been applied to audio listener
	*/
	ClearAudioListenerOverride(): void;
	/**
	 * Change Camera mode
	 * @param       New camera mode to set
	*/
	Camera(NewMode: string): void;
	/**
	 * Add Yaw (turn) input. This value is multiplied by InputYawScale.
	 * @param Val Amount to add to Yaw. This value is multiplied by InputYawScale.
	*/
	AddYawInput(Val: number): void;
	/**
	 * Add Roll input. This value is multiplied by InputRollScale.
	 * @param Val Amount to add to Roll. This value is multiplied by InputRollScale.
	*/
	AddRollInput(Val: number): void;
	/**
	 * Add Pitch (look up) input. This value is multiplied by InputPitchScale.
	 * @param Val Amount to add to Pitch. This value is multiplied by InputPitchScale.
	*/
	AddPitchInput(Val: number): void;
	/**
	 * Activates a new touch interface for this player controller
	*/
	ActivateTouchInterface(NewTouchInterface: TouchInterface): void;
	static C(Other: UObject): PlayerController;
	/**
	 * Writes an integer value to the specified leaderboard
	*/
	WriteLeaderboardInteger(StatName: string,StatValue: number): boolean;
	/**
	 * Transforms the given 2D screen space coordinate into a 3D world-space point and direction.
	 * @param Player                        Deproject using this player's view.
	 * @param ScreenPosition        2D screen space to deproject.
	 * @param WorldPosition         (out) Corresponding 3D position in world space.
	 * @param WorldDirection        (out) World space direction vector away from the camera at the given 2d poiunt.
	*/
	DeprojectScreenToWorld(ScreenPosition: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	/**
	 * Gets what controller ID a Player is using
	 * @param Player         The player controller of the player to get the ID of
	 * @return                       The ID of the passed in player. -1 if there is no controller for the passed in player
	*/
	GetPlayerControllerID(): number;
	/**
	 * Transforms the given 3D world-space point into a its 2D screen space coordinate.
	 * @param Player                        Project using this player's view.
	 * @param WorldPosition         World position to project.
	 * @param ScreenPosition        (out) Corresponding 2D position in screen space
	*/
	ProjectWorldToScreen(WorldPosition: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	/**
	 * Removes a player from this game.
	 * @param Player                       The player controller of the player to be removed
	 * @param bDestroyPawn         Whether the controlled pawn should be deleted as well
	*/
	RemovePlayer(bDestroyPawn: boolean): void;
	/**
	 * Sets what controller ID a Player should be using
	 * @param Player                        The player controller of the player to change the controller ID of
	 * @param ControllerId          The controller ID to assign to this player
	*/
	SetPlayerControllerID(ControllerId: number): void;
	/**
	 * Returns whether the player is logged in to the currently active online subsystem.
	 * @param Player Specific player's login status to get. May not be supported on all platforms. If null, defaults to the player with ControllerId 0.
	*/
	IsLoggedIn(): boolean;
	/**
	 * Displays the built-in achievements GUI (iOS and Android only; this function may be renamed or moved in a future release)
	 * @param SpecificPlayer Specific player's achievements to show. May not be supported on all platforms. If null, defaults to the player with ControllerId 0
	*/
	ShowPlatformSpecificAchievementsScreen(): void;
	/**
	 * Gets the mouse position of the player controller, scaled by the DPI.  If you're trying to go from raw mouse screenspace coordinates
	 * to fullscreen widget space, you'll need to transform the mouse into DPI Scaled space.  This function performs that scaling.
	 * MousePositionScaledByDPI = MousePosition * (1 / ViewportScale).
	*/
	GetMousePositionScaledByDPI(LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	/**
	 * Gets the projected world to screen position for a player, then converts it into a widget
	 * position, which takes into account any quality scaling.
	 * @param PlayerController The player controller to project the position in the world to their screen.
	 * @param WorldLocation The world location to project from.
	 * @param ScreenPosition The position in the viewport with quality scale removed and DPI scale remove.
	 * @return true if the position projects onto the screen.
	*/
	ProjectWorldLocationToWidgetPosition(WorldLocation: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	/**
	 * Set Input Mode Game and UI
	*/
	SetInputModeGameAndUI(InWidgetToFocus: Widget,bLockMouseToViewport: boolean,bHideCursorDuringCapture: boolean): void;
	/**
	 * Setup an input mode that allows only the UI to respond to user input, and if the UI doesn't handle it player input / player controller gets a chance.
	*/
	SetInputModeGameAndUI(InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode,bHideCursorDuringCapture: boolean): void;
	/**
	 * Setup an input mode that allows only player input / player controller to respond to user input.
	*/
	SetInputMode_GameOnly(): void;
	/**
	 * Set Input Mode UIOnly
	*/
	SetInputModeUIOnly(InWidgetToFocus: Widget,bLockMouseToViewport: boolean): void;
	/**
	 * Setup an input mode that allows only the UI to respond to user input.
	*/
	SetInputModeUIOnly(InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode): void;
	/**
	 * Writes an integer value to the specified leaderboard
	*/
	static WriteLeaderboardInteger(PlayerController: PlayerController,StatName: string,StatValue: number): boolean;
	/**
	 * Transforms the given 2D screen space coordinate into a 3D world-space point and direction.
	 * @param Player                        Deproject using this player's view.
	 * @param ScreenPosition        2D screen space to deproject.
	 * @param WorldPosition         (out) Corresponding 3D position in world space.
	 * @param WorldDirection        (out) World space direction vector away from the camera at the given 2d poiunt.
	*/
	static DeprojectScreenToWorld(Player: PlayerController,ScreenPosition: Vector2D,WorldPosition?: Vector,WorldDirection?: Vector): {WorldPosition: Vector, WorldDirection: Vector, $: boolean};
	/**
	 * Gets what controller ID a Player is using
	 * @param Player         The player controller of the player to get the ID of
	 * @return                       The ID of the passed in player. -1 if there is no controller for the passed in player
	*/
	static GetPlayerControllerID(Player: PlayerController): number;
	/**
	 * Transforms the given 3D world-space point into a its 2D screen space coordinate.
	 * @param Player                        Project using this player's view.
	 * @param WorldPosition         World position to project.
	 * @param ScreenPosition        (out) Corresponding 2D position in screen space
	*/
	static ProjectWorldToScreen(Player: PlayerController,WorldPosition: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	/**
	 * Removes a player from this game.
	 * @param Player                       The player controller of the player to be removed
	 * @param bDestroyPawn         Whether the controlled pawn should be deleted as well
	*/
	static RemovePlayer(Player: PlayerController,bDestroyPawn: boolean): void;
	/**
	 * Sets what controller ID a Player should be using
	 * @param Player                        The player controller of the player to change the controller ID of
	 * @param ControllerId          The controller ID to assign to this player
	*/
	static SetPlayerControllerID(Player: PlayerController,ControllerId: number): void;
	/**
	 * Returns whether the player is logged in to the currently active online subsystem.
	 * @param Player Specific player's login status to get. May not be supported on all platforms. If null, defaults to the player with ControllerId 0.
	*/
	static IsLoggedIn(SpecificPlayer: PlayerController): boolean;
	/**
	 * Displays the built-in achievements GUI (iOS and Android only; this function may be renamed or moved in a future release)
	 * @param SpecificPlayer Specific player's achievements to show. May not be supported on all platforms. If null, defaults to the player with ControllerId 0
	*/
	static ShowPlatformSpecificAchievementsScreen(SpecificPlayer: PlayerController): void;
	/**
	 * Gets the mouse position of the player controller, scaled by the DPI.  If you're trying to go from raw mouse screenspace coordinates
	 * to fullscreen widget space, you'll need to transform the mouse into DPI Scaled space.  This function performs that scaling.
	 * MousePositionScaledByDPI = MousePosition * (1 / ViewportScale).
	*/
	static GetMousePositionScaledByDPI(Player: PlayerController,LocationX?: number,LocationY?: number): {LocationX: number, LocationY: number, $: boolean};
	/**
	 * Gets the projected world to screen position for a player, then converts it into a widget
	 * position, which takes into account any quality scaling.
	 * @param PlayerController The player controller to project the position in the world to their screen.
	 * @param WorldLocation The world location to project from.
	 * @param ScreenPosition The position in the viewport with quality scale removed and DPI scale remove.
	 * @return true if the position projects onto the screen.
	*/
	static ProjectWorldLocationToWidgetPosition(PlayerController: PlayerController,WorldLocation: Vector,ScreenPosition?: Vector2D): {ScreenPosition: Vector2D, $: boolean};
	/**
	 * Set Input Mode Game and UI
	*/
	static SetInputModeGameAndUI(Target: PlayerController,InWidgetToFocus: Widget,bLockMouseToViewport: boolean,bHideCursorDuringCapture: boolean): void;
	/**
	 * Setup an input mode that allows only the UI to respond to user input, and if the UI doesn't handle it player input / player controller gets a chance.
	*/
	static SetInputModeGameAndUI(Target: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode,bHideCursorDuringCapture: boolean): void;
	/**
	 * Setup an input mode that allows only player input / player controller to respond to user input.
	*/
	static SetInputMode_GameOnly(Target: PlayerController): void;
	/**
	 * Set Input Mode UIOnly
	*/
	static SetInputModeUIOnly(Target: PlayerController,InWidgetToFocus: Widget,bLockMouseToViewport: boolean): void;
	/**
	 * Setup an input mode that allows only the UI to respond to user input.
	*/
	static SetInputModeUIOnly(Target: PlayerController,InWidgetToFocus: Widget,InMouseLockMode: EMouseLockMode): void;
}

declare class Controller extends Actor { 
	/**
	 * Pawn currently being controlled by this controller.  Use Pawn.Possess() to take control of a pawn
	*/
	Pawn: Pawn;
	/**
	 * Character currently being controlled by this controller.  Value is same as Pawn if the controlled pawn is a character, otherwise NULL
	*/
	Character: Character;
	/**
	 * PlayerState containing replicated information about the player using this controller (only exists for players, not NPCs).
	*/
	PlayerState: PlayerState;
	/**
	 * Transform Component
	*/
	TransformComponent: SceneComponent;
	/**
	 * The control rotation of the Controller. See GetControlRotation.
	*/
	ControlRotation: Rotator;
	/**
	 * If true, the controller location will match the possessed Pawn's location. If false, it will not be updated. Rotation will match ControlRotation in either case.
	 * Since a Controller's location is normally inaccessible, this is intended mainly for purposes of being able to attach
	 * an Actor that follows the possessed Pawn location, but that still has the full aim rotation (since a Pawn might
	 * update only some components of the rotation).
	*/
	bAttachToPawn: boolean;
	/**
	 * Whether this controller is a PlayerController.
	*/
	bIsPlayerController: boolean;
	/**
	 * CONTROLLER STATE PROPERTIES
	*/
	StateName: string;
	/**
	 * Called when the controller has instigated damage in any way
	*/
	OnInstigatedAnyDamage: UnrealEngineMulticastDelegate<(Damage: number, DamageType: DamageType, DamagedActor: Actor, DamageCauser: Actor) => void>;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Controller;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Controller;
	/**
	 * Called to unpossess our pawn for any reason that is not the pawn being destroyed (destruction handled by PawnDestroyed()).
	*/
	UnPossess(): void;
	/**
	 * Aborts the move the controller is currently performing
	*/
	StopMovement(): void;
	/**
	 * Set the initial location and rotation of the controller, as well as the control rotation. Typically used when the controller is first created.
	*/
	SetInitialLocationAndRotation(NewLocation: Vector,NewRotation: Rotator): void;
	/**
	 * Locks or unlocks movement input, consecutive calls stack up and require the same amount of calls to undo, or can all be undone using ResetIgnoreMoveInput.
	 * @param bNewMoveInput  If true, move input is ignored. If false, input is not ignored.
	*/
	SetIgnoreMoveInput(bNewMoveInput: boolean): void;
	/**
	 * Locks or unlocks look input, consecutive calls stack up and require the same amount of calls to undo, or can all be undone using ResetIgnoreLookInput.
	 * @param bNewLookInput  If true, look input is ignored. If false, input is not ignored.
	*/
	SetIgnoreLookInput(bNewLookInput: boolean): void;
	/**
	 * Set the control rotation.
	*/
	SetControlRotation(NewRotation: Rotator): void;
	/**
	 * Stops ignoring move input by resetting the ignore move input state.
	*/
	ResetIgnoreMoveInput(): void;
	/**
	 * Stops ignoring look input by resetting the ignore look input state.
	*/
	ResetIgnoreLookInput(): void;
	/**
	 * Reset move and look input ignore flags.
	*/
	ResetIgnoreInputFlags(): void;
	/**
	 * Event when this controller instigates ANY damage
	*/
	ReceiveInstigatedAnyDamage(Damage: number,DamageType: DamageType,DamagedActor: Actor,DamageCauser: Actor): void;
	/**
	 * Handles attaching this controller to the specified pawn.
	 * Only runs on the network authority (where HasAuthority() returns true).
	 * @param InPawn The Pawn to be possessed.
	 * @see HasAuthority()
	*/
	Possess(InPawn: Pawn): void;
	/**
	 * On Rep Player State
	*/
	OnRep_PlayerState(): void;
	/**
	 * Replication Notification Callbacks
	*/
	OnRep_Pawn(): void;
	/**
	 * Checks line to center and top of other actor
	 * @param Other is the actor whose visibility is being checked.
	 * @param ViewPoint is eye position visibility is being checked from.  If vect(0,0,0) passed in, uses current viewtarget's eye position.
	 * @param bAlternateChecks used only in AIController implementation
	 * @return true if controller's pawn can see Other actor.
	*/
	LineOfSightTo(Other: Actor,ViewPoint: Vector,bAlternateChecks: boolean): boolean;
	/**
	 * Return the Pawn that is currently 'controlled' by this PlayerController
	*/
	GetControlledPawn(): Pawn;
	/**
	 * Returns whether this Controller is a PlayerController.
	*/
	IsPlayerController(): boolean;
	/**
	 * Returns true if movement input is ignored.
	*/
	IsMoveInputIgnored(): boolean;
	/**
	 * Returns true if look input is ignored.
	*/
	IsLookInputIgnored(): boolean;
	/**
	 * Returns whether this Controller is a locally controlled PlayerController.
	*/
	IsLocalPlayerController(): boolean;
	/**
	 * Returns whether this Controller is a local controller.
	*/
	IsLocalController(): boolean;
	/**
	 * Get the actor the controller is looking at
	*/
	GetViewTarget(): Actor;
	/**
	 * Get the desired pawn target rotation
	*/
	GetDesiredRotation(): Rotator;
	/**
	 * Get the control rotation. This is the full aim rotation, which may be different than a camera orientation (for example in a third person view),
	 * and may differ from the rotation of the controlled Pawn (which may choose not to visually pitch or roll, for example).
	*/
	GetControlRotation(): Rotator;
	/**
	 * Replicated function to set the pawn rotation, allowing the server to force.
	*/
	ClientSetRotation(NewRotation: Rotator,bResetCamera: boolean): void;
	/**
	 * Replicated function to set the pawn location and rotation, allowing server to force (ex. teleports).
	*/
	ClientSetLocation(NewLocation: Vector,NewRotation: Rotator): void;
	/**
	 * Cast to Player Controller
	*/
	CastToPlayerController(): PlayerController;
	static C(Other: UObject): Controller;
	/**
	 * Simple Move to Actor
	*/
	SimpleMoveToActor(Goal: Actor): void;
	/**
	 * Simple Move to Location
	*/
	SimpleMoveToLocation(Goal: Vector): void;
	/**
	 * Simple Move to Actor
	*/
	static SimpleMoveToActor(Controller: Controller,Goal: Actor): void;
	/**
	 * Simple Move to Location
	*/
	static SimpleMoveToLocation(Controller: Controller,Goal: Vector): void;
}

declare class Pawn extends Actor { 
	/**
	 * If true, this Pawn's pitch will be updated to match the Controller's ControlRotation pitch, if controlled by a PlayerController.
	*/
	bUseControllerRotationPitch: boolean;
	/**
	 * If true, this Pawn's yaw will be updated to match the Controller's ControlRotation yaw, if controlled by a PlayerController.
	*/
	bUseControllerRotationYaw: boolean;
	/**
	 * If true, this Pawn's roll will be updated to match the Controller's ControlRotation roll, if controlled by a PlayerController.
	*/
	bUseControllerRotationRoll: boolean;
	/**
	 * If set to false (default) given pawn instance will never affect navigation generation.
	 *     Setting it to true will result in using regular AActor's navigation relevancy
	 *     calculation to check if this pawn instance should affect navigation generation
	 *     Use SetCanAffectNavigationGeneration to change this value at runtime.
	 *     Note that modifying this value at runtime will result in any navigation change only if runtime navigation generation is enabled.
	*/
	bCanAffectNavigationGeneration: boolean;
	/**
	 * Base eye height above collision center.
	*/
	BaseEyeHeight: number;
	/**
	 * Determines which PlayerController, if any, should automatically possess the pawn when the level starts or when the pawn is spawned.
	 * @see AutoPossessAI
	*/
	AutoPossessPlayer: EAutoReceiveInput;
	/**
	 * Determines when the Pawn creates and is possessed by an AI Controller (on level start, when spawned, etc).
	 * Only possible if AIControllerClass is set, and ignored if AutoPossessPlayer is enabled.
	 * @see AutoPossessPlayer
	*/
	AutoPossessAI: EAutoPossessAI;
	/**
	 * Default class to use when pawn is controlled by AI.
	*/
	AIControllerClass: UnrealEngineClass;
	/**
	 * If Pawn is possessed by a player, points to his playerstate.  Needed for network play as controllers are not replicated to clients.
	*/
	PlayerState: PlayerState;
	/**
	 * Replicated so we can see where remote clients are looking.
	*/
	RemoteViewPitch: number;
	/**
	 * Controller of the last Actor that caused us damage.
	*/
	LastHitBy: Controller;
	/**
	 * Controller currently possessing this Actor
	*/
	Controller: Controller;
	/**
	 * Accumulated control input vector, stored in world space. This is the pending input, which is cleared (zeroed) once consumed.
	 * @see GetPendingMovementInputVector(), AddMovementInput()
	*/
	ControlInputVector: Vector;
	/**
	 * The last control input vector that was processed by ConsumeMovementInputVector().
	 * @see GetLastMovementInputVector()
	*/
	LastControlInputVector: Vector;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Pawn;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Pawn;
	/**
	 * Spawn default controller for this Pawn, and get possessed by it.
	*/
	SpawnDefaultController(): void;
	/**
	 * Use SetCanAffectNavigationGeneration to change this value at runtime.
	 *     Note that calling this function at runtime will result in any navigation change only if runtime navigation generation is enabled.
	*/
	SetCanAffectNavigationGeneration(bNewValue: boolean,bForceUpdate: boolean): void;
	/**
	 * Event called when the Pawn is no longer possessed by a Controller.
	*/
	Unpossessed(OldController: Controller): void;
	/**
	 * Event called when the Pawn is possessed by a Controller (normally only occurs on the server/standalone).
	*/
	Possessed(NewController: Controller): void;
	/**
	 * Inform AIControllers that you've made a noise they might hear (they are sent a HearNoise message if they have bHearNoises==true)
	 * The instigator of this sound is the pawn which is used to call MakeNoise.
	 * @param Loudness - is the relative loudness of this noise (range 0.0 to 1.0).  Directly affects the hearing range specified by the AI's HearingThreshold.
	 * @param NoiseLocation - Position of noise source.  If zero vector, use the actor's location.
	 * @param bUseNoiseMakerLocation - If true, use the location of the NoiseMaker rather than NoiseLocation.  If false, use NoiseLocation.
	 * @param NoiseMaker - Which actor is the source of the noise.  Not to be confused with the Noise Instigator, which is responsible for the noise (and is the pawn on which this function is called).  If not specified, the pawn instigating the noise will be used as the NoiseMaker
	*/
	PawnMakeNoise(Loudness: number,NoiseLocation: Vector,bUseNoiseMakerLocation: boolean,NoiseMaker: Actor): void;
	/**
	 * PlayerState Replication Notification Callback
	*/
	OnRep_PlayerState(): void;
	/**
	 * Called when Controller is replicated
	*/
	OnRep_Controller(): void;
	/**
	 * Launch Pawn
	*/
	LaunchPawn(LaunchVelocity: Vector,bXYOverride: boolean,bZOverride: boolean): void;
	/**
	 * (Deprecated) Return the input vector in world space.
	*/
	GetMovementInputVector(): Vector;
	/**
	 * @return true if controlled by a human player (possessed by a PlayerController).
	*/
	IsPlayerControlled(): boolean;
	/**
	 * Helper to see if move input is ignored. If our controller is a PlayerController, checks Controller->IsMoveInputIgnored().
	*/
	IsMoveInputIgnored(): boolean;
	/**
	 * @return true if controlled by a local (not network) Controller.
	*/
	IsLocallyControlled(): boolean;
	/**
	 * See if this actor is currently being controlled
	*/
	IsControlled(): boolean;
	/**
	 * Return the pending input vector in world space. This is the most up-to-date value of the input vector, pending ConsumeMovementInputVector() which clears it,
	 * Usually only a PawnMovementComponent will want to read this value, or the Pawn itself if it is responsible for movement.
	 * @return The pending input vector in world space.
	 * @see AddMovementInput(), GetLastMovementInputVector(), ConsumeMovementInputVector()
	*/
	GetPendingMovementInputVector(): Vector;
	/**
	 * Basically retrieved pawn's location on navmesh
	*/
	GetNavAgentLocation(): Vector;
	/**
	 * Return our PawnMovementComponent, if we have one.
	*/
	GetMovementComponent(): PawnMovementComponent;
	/**
	 * Gets the owning actor of the Movement Base Component on which the pawn is standing.
	*/
	static GetMovementBaseActor(Pawn: Pawn): Actor;
	/**
	 * Return the last input vector in world space that was processed by ConsumeMovementInputVector(), which is usually done by the Pawn or PawnMovementComponent.
	 * Any user that needs to know about the input that last affected movement should use this function.
	 * For example an animation update would want to use this, since by default the order of updates in a frame is:
	 * PlayerController (device input) -> MovementComponent -> Pawn -> Mesh (animations)
	 * @return The last input vector in world space that was processed by ConsumeMovementInputVector().
	 * @see AddMovementInput(), GetPendingMovementInputVector(), ConsumeMovementInputVector()
	*/
	GetLastMovementInputVector(): Vector;
	/**
	 * Get the rotation of the Controller, often the 'view' rotation of this Pawn.
	*/
	GetControlRotation(): Rotator;
	/**
	 * Returns controller for this actor.
	*/
	GetController(): Controller;
	/**
	 * Return the aim rotation for the Pawn.
	 * If we have a controller, by default we aim at the player's 'eyes' direction
	 * that is by default the Pawn rotation for AI, and camera (crosshair) rotation for human players.
	*/
	GetBaseAimRotation(): Rotator;
	/**
	 * Call this function to detach safely pawn from its controller, knowing that we will be destroyed soon.
	*/
	DetachFromControllerPendingDestroy(): void;
	/**
	 * Returns the pending input vector and resets it to zero.
	 * This should be used during a movement update (by the Pawn or PawnMovementComponent) to prevent accumulation of control input between frames.
	 * Copies the pending input vector to the saved input vector (GetLastMovementInputVector()).
	 * @return The pending input vector.
	*/
	ConsumeMovementInputVector(): Vector;
	/**
	 * Add movement input along the given world direction vector (usually normalized) scaled by 'ScaleValue'. If ScaleValue < 0, movement will be in the opposite direction.
	 * Base Pawn classes won't automatically apply movement, it's up to the user to do so in a Tick event. Subclasses such as Character and DefaultPawn automatically handle this input and move.
	 * @param WorldDirection        Direction in world space to apply input
	 * @param ScaleValue            Scale to apply to input. This can be used for analog input, ie a value of 0.5 applies half the normal value, while -1.0 would reverse the direction.
	 * @param bForce                        If true always add the input, ignoring the result of IsMoveInputIgnored().
	 * @see GetPendingMovementInputVector(), GetLastMovementInputVector(), ConsumeMovementInputVector()
	*/
	AddMovementInput(WorldDirection: Vector,ScaleValue: number,bForce: boolean): void;
	/**
	 * Add input (affecting Yaw) to the Controller's ControlRotation, if it is a local PlayerController.
	 * This value is multiplied by the PlayerController's InputYawScale value.
	 * @param Val Amount to add to Yaw. This value is multiplied by the PlayerController's InputYawScale value.
	 * @see PlayerController::InputYawScale
	*/
	AddControllerYawInput(Val: number): void;
	/**
	 * Add input (affecting Roll) to the Controller's ControlRotation, if it is a local PlayerController.
	 * This value is multiplied by the PlayerController's InputRollScale value.
	 * @param Val Amount to add to Roll. This value is multiplied by the PlayerController's InputRollScale value.
	 * @see PlayerController::InputRollScale
	*/
	AddControllerRollInput(Val: number): void;
	/**
	 * Add input (affecting Pitch) to the Controller's ControlRotation, if it is a local PlayerController.
	 * This value is multiplied by the PlayerController's InputPitchScale value.
	 * @param Val Amount to add to Pitch. This value is multiplied by the PlayerController's InputPitchScale value.
	 * @see PlayerController::InputPitchScale
	*/
	AddControllerPitchInput(Val: number): void;
	static C(Other: UObject): Pawn;
	/**
	 * Send AIMessage
	*/
	SendAIMessage(Message: string,MessageSource: UObject,bSuccess: boolean): void;
	/**
	 * Send AIMessage
	*/
	static SendAIMessage(Target: Pawn,Message: string,MessageSource: UObject,bSuccess: boolean): void;
}

declare type ERadialImpulseFalloff = string | symbol;
declare var ERadialImpulseFalloff = { RIF_Constant:'RIF_Constant',RIF_Linear:'RIF_Linear', };
declare type EOverlapFilterOption = string | symbol;
declare var EOverlapFilterOption = { OverlapFilter_All:'OverlapFilter_All',OverlapFilter_DynamicOnly:'OverlapFilter_DynamicOnly',OverlapFilter_StaticOnly:'OverlapFilter_StaticOnly', };
declare class PrimitiveComponent extends SceneComponent { 
	/**
	 * The minimum distance at which the primitive should be rendered,
	 * measured in world space units from the center of the primitive's bounding sphere to the camera position.
	*/
	MinDrawDistance: number;
	/**
	 * Max draw distance exposed to LDs. The real max draw distance is the min (disregarding 0) of this and volumes affecting this object.
	*/
	LDMaxDrawDistance: number;
	/**
	 * The distance to cull this primitive at.
	 * A CachedMaxDrawDistance of 0 indicates that the primitive should not be culled by distance.
	*/
	CachedMaxDrawDistance: number;
	/**
	 * The scene depth priority group to draw the primitive in.
	*/
	DepthPriorityGroup: ESceneDepthPriorityGroup;
	/**
	 * The scene depth priority group to draw the primitive in, if it's being viewed by its owner.
	*/
	ViewOwnerDepthPriorityGroup: ESceneDepthPriorityGroup;
	/**
	 * Indicates if we'd like to create physics state all the time (for collision and simulation).
	 * If you set this to false, it still will create physics state if collision or simulation activated.
	 * This can help performance if you'd like to avoid overhead of creating physics state when triggers
	*/
	bAlwaysCreatePhysicsState: boolean;
	/**
	 * If true, this component will generate overlap events when it is overlapping other components (eg Begin Overlap).
	 * Both components (this and the other) must have this enabled for overlap events to occur.
	 * @see [Overlap Events](https://docs.unrealengine.com/latest/INT/Engine/Physics/Collision/index.html#overlapandgenerateoverlapevents)
	 * @see UpdateOverlaps(), BeginComponentOverlap(), EndComponentOverlap()
	*/
	bGenerateOverlapEvents: boolean;
	/**
	 * If true, this component will generate individual overlaps for each overlapping physics body if it is a multi-body component. When false, this component will
	 * generate only one overlap, regardless of how many physics bodies it has and how many of them are overlapping another component/body. This flag has no
	 * influence on single body components.
	*/
	bMultiBodyOverlap: boolean;
	/**
	 * If true, this component will look for collisions on both physic scenes during movement.
	 * Only required if the asynchronous physics scene is enabled and has geometry in it, and you wish to test for collisions with objects in that scene.
	 * @see MoveComponent()
	*/
	bCheckAsyncSceneOnMove: boolean;
	/**
	 * If true, component sweeps with this component should trace against complex collision during movement (for example, each triangle of a mesh).
	 * If false, collision will be resolved against simple collision bounds instead.
	 * @see MoveComponent()
	*/
	bTraceComplexOnMove: boolean;
	/**
	 * If true, component sweeps will return the material in their hit result.
	 * @see MoveComponent(), FHitResult
	*/
	bReturnMaterialOnMove: boolean;
	/**
	 * True if the primitive should be rendered using ViewOwnerDepthPriorityGroup if viewed by its owner.
	*/
	bUseViewOwnerDepthPriorityGroup: boolean;
	/**
	 * Whether to accept cull distance volumes to modify cached cull distance.
	*/
	bAllowCullDistanceVolume: boolean;
	/**
	 * true if the primitive has motion blur velocity meshes
	*/
	bHasMotionBlurVelocityMeshes: boolean;
	/**
	 * If true, this component will be rendered in the main pass (z prepass, basepass, transparency)
	*/
	bRenderInMainPass: boolean;
	/**
	 * Whether the primitive receives decals.
	*/
	bReceivesDecals: boolean;
	/**
	 * If this is True, this component won't be visible when the view actor is the component's owner, directly or indirectly.
	*/
	bOwnerNoSee: boolean;
	/**
	 * If this is True, this component will only be visible when the view actor is the component's owner, directly or indirectly.
	*/
	bOnlyOwnerSee: boolean;
	/**
	 * Treat this primitive as part of the background for occlusion purposes. This can be used as an optimization to reduce the cost of rendering skyboxes, large ground planes that are part of the vista, etc.
	*/
	bTreatAsBackgroundForOcclusion: boolean;
	/**
	 * Whether to render the primitive in the depth only pass.
	 * This should generally be true for all objects, and let the renderer make decisions about whether to render objects in the depth only pass.
	 * @todo - if any rendering features rely on a complete depth only pass, this variable needs to go away.
	*/
	bUseAsOccluder: boolean;
	/**
	 * If this is True, this component can be selected in the editor.
	*/
	bSelectable: boolean;
	/**
	 * If true, forces mips for textures used by this component to be resident when this component's level is loaded.
	*/
	bForceMipStreaming: boolean;
	/**
	 * If true a hit-proxy will be generated for each instance of instanced static meshes
	*/
	bHasPerInstanceHitProxies: boolean;
	/**
	 * Controls whether the primitive component should cast a shadow or not.
	 * This flag is ignored (no shadows will be generated) if all materials on this component have an Unlit shading model.
	*/
	CastShadow: boolean;
	/**
	 * Controls whether the primitive should inject light into the Light Propagation Volume.  This flag is only used if CastShadow is true. *
	*/
	bAffectDynamicIndirectLighting: boolean;
	/**
	 * Controls whether the primitive should affect dynamic distance field lighting methods.  This flag is only used if CastShadow is true. *
	*/
	bAffectDistanceFieldLighting: boolean;
	/**
	 * Controls whether the primitive should cast shadows in the case of non precomputed shadowing.  This flag is only used if CastShadow is true. *
	*/
	bCastDynamicShadow: boolean;
	/**
	 * Whether the object should cast a static shadow from shadow casting lights.  This flag is only used if CastShadow is true.
	*/
	bCastStaticShadow: boolean;
	/**
	 * Whether the object should cast a volumetric translucent shadow.
	 * Volumetric translucent shadows are useful for primitives with smoothly changing opacity like particles representing a volume,
	 * But have artifacts when used on highly opaque surfaces.
	*/
	bCastVolumetricTranslucentShadow: boolean;
	/**
	 * When enabled, the component will only cast a shadow on itself and not other components in the world.
	 * This is especially useful for first person weapons, and forces bCastInsetShadow to be enabled.
	*/
	bSelfShadowOnly: boolean;
	/**
	 * When enabled, the component will be rendering into the far shadow cascades (only for directional lights).
	*/
	bCastFarShadow: boolean;
	/**
	 * Whether this component should create a per-object shadow that gives higher effective shadow resolution.
	 * Useful for cinematic character shadowing. Assumed to be enabled if bSelfShadowOnly is enabled.
	*/
	bCastInsetShadow: boolean;
	/**
	 * Whether this component should cast shadows from lights that have bCastShadowsFromCinematicObjectsOnly enabled.
	 * This is useful for characters in a cinematic with special cinematic lights, where the cost of shadowmap rendering of the environment is undesired.
	*/
	bCastCinematicShadow: boolean;
	/**
	 * If true, the primitive will cast shadows even if bHidden is true.
	 * Controls whether the primitive should cast shadows when hidden.
	 * This flag is only used if CastShadow is true.
	*/
	bCastHiddenShadow: boolean;
	/**
	 * Whether this primitive should cast dynamic shadows as if it were a two sided material.
	*/
	bCastShadowAsTwoSided: boolean;
	/**
	 * Whether to light this primitive as if it were static, including generating lightmaps.
	 * This only has an effect for component types that can bake lighting, like static mesh components.
	 * This is useful for moving meshes that don't change significantly.
	*/
	bLightAsIfStatic: boolean;
	/**
	 * Whether to light this component and any attachments as a group.  This only has effect on the root component of an attachment tree.
	 * When enabled, attached component shadowing settings like bCastInsetShadow, bCastVolumetricTranslucentShadow, etc, will be ignored.
	 * This is useful for improving performance when multiple movable components are attached together.
	*/
	bLightAttachmentsAsGroup: boolean;
	/**
	 * Quality of indirect lighting for Movable primitives.  This has a large effect on Indirect Lighting Cache update time.
	*/
	IndirectLightingCacheQuality: EIndirectLightingCacheQuality;
	/**
	 * Mobile only:
	 * If enabled this component can receive combined static and CSM shadows from a stationary light. (Enabling will increase shading cost.)
	 * If disabled this component will only receive static shadows from stationary lights.
	*/
	bReceiveCombinedCSMAndStaticShadowsFromStationaryLights: boolean;
	/**
	 * Whether the whole component should be shadowed as one from stationary lights, which makes shadow receiving much cheaper.
	 * When enabled shadowing data comes from the volume lighting samples precomputed by Lightmass, which are very sparse.
	 * This is currently only used on stationary directional lights.
	*/
	bSingleSampleShadowFromStationaryLights: boolean;
	/**
	 * Channels that this component should be in.  Lights with matching channels will affect the component.
	 * These channels only apply to opaque materials, direct lighting, and dynamic lighting and shadowing.
	*/
	LightingChannels: LightingChannels;
	/**
	 * Has Cached Static Lighting
	*/
	bHasCachedStaticLighting: boolean;
	/**
	 * If true, asynchronous static build lighting will be enqueued to be applied to this
	*/
	bStaticLightingBuildEnqueued: boolean;
	/**
	 * Will ignore radial impulses applied to this component.
	*/
	bIgnoreRadialImpulse: boolean;
	/**
	 * Will ignore radial forces applied to this component.
	*/
	bIgnoreRadialForce: boolean;
	/**
	 * If this is True, this component must always be loaded on clients, even if Hidden and CollisionEnabled is NoCollision.
	*/
	AlwaysLoadOnClient: boolean;
	/**
	 * If this is True, this component must always be loaded on servers, even if Hidden and CollisionEnabled is NoCollision
	*/
	AlwaysLoadOnServer: boolean;
	/**
	 * Composite the drawing of this component onto the scene after post processing (only applies to editor drawing)
	*/
	bUseEditorCompositing: boolean;
	/**
	 * If true, this component will be rendered in the CustomDepth pass (usually used for outlines)
	*/
	bRenderCustomDepth: boolean;
	/**
	 * Optionally write this 0-255 value to the stencil buffer in CustomDepth pass (Requires project setting or r.CustomDepth == 3)
	*/
	CustomDepthStencilValue: number;
	/**
	 * Translucent objects with a lower sort priority draw behind objects with a higher priority.
	 * Translucent objects with the same priority are rendered from back-to-front based on their bounds origin.
	 * Ignored if the object is not translucent.  The default priority is zero.
	 * Warning: This should never be set to a non-default value unless you know what you are doing, as it will prevent the renderer from sorting correctly.
	 * It is especially problematic on dynamic gameplay effects.
	*/
	TranslucencySortPriority: number;
	/**
	 * Used for precomputed visibility
	*/
	VisibilityId: number;
	/**
	 * Multiplier used to scale the Light Propagation Volume light injection bias, to reduce light bleeding.
	 * Set to 0 for no bias, 1 for default or higher for increased biasing (e.g. for
	 * thin geometry such as walls)
	*/
	LpvBiasMultiplier: number;
	/**
	 * Physics scene information for this component, holds a single rigid body with multiple shapes.
	*/
	BodyInstance: BodyInstance;
	/**
	 * If true then DoCustomNavigableGeometryExport will be called to collect navigable geometry of this component.
	*/
	bHasCustomNavigableGeometry: EHasCustomNavigableGeometry;
	/**
	 * Scales the bounds of the object.
	 * This is useful when using World Position Offset to animate the vertices of the object outside of its bounds.
	 * Warning: Increasing the bounds of an object will reduce performance and shadow quality!
	 * Currently only used by StaticMeshComponent and SkeletalMeshComponent.
	*/
	BoundsScale: number;
	/**
	 * Last time the component was submitted for rendering (called FScene::AddPrimitive).
	*/
	LastSubmitTime: number;
	/**
	 * The value of WorldSettings->TimeSeconds for the frame when this component was last rendered.  This is written
	 * from the render thread, which is up to a frame behind the game thread, so you should allow this time to
	 * be at least a frame behind the game thread's world time before you consider the actor non-visible.
	*/
	LastRenderTime: number;
	/**
	 * Last Render Time on Screen
	*/
	LastRenderTimeOnScreen: number;
	/**
	 * Can be Character Base
	*/
	CanBeCharacterBase: ECanBeCharacterBase;
	/**
	 * Determine whether a Character can step up onto this component.
	 * This controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.
	 * @see FWalkableSlopeOverride
	*/
	CanCharacterStepUpOn: ECanBeCharacterBase;
	/**
	 * Set of actors to ignore during component sweeps in MoveComponent().
	 * All components owned by these actors will be ignored when this component moves or updates overlaps.
	 * Components on the other Actor may also need to be told to do the same when they move.
	 * Does not affect movement of this component when simulating physics.
	 * @see IgnoreActorWhenMoving()
	*/
	MoveIgnoreActors: Actor[];
	/**
	 * Event called when a component hits (or is hit by) something solid. This could happen due to things like Character movement, using Set Location with 'sweep' enabled, or physics simulation.
	 * For events when objects overlap (e.g. walking into a trigger) see the 'Overlap' event.
	 * @note For collisions during physics simulation to generate hit events, 'Simulation Generates Hit Events' must be enabled for this component.
	 * @note When receiving a hit from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal'
	 * will be adjusted to indicate force from the other object against this object.
	*/
	OnComponentHit: UnrealEngineMulticastDelegate<(HitComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, NormalImpulse: Vector, Hit: HitResult) => void>;
	/**
	 * Event called when something starts to overlaps this component, for example a player walking into a trigger.
	 * For events when objects have a blocking collision, for example a player hitting a wall, see 'Hit' events.
	 * @note Both this component and the other one must have bGenerateOverlapEvents set to true to generate overlap events.
	 * @note When receiving an overlap from another object's movement, the directions of 'Hit.Normal' and 'Hit.ImpactNormal'
	 * will be adjusted to indicate force from the other object against this object.
	*/
	OnComponentBeginOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
	/**
	 * Event called when something stops overlapping this component
	 * @note Both this component and the other one must have bGenerateOverlapEvents set to true to generate overlap events.
	*/
	OnComponentEndOverlap: UnrealEngineMulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number) => void>;
	/**
	 * Event called when the underlying physics objects is woken up
	*/
	OnComponentWake: UnrealEngineMulticastDelegate<(WakingComponent: PrimitiveComponent, BoneName: string) => void>;
	/**
	 * Event called when the underlying physics objects is put to sleep
	*/
	OnComponentSleep: UnrealEngineMulticastDelegate<(SleepingComponent: PrimitiveComponent, BoneName: string) => void>;
	/**
	 * Event called when the mouse cursor is moved over this component and mouse over events are enabled in the player controller
	*/
	OnBeginCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	/**
	 * Event called when the mouse cursor is moved off this component and mouse over events are enabled in the player controller
	*/
	OnEndCursorOver: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
	/**
	 * Event called when the left mouse button is clicked while the mouse is over this component and click events are enabled in the player controller
	*/
	OnClicked: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonPressed: Key) => void>;
	/**
	 * Event called when the left mouse button is released while the mouse is over this component click events are enabled in the player controller
	*/
	OnReleased: UnrealEngineMulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonReleased: Key) => void>;
	/**
	 * Event called when a touch input is received over this component when touch events are enabled in the player controller
	*/
	OnInputTouchBegin: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	/**
	 * Event called when a touch input is released over this component when touch events are enabled in the player controller
	*/
	OnInputTouchEnd: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	/**
	 * Event called when a finger is moved over this component when touch over events are enabled in the player controller
	*/
	OnInputTouchEnter: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	/**
	 * Event called when a finger is moved off this component when touch over events are enabled in the player controller
	*/
	OnInputTouchLeave: UnrealEngineMulticastDelegate<(FingerIndex: ETouchIndex, TouchedComponent: PrimitiveComponent) => void>;
	/**
	 * LOD parent primitive to draw instead of this one (multiple UPrim's will point to the same LODParent )
	*/
	LODParentPrimitive: PrimitiveComponent;
	/**
	 * Tick function for physics ticking *
	*/
	PostPhysicsComponentTick: PrimitiveComponentPostPhysicsTickFunction;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PrimitiveComponent;
	static Find(Outer: UObject, ResourceName: string): PrimitiveComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PrimitiveComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PrimitiveComponent;
	/**
	 * 'Wake' physics simulation for a single body.
	 * @param  BoneName        If a SkeletalMeshComponent, name of body to wake. 'None' indicates root body.
	*/
	WakeRigidBody(BoneName: string): void;
	/**
	 * Ensure simulation is running for all bodies in this component.
	*/
	WakeAllRigidBodies(): void;
	/**
	 * Sets a new slope override for this component instance.
	*/
	SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;
	/**
	 * Changes the value of TranslucentSortPriority.
	*/
	SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;
	/**
	 * Sets whether or not a single body should use physics simulation, or should be 'fixed' (kinematic).
	 * @param  bSimulate       New simulation state for single body
	*/
	SetSimulatePhysics(bSimulate: boolean): void;
	/**
	 * Sets bRenderInMainPass property and marks the render state dirty.
	*/
	SetRenderInMainPass(bValue: boolean): void;
	/**
	 * Sets the bRenderCustomDepth property and marks the render state dirty.
	*/
	SetRenderCustomDepth(bValue: boolean): void;
	/**
	 * Changes the current PhysMaterialOverride for this component.
	 * Note that if physics is already running on this component, this will _not_ alter its mass/inertia etc,
	 * it will only change its surface properties like friction.
	*/
	SetPhysicalMaterialOverride(NewPhysMaterial: PhysicalMaterial): void;
	/**
	 * Set the maximum angular velocity of a single body.
	 * @param NewMaxAngVel             New maximum angular velocity to apply to body, in degrees per second.
	 * @param bAddToCurrent    If true, NewMaxAngVel is added to the existing maximum angular velocity of the body.
	 * @param BoneName                 If a SkeletalMeshComponent, name of body to modify maximum angular velocity of. 'None' indicates root body.
	*/
	SetPhysicsMaxAngularVelocity(NewMaxAngVel: number,bAddToCurrent: boolean,BoneName: string): void;
	/**
	 * Set the linear velocity of a single body.
	 * This should be used cautiously - it may be better to use AddForce or AddImpulse.
	 * @param NewVel                   New linear velocity to apply to physics.
	 * @param bAddToCurrent    If true, NewVel is added to the existing velocity of the body.
	 * @param BoneName                 If a SkeletalMeshComponent, name of body to modify velocity of. 'None' indicates root body.
	*/
	SetPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	/**
	 * Set the angular velocity of a single body.
	 * This should be used cautiously - it may be better to use AddTorque or AddImpulse.
	 * @param NewAngVel                New angular velocity to apply to body, in degrees per second.
	 * @param bAddToCurrent    If true, NewAngVel is added to the existing angular velocity of the body.
	 * @param BoneName                 If a SkeletalMeshComponent, name of body to modify angular velocity of. 'None' indicates root body.
	*/
	SetPhysicsAngularVelocity(NewAngVel: Vector,bAddToCurrent: boolean,BoneName: string): void;
	/**
	 * Changes the value of bOwnerNoSee.
	*/
	SetOwnerNoSee(bNewOwnerNoSee: boolean): void;
	/**
	 * Changes the value of bOnlyOwnerSee.
	*/
	SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;
	/**
	 * Changes the value of bNotifyRigidBodyCollision
	 * @param bNewNotifyRigidBodyCollision - The value to assign to bNotifyRigidBodyCollision
	*/
	SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;
	/**
	 * Changes the material applied to an element of the mesh.
	 * @param ElementIndex - The element to access the material of.
	 * @return the material used by the indexed element of this mesh.
	*/
	SetMaterial(ElementIndex: number,Material: MaterialInterface): void;
	/**
	 * Change the mass scale used to calculate the mass of a single physics body
	*/
	SetMassScale(BoneName: string,InMassScale: number): void;
	/**
	 * Override the mass (in Kg) of a single physics body.
	 * Note that in the case where multiple bodies are attached together, the override mass will be set for the entire group.
	 * Set the Override Mass to false if you want to reset the body's mass to the auto-calculated physx mass.
	*/
	SetMassOverrideInKg(BoneName: string,MassInKg: number,bOverrideMass: boolean): void;
	/**
	 * Set Locked Axis
	*/
	SetLockedAxis(LockedAxis: EDOFMode): void;
	/**
	 * Sets the linear damping of this component.
	*/
	SetLinearDamping(InDamping: number): void;
	/**
	 * Enables/disables whether this component is affected by gravity. This applies only to components with bSimulatePhysics set to true.
	*/
	SetEnableGravity(bGravityEnabled: boolean): void;
	/**
	 * Sets the CustomDepth stencil value (0 - 255) and marks the render state dirty.
	*/
	SetCustomDepthStencilValue(Value: number): void;
	/**
	 * Changes the value of CullDistance.
	 * @param NewCullDistance - The value to assign to CullDistance.
	*/
	SetMaxDrawDistance(NewCullDistance: number): void;
	/**
	 * Sets the constraint mode of the component.
	 * @param ConstraintMode        The type of constraint to use.
	*/
	SetConstraintMode(ConstraintMode: EDOFMode): void;
	/**
	 * Changes a member of the ResponseToChannels container for this PrimitiveComponent.
	 * @param       Channel      The channel to change the response of
	 * @param       NewResponse  What the new response should be to the supplied Channel
	*/
	SetCollisionResponseToChannel(Channel: ECollisionChannel,NewResponse: ECollisionResponse): void;
	/**
	 * Changes all ResponseToChannels container for this PrimitiveComponent. to be NewResponse
	 * @param       NewResponse  What the new response should be to the supplied Channel
	*/
	SetCollisionResponseToAllChannels(NewResponse: ECollisionResponse): void;
	/**
	 * Set Collision Profile Name
	 * This function is called by constructors when they set ProfileName
	 * This will change current CollisionProfileName to be this, and overwrite Collision Setting
	 * @param InCollisionProfileName : New Profile Name
	*/
	SetCollisionProfileName(InCollisionProfileName: string): void;
	/**
	 * Changes the collision channel that this object uses when it moves
	 * @param      Channel     The new channel for this component to use
	*/
	SetCollisionObjectType(Channel: ECollisionChannel): void;
	/**
	 * Controls what kind of collision is enabled for this body
	*/
	SetCollisionEnabled(NewType: ECollisionEnabled): void;
	/**
	 * Set the center of mass of a single body. This will offset the physx-calculated center of mass.
	 * Note that in the case where multiple bodies are attached together, the center of mass will be set for the entire group.
	 * @param CenterOfMassOffset               User specified offset for the center of mass of this object, from the calculated location.
	 * @param BoneName                 If a SkeletalMeshComponent, name of body to set center of mass of. 'None' indicates root body.
	*/
	SetCenterOfMass(CenterOfMassOffset: Vector,BoneName: string): void;
	/**
	 * Changes the value of CastShadow.
	*/
	SetCastShadow(NewCastShadow: boolean): void;
	/**
	 * Scale the bounds of this object, used for frustum culling. Useful for features like WorldPositionOffset.
	*/
	SetBoundsScale(NewBoundsScale: number): void;
	/**
	 * Sets the angular damping of this component.
	*/
	SetAngularDamping(InDamping: number): void;
	/**
	 * Set the linear velocity of all bodies in this component.
	 * @param NewVel                   New linear velocity to apply to physics.
	 * @param bAddToCurrent    If true, NewVel is added to the existing velocity of the body.
	*/
	SetAllPhysicsLinearVelocity(NewVel: Vector,bAddToCurrent: boolean): void;
	/**
	 * Change the mass scale used fo all bodies in this component
	*/
	SetAllMassScale(InMassScale: number): void;
	/**
	 * Scales the given vector by the world space moment of inertia. Useful for computing the torque needed to rotate an object.
	*/
	ScaleByMomentOfInertia(InputVector: Vector,BoneName: string): Vector;
	/**
	 * Force a single body back to sleep.
	 * @param  BoneName        If a SkeletalMeshComponent, name of body to put to sleep. 'None' indicates root body.
	*/
	PutRigidBodyToSleep(BoneName: string): void;
	/**
	 * Perform a line trace against a single component
	*/
	LineTraceComponent(TraceStart: Vector,TraceEnd: Vector,bTraceComplex: boolean,bShowTrace: boolean,HitLocation?: Vector,HitNormal?: Vector,BoneName?: string): {HitLocation: Vector, HitNormal: Vector, BoneName: string, $: boolean};
	/**
	 * Utility to see if there is any query collision enabled on this component.
	*/
	IsQueryCollisionEnabled(): boolean;
	/**
	 * Utility to see if there is any physics collision enabled on this component.
	*/
	IsPhysicsCollisionEnabled(): boolean;
	/**
	 * Utility to see if there is any form of collision (query or physics) enabled on this component.
	*/
	IsCollisionEnabled(): boolean;
	/**
	 * Check whether this component is overlapping another component.
	 * @param OtherComp Component to test this component against.
	 * @return Whether this component is overlapping another component.
	*/
	IsOverlappingComponent(OtherComp: PrimitiveComponent): boolean;
	/**
	 * Check whether this component is overlapping any component of the given Actor.
	 * @param Other Actor to test this component against.
	 * @return Whether this component is overlapping any component of the given Actor.
	*/
	IsOverlappingActor(Other: Actor): boolean;
	/**
	 * Returns whether this component is affected by gravity. Returns always false if the component is not simulated.
	*/
	IsGravityEnabled(): boolean;
	/**
	 * Tells this component whether to ignore collision with all components of a specific Actor when this component is moved.
	 * Components on the other Actor may also need to be told to do the same when they move.
	 * Does not affect movement of this component when simulating physics.
	*/
	IgnoreActorWhenMoving(Actor: Actor,bShouldIgnore: boolean): void;
	/**
	 * Returns the slope override struct for this component.
	*/
	GetWalkableSlopeOverride(): WalkableSlopeOverride;
	/**
	 * Get the linear velocity of a point on a single body.
	 * @param Point                    Point is specified in world space.
	 * @param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body.
	*/
	GetPhysicsLinearVelocityAtPoint(Point: Vector,BoneName: string): Vector;
	/**
	 * Get the linear velocity of a single body.
	 * @param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body.
	*/
	GetPhysicsLinearVelocity(BoneName: string): Vector;
	/**
	 * Get the angular velocity of a single body, in degrees per second.
	 * @param BoneName                 If a SkeletalMeshComponent, name of body to get velocity of. 'None' indicates root body.
	*/
	GetPhysicsAngularVelocity(BoneName: string): Vector;
	/**
	 * Returns list of components this component is overlapping.
	*/
	GetOverlappingComponents(InOverlappingComponents?: PrimitiveComponent[]): {InOverlappingComponents: PrimitiveComponent[]};
	/**
	 * Returns a list of actors that this component is overlapping.
	 * @param OverlappingActors             [out] Returned list of overlapping actors
	 * @param ClassFilter                   [optional] If set, only returns actors of this class or subclasses
	*/
	GetOverlappingActors(OverlappingActors?: Actor[],ClassFilter?: UnrealEngineClass): {OverlappingActors: Actor[]};
	/**
	 * Returns list of components this component is overlapping.
	*/
	GetOverlapInfos(): OverlapInfo[];
	/**
	 * @return number of material elements in this primitive
	*/
	GetNumMaterials(): number;
	/**
	 * Returns the material used by the element at the specified index
	 * @param ElementIndex - The element to access the material of.
	 * @return the material used by the indexed element of this mesh.
	*/
	GetMaterial(ElementIndex: number): MaterialInterface;
	/**
	 * Returns the mass scale used to calculate the mass of a single physics body
	*/
	GetMassScale(BoneName: string): number;
	/**
	 * Returns the mass of this component in kg.
	*/
	GetMass(): number;
	/**
	 * Returns the linear damping of this component.
	*/
	GetLinearDamping(): number;
	/**
	 * Returns the inertia tensor of this component in kg cm^2. The inertia tensor is in local component space.
	*/
	GetInertiaTensor(BoneName: string): Vector;
	/**
	 * Gets the response type given a specific channel
	*/
	GetCollisionResponseToChannel(Channel: ECollisionChannel): ECollisionResponse;
	/**
	 * Get the collision profile name
	*/
	GetCollisionProfileName(): string;
	/**
	 * Gets the collision object type
	*/
	GetCollisionObjectType(): ECollisionChannel;
	/**
	 * Returns the form of collision for this component
	*/
	GetCollisionEnabled(): ECollisionEnabled;
	/**
	 * Returns the distance and closest point to the collision surface.
	 * Component must have simple collision to be queried for closest point.
	 * @param Point                          World 3D vector
	 * @param OutPointOnBody         Point on the surface of collision closest to Point
	 * @param BoneName                       If a SkeletalMeshComponent, name of body to set center of mass of. 'None' indicates root body.
	 * @return               Success if returns > 0.f, if returns 0.f, it is either not convex or inside of the point
	 *                               If returns < 0.f, this primitive does not have collsion
	*/
	GetClosestPointOnCollision(Point: Vector,OutPointOnBody?: Vector,BoneName?: string): {OutPointOnBody: Vector, $: number};
	/**
	 * Get the center of mass of a single body. In the case of a welded body this will return the center of mass of the entire welded body (including its parent and children)
	 * Objects that are not simulated return (0,0,0) as they do not have COM
	 * @param BoneName                 If a SkeletalMeshComponent, name of body to get center of mass of. 'None' indicates root body.
	*/
	GetCenterOfMass(BoneName: string): Vector;
	/**
	 * Returns the angular damping of this component.
	*/
	GetAngularDamping(): number;
	/**
	 * Creates a Dynamic Material Instance for the specified element index, optionally from the supplied material.
	 * @param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned.
	*/
	CreateDynamicMaterialInstance(ElementIndex: number,SourceMaterial: MaterialInterface): MaterialInstanceDynamic;
	/**
	 * Creates a Dynamic Material Instance for the specified element index.  The parent of the instance is set to the material being replaced.
	 * @param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned.
	*/
	CreateMIDForElementFromMaterial(ElementIndex: number,Parent: MaterialInterface): MaterialInstanceDynamic;
	/**
	 * Creates a Dynamic Material Instance for the specified element index.  The parent of the instance is set to the material being replaced.
	 * @param ElementIndex - The index of the skin to replace the material for.  If invalid, the material is unchanged and NULL is returned.
	*/
	CreateMIDForElement(ElementIndex: number): MaterialInstanceDynamic;
	/**
	 * Returns the list of actors we currently ignore when moving.
	*/
	GetMoveIgnoreActors(): Actor[];
	/**
	 * Clear the list of actors we ignore when moving.
	*/
	ClearMoveIgnoreActors(): void;
	/**
	 * Return true if the given Pawn can step up onto this component.
	 * This controls whether they can try to step up on it when they bump in to it, not whether they can walk on it after landing on it.
	 * @param Pawn the Pawn that wants to step onto this component.
	 * @see CanCharacterStepUpOn
	*/
	CanCharacterStepUp(Pawn: Pawn): boolean;
	/**
	 * Add a torque to a single rigid body.
	 * @param Torque           Torque to apply. Direction is axis of rotation and magnitude is strength of torque.
	 * @param BoneName         If a SkeletalMeshComponent, name of body to apply torque to. 'None' indicates root body.
	 * @param bAccelChange If true, Torque is taken as a change in angular acceleration instead of a physical torque (i.e. mass will have no affect).
	*/
	AddTorque(Torque: Vector,BoneName: string,bAccelChange: boolean): void;
	/**
	 * Add an impulse to all rigid bodies in this component, radiating out from the specified position.
	 * @param Origin                Point of origin for the radial impulse blast, in world space
	 * @param Radius                Size of radial impulse. Beyond this distance from Origin, there will be no affect.
	 * @param Strength              Maximum strength of impulse applied to body.
	 * @param Falloff               Allows you to control the strength of the impulse as a function of distance from Origin.
	 * @param bVelChange    If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no affect).
	*/
	AddRadialImpulse(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bVelChange: boolean): void;
	/**
	 * Add a force to all bodies in this component, originating from the supplied world-space location.
	 * @param Origin           Origin of force in world space.
	 * @param Radius           Radius within which to apply the force.
	 * @param Strength         Strength of force to apply.
	 * @param Falloff              Allows you to control the strength of the force as a function of distance from Origin.
	 * @param bAccelChange If true, Strength is taken as a change in acceleration instead of a physical force (i.e. mass will have no affect).
	*/
	AddRadialForce(Origin: Vector,Radius: number,Strength: number,Falloff: ERadialImpulseFalloff,bAccelChange: boolean): void;
	/**
	 * Add an impulse to a single rigid body at a specific location.
	 * @param  Impulse         Magnitude and direction of impulse to apply.
	 * @param  Location        Point in world space to apply impulse at.
	 * @param  BoneName        If a SkeletalMeshComponent, name of bone to apply impulse to. 'None' indicates root body.
	*/
	AddImpulseAtLocation(Impulse: Vector,Location: Vector,BoneName: string): void;
	/**
	 * Add an impulse to a single rigid body. Good for one time instant burst.
	 * @param  Impulse         Magnitude and direction of impulse to apply.
	 * @param  BoneName        If a SkeletalMeshComponent, name of body to apply impulse to. 'None' indicates root body.
	 * @param  bVelChange      If true, the Strength is taken as a change in velocity instead of an impulse (ie. mass will have no affect).
	*/
	AddImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	/**
	 * Add a force to a single rigid body at a particular location.
	 * This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.
	 * @param Force            Force vector to apply. Magnitude indicates strength of force.
	 * @param Location         Location to apply force, in world space.
	 * @param BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.
	*/
	AddForceAtLocation(Force: Vector,Location: Vector,BoneName: string): void;
	/**
	 * Add a force to a single rigid body.
	 * This is like a 'thruster'. Good for adding a burst over some (non zero) time. Should be called every frame for the duration of the force.
	 * @param  Force            Force vector to apply. Magnitude indicates strength of force.
	 * @param  BoneName         If a SkeletalMeshComponent, name of body to apply force to. 'None' indicates root body.
	 * @param  bAccelChange If true, Force is taken as a change in acceleration instead of a physical force (i.e. mass will have no affect).
	*/
	AddForce(Force: Vector,BoneName: string,bAccelChange: boolean): void;
	/**
	 * Add an angular impulse to a single rigid body. Good for one time instant burst.
	 * @param  AngularImpulse  Magnitude and direction of impulse to apply. Direction is axis of rotation.
	 * @param  BoneName        If a SkeletalMeshComponent, name of body to apply angular impulse to. 'None' indicates root body.
	 * @param  bVelChange      If true, the Strength is taken as a change in angular velocity instead of an impulse (ie. mass will have no affect).
	*/
	AddAngularImpulse(Impulse: Vector,BoneName: string,bVelChange: boolean): void;
	static C(Other: UObject): PrimitiveComponent;
	/**
	 * Component Overlap Actors DEPRECATED
	*/
	ComponentOverlapActors_DEPRECATED(ComponentTransform: Transform,Filter: EOverlapFilterOption,ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	/**
	 * Returns an array of actors that overlap the given component.
	 * @param Component                             Component to test with.
	 * @param ComponentTransform    Defines where to place the component for overlap testing.
	 * @param Filter                                Option to restrict results to only static or only dynamic.  For efficiency.
	 * @param ClassFilter                   If set, will only return results of this class or subclasses of it.
	 * @param ActorsToIgnore                Ignore these actors in the list
	 * @param OutActors                             Returned array of actors. Unsorted.
	 * @return                                              true if there was an overlap that passed the filters, false otherwise.
	*/
	ComponentOverlapActors(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	/**
	 * Component Overlap Components DEPRECATED
	*/
	ComponentOverlapComponents_DEPRECATED(ComponentTransform: Transform,Filter: EOverlapFilterOption,ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	/**
	 * Returns an array of components that overlap the given component.
	 * @param Component                             Component to test with.
	 * @param ComponentTransform    Defines where to place the component for overlap testing.
	 * @param Filter                                Option to restrict results to only static or only dynamic.  For efficiency.
	 * @param ClassFilter                   If set, will only return results of this class or subclasses of it.
	 * @param ActorsToIgnore                Ignore these actors in the list
	 * @param OutActors                             Returned array of actors. Unsorted.
	 * @return                                              true if there was an overlap that passed the filters, false otherwise.
	*/
	ComponentOverlapComponents(ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	/**
	 * Component Overlap Actors DEPRECATED
	*/
	static ComponentOverlapActors_DEPRECATED(Component: PrimitiveComponent,ComponentTransform: Transform,Filter: EOverlapFilterOption,ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	/**
	 * Returns an array of actors that overlap the given component.
	 * @param Component                             Component to test with.
	 * @param ComponentTransform    Defines where to place the component for overlap testing.
	 * @param Filter                                Option to restrict results to only static or only dynamic.  For efficiency.
	 * @param ClassFilter                   If set, will only return results of this class or subclasses of it.
	 * @param ActorsToIgnore                Ignore these actors in the list
	 * @param OutActors                             Returned array of actors. Unsorted.
	 * @return                                              true if there was an overlap that passed the filters, false otherwise.
	*/
	static ComponentOverlapActors(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ActorClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutActors?: Actor[]): {OutActors: Actor[], $: boolean};
	/**
	 * Component Overlap Components DEPRECATED
	*/
	static ComponentOverlapComponents_DEPRECATED(Component: PrimitiveComponent,ComponentTransform: Transform,Filter: EOverlapFilterOption,ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
	/**
	 * Returns an array of components that overlap the given component.
	 * @param Component                             Component to test with.
	 * @param ComponentTransform    Defines where to place the component for overlap testing.
	 * @param Filter                                Option to restrict results to only static or only dynamic.  For efficiency.
	 * @param ClassFilter                   If set, will only return results of this class or subclasses of it.
	 * @param ActorsToIgnore                Ignore these actors in the list
	 * @param OutActors                             Returned array of actors. Unsorted.
	 * @return                                              true if there was an overlap that passed the filters, false otherwise.
	*/
	static ComponentOverlapComponents(Component: PrimitiveComponent,ComponentTransform: Transform,ObjectTypes: EObjectTypeQuery[],ComponentClassFilter: UnrealEngineClass,ActorsToIgnore: Actor[],OutComponents?: PrimitiveComponent[]): {OutComponents: PrimitiveComponent[], $: boolean};
}

declare class BrushComponent extends PrimitiveComponent { 
	/**
	 * Brush
	*/
	Brush: Model;
	/**
	 * Description of collision
	*/
	BrushBodySetup: BodySetup;
	/**
	 * Local space translation
	*/
	PrePivot: Vector;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BrushComponent;
	static Find(Outer: UObject, ResourceName: string): BrushComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BrushComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushComponent;
	static C(Other: UObject): BrushComponent;
}

declare class BuilderPoly { 
	/**
	 * Vertex Indices
	*/
	VertexIndices: number[];
	/**
	 * Direction
	*/
	Direction: number;
	/**
	 * Item Name
	*/
	ItemName: string;
	/**
	 * Poly Flags
	*/
	PolyFlags: number;
	clone() : BuilderPoly;
	static C(Other: UObject): BuilderPoly;
}

declare class BrushBuilder extends UObject { 
	/**
	 * Bitmap Filename
	*/
	BitmapFilename: string;
	/**
	 * localized FString that will be displayed as the name of this brush builder in the editor
	*/
	ToolTip: string;
	/**
	 * If false, disabled the bad param notifications
	*/
	NotifyBadParams: boolean;
	/**
	 * Vertices
	*/
	Vertices: Vector[];
	/**
	 * Polys
	*/
	Polys: BuilderPoly[];
	/**
	 * Layer
	*/
	Layer: string;
	/**
	 * Merge Coplanars
	*/
	MergeCoplanars: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BrushBuilder;
	static Find(Outer: UObject, ResourceName: string): BrushBuilder;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BrushBuilder;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrushBuilder;
	static C(Other: UObject): BrushBuilder;
	/**
	 * Build
	*/
	Build(InWorld: World,InBrush: Brush): boolean;
	/**
	 * Build
	*/
	static Build(Builder: BrushBuilder,InWorld: World,InBrush: Brush): boolean;
}

declare class GeomSelection { 
	/**
	 * Type
	*/
	Type: number;
	/**
	 * EGeometrySelectionType_
	*/
	Index: number;
	/**
	 * Index into the geometry data structures
	*/
	SelectionIndex: number;
	clone() : GeomSelection;
	static C(Other: UObject): GeomSelection;
}

declare class Brush extends Actor { 
	/**
	 * Type of brush
	*/
	BrushType: EBrushType;
	/**
	 * Information.
	*/
	BrushColor: Color;
	/**
	 * Poly Flags
	*/
	PolyFlags: number;
	/**
	 * Colored
	*/
	bColored: boolean;
	/**
	 * Solid when Selected
	*/
	bSolidWhenSelected: boolean;
	/**
	 * If true, this brush class can be placed using the class browser like other simple class types
	*/
	bPlaceableFromClassBrowser: boolean;
	/**
	 * If true, this brush is a builder or otherwise does not need to be loaded into the game
	*/
	bNotForClientOrServer: boolean;
	/**
	 * Brush
	*/
	Brush: Model;
	/**
	 * Brush Component
	*/
	BrushComponent: BrushComponent;
	/**
	 * Brush Builder
	*/
	BrushBuilder: BrushBuilder;
	/**
	 * Flag set when we are in a manipulation (scaling, translation, brush builder param change etc.)
	*/
	bInManipulation: boolean;
	/**
	 * Stores selection information from geometry mode.  This is the only information that we can't
	 * regenerate by looking at the source brushes following an undo operation.
	*/
	SavedSelections: GeomSelection[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Brush;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Brush;
	static C(Other: UObject): Brush;
	/**
	 * Get Surfaces
	*/
	GetSurfaces(Surfaces?: number[]): {Surfaces: number[]};
	/**
	 * Csg Add
	*/
	csgAdd(PolyFlags: number,BrushType: EBrushType): Brush;
	/**
	 * Get Surfaces
	*/
	static GetSurfaces(Brush: Brush,Surfaces?: number[]): {Surfaces: number[]};
	/**
	 * Csg Add
	*/
	static csgAdd(DefaultBrush: Brush,PolyFlags: number,BrushType: EBrushType): Brush;
}

declare class Volume extends Brush { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Volume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Volume;
	static C(Other: UObject): Volume;
	/**
	 * Create Brush for Volume Actor
	*/
	CreateBrushForVolumeActor(BrushBuilder: BrushBuilder): void;
	/**
	 * Create Brush for Volume Actor
	*/
	static CreateBrushForVolumeActor(NewActor: Volume,BrushBuilder: BrushBuilder): void;
}

declare class PhysicsVolume extends Volume { 
	/**
	 * Terminal velocity of pawns using CharacterMovement when falling.
	*/
	TerminalVelocity: number;
	/**
	 * Determines which PhysicsVolume takes precedence if they overlap (higher number = higher priority).
	*/
	Priority: number;
	/**
	 * This property controls the amount of friction applied by the volume as pawns using CharacterMovement move through it. The higher this value, the harder it will feel to move through
	*/
	FluidFriction: number;
	/**
	 * True if this volume contains a fluid like water
	*/
	bWaterVolume: boolean;
	/**
	 * By default, the origin of an AActor must be inside a PhysicsVolume for it to affect the actor. However if this flag is true, the other actor only has to touch the volume to be affected by it.
	*/
	bPhysicsOnContact: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsVolume;
	static C(Other: UObject): PhysicsVolume;
}

declare type EDetachmentRule = string | symbol;
declare var EDetachmentRule = { KeepRelative:'KeepRelative',KeepWorld:'KeepWorld', };
declare type ERelativeTransformSpace = string | symbol;
declare var ERelativeTransformSpace = { RTS_World:'RTS_World',RTS_Actor:'RTS_Actor',RTS_Component:'RTS_Component',RTS_ParentBoneSpace:'RTS_ParentBoneSpace', };
declare type EMoveComponentAction = string | symbol;
declare var EMoveComponentAction = { Move:'Move',Stop:'Stop',Return:'Return', };
declare class SceneComponent extends ActorComponent { 
	/**
	 * Attach Parent
	*/
	AttachParent: SceneComponent;
	/**
	 * List of child SceneComponents that are attached to us.
	*/
	AttachChildren: SceneComponent[];
	/**
	 * Optional socket name on AttachParent that we are attached to.
	*/
	AttachSocketName: string;
	/**
	 * True if we have ever updated ComponentToWorld based on RelativeLocation/Rotation/Scale. Used at startup to make sure it is initialized.
	*/
	bWorldToComponentUpdated: boolean;
	/**
	 * If RelativeLocation should be considered relative to the world, rather than the parent
	*/
	bAbsoluteLocation: boolean;
	/**
	 * If RelativeRotation should be considered relative to the world, rather than the parent
	*/
	bAbsoluteRotation: boolean;
	/**
	 * If RelativeScale3D should be considered relative to the world, rather than the parent
	*/
	bAbsoluteScale: boolean;
	/**
	 * Whether to completely draw the primitive; if false, the primitive is not drawn, does not cast a shadow.
	*/
	bVisible: boolean;
	/**
	 * Whether to hide the primitive in game, if the primitive is Visible.
	*/
	bHiddenInGame: boolean;
	/**
	 * Whether or not the cached PhysicsVolume this component overlaps should be updated when the component is moved.
	 * @see GetPhysicsVolume()
	*/
	bShouldUpdatePhysicsVolume: boolean;
	/**
	 * If true, a change in the bounds of the component will call trigger a streaming data rebuild
	*/
	bBoundsChangeTriggersStreamingDataRebuild: boolean;
	/**
	 * If true, this component uses its parents bounds when attached.
	 * This can be a significant optimization with many components attached together.
	*/
	bUseAttachParentBound: boolean;
	/**
	 * DEPRECATED
	*/
	bAbsoluteTranslation: boolean;
	/**
	 * Physics Volume in which this SceneComponent is located *
	*/
	PhysicsVolume: any;
	/**
	 * Location of the component relative to its parent
	*/
	RelativeLocation: Vector;
	/**
	 * Rotation of the component relative to its parent
	*/
	RelativeRotation: Rotator;
	/**
	 * Non-uniform scaling of the component relative to its parent.
	 * Note that scaling is always applied in local space (no shearing etc)
	*/
	RelativeScale3D: Vector;
	/**
	 * Relative Translation
	*/
	RelativeTranslation: Vector;
	/**
	 * How often this component is allowed to move, used to make various optimizations. Only safe to set in constructor.
	*/
	Mobility: EComponentMobility;
	/**
	 * If detail mode is >= system detail mode, primitive won't be rendered.
	*/
	DetailMode: EDetailMode;
	/**
	 * Velocity of the component.
	 * @see GetComponentVelocity()
	*/
	ComponentVelocity: Vector;
	/**
	 * Delegate that will be called when PhysicsVolume has been changed *
	*/
	PhysicsVolumeChangedDelegate: UnrealEngineMulticastDelegate<(NewVolume: PhysicsVolume) => void>;
	/**
	 * Visualize Component
	*/
	bVisualizeComponent: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): SceneComponent;
	static Find(Outer: UObject, ResourceName: string): SceneComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): SceneComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): SceneComponent;
	/**
	 * Toggle visibility of the component
	*/
	ToggleVisibility(bPropagateToChildren: boolean): void;
	/**
	 * Zeroes out the relative transform of the component, and calls AttachTo(). Useful for attaching directly to a scene component or socket location
	*/
	SnapTo(InParent: SceneComponent,InSocketName: string): boolean;
	/**
	 * Set the relative scale of the component to put it at the supplied scale in world space.
	 * @param NewScale              New scale in world space for this component.
	*/
	SetWorldScale3D(NewScale: Vector): void;
	/**
	 * Set visibility of the component, if during game use this to turn on/off
	*/
	SetVisibility(bNewVisibility: boolean,bPropagateToChildren: boolean): void;
	/**
	 * Set the non-uniform scale of the component relative to its parent
	*/
	SetRelativeScale3D(NewScale3D: Vector): void;
	/**
	 * Changes the value of HiddenGame.
	 * @param NewHidden     - The value to assign to HiddenGame.
	*/
	SetHiddenInGame(NewHidden: boolean,bPropagateToChildren: boolean): void;
	/**
	 * Set which parts of the relative transform should be relative to parent, and which should be relative to world
	*/
	SetAbsolute(bNewAbsoluteLocation: boolean,bNewAbsoluteRotation: boolean,bNewAbsoluteScale: boolean): void;
	/**
	 * Reset the transform of the component relative to its parent. Sets relative location to zero, relative rotation to no rotation, and Scale to 1.
	*/
	ResetRelativeTransform(): void;
	/**
	 * On Rep Visibility
	*/
	OnRep_Visibility(OldValue: boolean): void;
	/**
	 * On Rep Transform
	*/
	OnRep_Transform(): void;
	/**
	 * On Rep Attach Socket Name
	*/
	OnRep_AttachSocketName(): void;
	/**
	 * On Rep Attach Parent
	*/
	OnRep_AttachParent(): void;
	/**
	 * Set the transform of the component in world space.
	 * @param NewTransform          New transform in world space for the component.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	SetWorldTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * * Put this component at the specified rotation in world space. Updates relative rotation to achieve the final world rotation.
	 * * @param NewRotation           New rotation in world space for the component.
	 * * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * * @param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
	 * * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 * *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 * *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 * *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	SetWorldRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Set the relative location and rotation of the component to put it at the supplied pose in world space.
	 * @param NewLocation           New location in world space for the component.
	 * @param NewRotation           New rotation in world space for the component.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	SetWorldLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Put this component at the specified location in world space. Updates relative location to achieve the final world location.
	 * @param NewLocation           New location in world space for the component.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	SetWorldLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Set the transform of the component relative to its parent
	 * @param NewTransform          New transform of the component relative to its parent.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	*/
	SetRelativeTransform(NewTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Set the rotation of the component relative to its parent
	 * @param NewRotation           New rotation of the component relative to its parent
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	*/
	SetRelativeRotation(NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Set the location and rotation of the component relative to its parent
	 * @param NewLocation           New location of the component relative to its parent.
	 * @param NewRotation           New rotation of the component relative to its parent.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	SetRelativeLocationAndRotation(NewLocation: Vector,NewRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Set the location of the component relative to its parent
	 * @param NewLocation           New location of the component relative to its parent.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	SetRelativeLocation(NewLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Get the current component-to-world transform for this component
	*/
	GetWorldTransform(): Transform;
	/**
	 * Returns scale of the component, in world space.
	*/
	GetWorldScale(): Vector;
	/**
	 * Returns rotation of the component, in world space.
	*/
	GetWorldRotation(): Rotator;
	/**
	 * Return location of the component, in world space
	*/
	GetWorldLocation(): Vector;
	/**
	 * Detach this component from whatever it is attached to. Automatically unwelds components that are welded together (See WeldTo)
	 * @param LocationRule                          How to handle translations when detaching.
	 * @param RotationRule                          How to handle rotation when detaching.
	 * @param ScaleRule                                     How to handle scales when detaching.
	 * @param bCallModify                           If true, call Modify() on the component and the current attach parent component
	*/
	DetachFromComponent(LocationRule: EDetachmentRule,RotationRule: EDetachmentRule,ScaleRule: EDetachmentRule,bCallModify: boolean): void;
	/**
	 * Attach this component to another scene component, optionally at a named socket. It is valid to call this on components whether or not they have been Registered.
	 * @param  Parent                                        Parent to attach to.
	 * @param  SocketName                            Optional socket to attach to on the parent.
	 * @param  LocationRule                          How to handle translation when attaching.
	 * @param  RotationRule                          How to handle rotation when attaching.
	 * @param  ScaleRule                                     How to handle scale when attaching.
	 * @param  bWeldSimulatedBodies          Whether to weld together simulated physics bodies.
	 * @return True if attachment is successful (or already attached to requested parent/socket), false if attachment is rejected and there is no change in AttachParent.
	*/
	AttachToComponent(Parent: SceneComponent,SocketName: string,LocationRule: EAttachmentRule,RotationRule: EAttachmentRule,ScaleRule: EAttachmentRule,bWeldSimulatedBodies: boolean): boolean;
	/**
	 * Attach this component to another scene component, optionally at a named socket. It is valid to call this on components whether or not they have been Registered.
	 * @param  InParent                             Parent to attach to.
	 * @param  InSocketName                 Optional socket to attach to on the parent.
	 * @param  AttachType                   How to handle transform when attaching (Keep relative offset, keep world position, etc).
	 * @param  bWeldSimulatedBodies Whether to weld together simulated physics bodies.
	 * @return True if attachment is successful (or already attached to requested parent/socket), false if attachment is rejected and there is no change in AttachParent.
	*/
	AttachTo(InParent: SceneComponent,InSocketName: string,AttachType: EAttachLocation,bWeldSimulatedBodies: boolean): boolean;
	/**
	 * Adds a delta to the transform of the component in world space. Scale is unchanged.
	 * @param DeltaTransform        Change in transform in world space for the component. Scale is unchanged.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	AddWorldTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Adds a delta to the rotation of the component in world space.
	 * @param DeltaRotation         Change in rotation in world space for the component.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	AddWorldRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Adds a delta to the location of the component in world space.
	 * @param DeltaLocation         Change in location in world space for the component.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	AddWorldOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Adds a delta the rotation of the component relative to its parent
	 * @param DeltaRotation         Change in rotation of the component relative to is parent.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	*/
	AddRelativeRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Adds a delta to the translation of the component relative to its parent
	 * @param DeltaLocation         Change in location of the component relative to its parent
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	AddRelativeLocation(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Adds a delta to the transform of the component in its local reference frame. Scale is unchanged.
	 * @param DeltaTransform        Change in transform of the component in its local reference frame. Scale is unchanged.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	AddLocalTransform(DeltaTransform: Transform,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Adds a delta to the rotation of the component in its local reference frame
	 * @param DeltaRotation         Change in rotation of the component in its local reference frame.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination (currently not supported for rotation).
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	*/
	AddLocalRotation(DeltaRotation: Rotator,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Adds a delta to the location of the component in its local reference frame
	 * @param DeltaLocation         Change in location of the component in its local reference frame.
	 * @param SweepHitResult        Hit result from any impact if sweep is true.
	 * @param bSweep                        Whether we sweep to the destination location, triggering overlaps along the way and stopping short of the target if blocked by something.
	 *                                                      Only the root component is swept and checked for blocking collision, child components move without sweeping. If collision is off, this has no effect.
	 * @param bTeleport                     Whether we teleport the physics state (if physics collision is enabled for this object).
	 *                                                      If true, physics velocity for this object is unchanged (so ragdoll parts are not affected by change in location).
	 *                                                      If false, physics velocity is updated based on the change in position (affecting ragdoll parts).
	 *                                                      If CCD is on and not teleporting, this will affect objects along the entire sweep volume.
	*/
	AddLocalOffset(DeltaLocation: Vector,bSweep: boolean,SweepHitResult?: HitResult,bTeleport?: boolean): {SweepHitResult: HitResult};
	/**
	 * Is this component visible or not in game
	 * @return true if visible
	*/
	IsVisible(): boolean;
	/**
	 * Returns whether the specified body is currently using physics simulation
	*/
	IsSimulatingPhysics(BoneName: string): boolean;
	/**
	 * Returns whether the specified body is currently using physics simulation
	*/
	IsAnySimulatingPhysics(): boolean;
	/**
	 * Get the up (Z) unit direction vector from this component, in world space.
	*/
	GetUpVector(): Vector;
	/**
	 * Get world-space socket transform.
	 * @param InSocketName Name of the socket or the bone to get the transform
	 * @return Socket transform in world space if socket if found. Otherwise it will return component's transform in world space.
	*/
	GetSocketTransform(InSocketName: string,TransformSpace: ERelativeTransformSpace): Transform;
	/**
	 * Get world-space socket or bone  FRotator rotation.
	 * @param InSocketName Name of the socket or the bone to get the transform
	 * @return Socket transform in world space if socket if found. Otherwise it will return component's transform in world space.
	*/
	GetSocketRotation(InSocketName: string): Rotator;
	/**
	 * Get world-space socket or bone FQuat rotation.
	 * @param InSocketName Name of the socket or the bone to get the transform
	 * @return Socket transform in world space if socket if found. Otherwise it will return component's transform in world space.
	*/
	GetSocketQuaternion(InSocketName: string): Quat;
	/**
	 * Get world-space socket or bone location.
	 * @param InSocketName Name of the socket or the bone to get the transform
	 * @return Socket transform in world space if socket if found. Otherwise it will return component's transform in world space.
	*/
	GetSocketLocation(InSocketName: string): Vector;
	/**
	 * Get the right (Y) unit direction vector from this component, in world space.
	*/
	GetRightVector(): Vector;
	/**
	 * Returns the transform of the component relative to its parent
	*/
	GetRelativeTransform(): Transform;
	/**
	 * Get the PhysicsVolume overlapping this component.
	*/
	GetPhysicsVolume(): PhysicsVolume;
	/**
	 * Gets all parent components up to and including the root component
	*/
	GetParentComponents(Parents?: SceneComponent[]): {Parents: SceneComponent[]};
	/**
	 * Gets the number of attached children components
	*/
	GetNumChildrenComponents(): number;
	/**
	 * Get the forward (X) unit direction vector from this component, in world space.
	*/
	GetForwardVector(): Vector;
	/**
	 * Get velocity of the component: either ComponentVelocity, or the velocity of the physics body if simulating physics.
	 * @return Velocity of the component
	*/
	GetComponentVelocity(): Vector;
	/**
	 * Gets all the attached child components
	 * @param bIncludeAllDescendants Whether to include all descendants in the list of children (i.e. grandchildren, great grandchildren, etc.)
	 * @param Children The list of attached child components
	*/
	GetChildrenComponents(bIncludeAllDescendants: boolean,Children?: SceneComponent[]): {Children: SceneComponent[]};
	/**
	 * Gets the attached child component at the specified location
	*/
	GetChildComponent(ChildIndex: number): SceneComponent;
	/**
	 * Get the socket we are attached to.
	*/
	GetAttachSocketName(): string;
	/**
	 * Get the SceneComponent we are attached to.
	*/
	GetAttachParent(): SceneComponent;
	/**
	 * Gets the names of all the sockets on the component.
	 * @return Get the names of all the sockets on the component.
	*/
	GetAllSocketNames(): string[];
	/**
	 * return true if socket with the given name exists
	 * @param InSocketName Name of the socket or the bone to get the transform
	 * @return true if the socket with the given name exists. Otherwise, return false
	*/
	DoesSocketExist(InSocketName: string): boolean;
	/**
	 * Detach from Parent
	*/
	DetachFromParent(bMaintainWorldPosition: boolean,bCallModify: boolean): void;
	static C(Other: UObject): SceneComponent;
	/**
	 * Set Mobile
	*/
	SetMobile(): void;
	/**
	 * Set Mobility
	*/
	SetMobility(Type: EComponentMobility): void;
	/**
	 * Get bounds
	*/
	GetComponentBounds(Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	/**
	 * * Interpolate a component to the specified relative location and rotation over the course of OverTime seconds.
	 * * @param Component                                             Component to interpolate
	 * * @param TargetRelativeLocation                Relative target location
	 * * @param TargetRelativeRotation                Relative target rotation
	 * * @param bEaseOut                                              if true we will ease out (ie end slowly) during interpolation
	 * * @param bEaseIn                                               if true we will ease in (ie start slowly) during interpolation
	 * * @param OverTime                                              duration of interpolation
	 * * @param bForceShortestRotationPath    if true we will always use the shortest path for rotation
	 * * @param MoveAction                                    required movement behavior @see EMoveComponentAction
	 * * @param LatentInfo                                    The latent action
	*/
	MoveComponentTo(TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
	/**
	 * Set Mobile
	*/
	static SetMobile(SceneComponent: SceneComponent): void;
	/**
	 * Set Mobility
	*/
	static SetMobility(SceneComponent: SceneComponent,Type: EComponentMobility): void;
	/**
	 * Get bounds
	*/
	static GetComponentBounds(Component: SceneComponent,Origin?: Vector,BoxExtent?: Vector,SphereRadius?: number): {Origin: Vector, BoxExtent: Vector, SphereRadius: number};
	/**
	 * * Interpolate a component to the specified relative location and rotation over the course of OverTime seconds.
	 * * @param Component                                             Component to interpolate
	 * * @param TargetRelativeLocation                Relative target location
	 * * @param TargetRelativeRotation                Relative target rotation
	 * * @param bEaseOut                                              if true we will ease out (ie end slowly) during interpolation
	 * * @param bEaseIn                                               if true we will ease in (ie start slowly) during interpolation
	 * * @param OverTime                                              duration of interpolation
	 * * @param bForceShortestRotationPath    if true we will always use the shortest path for rotation
	 * * @param MoveAction                                    required movement behavior @see EMoveComponentAction
	 * * @param LatentInfo                                    The latent action
	*/
	static MoveComponentTo(Component: SceneComponent,TargetRelativeLocation: Vector,TargetRelativeRotation: Rotator,bEaseOut: boolean,bEaseIn: boolean,OverTime: number,bForceShortestRotationPath: boolean,MoveAction: EMoveComponentAction,LatentInfo: LatentActionInfo): void;
}

declare class RepAttachment { 
	/**
	 * Attach Parent
	*/
	AttachParent: Actor;
	/**
	 * Location Offset
	*/
	LocationOffset: Vector_NetQuantize100;
	/**
	 * Relative Scale 3D
	*/
	RelativeScale3D: Vector_NetQuantize100;
	/**
	 * Rotation Offset
	*/
	RotationOffset: Rotator;
	/**
	 * Attach Socket
	*/
	AttachSocket: string;
	/**
	 * Attach Component
	*/
	AttachComponent: SceneComponent;
	clone() : RepAttachment;
	static C(Other: UObject): RepAttachment;
}

declare type EInputConsumeOptions = string | symbol;
declare var EInputConsumeOptions = { ICO_ConsumeAll:'ICO_ConsumeAll',ICO_ConsumeBoundKeys:'ICO_ConsumeBoundKeys',ICO_ConsumeNone:'ICO_ConsumeNone', };
declare type ESpawnActorCollisionHandlingMethod = string | symbol;
declare var ESpawnActorCollisionHandlingMethod = { Undefined:'Undefined',AlwaysSpawn:'AlwaysSpawn',AdjustIfPossibleButAlwaysSpawn:'AdjustIfPossibleButAlwaysSpawn',AdjustIfPossibleButDontSpawnIfColliding:'AdjustIfPossibleButDontSpawnIfColliding',DontSpawnIfColliding:'DontSpawnIfColliding', };
declare class InterpFilter extends UObject { 
	/**
	 * Caption for this filter.
	*/
	Caption: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpFilter;
	static Find(Outer: UObject, ResourceName: string): InterpFilter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpFilter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpFilter;
	static C(Other: UObject): InterpFilter;
}

declare class InterpGroupDirector extends InterpGroup { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpGroupDirector;
	static Find(Outer: UObject, ResourceName: string): InterpGroupDirector;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpGroupDirector;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpGroupDirector;
	static C(Other: UObject): InterpGroupDirector;
}

declare class InterpData extends UObject { 
	/**
	 * Duration of interpolation sequence - in seconds.
	*/
	InterpLength: number;
	/**
	 * Position in Interp to move things to for path-building in editor.
	*/
	PathBuildTime: number;
	/**
	 * Actual interpolation data. Groups of InterpTracks.
	*/
	InterpGroups: InterpGroup[];
	/**
	 * Used for curve editor to remember curve-editing setup. Only loaded in editor.
	*/
	CurveEdSetup: InterpCurveEdSetup;
	/**
	 * Used for filtering which tracks are currently visible.
	*/
	InterpFilters: InterpFilter[];
	/**
	 * The currently selected filter.
	*/
	SelectedFilter: InterpFilter;
	/**
	 * Array of default filters.
	*/
	DefaultFilters: InterpFilter[];
	/**
	 * Used in editor for defining sections to loop, stretch etc.
	*/
	EdSectionStart: number;
	/**
	 * Used in editor for defining sections to loop, stretch etc.
	*/
	EdSectionEnd: number;
	/**
	 * If true, then the matinee should be baked and pruned at cook time.
	*/
	bShouldBakeAndPrune: boolean;
	/**
	 * Cached version of the director group, if any, for easy access while in game
	*/
	CachedDirectorGroup: InterpGroupDirector;
	/**
	 * Unique names of all events contained across all event tracks
	*/
	AllEventNames: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): InterpData;
	static Find(Outer: UObject, ResourceName: string): InterpData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): InterpData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): InterpData;
	static C(Other: UObject): InterpData;
}

declare class InterpGroupActorInfo { 
	/**
	 * Object Name
	*/
	ObjectName: string;
	/**
	 * Actors
	*/
	Actors: Actor[];
	clone() : InterpGroupActorInfo;
	static C(Other: UObject): InterpGroupActorInfo;
}

declare class CameraCutInfo { 
	/**
	 * Location
	*/
	Location: Vector;
	/**
	 * Time Stamp
	*/
	TimeStamp: number;
	clone() : CameraCutInfo;
	static C(Other: UObject): CameraCutInfo;
}

declare class MatineeActor extends Actor { 
	/**
	 * The matinee data used by this actor
	*/
	MatineeData: InterpData;
	/**
	 * Name of controller node in level script, used to know what function to try and find for events
	*/
	MatineeControllerName: string;
	/**
	 * Time multiplier for playback.
	*/
	PlayRate: number;
	/**
	 * If true, the matinee will play when the level is loaded.
	*/
	bPlayOnLevelLoad: boolean;
	/**
	 * Lets you force the sequence to always start at ForceStartPosition
	*/
	bForceStartPos: boolean;
	/**
	 * Time position to always start at if bForceStartPos is set to true.
	*/
	ForceStartPosition: number;
	/**
	 * If sequence should pop back to beginning when finished.
	 * Note, if true, will never get Completed/Reversed events - sequence must be explicitly Stopped.
	*/
	bLooping: boolean;
	/**
	 * If true, sequence will rewind itself back to the start each time the Play input is activated.
	*/
	bRewindOnPlay: boolean;
	/**
	 * If true, when rewinding this interpolation, reset the 'initial positions' of any RelateToInitial movements to the current location.
	 * This allows the next loop of movement to proceed from the current locations.
	*/
	bNoResetOnRewind: boolean;
	/**
	 * Only used if bRewindOnPlay if true. Defines what should happen if the Play input is activated while currently playing.
	 * If true, hitting Play while currently playing will pop the position back to the start and begin playback over again.
	 * If false, hitting Play while currently playing will do nothing.
	*/
	bRewindIfAlreadyPlaying: boolean;
	/**
	 * If true, disables the realtime radio effect
	*/
	bDisableRadioFilter: boolean;
	/**
	 * Indicates that this interpolation does not affect gameplay. This means that:
	 * -it is not replicated via MatineeActor
	 * -it is not ticked if no affected Actors are visible
	 * -on dedicated servers, it is completely ignored
	*/
	bClientSideOnly: boolean;
	/**
	 * if bClientSideOnly is true, whether this matinee should be completely skipped if none of the affected Actors are visible
	*/
	bSkipUpdateIfNotVisible: boolean;
	/**
	 * Lets you skip the matinee with the CANCELMATINEE exec command. Triggers all events to the end along the way.
	*/
	bIsSkippable: boolean;
	/**
	 * Preferred local viewport number (when split screen is active) the director track should associate with, or zero for 'all'.
	*/
	PreferredSplitScreenNum: number;
	/**
	 * Disable Input from player during play
	*/
	bDisableMovementInput: boolean;
	/**
	 * Disable LookAt Input from player during play
	*/
	bDisableLookAtInput: boolean;
	/**
	 * Hide Player Pawn during play
	*/
	bHidePlayer: boolean;
	/**
	 * Hide HUD during play
	*/
	bHideHud: boolean;
	/**
	 * @todo UE4 matinee - shouldnt be directly editable.  Needs a nice interface in matinee
	*/
	GroupActorInfos: InterpGroupActorInfo[];
	/**
	 * Cached value that indicates whether or not gore was enabled when the sequence was started
	*/
	bShouldShowGore: boolean;
	/**
	 * Instance data for interp groups. One for each variable/group combination.
	*/
	GroupInst: InterpGroupInst[];
	/**
	 * Contains the camera world-position for each camera cut in the cinematic.
	*/
	CameraCuts: CameraCutInfo[];
	/**
	 * Sprite Component
	*/
	SpriteComponent: BillboardComponent;
	/**
	 * Is Being Edited
	*/
	bIsBeingEdited: boolean;
	/**
	 * Set by the editor when scrubbing data
	*/
	bIsScrubbing: boolean;
	/**
	 * properties that may change on InterpAction that we need to notify clients about, since the object's properties will not be replicated
	*/
	bIsPlaying: boolean;
	/**
	 * Reverse Playback
	*/
	bReversePlayback: boolean;
	/**
	 * Paused
	*/
	bPaused: boolean;
	/**
	 * The below property is deprecated and will be removed in 4.9.
	*/
	bPendingStop: boolean;
	/**
	 * Interp Position
	*/
	InterpPosition: number;
	/**
	 * Counter to indicate that play count has changed. Used to work around single frames that go from play-stop-play where bIsPlaying won't get replicated.
	*/
	ReplicationForceIsPlaying: number;
	/**
	 * Event triggered when the matinee is played for whatever reason
	*/
	OnPlay: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Event triggered when the matinee is stopped for whatever reason
	*/
	OnStop: UnrealEngineMulticastDelegate<() => void>;
	/**
	 * Event triggered when the matinee is paused for whatever reason
	*/
	OnPause: UnrealEngineMulticastDelegate<() => void>;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): MatineeActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): MatineeActor;
	/**
	 * Stops playback at the current position
	*/
	Stop(): void;
	/**
	 * Set the position of the interpolation.
	 * @note if the interpolation is not currently active, this function doesn't send any Kismet events
	 * @param NewPosition the new position to set the interpolation to
	 * @param bJump if true, teleport to the new position (don't trigger any events between the old and new positions, etc)
	*/
	SetPosition(NewPosition: number,bJump: boolean): void;
	/**
	 * Change the looping behaviour of this matinee
	*/
	SetLoopingState(bNewLooping: boolean): void;
	/**
	 * Similar to play, but the playback will go backwards until the beginning of the sequence is reached.
	*/
	Reverse(): void;
	/**
	 * Begin playback of the matinee. Only called in game.
	 * Will then advance Position by (PlayRate * Deltatime) each time the matinee is ticked.
	*/
	Play(): void;
	/**
	 * Hold playback at its current position. Calling Pause again will continue playback in its current direction.
	*/
	Pause(): void;
	/**
	 * Enable Group by Name
	*/
	EnableGroupByName(GroupName: string,bEnable: boolean): void;
	/**
	 * Changes the direction of playback (go in reverse if it was going forward, or vice versa)
	*/
	ChangePlaybackDirection(): void;
	static C(Other: UObject): MatineeActor;
}

declare class ChildActorComponent extends SceneComponent { 
	/**
	 * The class of Actor to spawn
	*/
	ChildActorClass: UnrealEngineClass;
	/**
	 * The actor that we spawned and own
	*/
	ChildActor: Actor;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ChildActorComponent;
	static Find(Outer: UObject, ResourceName: string): ChildActorComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ChildActorComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ChildActorComponent;
	/**
	 * Set Child Actor Class
	*/
	SetChildActorClass(InClass: UnrealEngineClass): void;
	static C(Other: UObject): ChildActorComponent;
}

declare class ModelComponent extends PrimitiveComponent { 
	/**
	 * Description of collision
	*/
	ModelBodySetup: BodySetup;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ModelComponent;
	static Find(Outer: UObject, ResourceName: string): ModelComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ModelComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ModelComponent;
	static C(Other: UObject): ModelComponent;
}

declare class LevelScriptBlueprint extends Blueprint { 
	/**
	 * The friendly name to use for UI
	*/
	FriendlyName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): LevelScriptBlueprint;
	static Find(Outer: UObject, ResourceName: string): LevelScriptBlueprint;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelScriptBlueprint;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelScriptBlueprint;
	static C(Other: UObject): LevelScriptBlueprint;
}

declare class IntVector { 
	/**
	 * X
	*/
	X: number;
	/**
	 * Y
	*/
	Y: number;
	/**
	 * Z
	*/
	Z: number;
	clone() : IntVector;
	static C(Other: UObject): IntVector;
}

declare class LevelScriptActor extends Actor { 
	/**
	 * Input Enabled
	*/
	bInputEnabled: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): LevelScriptActor;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): LevelScriptActor;
	/**
	 * Event called on world origin location changes
	 * @param       OldOriginLocation       Previous world origin location
	 * @param       NewOriginLocation       New world origin location
	*/
	WorldOriginLocationChanged(OldOriginLocation: IntVector,NewOriginLocation: IntVector): void;
	/**
	 * Sets the cinematic mode on all PlayerControllers
	 * @param       bInCinematicMode        specify true if the player is entering cinematic mode; false if the player is leaving cinematic mode.
	 * @param       bHidePlayer                     specify true to hide the player's pawn (only relevant if bInCinematicMode is true)
	 * @param       bAffectsHUD                     specify true if we should show/hide the HUD to match the value of bCinematicMode
	 * @param       bAffectsMovement        specify true to disable movement in cinematic mode, enable it when leaving
	 * @param       bAffectsTurning         specify true to disable turning in cinematic mode or enable it when leaving
	*/
	SetCinematicMode(bCinematicMode: boolean,bHidePlayer: boolean,bAffectsHUD: boolean,bAffectsMovement: boolean,bAffectsTurning: boolean): void;
	/**
	 * Tries to find an event named "EventName" on all other levels, and calls it
	*/
	RemoteEvent(EventName: string): boolean;
	/**
	 * @todo document
	*/
	LevelReset(): void;
	static C(Other: UObject): LevelScriptActor;
}

declare class NavigationObjectBase extends Actor { 
	/**
	 * Capsule Component
	*/
	CapsuleComponent: CapsuleComponent;
	/**
	 * Good Sprite
	*/
	GoodSprite: BillboardComponent;
	/**
	 * Bad Sprite
	*/
	BadSprite: BillboardComponent;
	/**
	 * True if this nav point was spawned to be a PIE player start.
	*/
	bIsPIEPlayerStart: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationObjectBase;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationObjectBase;
	static C(Other: UObject): NavigationObjectBase;
}

declare class NavigationDataChunk extends UObject { 
	/**
	 * Name of NavigationData actor that owns this chunk
	*/
	NavigationDataName: string;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationDataChunk;
	static Find(Outer: UObject, ResourceName: string): NavigationDataChunk;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationDataChunk;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationDataChunk;
	static C(Other: UObject): NavigationDataChunk;
}

declare class MaterialSimplificationSettings { 
	/**
	 * Size of generated BaseColor map
	*/
	BaseColorMapSize: IntPoint;
	/**
	 * Whether to generate normal map
	*/
	bNormalMap: boolean;
	/**
	 * Size of generated specular map
	*/
	NormalMapSize: IntPoint;
	/**
	 * Metallic constant
	*/
	MetallicConstant: number;
	/**
	 * Whether to generate metallic map
	*/
	bMetallicMap: boolean;
	/**
	 * Size of generated metallic map
	*/
	MetallicMapSize: IntPoint;
	/**
	 * Roughness constant
	*/
	RoughnessConstant: number;
	/**
	 * Whether to generate roughness map
	*/
	bRoughnessMap: boolean;
	/**
	 * Size of generated roughness map
	*/
	RoughnessMapSize: IntPoint;
	/**
	 * Specular constant
	*/
	SpecularConstant: number;
	/**
	 * Whether to generate specular map
	*/
	bSpecularMap: boolean;
	/**
	 * Size of generated specular map
	*/
	SpecularMapSize: IntPoint;
	clone() : MaterialSimplificationSettings;
	static C(Other: UObject): MaterialSimplificationSettings;
}

declare type ETextureSizingType = string | symbol;
declare var ETextureSizingType = { TextureSizingType_UseSingleTextureSize:'TextureSizingType_UseSingleTextureSize',TextureSizingType_UseAutomaticBiasedSizes:'TextureSizingType_UseAutomaticBiasedSizes',TextureSizingType_UseManualOverrideTextureSize:'TextureSizingType_UseManualOverrideTextureSize',TextureSizingType_UseSimplygonAutomaticSizing:'TextureSizingType_UseSimplygonAutomaticSizing', };
declare type EMaterialMergeType = string | symbol;
declare var EMaterialMergeType = { MaterialMergeType_Default:'MaterialMergeType_Default',MaterialMergeType_Simplygon:'MaterialMergeType_Simplygon', };
declare class MaterialProxySettings { 
	/**
	 * Size of generated BaseColor map
	*/
	TextureSize: IntPoint;
	/**
	 * Texture Sizing Type
	*/
	TextureSizingType: ETextureSizingType;
	/**
	 * Gutter Space
	*/
	GutterSpace: number;
	/**
	 * Whether to generate normal map
	*/
	bNormalMap: boolean;
	/**
	 * Whether to generate metallic map
	*/
	bMetallicMap: boolean;
	/**
	 * Metallic constant
	*/
	MetallicConstant: number;
	/**
	 * Whether to generate roughness map
	*/
	bRoughnessMap: boolean;
	/**
	 * Roughness constant
	*/
	RoughnessConstant: number;
	/**
	 * Whether to generate specular map
	*/
	bSpecularMap: boolean;
	/**
	 * Specular constant
	*/
	SpecularConstant: number;
	/**
	 * Whether to generate emissive map
	*/
	bEmissiveMap: boolean;
	/**
	 * Whether to generate opacity map
	*/
	bOpacityMap: boolean;
	/**
	 * Override diffuse map size
	*/
	DiffuseTextureSize: IntPoint;
	/**
	 * Override normal map size
	*/
	NormalTextureSize: IntPoint;
	/**
	 * Override metallic map size
	*/
	MetallicTextureSize: IntPoint;
	/**
	 * Override roughness map size
	*/
	RoughnessTextureSize: IntPoint;
	/**
	 * Override specular map size
	*/
	SpecularTextureSize: IntPoint;
	/**
	 * Override emissive map size
	*/
	EmissiveTextureSize: IntPoint;
	/**
	 * Override opacity map size
	*/
	OpacityTextureSize: IntPoint;
	/**
	 * Material Merge Type
	*/
	MaterialMergeType: EMaterialMergeType;
	clone() : MaterialProxySettings;
	static C(Other: UObject): MaterialProxySettings;
}

declare class LevelSimplificationDetails { 
	/**
	 * Whether to create separate packages for each generated asset. All in map package otherwise
	*/
	bCreatePackagePerAsset: boolean;
	/**
	 * Percentage of details for static mesh proxy
	*/
	DetailsPercentage: number;
	/**
	 * Static mesh material simplification
	*/
	StaticMeshMaterial: MaterialSimplificationSettings;
	/**
	 * Landscape material simplification
	*/
	StaticMeshMaterialSettings: MaterialProxySettings;
	/**
	 * Override Landscape Export LOD
	*/
	bOverrideLandscapeExportLOD: boolean;
	/**
	 * Landscape LOD to use for static mesh generation, when not specified 'Max LODLevel' from landscape actor will be used
	*/
	LandscapeExportLOD: number;
	/**
	 * Landscape material simplification
	*/
	LandscapeMaterial: MaterialSimplificationSettings;
	/**
	 * Landscape material simplification
	*/
	LandscapeMaterialSettings: MaterialProxySettings;
	/**
	 * Whether to bake foliage into landscape static mesh texture
	*/
	bBakeFoliageToLandscape: boolean;
	/**
	 * Whether to bake grass into landscape static mesh texture
	*/
	bBakeGrassToLandscape: boolean;
	/**
	 * Generate Mesh Normal Map
	*/
	bGenerateMeshNormalMap: boolean;
	/**
	 * Generate Mesh Metallic Map
	*/
	bGenerateMeshMetallicMap: boolean;
	/**
	 * Generate Mesh Roughness Map
	*/
	bGenerateMeshRoughnessMap: boolean;
	/**
	 * Generate Mesh Specular Map
	*/
	bGenerateMeshSpecularMap: boolean;
	/**
	 * Generate Landscape Normal Map
	*/
	bGenerateLandscapeNormalMap: boolean;
	/**
	 * Generate Landscape Metallic Map
	*/
	bGenerateLandscapeMetallicMap: boolean;
	/**
	 * Generate Landscape Roughness Map
	*/
	bGenerateLandscapeRoughnessMap: boolean;
	/**
	 * Generate Landscape Specular Map
	*/
	bGenerateLandscapeSpecularMap: boolean;
	clone() : LevelSimplificationDetails;
	static C(Other: UObject): LevelSimplificationDetails;
}

declare class DefaultPhysicsVolume extends PhysicsVolume { 
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): DefaultPhysicsVolume;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): DefaultPhysicsVolume;
	static C(Other: UObject): DefaultPhysicsVolume;
}

declare class PhysicsCollisionHandler extends UObject { 
	/**
	 * How hard an impact must be to trigger effect/sound
	*/
	ImpactThreshold: number;
	/**
	 * Min time between effect/sound being triggered
	*/
	ImpactReFireDelay: number;
	/**
	 * Sound to play
	*/
	DefaultImpactSound: SoundBase;
	/**
	 * Time since last impact sound
	*/
	LastImpactSoundTime: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PhysicsCollisionHandler;
	static Find(Outer: UObject, ResourceName: string): PhysicsCollisionHandler;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PhysicsCollisionHandler;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PhysicsCollisionHandler;
	static C(Other: UObject): PhysicsCollisionHandler;
}

declare class GameSession extends Info { 
	/**
	 * Maximum number of spectators allowed by this server.
	*/
	MaxSpectators: number;
	/**
	 * Maximum number of players allowed by this server.
	*/
	MaxPlayers: number;
	/**
	 * Restrictions on the largest party that can join together
	*/
	MaxPartySize: number;
	/**
	 * Maximum number of splitscreen players to allow from one connection
	*/
	MaxSplitscreensPerConnection: number;
	/**
	 * Is voice enabled always or via a push to talk keybinding
	*/
	bRequiresPushToTalk: boolean;
	/**
	 * SessionName local copy from PlayerState class.  should really be define in this class, but need to address replication issues
	*/
	SessionName: string;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameSession;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameSession;
	static C(Other: UObject): GameSession;
}

declare class GameState extends Info { 
	/**
	 * Class of the server's game mode, assigned by GameMode.
	*/
	GameModeClass: UnrealEngineClass;
	/**
	 * Instance of the current game mode, exists only on the server. For non-authority clients, this will be NULL.
	*/
	AuthorityGameMode: GameMode;
	/**
	 * Class used by spectators, assigned by GameMode.
	*/
	SpectatorClass: UnrealEngineClass;
	/**
	 * What match state we are currently in
	*/
	MatchState: string;
	/**
	 * Previous map state, used to handle if multiple transitions happen per frame
	*/
	PreviousMatchState: string;
	/**
	 * Elapsed game time since match has started.
	*/
	ElapsedTime: number;
	/**
	 * Array of all PlayerStates, maintained on both server and clients (PlayerStates are always relevant)
	*/
	PlayerArray: PlayerState[];
	/**
	 * Server TimeSeconds. Useful for syncing up animation and gameplay.
	*/
	ReplicatedWorldTimeSeconds: number;
	/**
	 * The difference from the local world's TimeSeconds and the server world's TimeSeconds.
	*/
	ServerWorldTimeSecondsDelta: number;
	/**
	 * Frequency that the server updates the replicated TimeSeconds from the world. Set to zero to disable periodic updates.
	*/
	ServerWorldTimeSecondsUpdateFrequency: number;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameState;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameState;
	/**
	 * Callback when we receive the spectator class
	*/
	OnRep_SpectatorClass(): void;
	/**
	 * Allows clients to calculate ServerWorldTimeSecondsDelta
	*/
	OnRep_ReplicatedWorldTimeSeconds(): void;
	/**
	 * Match state has changed
	*/
	OnRep_MatchState(): void;
	/**
	 * GameMode class notification callback.
	*/
	OnRep_GameModeClass(): void;
	/**
	 * Gives clients the chance to do something when time gets updates
	*/
	OnRep_ElapsedTime(): void;
	/**
	 * Returns the simulated TimeSeconds on the server
	*/
	GetServerWorldTimeSeconds(): number;
	static C(Other: UObject): GameState;
}

declare class GameClassShortName { 
	/**
	 * Abbreviation that can be used as an alias for the class name
	*/
	ShortName: string;
	/**
	 * The class name to use when the alias is specified in a URL
	*/
	GameClassName: string;
	clone() : GameClassShortName;
	static C(Other: UObject): GameClassShortName;
}

declare class GameMode extends Info { 
	/**
	 * What match state we are currently in
	*/
	MatchState: string;
	/**
	 * perform map travels using SeamlessTravel() which loads in the background and doesn't disconnect clients
	 * @see World::SeamlessTravel()
	*/
	bUseSeamlessTravel: boolean;
	/**
	 * Whether the game is pauseable.
	*/
	bPauseable: boolean;
	/**
	 * Whether players should immediately spawn when logging in, or stay as spectators until they manually spawn
	*/
	bStartPlayersAsSpectators: boolean;
	/**
	 * Whether the game should immediately start when the first player logs in. Affects the default behavior of ReadyToStartMatch
	*/
	bDelayedStart: boolean;
	/**
	 * Save options string and parse it when needed
	*/
	OptionsString: string;
	/**
	 * The default pawn class used by players.
	*/
	DefaultPawnClass: UnrealEngineClass;
	/**
	 * HUD class this game uses.
	*/
	HUDClass: UnrealEngineClass;
	/**
	 * Current number of spectators.
	*/
	NumSpectators: number;
	/**
	 * Current number of human players.
	*/
	NumPlayers: number;
	/**
	 * number of non-human players (AI controlled but participating as a player).
	*/
	NumBots: number;
	/**
	 * Minimum time before player can respawn after dying.
	*/
	MinRespawnDelay: number;
	/**
	 * Game Session handles login approval, arbitration, online game interface
	*/
	GameSession: GameSession;
	/**
	 * Number of players that are still traveling from a previous map
	*/
	NumTravellingPlayers: number;
	/**
	 * The default player name assigned to players that join with no name specified.
	*/
	DefaultPlayerName: string;
	/**
	 * Contains strings describing localized game agnostic messages.
	*/
	EngineMessageClass: UnrealEngineClass;
	/**
	 * The class of PlayerController to spawn for players logging in.
	*/
	PlayerControllerClass: UnrealEngineClass;
	/**
	 * The pawn class used by the PlayerController for players when spectating.
	*/
	SpectatorClass: UnrealEngineClass;
	/**
	 * The PlayerController class used when spectating a network replay.
	*/
	ReplaySpectatorPlayerControllerClass: UnrealEngineClass;
	/**
	 * A PlayerState of this class will be associated with every player to replicate relevant player information to all clients.
	*/
	PlayerStateClass: UnrealEngineClass;
	/**
	 * Class of GameState associated with this GameMode.
	*/
	GameStateClass: UnrealEngineClass;
	/**
	 * GameState is used to replicate game state relevant properties to all clients.
	*/
	GameState: GameState;
	/**
	 * PlayerStates of players who have disconnected from the server (saved in case they reconnect)
	*/
	InactivePlayerArray: PlayerState[];
	/**
	 * Handy alternate short names for GameMode classes (e.g. "DM" could be an alias for "MyProject.MyGameModeMP_DM".
	*/
	GameModeClassAliases: GameClassShortName[];
	/**
	 * Time a playerstate will stick around in an inactive state after a player logout
	*/
	InactivePlayerStateLifeSpan: number;
	/**
	 * If true, dedicated servers will record replays when HandleMatchHasStarted/HandleMatchHasStopped is called
	*/
	bHandleDedicatedServerReplays: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameMode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameMode;
	/**
	 * Transitions to WaitingToStart and calls BeginPlay on actors.
	*/
	StartPlay(): void;
	/**
	 * Transition from WaitingToStart to InProgress. You can call this manually, will also get called if ReadyToStartMatch returns true
	*/
	StartMatch(): void;
	/**
	 * @param       NewPlayer - Controller for whom this pawn is spawned
	 * @param       StartSpot - PlayerStart at which to spawn pawn
	 * @return      a pawn of the default pawn class
	*/
	SpawnDefaultPawnFor(NewPlayer: Controller,StartSpot: Actor): Pawn;
	/**
	 * Overridable function to determine whether an Actor should have Reset called when the game has Reset called on it.
	 * Default implementation returns true
	 * @param ActorToReset The actor to make a determination for
	 * @return true if ActorToReset should have Reset() called on it while restarting the game,
	 *                 false if the GameMode will manually reset it or if the actor does not need to be reset
	*/
	ShouldReset(ActorToReset: Actor): boolean;
	/**
	 * Alters the synthetic bandwidth limit for a running game.
	*/
	SetBandwidthLimit(AsyncIOBandwidthLimit: number): void;
	/**
	 * Return to main menu, and disconnect any players
	*/
	ReturnToMainMenuHost(): void;
	/**
	 * Restart the game, by default travel to the current map
	*/
	RestartGame(): void;
	/**
	 * Overridable function called when resetting level.
	 * Default implementation calls Reset() on all actors except GameMode and Controllers
	*/
	ResetLevel(): void;
	/**
	 * @return True if ready to Start Match. Games should override this
	*/
	ReadyToStartMatch(): boolean;
	/**
	 * @return true if ready to End Match. Games should override this
	*/
	ReadyToEndMatch(): boolean;
	/**
	 * @return true if it's valid to call RestartPlayer. Will call Player->CanRestartPlayer
	*/
	PlayerCanRestart(Player: PlayerController): boolean;
	/**
	 * @Returns true if NewPlayerController may only join the server as a spectator.
	*/
	MustSpectate(NewPlayerController: PlayerController): boolean;
	/**
	 * Notification that a player has successfully logged in, and has been given a player controller
	*/
	OnPostLogin(NewPlayer: PlayerController): void;
	/**
	 * K2 on Swap Player Controllers
	*/
	OnSwapPlayerControllers(OldPC: PlayerController,NewPC: PlayerController): void;
	/**
	 * Implementable event to respond to match state changes
	*/
	OnSetMatchState(NewState: string): void;
	/**
	 * K2 on Restart Player
	*/
	OnRestartPlayer(NewPlayer: Controller): void;
	/**
	 * Implementable event when a Controller with a PlayerState leaves the match.
	*/
	OnLogout(ExitingController: Controller): void;
	/**
	 * Overridable event for GameMode blueprint to respond to a change name call
	 * @param Controller    The controller of the player to change the name of
	 * @param NewName               The name to set the player to
	 * @param bNameChange   Whether the name is changing or if this is the first time it has been set
	*/
	OnChangeName(Other: Controller,NewName: string,bNameChange: boolean): void;
	/**
	 * Calls code to select the best player start for this player to start from.
	*/
	FindPlayerStart(Player: Controller): Actor;
	/**
	 * Returns true if the match state is InProgress or other gameplay state
	*/
	IsMatchInProgress(): boolean;
	/**
	 * Called when StartSpot is selected for spawning NewPlayer to allow optional initialization.
	*/
	InitStartSpot(StartSpot: Actor,NewPlayer: Controller): void;
	/**
	 * Returns true if the match state is InProgress or later
	*/
	HasMatchStarted(): boolean;
	/**
	 * Returns true if the match state is WaitingPostMatch or later
	*/
	HasMatchEnded(): boolean;
	/**
	 * Total number of players
	*/
	GetNumPlayers(): number;
	/**
	 * Returns the current match state, this is an accessor to protect the state machine flow
	*/
	GetMatchState(): string;
	/**
	 * returns default pawn class for given controller
	*/
	GetDefaultPawnClassForController(InController: Controller): UnrealEngineClass;
	/**
	 * Return the 'best' player start for this player to start from.
	 * @param Player The AController for whom we are choosing a Player Start
	 * @param IncomingName Specifies the tag of a Player Start to use
	 * @returns Actor chosen as player start (usually a PlayerStart)
	*/
	FindPlayerStart(Player: Controller,IncomingName: string): Actor;
	/**
	 * Transition from InProgress to WaitingPostMatch. You can call this manually, will also get called if ReadyToEndMatch returns true
	*/
	EndMatch(): void;
	/**
	 * Return the 'best' player start for this player to start from.
	 * Default implementation just returns the first PlayerStart found.
	 * @param Player is the controller for whom we are choosing a playerstart
	 * @returns AActor chosen as player start (usually a PlayerStart)
	*/
	ChoosePlayerStart(Player: Controller): Actor;
	/**
	 * Sets the name for a controller
	 * @param Controller    The controller of the player to change the name of
	 * @param NewName               The name to set the player to
	 * @param bNameChange   Whether the name is changing or if this is the first time it has been set
	*/
	ChangeName(Controller: Controller,NewName: string,bNameChange: boolean): void;
	/**
	 * Return whether Viewer is allowed to spectate from the point of view of ViewTarget.
	*/
	CanSpectate(Viewer: PlayerController,ViewTarget: PlayerState): boolean;
	/**
	 * Report that a match has failed due to unrecoverable error
	*/
	AbortMatch(): void;
	static C(Other: UObject): GameMode;
	/**
	 * Handle Seamless Travel Player
	*/
	HandleSeamlessTravelPlayer(C?: Controller): {C: Controller};
	/**
	 * Handle Seamless Travel Player
	*/
	static HandleSeamlessTravelPlayer(GameMode: GameMode,C?: Controller): {C: Controller};
}

declare class GameModePrefix { 
	/**
	 * map prefix, e.g. "DM"
	*/
	Prefix: string;
	/**
	 * GameMode used if none specified on the URL
	*/
	GameMode: string;
	clone() : GameModePrefix;
	static C(Other: UObject): GameModePrefix;
}

declare class GameNetworkManager extends Info { 
	/**
	 * Current adjusted net speed - Used for dynamically managing netspeed for listen servers
	*/
	AdjustedNetSpeed: number;
	/**
	 * Last time netspeed was updated for server (by client entering or leaving)
	*/
	LastNetSpeedUpdateTime: number;
	/**
	 * Total available bandwidth for listen server, split dynamically across net connections
	*/
	TotalNetBandwidth: number;
	/**
	 * Minimum bandwidth dynamically set per connection
	*/
	MinDynamicBandwidth: number;
	/**
	 * Maximum bandwidth dynamically set per connection
	*/
	MaxDynamicBandwidth: number;
	/**
	 * Used to determine if checking for standby cheats should occur
	*/
	bIsStandbyCheckingEnabled: boolean;
	/**
	 * Used to determine whether we've already caught a cheat or not
	*/
	bHasStandbyCheatTriggered: boolean;
	/**
	 * The amount of time without packets before triggering the cheat code
	*/
	StandbyRxCheatTime: number;
	/**
	 * The amount of time without packets before triggering the cheat code
	*/
	StandbyTxCheatTime: number;
	/**
	 * The point we determine the server is either delaying packets or has bad upstream
	*/
	BadPingThreshold: number;
	/**
	 * The percentage of clients missing RX data before triggering the standby code
	*/
	PercentMissingForRxStandby: number;
	/**
	 * The percentage of clients missing TX data before triggering the standby code
	*/
	PercentMissingForTxStandby: number;
	/**
	 * The percentage of clients with bad ping before triggering the standby code
	*/
	PercentForBadPing: number;
	/**
	 * The amount of time to wait before checking a connection for standby issues
	*/
	JoinInProgressStandbyWaitTime: number;
	/**
	 * Average size of replicated move packet (ServerMove() packet size) from player
	*/
	MoveRepSize: number;
	/**
	 * MAXPOSITIONERRORSQUARED is the square of the max position error that is accepted (not corrected) in net play
	*/
	MAXPOSITIONERRORSQUARED: number;
	/**
	 * MAXNEARZEROVELOCITYSQUARED is the square of the max velocity that is considered zero (not corrected) in net play
	*/
	MAXNEARZEROVELOCITYSQUARED: number;
	/**
	 * CLIENTADJUSTUPDATECOST is the bandwidth cost in bytes of sending a client adjustment update. 180 is greater than the actual cost, but represents a tweaked value reserving enough bandwidth for
	 *       other updates sent to the client.  Increase this value to reduce client adjustment update frequency, or if the amount of data sent in the clientadjustment() call increases
	*/
	CLIENTADJUSTUPDATECOST: number;
	/**
	 * MAXCLIENTUPDATEINTERVAL is the maximum time between movement updates from the client before the server forces an update.
	*/
	MAXCLIENTUPDATEINTERVAL: number;
	/**
	 * MaxMoveDeltaTime is the default maximum time delta of CharacterMovement ServerMoves. Should be less than or equal to MAXCLIENTUPDATEINTERVAL, otherwise server will interfere by forceing position updates
	*/
	MaxMoveDeltaTime: number;
	/**
	 * If client update is within MAXPOSITIONERRORSQUARED then he is authorative on his final position
	*/
	ClientAuthorativePosition: boolean;
	/**
	 * Minimum delay between the server sending error corrections to a client, in seconds.
	*/
	ClientErrorUpdateRateLimit: number;
	/**
	 * Whether movement time discrepancy detection is enabled.
	*/
	bMovementTimeDiscrepancyDetection: boolean;
	/**
	 * Whether movement time discrepancy resolution is enabled (when detected, make client movement "pay back" excessive time discrepancies)
	*/
	bMovementTimeDiscrepancyResolution: boolean;
	/**
	 * Maximum time client can be ahead before triggering movement time discrepancy detection/resolution (if enabled).
	*/
	MovementTimeDiscrepancyMaxTimeMargin: number;
	/**
	 * Maximum time client can be behind.
	*/
	MovementTimeDiscrepancyMinTimeMargin: number;
	/**
	 * During time discrepancy resolution, we "pay back" the time discrepancy at this rate for future moves until total error is zero.
	 * 1.0 = 100% resolution rate, meaning the next X ServerMoves from the client are fully paying back the time,
	 * 0.5 = 50% resolution rate, meaning future ServerMoves will spend 50% of tick continuing to move the character and 50% paying back.
	 * Lowering from 100% could be used to produce less severe/noticeable corrections, although typically we would want to correct
	 * the client as quickly as possible.
	*/
	MovementTimeDiscrepancyResolutionRate: number;
	/**
	 * Accepted drift in clocks between client and server as a percent per second allowed.
	 * 0.0 is "no forgiveness" and all logic would run on raw values, no tampering on the server side.
	 * 0.02 would be a 2% per second difference "forgiven" - if the time discrepancy in a given second was less than 2%,
	 * the error handling/detection code effectively ignores it.
	 * Increasing this value above 0% lessens the chance of false positives on time discrepancy (burst packet loss, performance
	 * hitches), but also means anyone tampering with their client time below that percent will not be detected and no resolution
	 * action will be taken, and anyone above that threshold will still gain the advantage of this % of time boost (if running at
	 * 10% speed-up and this value is 0.05 or 5% allowance, they would only be resolved down to a 5% speed boost).
	 * Time discrepancy detection code DOES keep track of LifetimeRawTimeDiscrepancy, which is unaffected by this drift allowance,
	 * so cheating below DriftAllowance percent could be tracked and acted on outside of an individual game. For example, if DriftAllowance
	 * was 0.05 (meaning we're not going to actively prevent any cheating below 5% boosts to ensure less false positives for normal players),
	 * we could still post-process analytics of the game showing that Player X regularly runs at 4% speed boost and take action.
	*/
	MovementTimeDiscrepancyDriftAllowance: number;
	/**
	 * Whether client moves should be force corrected during time discrepancy resolution, useful for projects that have lenient
	 * move error tolerance/ClientAuthorativePosition enabled.
	*/
	bMovementTimeDiscrepancyForceCorrectionsDuringResolution: boolean;
	/**
	 * If true, actor network relevancy is constrained by whether they are within their NetCullDistanceSquared from the client's view point.
	*/
	bUseDistanceBasedRelevancy: boolean;
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameNetworkManager;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameNetworkManager;
	static C(Other: UObject): GameNetworkManager;
}

declare type EVisibilityAggressiveness = string | symbol;
declare var EVisibilityAggressiveness = { VIS_LeastAggressive:'VIS_LeastAggressive',VIS_ModeratelyAggressive:'VIS_ModeratelyAggressive',VIS_MostAggressive:'VIS_MostAggressive', };
declare class LightmassWorldInfoSettings { 
	/**
	 * Warning: Setting this to less than 1 will greatly increase build times!
	 * Scale of the level relative to real world scale (1 Unreal Unit = 1 cm).
	 * All scale-dependent Lightmass setting defaults have been tweaked to work well with real world scale,
	 * Any levels with a different scale should use this scale to compensate.
	 * For large levels it can drastically reduce build times to set this to 2 or 4.
	*/
	StaticLightingLevelScale: number;
	/**
	 * Number of times light is allowed to bounce off of surfaces, starting from the light source.
	 * 0 is direct lighting only, 1 is one bounce, etc.
	 * Bounce 1 takes the most time to calculate and contributes the most to visual quality, followed by bounce 2.
	 * Successive bounces don't really affect build times, but have a much lower visual impact.
	*/
	NumIndirectLightingBounces: number;
	/**
	 * Warning: Setting this higher than 1 will greatly increase build times!
	 * Can be used to increase the GI solver sample counts in order to get higher quality for levels that need it.
	 * It can be useful to reduce IndirectLightingSmoothness somewhat (~.75) when increasing quality to get defined indirect shadows.
	 * Note that this can't affect compression artifacts, UV seams or other texture based artifacts.
	*/
	IndirectLightingQuality: number;
	/**
	 * Smoothness factor to apply to indirect lighting.  This is useful in some lighting conditions when Lightmass cannot resolve accurate indirect lighting.
	 * 1 is default smoothness tweaked for a variety of lighting situations.
	 * Higher values like 3 smooth out the indirect lighting more, but at the cost of indirect shadows losing detail.
	*/
	IndirectLightingSmoothness: number;
	/**
	 * Represents a constant color light surrounding the upper hemisphere of the level, like a sky.
	 * This light source currently does not get bounced as indirect lighting.
	*/
	EnvironmentColor: Color;
	/**
	 * Scales EnvironmentColor to allow independent color and brightness controls.
	*/
	EnvironmentIntensity: number;
	/**
	 * Scales the emissive contribution of all materials in the scene.  Currently disabled and should be removed with mesh area lights.
	*/
	EmissiveBoost: number;
	/**
	 * Scales the diffuse contribution of all materials in the scene.
	*/
	DiffuseBoost: number;
	/**
	 * If true, AmbientOcclusion will be enabled.
	*/
	bUseAmbientOcclusion: boolean;
	/**
	 * Whether to generate textures storing the AO computed by Lightmass.
	 * These can be accessed through the PrecomputedAOMask material node,
	 * Which is useful for blending between material layers on environment assets.
	 * Be sure to set DirectIlluminationOcclusionFraction and IndirectIlluminationOcclusionFraction to 0 if you only want the PrecomputedAOMask!
	*/
	bGenerateAmbientOcclusionMaterialMask: boolean;
	/**
	 * How much of the AO to apply to direct lighting.
	*/
	DirectIlluminationOcclusionFraction: number;
	/**
	 * How much of the AO to apply to indirect lighting.
	*/
	IndirectIlluminationOcclusionFraction: number;
	/**
	 * Higher exponents increase contrast.
	*/
	OcclusionExponent: number;
	/**
	 * Fraction of samples taken that must be occluded in order to reach full occlusion.
	*/
	FullyOccludedSamplesFraction: number;
	/**
	 * Maximum distance for an object to cause occlusion on another object.
	*/
	MaxOcclusionDistance: number;
	/**
	 * If true, override normal direct and indirect lighting with just the exported diffuse term.
	*/
	bVisualizeMaterialDiffuse: boolean;
	/**
	 * If true, override normal direct and indirect lighting with just the AO term.
	*/
	bVisualizeAmbientOcclusion: boolean;
	/**
	 * Scales the distances at which volume lighting samples are placed.  Volume lighting samples are computed by Lightmass and are used for GI on movable components.
	 * Using larger scales results in less sample memory usage and reduces Indirect Lighting Cache update times, but less accurate transitions between lighting areas.
	*/
	VolumeLightSamplePlacementScale: number;
	/**
	 * Whether to compress lightmap textures.  Disabling lightmap texture compression will reduce artifacts but increase memory and disk size by 4x.
	 * Use caution when disabling this.
	*/
	bCompressLightmaps: boolean;
	clone() : LightmassWorldInfoSettings;
	static C(Other: UObject): LightmassWorldInfoSettings;
}

declare type ELightingBuildQuality = string | symbol;
declare var ELightingBuildQuality = { Quality_Preview:'Quality_Preview',Quality_Medium:'Quality_Medium',Quality_High:'Quality_High',Quality_Production:'Quality_Production', };
declare type ReverbPreset = string | symbol;
declare var ReverbPreset = { REVERB_Default:'REVERB_Default',REVERB_Bathroom:'REVERB_Bathroom',REVERB_StoneRoom:'REVERB_StoneRoom',REVERB_Auditorium:'REVERB_Auditorium',REVERB_ConcertHall:'REVERB_ConcertHall',REVERB_Cave:'REVERB_Cave',REVERB_Hallway:'REVERB_Hallway',REVERB_StoneCorridor:'REVERB_StoneCorridor',REVERB_Alley:'REVERB_Alley',REVERB_Forest:'REVERB_Forest',REVERB_City:'REVERB_City',REVERB_Mountains:'REVERB_Mountains',REVERB_Quarry:'REVERB_Quarry',REVERB_Plain:'REVERB_Plain',REVERB_ParkingLot:'REVERB_ParkingLot',REVERB_SewerPipe:'REVERB_SewerPipe',REVERB_Underwater:'REVERB_Underwater',REVERB_SmallRoom:'REVERB_SmallRoom',REVERB_MediumRoom:'REVERB_MediumRoom',REVERB_LargeRoom:'REVERB_LargeRoom',REVERB_MediumHall:'REVERB_MediumHall',REVERB_LargeHall:'REVERB_LargeHall',REVERB_Plate:'REVERB_Plate', };
declare class ReverbEffect extends UObject { 
	/**
	 * Density - 0.0 < 1.0 < 1.0 - Coloration of the late reverb - lower value is more
	*/
	Density: number;
	/**
	 * Diffusion - 0.0 < 1.0 < 1.0 - Echo density in the reverberation decay - lower is more grainy
	*/
	Diffusion: number;
	/**
	 * Reverb Gain - 0.0 < 0.32 < 1.0 - overall reverb gain - master volume control
	*/
	Gain: number;
	/**
	 * Reverb Gain High Frequency - 0.0 < 0.89 < 1.0 - attenuates the high frequency reflected sound
	*/
	GainHF: number;
	/**
	 * Decay Time - 0.1 < 1.49 < 20.0 Seconds - larger is more reverb
	*/
	DecayTime: number;
	/**
	 * Decay High Frequency Ratio - 0.1 < 0.83 < 2.0 - how much the quicker or slower the high frequencies decay relative to the lower frequencies.
	*/
	DecayHFRatio: number;
	/**
	 * Reflections Gain - 0.0 < 0.05 < 3.16 - controls the amount of initial reflections
	*/
	ReflectionsGain: number;
	/**
	 * Reflections Delay - 0.0 < 0.007 < 0.3 Seconds - the time between the listener receiving the direct path sound and the first reflection
	*/
	ReflectionsDelay: number;
	/**
	 * Late Reverb Gain - 0.0 < 1.26 < 10.0 - gain of the late reverb
	*/
	LateGain: number;
	/**
	 * Late Reverb Delay - 0.0 < 0.011 < 0.1 Seconds - time difference between late reverb and first reflections
	*/
	LateDelay: number;
	/**
	 * Air Absorption - 0.892 < 0.994 < 1.0 - lower value means more absorption
	*/
	AirAbsorptionGainHF: number;
	/**
	 * Room Rolloff - 0.0 < 0.0 < 10.0 - multiplies the attenuation due to distance
	*/
	RoomRolloffFactor: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): ReverbEffect;
	static Find(Outer: UObject, ResourceName: string): ReverbEffect;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): ReverbEffect;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): ReverbEffect;
	static C(Other: UObject): ReverbEffect;
}

declare class ReverbSettings { 
	/**
	 * Whether to apply the reverb settings below.
	*/
	bApplyReverb: boolean;
	/**
	 * The reverb preset to employ.
	*/
	ReverbType: ReverbPreset;
	/**
	 * The reverb asset to employ.
	*/
	ReverbEffect: ReverbEffect;
	/**
	 * Volume level of the reverb affect.
	*/
	Volume: number;
	/**
	 * Time to fade from the current reverb settings into this setting, in seconds.
	*/
	FadeTime: number;
	clone() : ReverbSettings;
	static C(Other: UObject): ReverbSettings;
}

declare class InteriorSettings { 
	/**
	 * Whether these interior settings are the default values for the world
	*/
	bIsWorldSettings: boolean;
	/**
	 * The desired volume of sounds outside the volume when the player is inside the volume
	*/
	ExteriorVolume: number;
	/**
	 * The time over which to interpolate from the current volume to the desired volume of sounds outside the volume when the player enters the volume
	*/
	ExteriorTime: number;
	/**
	 * The desired LPF frequency cutoff in hertz of sounds outside the volume when the player is inside the volume
	*/
	ExteriorLPF: number;
	/**
	 * The time over which to interpolate from the current LPF to the desired LPF of sounds outside the volume when the player enters the volume
	*/
	ExteriorLPFTime: number;
	/**
	 * The desired volume of sounds inside the volume when the player is outside the volume
	*/
	InteriorVolume: number;
	/**
	 * The time over which to interpolate from the current volume to the desired volume of sounds inside the volume when the player enters the volume
	*/
	InteriorTime: number;
	/**
	 * The desired LPF frequency cutoff in hertz of sounds inside  the volume when the player is outside the volume
	*/
	InteriorLPF: number;
	/**
	 * The time over which to interpolate from the current LPF to the desired LPF of sounds inside the volume when the player enters the volume
	*/
	InteriorLPFTime: number;
	clone() : InteriorSettings;
	static C(Other: UObject): InteriorSettings;
}

declare type ELandscapeCullingPrecision = string | symbol;
declare var ELandscapeCullingPrecision = { High:'High',Medium:'Medium',Low:'Low', };
declare class MeshProxySettings { 
	/**
	 * Screen size of the resulting proxy mesh in pixel size
	*/
	ScreenSize: number;
	/**
	 * Material simplification
	*/
	MaterialSettings: MaterialProxySettings;
	/**
	 * Texture Width
	*/
	TextureWidth: number;
	/**
	 * Texture Height
	*/
	TextureHeight: number;
	/**
	 * Export Normal Map
	*/
	bExportNormalMap: boolean;
	/**
	 * Export Metallic Map
	*/
	bExportMetallicMap: boolean;
	/**
	 * Export Roughness Map
	*/
	bExportRoughnessMap: boolean;
	/**
	 * Export Specular Map
	*/
	bExportSpecularMap: boolean;
	/**
	 * Material simplification
	*/
	Material: MaterialSimplificationSettings;
	/**
	 * Determines whether or not the correct LOD models should be calculated given the source meshes and transition size
	*/
	bCalculateCorrectLODModel: boolean;
	/**
	 * Distance at which meshes should be merged together
	*/
	MergeDistance: number;
	/**
	 * Angle at which a hard edge is introduced between faces
	*/
	HardAngleThreshold: number;
	/**
	 * Lightmap resolution
	*/
	LightMapResolution: number;
	/**
	 * Whether Simplygon should recalculate normals, otherwise the normals channel will be sampled from the original mesh
	*/
	bRecalculateNormals: boolean;
	/**
	 * Bake Vertex Data
	*/
	bBakeVertexData: boolean;
	/**
	 * Whether or not to use available landscape geometry to cull away invisible triangles
	*/
	bUseLandscapeCulling: boolean;
	/**
	 * Level of detail of the landscape that should be used for the culling
	*/
	LandscapeCullingPrecision: ELandscapeCullingPrecision;
	clone() : MeshProxySettings;
	static C(Other: UObject): MeshProxySettings;
}

declare type EMeshLODSelectionType = string | symbol;
declare var EMeshLODSelectionType = { AllLODs:'AllLODs',SpecificLOD:'SpecificLOD',CalculateLOD:'CalculateLOD', };
declare class MeshMergingSettings { 
	/**
	 * Whether to generate lightmap UVs for a merged mesh
	*/
	bGenerateLightMapUV: boolean;
	/**
	 * Target UV channel in a merged mesh for a lightmap
	*/
	TargetLightMapUVChannel: number;
	/**
	 * Target lightmap resolution
	*/
	TargetLightMapResolution: number;
	/**
	 * Whether we should import vertex colors into merged mesh
	*/
	bImportVertexColors: boolean;
	/**
	 * Whether merged mesh should have pivot at world origin, or at first merged component otherwise
	*/
	bPivotPointAtZero: boolean;
	/**
	 * Whether to merge physics data (collision primitives)
	*/
	bMergePhysicsData: boolean;
	/**
	 * Whether to merge source materials into one flat material
	*/
	bMergeMaterials: boolean;
	/**
	 * Material simplification
	*/
	MaterialSettings: MaterialProxySettings;
	/**
	 * Whether or not vertex data such as vertex colours should be baked into the resulting mesh
	*/
	bBakeVertexDataToMesh: boolean;
	/**
	 * Whether or not vertex data such as vertex colours should be used when baking out materials
	*/
	bUseVertexDataForBakingMaterial: boolean;
	/**
	 * Calculate Correct LODModel
	*/
	bCalculateCorrectLODModel: boolean;
	/**
	 * LODSelection Type
	*/
	LODSelectionType: EMeshLODSelectionType;
	/**
	 * Export Specific LOD
	*/
	ExportSpecificLOD: number;
	/**
	 * A given LOD level to export from the source meshes
	*/
	SpecificLOD: number;
	/**
	 * Whether or not to use available landscape geometry to cull away invisible triangles
	*/
	bUseLandscapeCulling: boolean;
	/**
	 * Whether to export normal maps for material merging
	*/
	bExportNormalMap: boolean;
	/**
	 * Whether to export metallic maps for material merging
	*/
	bExportMetallicMap: boolean;
	/**
	 * Whether to export roughness maps for material merging
	*/
	bExportRoughnessMap: boolean;
	/**
	 * Whether to export specular maps for material merging
	*/
	bExportSpecularMap: boolean;
	/**
	 * Merged material texture atlas resolution
	*/
	MergedMaterialAtlasResolution: number;
	clone() : MeshMergingSettings;
	static C(Other: UObject): MeshMergingSettings;
}

declare class HierarchicalSimplification { 
	/**
	 * The screen radius an mesh object should reach before swapping to the LOD actor, once one of parent displays, it won't draw any of children.
	*/
	TransitionScreenSize: number;
	/**
	 * If this is true, it will simplify mesh but it is slower.
	 * If false, it will just merge actors but not simplify using the lower LOD if exists.
	 * For example if you build LOD 1, it will use LOD 1 of the mesh to merge actors if exists.
	 * If you merge material, it will reduce drawcalls.
	*/
	bSimplifyMesh: boolean;
	/**
	 * Simplification Setting if bSimplifyMesh is true
	*/
	ProxySetting: MeshProxySettings;
	/**
	 * Merge Mesh Setting if bSimplifyMesh is false
	*/
	MergeSetting: MeshMergingSettings;
	/**
	 * Desired Bounding Radius for clustering - this is not guaranteed but used to calculate filling factor for auto clustering
	*/
	DesiredBoundRadius: number;
	/**
	 * Desired Filling Percentage for clustering - this is not guaranteed but used to calculate filling factor  for auto clustering
	*/
	DesiredFillingPercentage: number;
	/**
	 * Min number of actors to build LODActor
	*/
	MinNumberOfActorsToBuild: number;
	clone() : HierarchicalSimplification;
	static C(Other: UObject): HierarchicalSimplification;
}

declare class BookMark extends UObject { 
	/**
	 * Camera position
	*/
	Location: Vector;
	/**
	 * Camera rotation
	*/
	Rotation: Rotator;
	/**
	 * Array of levels that are hidden
	*/
	HiddenLevels: string[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BookMark;
	static Find(Outer: UObject, ResourceName: string): BookMark;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BookMark;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BookMark;
	static C(Other: UObject): BookMark;
}

declare class NetViewer { 
	/**
	 * Connection
	*/
	Connection: NetConnection;
	/**
	 * The "controlling net object" associated with this view (typically player controller)
	*/
	InViewer: Actor;
	/**
	 * The actor that is being directly viewed, usually a pawn.  Could also be the net actor of consequence
	*/
	ViewTarget: Actor;
	/**
	 * Where the viewer is looking from
	*/
	ViewLocation: Vector;
	/**
	 * Direction the viewer is looking
	*/
	ViewDir: Vector;
	clone() : NetViewer;
	static C(Other: UObject): NetViewer;
}

declare class WorldSettings extends Info { 
	/**
	 * If true, enables CheckStillInWorld checks
	*/
	bEnableWorldBoundsChecks: boolean;
	/**
	 * if set to false navigation system will not get created (and all navigation functionality won't be accessible)
	*/
	bEnableNavigationSystem: boolean;
	/**
	 * Enables tools for composing a tiled world.
	 * Level has to be saved and all sub-levels removed before enabling this option.
	*/
	bEnableWorldComposition: boolean;
	/**
	 * World origin will shift to a camera position when camera goes far away from current origin
	*/
	bEnableWorldOriginRebasing: boolean;
	/**
	 * if set to true, when we call GetGravityZ we assume WorldGravityZ has already been initialized and skip the lookup of DefaultGravityZ and GlobalGravityZ
	*/
	bWorldGravitySet: boolean;
	/**
	 * If set to true we will use GlobalGravityZ instead of project setting DefaultGravityZ
	*/
	bGlobalGravitySet: boolean;
	/**
	 * any actor falling below this level gets destroyed
	*/
	KillZ: number;
	/**
	 * The type of damage inflicted when a actor falls below KillZ
	*/
	KillZDamageType: UnrealEngineClass;
	/**
	 * current gravity actually being used
	*/
	WorldGravityZ: number;
	/**
	 * optional level specific gravity override set by level designer
	*/
	GlobalGravityZ: number;
	/**
	 * level specific default physics volume
	*/
	DefaultPhysicsVolumeClass: UnrealEngineClass;
	/**
	 * optional level specific collision handler
	*/
	PhysicsCollisionHandlerClass: UnrealEngineClass;
	/**
	 * The default GameMode to use when starting this map in the game. If this value is NULL, the INI setting for default game type is used.
	*/
	DefaultGameMode: UnrealEngineClass;
	/**
	 * Used for loading appropriate game type if non-specified in URL
	*/
	DefaultMapPrefixes: GameModePrefix[];
	/**
	 * Class of GameNetworkManager to spawn for network games
	*/
	GameNetworkManagerClass: UnrealEngineClass;
	/**
	 * Maximum size of textures for packed light and shadow maps
	*/
	PackedLightAndShadowMapTextureSize: number;
	/**
	 * Causes the BSP build to generate as few sections as possible.
	 * This is useful when you need to reduce draw calls but can reduce texture streaming efficiency and effective lightmap resolution.
	 * Note - changes require a rebuild to propagate.  Also, be sure to select all surfaces and make sure they all have the same flags to minimize section count.
	*/
	bMinimizeBSPSections: boolean;
	/**
	 * Default color scale for the level
	*/
	DefaultColorScale: Vector;
	/**
	 * Max occlusion distance used by mesh distance fields, overridden if there is a movable skylight.
	*/
	DefaultMaxDistanceFieldOcclusionDistance: number;
	/**
	 * Distance from the camera that the global distance field should cover.
	*/
	GlobalDistanceFieldViewDistance: number;
	/**
	 * Whether to place visibility cells inside Precomputed Visibility Volumes and along camera tracks in this level.
	 * Precomputing visibility reduces rendering thread time at the cost of some runtime memory and somewhat increased lighting build times.
	*/
	bPrecomputeVisibility: boolean;
	/**
	 * Whether to place visibility cells only along camera tracks or only above shadow casting surfaces.
	*/
	bPlaceCellsOnlyAlongCameraTracks: boolean;
	/**
	 * World space size of precomputed visibility cells in x and y.
	 * Smaller sizes produce more effective occlusion culling at the cost of increased runtime memory usage and lighting build times.
	*/
	VisibilityCellSize: number;
	/**
	 * Determines how aggressive precomputed visibility should be.
	 * More aggressive settings cull more objects but also cause more visibility errors like popping.
	*/
	VisibilityAggressiveness: EVisibilityAggressiveness;
	/**
	 * Whether to force lightmaps and other precomputed lighting to not be created even when the engine thinks they are needed.
	 * This is useful for improving iteration in levels with fully dynamic lighting and shadowing.
	 * Note that any lighting and shadowing interactions that are usually precomputed will be lost if this is enabled.
	*/
	bForceNoPrecomputedLighting: boolean;
	/**
	 * Lightmass Settings
	*/
	LightmassSettings: LightmassWorldInfoSettings;
	/**
	 * The lighting quality the level was last built with
	*/
	LevelLightingQuality: ELightingBuildQuality;
	/**
	 * Default reverb settings used by audio volumes.
	*/
	DefaultReverbSettings: ReverbSettings;
	/**
	 * Default interior settings used by audio volumes.
	*/
	DefaultAmbientZoneSettings: InteriorSettings;
	/**
	 * Default Base SoundMix.
	*/
	DefaultBaseSoundMix: SoundMix;
	/**
	 * if set to true, hierarchical LODs will be built, which will create hierarchical LODActors
	*/
	bEnableHierarchicalLODSystem: boolean;
	/**
	 * Hierarchical LOD Setup
	*/
	HierarchicalLODSetup: HierarchicalSimplification[];
	/**
	 * Num HLODLevels
	*/
	NumHLODLevels: number;
	/**
	 * scale of 1uu to 1m in real world measurements, for HMD and other physically tracked devices (e.g. 1uu = 1cm would be 100.0)
	*/
	WorldToMeters: number;
	/**
	 * Level Bookmarks: 10 should be MAX_BOOKMARK_NUMBER @fixmeconst
	*/
	BookMarks: BookMark;
	/**
	 * Normally 1 - scales real time passage.
	 * Warning - most use cases should use GetEffectiveTimeDilation() instead of reading from this directly
	*/
	TimeDilation: number;
	/**
	 * Additional time dilation used by Matinee (or Sequencer) slomo track.  Transient because this is often
	 * temporarily modified by the editor when previewing slow motion effects, yet we don't want it saved or loaded from level packages.
	*/
	MatineeTimeDilation: number;
	/**
	 * Additional TimeDilation used to control demo playback speed
	*/
	DemoPlayTimeDilation: number;
	/**
	 * Lowest acceptable global time dilation.
	*/
	MinGlobalTimeDilation: number;
	/**
	 * Highest acceptable global time dilation.
	*/
	MaxGlobalTimeDilation: number;
	/**
	 * Smallest possible frametime, not considering dilation. Equiv to 1/FastestFPS.
	*/
	MinUndilatedFrameTime: number;
	/**
	 * Largest possible frametime, not considering dilation. Equiv to 1/SlowestFPS.
	*/
	MaxUndilatedFrameTime: number;
	/**
	 * If paused, FName of person pausing the game.
	*/
	Pauser: PlayerState;
	/**
	 * when this flag is set, more time is allocated to background loading (replicated)
	*/
	bHighPriorityLoading: boolean;
	/**
	 * copy of bHighPriorityLoading that is not replicated, for clientside-only loading operations
	*/
	bHighPriorityLoadingLocal: boolean;
	/**
	 * valid only during replication - information about the player(s) being replicated to
	 * (there could be more than one in the case of a splitscreen client)
	*/
	ReplicationViewers: NetViewer[];
	/**
	 * Array of user data stored with the asset
	*/
	AssetUserData: AssetUserData[];
	constructor(InWorld: World, Location?: Vector, Rotation?: Rotator);
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): WorldSettings;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): WorldSettings;
	/**
	 * On Rep World Gravity Z
	*/
	OnRep_WorldGravityZ(): void;
	static C(Other: UObject): WorldSettings;
}

declare class Level extends UObject { 
	/**
	 * The World that has this level in its Levels array.
	 * This is not the same as GetOuter(), because GetOuter() for a streaming level is a vestigial world that is not used.
	 * It should not be accessed during BeginDestroy(), just like any other UObject references, since GC may occur in any order.
	*/
	OwningWorld: World;
	/**
	 * BSP UModel.
	*/
	Model: Model;
	/**
	 * BSP Model components used for rendering.
	*/
	ModelComponents: ModelComponent[];
	/**
	 * Reference to the blueprint for level scripting
	*/
	LevelScriptBlueprint: LevelScriptBlueprint;
	/**
	 * The level scripting actor, created by instantiating the class from LevelScriptBlueprint.  This handles all level scripting
	*/
	LevelScriptActor: LevelScriptActor;
	/**
	 * Start and end of the navigation list for this level, used for quickly fixing up
	 * when streaming this level in/out. @TODO DEPRECATED - DELETE
	*/
	NavListStart: NavigationObjectBase;
	/**
	 * Nav List End
	*/
	NavListEnd: NavigationObjectBase;
	/**
	 * Navigation related data that can be stored per level
	*/
	NavDataChunks: NavigationDataChunk[];
	/**
	 * Total number of KB used for lightmap textures in the level.
	*/
	LightmapTotalSize: number;
	/**
	 * Total number of KB used for shadowmap textures in the level.
	*/
	ShadowmapTotalSize: number;
	/**
	 * threes of triangle vertices - AABB filtering friendly. Stored if there's a runtime need to rebuild navigation that accepts BSPs
	 *     as well - it's a lot easier this way than retrieve this data at runtime
	*/
	StaticNavigableGeometry: Vector[];
	/**
	 * The Guid of each texture refered by FStreamingTextureBuildInfo::TextureLevelIndex
	*/
	StreamingTextureGuids: Guid[];
	/**
	 * Whether a level transform rotation was applied since the texture streaming builds. Invalidates the precomputed streaming bounds.
	*/
	bTextureStreamingRotationChanged: boolean;
	/**
	 * Whether the level is currently visible/ associated with the world
	*/
	bIsVisible: boolean;
	/**
	 * Whether this level is locked; that is, its actors are read-only
	 *     Used by WorldBrowser to lock a level when corresponding ULevelStreaming does not exist
	*/
	bLocked: boolean;
	/**
	 * Level simplification settings for each LOD
	*/
	LevelSimplification: LevelSimplificationDetails;
	/**
	 * The level color used for visualization. (Show -> Advanced -> Level Coloration)
	 * Used only in world composition mode
	*/
	LevelColor: LinearColor;
	/**
	 * World Settings
	*/
	WorldSettings: WorldSettings;
	/**
	 * Array of user data stored with the asset
	*/
	AssetUserData: AssetUserData[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): Level;
	static Find(Outer: UObject, ResourceName: string): Level;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): Level;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): Level;
	static C(Other: UObject): Level;
	/**
	 * Update Model Components
	*/
	UpdateModelComponents(): void;
	/**
	 * Update Model Components
	*/
	static UpdateModelComponents(Level: Level): void;
}

declare type EPathFollowingAction = string | symbol;
declare var EPathFollowingAction = { Error:'Error',NoMove:'NoMove',DirectMove:'DirectMove',PartialPath:'PartialPath',PathToGoal:'PathToGoal', };
declare class PathFollowingComponent extends ActorComponent { 
	/**
	 * associated movement component
	*/
	MovementComp: NavMovementComponent;
	/**
	 * navigation data for agent described in movement component
	*/
	MyNavData: NavigationData;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PathFollowingComponent;
	static Find(Outer: UObject, ResourceName: string): PathFollowingComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PathFollowingComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PathFollowingComponent;
	/**
	 * called when moving agent collides with another actor
	*/
	OnActorBump(SelfActor: Actor,OtherActor: Actor,NormalImpulse: Vector,Hit: HitResult): void;
	/**
	 * Get Path Destination
	*/
	GetPathDestination(): Vector;
	/**
	 * Get Path Action Type
	*/
	GetPathActionType(): EPathFollowingAction;
	static C(Other: UObject): PathFollowingComponent;
}

declare class BlackboardKeyType extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardKeyType;
	static Find(Outer: UObject, ResourceName: string): BlackboardKeyType;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardKeyType;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardKeyType;
	static C(Other: UObject): BlackboardKeyType;
}

declare class BlackboardEntry { 
	/**
	 * Entry Name
	*/
	EntryName: string;
	/**
	 * Optional description to explain what this blackboard entry does.
	*/
	EntryDescription: string;
	/**
	 * key type and additional properties
	*/
	KeyType: BlackboardKeyType;
	/**
	 * if set to true then this field will be synchronized across all instances of this blackboard
	*/
	bInstanceSynced: boolean;
	clone() : BlackboardEntry;
	static C(Other: UObject): BlackboardEntry;
}

declare class BlackboardData extends DataAsset { 
	/**
	 * parent blackboard (keys can be overridden)
	*/
	Parent: BlackboardData;
	/**
	 * all keys inherited from parent chain
	*/
	ParentKeys: BlackboardEntry[];
	/**
	 * blackboard keys
	*/
	Keys: BlackboardEntry[];
	/**
	 * Has Synchronized Keys
	*/
	bHasSynchronizedKeys: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardData;
	static Find(Outer: UObject, ResourceName: string): BlackboardData;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardData;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardData;
	static C(Other: UObject): BlackboardData;
}

declare class BlackboardComponent extends ActorComponent { 
	/**
	 * cached behavior tree component
	*/
	BrainComp: BrainComponent;
	/**
	 * data asset defining entries
	*/
	BlackboardAsset: BlackboardData;
	/**
	 * instanced keys with custom data allocations
	*/
	KeyInstances: BlackboardKeyType[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BlackboardComponent;
	static Find(Outer: UObject, ResourceName: string): BlackboardComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BlackboardComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BlackboardComponent;
	/**
	 * Set Value as Vector
	*/
	SetValueAsVector(KeyName: string,VectorValue: Vector): void;
	/**
	 * Set Value as String
	*/
	SetValueAsString(KeyName: string,StringValue: string): void;
	/**
	 * Set Value as Rotator
	*/
	SetValueAsRotator(KeyName: string,VectorValue: Rotator): void;
	/**
	 * Set Value as Object
	*/
	SetValueAsObject(KeyName: string,ObjectValue: UObject): void;
	/**
	 * Set Value as Name
	*/
	SetValueAsName(KeyName: string,NameValue: string): void;
	/**
	 * Set Value as Int
	*/
	SetValueAsInt(KeyName: string,IntValue: number): void;
	/**
	 * Set Value as Float
	*/
	SetValueAsFloat(KeyName: string,FloatValue: number): void;
	/**
	 * Set Value as Enum
	*/
	SetValueAsEnum(KeyName: string,EnumValue: number): void;
	/**
	 * Set Value as Class
	*/
	SetValueAsClass(KeyName: string,ClassValue: UnrealEngineClass): void;
	/**
	 * Set Value as Bool
	*/
	SetValueAsBool(KeyName: string,BoolValue: boolean): void;
	/**
	 * If the vector value has been set (and not cleared), this function returns true (indicating that the value should be valid).  If it's not set, the vector value is invalid and this function will return false.  (Also returns false if the key specified does not hold a vector.)
	*/
	IsVectorValueSet(KeyName: string): boolean;
	/**
	 * Get Value as Vector
	*/
	GetValueAsVector(KeyName: string): Vector;
	/**
	 * Get Value as String
	*/
	GetValueAsString(KeyName: string): string;
	/**
	 * Get Value as Rotator
	*/
	GetValueAsRotator(KeyName: string): Rotator;
	/**
	 * Get Value as Object
	*/
	GetValueAsObject(KeyName: string): UObject;
	/**
	 * Get Value as Name
	*/
	GetValueAsName(KeyName: string): string;
	/**
	 * Get Value as Int
	*/
	GetValueAsInt(KeyName: string): number;
	/**
	 * Get Value as Float
	*/
	GetValueAsFloat(KeyName: string): number;
	/**
	 * Get Value as Enum
	*/
	GetValueAsEnum(KeyName: string): number;
	/**
	 * Get Value as Class
	*/
	GetValueAsClass(KeyName: string): UnrealEngineClass;
	/**
	 * Get Value as Bool
	*/
	GetValueAsBool(KeyName: string): boolean;
	/**
	 * return false if call failed (most probably no such entry in BB)
	*/
	GetRotationFromEntry(KeyName: string,ResultRotation?: Rotator): {ResultRotation: Rotator, $: boolean};
	/**
	 * return false if call failed (most probably no such entry in BB)
	*/
	GetLocationFromEntry(KeyName: string,ResultLocation?: Vector): {ResultLocation: Vector, $: boolean};
	/**
	 * Clear Value
	*/
	ClearValue(KeyName: string): void;
	static C(Other: UObject): BlackboardComponent;
}

declare class BrainComponent extends ActorComponent { 
	/**
	 * blackboard component
	*/
	BlackboardComp: BlackboardComponent;
	/**
	 * AIOwner
	*/
	AIOwner: AIController;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BrainComponent;
	static Find(Outer: UObject, ResourceName: string): BrainComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BrainComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BrainComponent;
	/**
	 * Stop Logic
	*/
	StopLogic(Reason: string): void;
	/**
	 * Restart Logic
	*/
	RestartLogic(): void;
	static C(Other: UObject): BrainComponent;
}

declare class AISenseConfig extends UObject { 
	/**
	 * Debug Color
	*/
	DebugColor: Color;
	/**
	 * specifies age limit after stimuli generated by this sense become forgotten. 0 means "never"
	*/
	MaxAge: number;
	/**
	 * determines whether given sense starts in an enabled state
	*/
	bStartsEnabled: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseConfig;
	static Find(Outer: UObject, ResourceName: string): AISenseConfig;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseConfig;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseConfig;
	static C(Other: UObject): AISenseConfig;
}

declare type EAISenseNotifyType = string | symbol;
declare var EAISenseNotifyType = { OnEveryPerception:'OnEveryPerception',OnPerceptionChange:'OnPerceptionChange', };
declare class AISenseEvent extends UObject { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISenseEvent;
	static Find(Outer: UObject, ResourceName: string): AISenseEvent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISenseEvent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISenseEvent;
	static C(Other: UObject): AISenseEvent;
}

declare class AIStimulus { 
	/**
	 * Age
	*/
	Age: number;
	/**
	 * Expiration Age
	*/
	ExpirationAge: number;
	/**
	 * Strength
	*/
	Strength: number;
	/**
	 * Stimulus Location
	*/
	StimulusLocation: Vector;
	/**
	 * Receiver Location
	*/
	ReceiverLocation: Vector;
	/**
	 * Tag
	*/
	Tag: string;
	/**
	 * Successfully Sensed
	*/
	bSuccessfullySensed: boolean;
	clone() : AIStimulus;
	static C(Other: UObject): AIStimulus;
}

declare class AIPerceptionSystem extends UObject { 
	/**
	 * Senses
	*/
	Senses: AISense[];
	/**
	 * Perception Aging Rate
	*/
	PerceptionAgingRate: number;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIPerceptionSystem;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionSystem;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIPerceptionSystem;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionSystem;
	/**
	 * Report Perception Event
	*/
	static ReportPerceptionEvent(WorldContext: UObject,PerceptionEvent: AISenseEvent): void;
	/**
	 * Report Event
	*/
	ReportEvent(PerceptionEvent: AISenseEvent): void;
	/**
	 * Register Perception Stimuli Source
	*/
	static RegisterPerceptionStimuliSource(WorldContext: UObject,Sense: UnrealEngineClass,Target: Actor): boolean;
	/**
	 * On Perception Stimuli Source End Play
	*/
	OnPerceptionStimuliSourceEndPlay(Actor: Actor,EndPlayReason: EEndPlayReason): void;
	/**
	 * Get Sense Class for Stimulus
	*/
	static GetSenseClassForStimulus(WorldContext: UObject,Stimulus: AIStimulus): UnrealEngineClass;
	static C(Other: UObject): AIPerceptionSystem;
}

declare class AISense extends UObject { 
	/**
	 * age past which stimulus of this sense are "forgotten"
	*/
	DefaultExpirationAge: number;
	/**
	 * Notify Type
	*/
	NotifyType: EAISenseNotifyType;
	/**
	 * whether this sense is interested in getting notified about new Pawns being spawned
	 *     this can be used for example for automated sense sources registration
	*/
	bWantsNewPawnNotification: boolean;
	/**
	 * If true all newly spawned pawns will get auto registered as source for this sense.
	*/
	bAutoRegisterAllPawnsAsSources: boolean;
	/**
	 * Perception System Instance
	*/
	PerceptionSystemInstance: AIPerceptionSystem;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AISense;
	static Find(Outer: UObject, ResourceName: string): AISense;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AISense;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AISense;
	static C(Other: UObject): AISense;
}

declare class ActorPerceptionBlueprintInfo { 
	/**
	 * Target
	*/
	Target: Actor;
	/**
	 * Last Sensed Stimuli
	*/
	LastSensedStimuli: AIStimulus[];
	/**
	 * Is Hostile
	*/
	bIsHostile: boolean;
	clone() : ActorPerceptionBlueprintInfo;
	static C(Other: UObject): ActorPerceptionBlueprintInfo;
}

declare class AIPerceptionComponent extends ActorComponent { 
	/**
	 * Senses Config
	*/
	SensesConfig: AISenseConfig[];
	/**
	 * Indicated sense that takes precedence over other senses when determining sensed actor's location.
	 *     Should be set to one of the senses configured in SensesConfig, or None.
	*/
	DominantSense: UnrealEngineClass;
	/**
	 * AIOwner
	*/
	AIOwner: AIController;
	/**
	 * Might want to move these to special "BP_AIPerceptionComponent"
	*/
	OnPerceptionUpdated: UnrealEngineMulticastDelegate<(UpdatedActors: Actor[]) => void>;
	/**
	 * On Target Perception Updated
	*/
	OnTargetPerceptionUpdated: UnrealEngineMulticastDelegate<(Actor: Actor, Stimulus: AIStimulus) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): AIPerceptionComponent;
	static Find(Outer: UObject, ResourceName: string): AIPerceptionComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): AIPerceptionComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): AIPerceptionComponent;
	/**
	 * Notifies AIPerceptionSystem to update properties for this "stimuli listener"
	*/
	RequestStimuliListenerUpdate(): void;
	/**
	 * On Owner End Play
	*/
	OnOwnerEndPlay(Actor: Actor,EndPlayReason: EEndPlayReason): void;
	/**
	 * blueprint interface
	*/
	GetPerceivedHostileActors(OutActors?: Actor[]): {OutActors: Actor[]};
	/**
	 * Get Perceived Actors
	*/
	GetPerceivedActors(SenseToUse: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	/**
	 * If SenseToUse is none all actors ever perceived in any way (and not forgotten yet) will get fetched
	*/
	GetKnownPerceivedActors(SenseToUse: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	/**
	 * If SenseToUse is none all actors currently perceived in any way will get fetched
	*/
	GetCurrentlyPerceivedActors(SenseToUse: UnrealEngineClass,OutActors?: Actor[]): {OutActors: Actor[]};
	/**
	 * Retrieves whatever has been sensed about given actor
	*/
	GetActorsPerception(Actor: Actor,Info?: ActorPerceptionBlueprintInfo): {Info: ActorPerceptionBlueprintInfo, $: boolean};
	static C(Other: UObject): AIPerceptionComponent;
}

declare type EAIRequestPriority = string | symbol;
declare var EAIRequestPriority = { SoftScript:'SoftScript',Logic:'Logic',HardScript:'HardScript',Reaction:'Reaction',Ultimate:'Ultimate',MAX:'MAX', };
declare type EPawnActionResult = string | symbol;
declare var EPawnActionResult = { NotStarted:'NotStarted',InProgress:'InProgress',Success:'Success',Failed:'Failed',Aborted:'Aborted', };
declare class PawnAction extends UObject { 
	/**
	 * Current child node executing on top of this Action
	*/
	ChildAction: PawnAction;
	/**
	 * Parent Action
	*/
	ParentAction: PawnAction;
	/**
	 * Extra reference to the component this action is being governed by
	*/
	OwnerComponent: PawnActionsComponent;
	/**
	 * indicates an object that caused this action. Used for mass removal of actions
	 *     by specific object
	*/
	Instigator: UObject;
	/**
	 * @Note: THIS IS HERE _ONLY_ BECAUSE OF THE WAY AI MESSAGING IS CURRENTLY IMPLEMENTED. WILL GO AWAY!
	*/
	BrainComp: BrainComponent;
	/**
	 * if this is FALSE and we're trying to push a new instance of a given class,
	 *     but the top of the stack is already an instance of that class ignore the attempted push
	*/
	bAllowNewSameClassInstance: boolean;
	/**
	 * if this is TRUE, when we try to push a new instance of an action who has the
	 *     same class as the action on the top of the stack, pop the one on the stack, and push the new one
	 *     NOTE: This trumps bAllowNewClassInstance (e.g. if this is true and bAllowNewClassInstance
	 *     is false the active instance will still be replaced)
	*/
	bReplaceActiveSameClassInstance: boolean;
	/**
	 * this is a temporary solution to allow having movement action running in background while there's
	 *     another action on top doing its thing
	 *     @note should go away once AI resource locking comes on-line
	*/
	bShouldPauseMovement: boolean;
	/**
	 * if set, action will call OnFinished notify even when ending as FailedToStart
	*/
	bAlwaysNotifyOnFinished: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnAction;
	static Find(Outer: UObject, ResourceName: string): PawnAction;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnAction;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnAction;
	/**
	 * Blueprint interface
	*/
	GetActionPriority(): EAIRequestPriority;
	/**
	 * Finish
	*/
	Finish(WithResult: EPawnActionResult): void;
	/**
	 * Create Action Instance
	*/
	static CreateActionInstance(WorldContextObject: UObject,ActionClass: UnrealEngineClass): PawnAction;
	static C(Other: UObject): PawnAction;
}

declare class PawnActionStack { 
	/**
	 * Top Action
	*/
	TopAction: PawnAction;
	clone() : PawnActionStack;
	static C(Other: UObject): PawnActionStack;
}

declare class PawnActionEvent { 
	/**
	 * Action
	*/
	Action: PawnAction;
	clone() : PawnActionEvent;
	static C(Other: UObject): PawnActionEvent;
}

declare type EPawnActionAbortState = string | symbol;
declare var EPawnActionAbortState = { NeverStarted:'NeverStarted',NotBeingAborted:'NotBeingAborted',MarkPendingAbort:'MarkPendingAbort',LatentAbortInProgress:'LatentAbortInProgress',AbortDone:'AbortDone',MAX:'MAX', };
declare class PawnActionsComponent extends ActorComponent { 
	/**
	 * Controlled Pawn
	*/
	ControlledPawn: Pawn;
	/**
	 * Action Stacks
	*/
	ActionStacks: PawnActionStack[];
	/**
	 * Action Events
	*/
	ActionEvents: PawnActionEvent[];
	/**
	 * Current Action
	*/
	CurrentAction: PawnAction;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): PawnActionsComponent;
	static Find(Outer: UObject, ResourceName: string): PawnActionsComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): PawnActionsComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): PawnActionsComponent;
	/**
	 * K2 Push Action
	*/
	PushAction(NewAction: PawnAction,Priority: EAIRequestPriority,Instigator: UObject): boolean;
	/**
	 * blueprint interface
	*/
	static PerformAction(Pawn: Pawn,Action: PawnAction,Priority: EAIRequestPriority): boolean;
	/**
	 * Aborts given action instance
	*/
	ForceAbortAction(ActionToAbort: PawnAction): EPawnActionAbortState;
	/**
	 * Aborts given action instance
	*/
	AbortAction(ActionToAbort: PawnAction): EPawnActionAbortState;
	static C(Other: UObject): PawnActionsComponent;
}

declare class GameplayTask extends UObject { 
	/**
	 * This name allows us to find the task later so that we can end it.
	*/
	InstanceName: string;
	/**
	 * child task instance
	*/
	ChildTask: GameplayTask;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTask;
	static Find(Outer: UObject, ResourceName: string): GameplayTask;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTask;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTask;
	/**
	 * Called to trigger the actual task once the delegates have been set up
	*/
	ReadyForActivation(): void;
	/**
	 * Called explicitly to end the task (usually by the task itself). Calls OnDestroy.
	 *     @NOTE: you need to call EndTask before sending out any "on completed" delegates.
	 *     If you don't the task will still be in an "active" state while the event receivers may
	 *     assume it's already "finished"
	*/
	EndTask(): void;
	static C(Other: UObject): GameplayTask;
}

declare class GameplayResourceSet { 
	clone() : GameplayResourceSet;
	static C(Other: UObject): GameplayResourceSet;
}

declare class GameplayTasksComponent extends ActorComponent { 
	/**
	 * Tasks that run on simulated proxies
	*/
	SimulatedTasks: GameplayTask[];
	/**
	 * Task Priority Queue
	*/
	TaskPriorityQueue: GameplayTask[];
	/**
	 * Array of currently active UGameplayTask that require ticking
	*/
	TickingTasks: GameplayTask[];
	/**
	 * On Claimed Resources Change
	*/
	OnClaimedResourcesChange: UnrealEngineMulticastDelegate<(NewlyClaimed: GameplayResourceSet, FreshlyReleased: GameplayResourceSet) => void>;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTasksComponent;
	static Find(Outer: UObject, ResourceName: string): GameplayTasksComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTasksComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTasksComponent;
	/**
	 * On Rep Simulated Tasks
	*/
	OnRep_SimulatedTasks(): void;
	static C(Other: UObject): GameplayTasksComponent;
}

declare class NavigationFilterArea { 
	/**
	 * navigation area class
	*/
	AreaClass: UnrealEngineClass;
	/**
	 * override for travel cost
	*/
	TravelCostOverride: number;
	/**
	 * override for entering cost
	*/
	EnteringCostOverride: number;
	/**
	 * mark as excluded
	*/
	bIsExcluded: boolean;
	/**
	 * Override Travel Cost
	*/
	bOverrideTravelCost: boolean;
	/**
	 * Override Entering Cost
	*/
	bOverrideEnteringCost: boolean;
	clone() : NavigationFilterArea;
	static C(Other: UObject): NavigationFilterArea;
}

declare class NavigationFilterFlags { 
	/**
	 * Nav Flag 0
	*/
	bNavFlag0: boolean;
	/**
	 * Nav Flag 1
	*/
	bNavFlag1: boolean;
	/**
	 * Nav Flag 2
	*/
	bNavFlag2: boolean;
	/**
	 * Nav Flag 3
	*/
	bNavFlag3: boolean;
	/**
	 * Nav Flag 4
	*/
	bNavFlag4: boolean;
	/**
	 * Nav Flag 5
	*/
	bNavFlag5: boolean;
	/**
	 * Nav Flag 6
	*/
	bNavFlag6: boolean;
	/**
	 * Nav Flag 7
	*/
	bNavFlag7: boolean;
	/**
	 * Nav Flag 8
	*/
	bNavFlag8: boolean;
	/**
	 * Nav Flag 9
	*/
	bNavFlag9: boolean;
	/**
	 * Nav Flag 10
	*/
	bNavFlag10: boolean;
	/**
	 * Nav Flag 11
	*/
	bNavFlag11: boolean;
	/**
	 * Nav Flag 12
	*/
	bNavFlag12: boolean;
	/**
	 * Nav Flag 13
	*/
	bNavFlag13: boolean;
	/**
	 * Nav Flag 14
	*/
	bNavFlag14: boolean;
	/**
	 * Nav Flag 15
	*/
	bNavFlag15: boolean;
	clone() : NavigationFilterFlags;
	static C(Other: UObject): NavigationFilterFlags;
}

declare class NavigationQueryFilter extends UObject { 
	/**
	 * list of overrides for navigation areas
	*/
	Areas: NavigationFilterArea[];
	/**
	 * required flags of navigation nodes
	*/
	IncludeFlags: NavigationFilterFlags;
	/**
	 * forbidden flags of navigation nodes
	*/
	ExcludeFlags: NavigationFilterFlags;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): NavigationQueryFilter;
	static Find(Outer: UObject, ResourceName: string): NavigationQueryFilter;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): NavigationQueryFilter;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): NavigationQueryFilter;
	static C(Other: UObject): NavigationQueryFilter;
}

declare class AIRequestID { 
	/**
	 * Request ID
	*/
	RequestID: any;
	clone() : AIRequestID;
	static C(Other: UObject): AIRequestID;
}

declare type EPathFollowingResult = string | symbol;
declare var EPathFollowingResult = { Success:'Success',Blocked:'Blocked',OffPath:'OffPath',Aborted:'Aborted',Skipped_DEPRECATED:'Skipped_DEPRECATED',Invalid:'Invalid', };
declare class GameplayTaskResource extends UObject { 
	/**
	 * Overrides AutoResourceID. -1 means auto ID will be applied
	*/
	ManualResourceID: number;
	/**
	 * Auto Resource ID
	*/
	AutoResourceID: any;
	/**
	 * Manually Set ID
	*/
	bManuallySetID: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): GameplayTaskResource;
	static Find(Outer: UObject, ResourceName: string): GameplayTaskResource;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): GameplayTaskResource;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): GameplayTaskResource;
	static C(Other: UObject): GameplayTaskResource;
}

declare class BlackboardKeySelector { 
	/**
	 * array of allowed types with additional properties (e.g. uobject's base class)
	 * EditAnywhere is required for FBlackboardSelectorDetails::CacheBlackboardData()
	*/
	AllowedTypes: BlackboardKeyType[];
	/**
	 * name of selected key
	*/
	SelectedKeyName: string;
	/**
	 * class of selected key
	*/
	SelectedKeyType: UnrealEngineClass;
	/**
	 * ID of selected key
	*/
	SelectedKeyID: number;
	/**
	 * None Is Allowed Value
	*/
	bNoneIsAllowedValue: boolean;
	clone() : BlackboardKeySelector;
	static C(Other: UObject): BlackboardKeySelector;
}

declare type EGameplayTagMatchType = string | symbol;
declare var EGameplayTagMatchType = { Explicit:'Explicit',IncludeParentTags:'IncludeParentTags', };
declare class GameplayTag { 
	/**
	 * This Tags Name
	*/
	TagName: string;
	clone() : GameplayTag;
	static C(Other: UObject): GameplayTag;
	/**
	 * Determine if the specified gameplay tags match, given the specified match types
	 * @param TagOne                        First tag to check
	 * @param TagTwo                        Second tag to check
	 * @param TagOneMatchType       Matching type to use on the first tag
	 * @param TagTwoMatchType       Matching type to use on the second tag
	 * @return True if the tags match, false if they do not
	*/
	DoGameplayTagsMatch(TagTwo: GameplayTag,TagOneMatchType: EGameplayTagMatchType,TagTwoMatchType: EGameplayTagMatchType): boolean;
	/**
	 * Returns an FString representation of a gameplay tag for debugging purposes.
	 * @param GameplayTag   The tag to get the debug string from.
	*/
	GetDebugStringFromGameplayTag(): string;
	/**
	 * Check if the specified tag container has the specified tag, using the specified tag matching types
	 * @param TagContainer                          Container to check for the tag
	 * @param ContainerTagsMatchType        Matching options to use for tags inside the container
	 * @param Tag                                           Tag to check for in the container
	 * @param TagMatchType                          Matching option to use for the tag
	 * @return True if the container has the specified tag, false if it does not
	*/
	IsGameplayTagValid(): boolean;
	/**
	 * Creates a literal FGameplayTag
	 * @param       Value   value to set the FGameplayTag to
	 * @return      The literal FGameplayTag
	*/
	MakeLiteralGameplayTag(): GameplayTag;
	/**
	 * Checks if a gameplay tag's name and a string are not equal to one another
	*/
	NotEqual_TagTag(B: string): boolean;
	/**
	 * Determine if the specified gameplay tags match, given the specified match types
	 * @param TagOne                        First tag to check
	 * @param TagTwo                        Second tag to check
	 * @param TagOneMatchType       Matching type to use on the first tag
	 * @param TagTwoMatchType       Matching type to use on the second tag
	 * @return True if the tags match, false if they do not
	*/
	static DoGameplayTagsMatch(TagOne: GameplayTag,TagTwo: GameplayTag,TagOneMatchType: EGameplayTagMatchType,TagTwoMatchType: EGameplayTagMatchType): boolean;
	/**
	 * Returns an FString representation of a gameplay tag for debugging purposes.
	 * @param GameplayTag   The tag to get the debug string from.
	*/
	static GetDebugStringFromGameplayTag(GameplayTag: GameplayTag): string;
	/**
	 * Check if the specified tag container has the specified tag, using the specified tag matching types
	 * @param TagContainer                          Container to check for the tag
	 * @param ContainerTagsMatchType        Matching options to use for tags inside the container
	 * @param Tag                                           Tag to check for in the container
	 * @param TagMatchType                          Matching option to use for the tag
	 * @return True if the container has the specified tag, false if it does not
	*/
	static IsGameplayTagValid(TagContainer: GameplayTag): boolean;
	/**
	 * Creates a literal FGameplayTag
	 * @param       Value   value to set the FGameplayTag to
	 * @return      The literal FGameplayTag
	*/
	static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;
	/**
	 * Checks if a gameplay tag's name and a string are not equal to one another
	*/
	static NotEqual_TagTag(A: GameplayTag,B: string): boolean;
}

declare class BehaviorTreeComponent extends BrainComponent { 
	/**
	 * instanced nodes
	*/
	NodeInstances: BTNode[];
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BehaviorTreeComponent;
	static Find(Outer: UObject, ResourceName: string): BehaviorTreeComponent;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BehaviorTreeComponent;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BehaviorTreeComponent;
	/**
	 * assign subtree to RunBehaviorDynamic task specified by tag
	*/
	SetDynamicSubtree(InjectTag: GameplayTag,BehaviorAsset: BehaviorTree): void;
	/**
	 * @return the cooldown tag end time, 0.0f if CooldownTag is not found
	*/
	GetTagCooldownEndTime(CooldownTag: GameplayTag): number;
	/**
	 * add to the cooldown tag's duration
	*/
	AddCooldownTagDuration(CooldownTag: GameplayTag,CooldownDuration: number,bAddToExistingDuration: boolean): void;
	static C(Other: UObject): BehaviorTreeComponent;
}

declare class BTNode extends UObject { 
	/**
	 * node name
	*/
	NodeName: string;
	/**
	 * source asset
	*/
	TreeAsset: BehaviorTree;
	/**
	 * parent node
	*/
	ParentNode: BTCompositeNode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTNode;
	static Find(Outer: UObject, ResourceName: string): BTNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTNode;
	static C(Other: UObject): BTNode;
	/**
	 * Resets indicated value to "not set" value, based on values type
	*/
	ClearBlackboardValue(Key: BlackboardKeySelector): void;
	/**
	 * (DEPRECATED) Use ClearBlackboardValue instead
	*/
	ClearBlackboardValueAsVector(Key: BlackboardKeySelector): void;
	/**
	 * Get Blackboard Value as Actor
	*/
	GetBlackboardValueAsActor(Key: BlackboardKeySelector): Actor;
	/**
	 * Get Blackboard Value as Bool
	*/
	GetBlackboardValueAsBool(Key: BlackboardKeySelector): boolean;
	/**
	 * Get Blackboard Value as Class
	*/
	GetBlackboardValueAsClass(Key: BlackboardKeySelector): UnrealEngineClass;
	/**
	 * Get Blackboard Value as Enum
	*/
	GetBlackboardValueAsEnum(Key: BlackboardKeySelector): number;
	/**
	 * Get Blackboard Value as Float
	*/
	GetBlackboardValueAsFloat(Key: BlackboardKeySelector): number;
	/**
	 * Get Blackboard Value as Int
	*/
	GetBlackboardValueAsInt(Key: BlackboardKeySelector): number;
	/**
	 * Get Blackboard Value as Name
	*/
	GetBlackboardValueAsName(Key: BlackboardKeySelector): string;
	/**
	 * Get Blackboard Value as Object
	*/
	GetBlackboardValueAsObject(Key: BlackboardKeySelector): UObject;
	/**
	 * Get Blackboard Value as Rotator
	*/
	GetBlackboardValueAsRotator(Key: BlackboardKeySelector): Rotator;
	/**
	 * Get Blackboard Value as String
	*/
	GetBlackboardValueAsString(Key: BlackboardKeySelector): string;
	/**
	 * Get Blackboard Value as Vector
	*/
	GetBlackboardValueAsVector(Key: BlackboardKeySelector): Vector;
	/**
	 * Get Owner Component
	*/
	GetOwnerComponent(): BehaviorTreeComponent;
	/**
	 * Get Owners Blackboard
	*/
	GetOwnersBlackboard(): BlackboardComponent;
	/**
	 * Set Blackboard Value as Bool
	*/
	SetBlackboardValueAsBool(Key: BlackboardKeySelector,Value: boolean): void;
	/**
	 * Set Blackboard Value as Class
	*/
	SetBlackboardValueAsClass(Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	/**
	 * Set Blackboard Value as Enum
	*/
	SetBlackboardValueAsEnum(Key: BlackboardKeySelector,Value: number): void;
	/**
	 * Set Blackboard Value as Float
	*/
	SetBlackboardValueAsFloat(Key: BlackboardKeySelector,Value: number): void;
	/**
	 * Set Blackboard Value as Int
	*/
	SetBlackboardValueAsInt(Key: BlackboardKeySelector,Value: number): void;
	/**
	 * Set Blackboard Value as Name
	*/
	SetBlackboardValueAsName(Key: BlackboardKeySelector,Value: string): void;
	/**
	 * Set Blackboard Value as Object
	*/
	SetBlackboardValueAsObject(Key: BlackboardKeySelector,Value: UObject): void;
	/**
	 * Set Blackboard Value as Rotator
	*/
	SetBlackboardValueAsRotator(Key: BlackboardKeySelector,Value: Rotator): void;
	/**
	 * Set Blackboard Value as String
	*/
	SetBlackboardValueAsString(Key: BlackboardKeySelector,Value: string): void;
	/**
	 * Set Blackboard Value as Vector
	*/
	SetBlackboardValueAsVector(Key: BlackboardKeySelector,Value: Vector): void;
	/**
	 * Initialize variables marked as "instance memory" and set owning actor for blackboard operations
	*/
	StartUsingExternalEvent(OwningActor: Actor): void;
	/**
	 * Save variables marked as "instance memory" and clear owning actor
	*/
	StopUsingExternalEvent(): void;
	/**
	 * Resets indicated value to "not set" value, based on values type
	*/
	static ClearBlackboardValue(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	/**
	 * (DEPRECATED) Use ClearBlackboardValue instead
	*/
	static ClearBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): void;
	/**
	 * Get Blackboard Value as Actor
	*/
	static GetBlackboardValueAsActor(NodeOwner: BTNode,Key: BlackboardKeySelector): Actor;
	/**
	 * Get Blackboard Value as Bool
	*/
	static GetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector): boolean;
	/**
	 * Get Blackboard Value as Class
	*/
	static GetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector): UnrealEngineClass;
	/**
	 * Get Blackboard Value as Enum
	*/
	static GetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	/**
	 * Get Blackboard Value as Float
	*/
	static GetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	/**
	 * Get Blackboard Value as Int
	*/
	static GetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector): number;
	/**
	 * Get Blackboard Value as Name
	*/
	static GetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	/**
	 * Get Blackboard Value as Object
	*/
	static GetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector): UObject;
	/**
	 * Get Blackboard Value as Rotator
	*/
	static GetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector): Rotator;
	/**
	 * Get Blackboard Value as String
	*/
	static GetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector): string;
	/**
	 * Get Blackboard Value as Vector
	*/
	static GetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector): Vector;
	/**
	 * Get Owner Component
	*/
	static GetOwnerComponent(NodeOwner: BTNode): BehaviorTreeComponent;
	/**
	 * Get Owners Blackboard
	*/
	static GetOwnersBlackboard(NodeOwner: BTNode): BlackboardComponent;
	/**
	 * Set Blackboard Value as Bool
	*/
	static SetBlackboardValueAsBool(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: boolean): void;
	/**
	 * Set Blackboard Value as Class
	*/
	static SetBlackboardValueAsClass(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UnrealEngineClass): void;
	/**
	 * Set Blackboard Value as Enum
	*/
	static SetBlackboardValueAsEnum(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	/**
	 * Set Blackboard Value as Float
	*/
	static SetBlackboardValueAsFloat(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	/**
	 * Set Blackboard Value as Int
	*/
	static SetBlackboardValueAsInt(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: number): void;
	/**
	 * Set Blackboard Value as Name
	*/
	static SetBlackboardValueAsName(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	/**
	 * Set Blackboard Value as Object
	*/
	static SetBlackboardValueAsObject(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: UObject): void;
	/**
	 * Set Blackboard Value as Rotator
	*/
	static SetBlackboardValueAsRotator(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Rotator): void;
	/**
	 * Set Blackboard Value as String
	*/
	static SetBlackboardValueAsString(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: string): void;
	/**
	 * Set Blackboard Value as Vector
	*/
	static SetBlackboardValueAsVector(NodeOwner: BTNode,Key: BlackboardKeySelector,Value: Vector): void;
	/**
	 * Initialize variables marked as "instance memory" and set owning actor for blackboard operations
	*/
	static StartUsingExternalEvent(NodeOwner: BTNode,OwningActor: Actor): void;
	/**
	 * Save variables marked as "instance memory" and clear owning actor
	*/
	static StopUsingExternalEvent(NodeOwner: BTNode): void;
}

declare class BTAuxiliaryNode extends BTNode { 
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTAuxiliaryNode;
	static Find(Outer: UObject, ResourceName: string): BTAuxiliaryNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTAuxiliaryNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTAuxiliaryNode;
	static C(Other: UObject): BTAuxiliaryNode;
}

declare class BTService extends BTAuxiliaryNode { 
	/**
	 * defines time span between subsequent ticks of the service
	*/
	Interval: number;
	/**
	 * adds random range to service's Interval
	*/
	RandomDeviation: number;
	/**
	 * call Tick event when task search enters this node (SearchStart will be called as well)
	*/
	bCallTickOnSearchStart: boolean;
	/**
	 * if set, next tick time will be always reset to service's interval when node is activated
	*/
	bRestartTimerOnEachActivation: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTService;
	static Find(Outer: UObject, ResourceName: string): BTService;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTService;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTService;
	static C(Other: UObject): BTService;
}

declare class BTTaskNode extends BTNode { 
	/**
	 * service nodes
	*/
	Services: BTService[];
	/**
	 * if set, task search will be discarded when this task is selected to execute but is already running
	*/
	bIgnoreRestartSelf: boolean;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTTaskNode;
	static Find(Outer: UObject, ResourceName: string): BTTaskNode;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTTaskNode;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTTaskNode;
	static C(Other: UObject): BTTaskNode;
}

declare type EBTFlowAbortMode = string | symbol;
declare var EBTFlowAbortMode = { None:'None',LowerPriority:'LowerPriority',Self:'Self',Both:'Both', };
declare class BTDecorator extends BTAuxiliaryNode { 
	/**
	 * if set, condition check result will be inversed
	*/
	bInverseCondition: boolean;
	/**
	 * flow controller settings
	*/
	FlowAbortMode: EBTFlowAbortMode;
	constructor();
	constructor(Outer: UObject);
	static Load(ResourceName: string): BTDecorator;
	static Find(Outer: UObject, ResourceName: string): BTDecorator;
	static StaticClass: any;
	static GetClassObject(): UClass;
	static GetDefaultObject(): BTDecorator;
	static GetDefaultSubobjectByName(Name: string): UObject;
	static SetDefaultSubobjectClass(Name: string): void;
	static CreateDefaultSubobject(Name: string, Transient?: boolean, Required?: boolean, Abstract?: boolean): BTDecorator;
	static C(Other: UObject): BTDecorator;
}

